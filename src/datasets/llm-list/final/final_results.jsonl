{"id": "llmlist_0", "header": "def length(lst):", "description": "Return the number of elements in lst.", "code": "def length(lst):\n    i = 0\n    try:\n        while True:\n            lst[i]\n            i += 1\n    except (IndexError, TypeError):\n        i = 0\n        it = iter(lst)\n        while True:\n            try:\n                next(it)\n                i += 1\n            except StopIteration:\n                break\n    return i", "inputs": [["[1, 2, 3]"], ["[[1], [2], [3]]"], ["[True, False, 0]"]], "outputs": ["3", "3", "3"]}
{"id": "llmlist_1", "header": "def is_empty(lst):", "description": "Return True if lst has no elements, else False.", "code": "def is_empty(lst):\n    if lst is None:\n        return True\n    try:\n        n = len(lst)\n    except Exception:\n        count = 0\n        for _ in lst:\n            count += 1\n            if count > 0:\n                return False\n        return True\n    if n == 0:\n        return True\n    return False", "inputs": [["[1]"], ["[0, -1, 2]"], ["[[1], True]"]], "outputs": ["False", "False", "False"]}
{"id": "llmlist_2", "header": "def head(lst):", "description": "Return the first element of lst, or raise if empty.", "code": "def head(lst):\n    if len(lst) == 0:\n        raise IndexError(\"head from empty list\")\n    return lst[0]", "inputs": [["[1, 2, 3]"], ["[0]"], ["[[1], 2]"]], "outputs": ["1", "0", "[1]"]}
{"id": "llmlist_3", "header": "def tail(lst):", "description": "Return a new list of all elements except the first.", "code": "def tail(lst):\n    result = []\n    count = 0\n    for _ in lst:\n        count += 1\n    idx = 0\n    for item in lst:\n        if idx > 0 and idx < count:\n            result.append(item)\n        idx += 1\n    return result", "inputs": [["[1]"], ["[1, 2, 3]"], ["[[1], [2, 3], [4]]"]], "outputs": ["[]", "[2, 3]", "[[2, 3], [4]]"]}
{"id": "llmlist_4", "header": "def last(lst):", "description": "Return the last element of lst, or raise if empty.", "code": "def last(lst):\n    if lst is None:\n        raise TypeError(\"lst is None\")\n    try:\n        n = len(lst)\n    except Exception:\n        n = None\n    if n is not None:\n        if n == 0:\n            raise IndexError(\"empty\")\n        try:\n            return lst[n - 1]\n        except Exception:\n            pass\n    sentinel = object()\n    result = sentinel\n    for item in lst:\n        result = item\n    if result is sentinel:\n        raise IndexError(\"empty\")\n    return result", "inputs": [["[1]"], ["[1, 2, 3]"], ["[True, 0, -5]"]], "outputs": ["1", "3", "-5"]}
{"id": "llmlist_5", "header": "def init(lst):", "description": "Return a new list of all elements except the last.", "code": "def init(lst):\n    n = len(lst)\n    if n <= 1:\n        return []\n    res = []\n    for i in range(n - 1):\n        res.append(lst[i])\n    return res", "inputs": [["[1]"], ["[1, 2, 3]"], ["[[1], [2]]"]], "outputs": ["[]", "[1, 2]", "[[1]]"]}
{"id": "llmlist_6", "header": "def reverse(lst):", "description": "Return a new list with elements of lst in reverse order.", "code": "def reverse(lst):\n    n = len(lst)\n    res = [None] * n\n    i = 0\n    while i < n:\n        res[i] = lst[n - 1 - i]\n        i += 1\n    return res", "inputs": [["[1, 2, 3]"], ["[42]"], ["[True, 0, -5, 7]"]], "outputs": ["[3, 2, 1]", "[42]", "[7, -5, 0, True]"]}
{"id": "llmlist_7", "header": "def copy(lst):", "description": "Return a shallow copy of lst.", "code": "def copy(lst):\n    n = len(lst)\n    result = [None] * n\n    i = 0\n    while i < n:\n        result[i] = lst[i]\n        i += 1\n    return result", "inputs": [["[1, 2, 3]"], ["[True, False, 0]"], ["[[1, 2], [3], 4]"]], "outputs": ["[1, 2, 3]", "[True, False, 0]", "[[1, 2], [3], 4]"]}
{"id": "llmlist_8", "header": "def append_item(lst, value):", "description": "Return a new list with value appended to the end.", "code": "def append_item(lst, value):\n    n = 0\n    for _ in lst:\n        n += 1\n    result = [None] * (n + 1)\n    i = 0\n    for x in lst:\n        result[i] = x\n        i += 1\n    result[i] = value\n    return result", "inputs": [["[1]", "2"], ["[1, 2, 3]", "0"], ["[True, False]", "[3]"]], "outputs": ["[1, 2]", "[1, 2, 3, 0]", "[True, False, [3]]"]}
{"id": "llmlist_9", "header": "def prepend_item(lst, value):", "description": "Return a new list with value inserted at the beginning.", "code": "def prepend_item(lst, value):\n    result = [value]\n    for i in range(len(lst)):\n        result.append(lst[i])\n    return result", "inputs": [["[1, 2, 3]", "0"], ["[True, False]", "True"], ["[[1], [2]]", "[0]"]], "outputs": ["[0, 1, 2, 3]", "[True, True, False]", "[[0], [1], [2]]"]}
{"id": "llmlist_10", "header": "def insert_at(lst, index, value):", "description": "Return a new list with value inserted at position index.", "code": "def insert_at(lst, index, value):\n    n = len(lst)\n    if index < 0:\n        pos = 0\n    elif index > n:\n        pos = n\n    else:\n        pos = index\n    result = []\n    i = 0\n    while i < pos and i < n:\n        result.append(lst[i])\n        i += 1\n    result.append(value)\n    while i < n:\n        result.append(lst[i])\n        i += 1\n    return result", "inputs": [["[1, 2, 3]", "1", "99"], ["[4, 5]", "-5", "0"], ["[7, 8, 9]", "10", "True"]], "outputs": ["[1, 99, 2, 3]", "[0, 4, 5]", "[7, 8, 9, True]"]}
{"id": "llmlist_11", "header": "def remove_at(lst, index):", "description": "Return a new list with the element at index removed.", "code": "def remove_at(lst, index):\n    if not isinstance(index, int):\n        raise TypeError(\"index must be an integer\")\n    n = len(lst)\n    if index < 0:\n        index = n + index\n    if index < 0 or index >= n:\n        raise IndexError(\"index out of range\")\n    result = []\n    i = 0\n    while i < n:\n        if i != index:\n            result.append(lst[i])\n        i += 1\n    return result", "inputs": [["[1, 2, 3]", "1"], ["[10, 20, 30]", "-1"], ["[7]", "0"]], "outputs": ["[1, 3]", "[10, 20]", "[]"]}
{"id": "llmlist_12", "header": "def replace_at(lst, index, value):", "description": "Return a new list with the element at index replaced by value.", "code": "def replace_at(lst, index, value):\n    if not isinstance(index, int):\n        raise TypeError(\"index must be an integer\")\n    n = len(lst)\n    if index < 0:\n        idx = n + index\n    else:\n        idx = index\n    if idx < 0 or idx >= n:\n        raise IndexError(\"list index out of range\")\n    new_list = []\n    i = 0\n    while i < n:\n        if i == idx:\n            new_list.append(value)\n        else:\n            new_list.append(lst[i])\n        i += 1\n    return new_list", "inputs": [["[1, 2, 3]", "1", "9"], ["[4, 5, 6]", "-1", "0"], ["[7]", "0", "True"]], "outputs": ["[1, 9, 3]", "[4, 5, 0]", "[True]"]}
{"id": "llmlist_13", "header": "def slice_range(lst, start, end):", "description": "Return a sublist from start (inclusive) to end (exclusive).", "code": "def slice_range(lst, start, end):\n    n = 0\n    for _ in lst:\n        n += 1\n    s = start\n    e = end\n    if s < 0:\n        s += n\n    if e < 0:\n        e += n\n    if s < 0:\n        s = 0\n    if e < 0:\n        e = 0\n    if s > n:\n        s = n\n    if e > n:\n        e = n\n    result = []\n    i = s\n    while i < e:\n        result.append(lst[i])\n        i += 1\n    return result", "inputs": [["[1, 2, 3, 4]", "1", "3"], ["[7, 8, 9]", "-10", "10"], ["[5, 6, 7, 8]", "3", "1"]], "outputs": ["[2, 3]", "[7, 8, 9]", "[]"]}
{"id": "llmlist_14", "header": "def concat(lst, other):", "description": "Return a new list that is lst followed by other.", "code": "def concat(lst, other):\n    if not isinstance(lst, list) or not isinstance(other, list):\n        raise TypeError(\"Both arguments must be lists\")\n    result = []\n    i = 0\n    n = len(lst)\n    while i < n:\n        result.append(lst[i])\n        i += 1\n    j = 0\n    m = len(other)\n    while j < m:\n        result.append(other[j])\n        j += 1\n    return result", "inputs": [["[1, 2]", "[3]"], ["[True]", "[0, 1]"], ["[[1], 2]", "[3, [4]]"]], "outputs": ["[1, 2, 3]", "[True, 0, 1]", "[[1], 2, 3, [4]]"]}
{"id": "llmlist_15", "header": "def index_of(lst, value):", "description": "Return the first index of value in lst, or -1 if not found.", "code": "def index_of(lst, value):\n    n = len(lst)\n    i = 0\n    while i < n:\n        if lst[i] == value:\n            return i\n        i += 1\n    return -1", "inputs": [["[5, 2, 3]", "5"], ["[1, 2, 2, 3]", "2"], ["[1, 3, 4]", "2"]], "outputs": ["0", "1", "-1"]}
{"id": "llmlist_16", "header": "def last_index_of(lst, value):", "description": "Return the last index of value in lst, or -1 if not found.", "code": "def last_index_of(lst, value):\n    i = len(lst) - 1\n    while i >= 0:\n        if lst[i] == value:\n            return i\n        i -= 1\n    return -1", "inputs": [["[1, 2, 3, 2]", "2"], ["[5, 6, 7]", "4"], ["[9, 8]", "8"]], "outputs": ["3", "-1", "1"]}
{"id": "llmlist_17", "header": "def contains(lst, value):", "description": "Return True if value appears in lst, else False.", "code": "def contains(lst, value):\n    n = 0\n    for _ in lst:\n        n += 1\n    i = 0\n    found = False\n    while i < n and not found:\n        item = lst[i]\n        try:\n            if item == value:\n                found = True\n        except Exception:\n            found = False\n        i += 1\n    if found:\n        return True\n    return False", "inputs": [["[1, 2, 3]", "4"], ["[True, False, 0]", "1"], ["[[1, 2], 3]", "[1, 2]"]], "outputs": ["False", "True", "True"]}
{"id": "llmlist_18", "header": "def count_value(lst, value):", "description": "Return how many times value appears in lst.", "code": "def count_value(lst, value):\n    total = 0\n    for item in lst:\n        if item == value:\n            total += 1\n    return total", "inputs": [["[1, 2, 1, 1]", "1"], ["[3, 4]", "1"], ["[True, 1, False, 0]", "True"]], "outputs": ["3", "0", "2"]}
{"id": "llmlist_19", "header": "def all_equal(lst):", "description": "Return True if all elements in lst are equal or lst is empty.", "code": "def all_equal(lst):\n    it = iter(lst)\n    try:\n        first = next(it)\n    except StopIteration:\n        return True\n    for x in it:\n        if x != first:\n            return False\n    return True", "inputs": [["[5]"], ["[2, 2, 2]"], ["[1, 2, 1]"]], "outputs": ["True", "True", "False"]}
{"id": "llmlist_20", "header": "def equals(lst, other):", "description": "Return True if lst and other have the same elements in the same order.", "code": "def equals(lst, other):\n    if lst is other:\n        return True\n    try:\n        len1 = len(lst)\n        len2 = len(other)\n    except Exception:\n        return False\n    if len1 != len2:\n        return False\n    i = 0\n    it1 = iter(lst)\n    it2 = iter(other)\n    while i < len1:\n        try:\n            a = next(it1)\n        except StopIteration:\n            return False\n        try:\n            b = next(it2)\n        except StopIteration:\n            return False\n        if a != b:\n            return False\n        i += 1\n    try:\n        next(it1)\n        return False\n    except StopIteration:\n        pass\n    try:\n        next(it2)\n        return False\n    except StopIteration:\n        pass\n    return True", "inputs": [["[1, 2]", "(1, 2)"], ["[1, 2]", "[1, 3]"], ["[1]", "0"]], "outputs": ["True", "False", "False"]}
{"id": "llmlist_21", "header": "def unique(lst):", "description": "Return a new list with first occurrences of each value, preserving order.", "code": "def unique(lst):\n    result = []\n    seen_hashable = {}\n    for x in lst:\n        is_hashable = True\n        try:\n            hx = hash(x)\n        except TypeError:\n            is_hashable = False\n        if is_hashable:\n            bucket = seen_hashable.get(hx)\n            if bucket is None:\n                seen_hashable[hx] = [x]\n                result.append(x)\n            else:\n                found = False\n                for y in bucket:\n                    if x == y:\n                        found = True\n                        break\n                if not found:\n                    bucket.append(x)\n                    result.append(x)\n        else:\n            exists = False\n            for y in result:\n                try:\n                    if x == y:\n                        exists = True\n                        break\n                except Exception:\n                    pass\n            if not exists:\n                result.append(x)\n    return result", "inputs": [["[1, True, 0, False, 1, 2, True, 0]"], ["[[1, 2], [1, 2], [1, 3], [1, 2, 3], [1, 3]]"], ["[(1, 2), (1, 2), [1, 2], [1, 2], (1, 2, 3), [1, 2, 3], None, None]"]], "outputs": ["[1, 0, 2]", "[[1, 2], [1, 3], [1, 2, 3]]", "[(1, 2), [1, 2], (1, 2, 3), [1, 2, 3], None]"]}
{"id": "llmlist_22", "header": "def dedupe_consecutive(lst):", "description": "Return a new list with consecutive duplicates removed.", "code": "def dedupe_consecutive(lst):\n    result = []\n    length = len(lst)\n    i = 0\n    while i < length:\n        current = lst[i]\n        if len(result) == 0:\n            result.append(current)\n        else:\n            if current != result[-1]:\n                result.append(current)\n        i += 1\n    return result", "inputs": [["[1, 1, 2, 2, 2, 1, 3, 3]"], ["['a', 'a', 'b', 'a', 'a']"], ["[7]"]], "outputs": ["[1, 2, 1, 3]", "['a', 'b', 'a']", "[7]"]}
{"id": "llmlist_23", "header": "def filter_less_than(lst, threshold):", "description": "Return a new list of elements < threshold.", "code": "def filter_less_than(lst, threshold):\n    result = []\n    try:\n        length = len(lst)\n    except Exception:\n        raise TypeError(\"lst must support len()\")\n    index = 0\n    while index < length:\n        elem = lst[index]\n        is_comparable = True\n        try:\n            cmp_result = elem < threshold\n        except Exception:\n            is_comparable = False\n            cmp_result = False\n        if is_comparable:\n            if bool(cmp_result):\n                result.append(elem)\n        index += 1\n    return result", "inputs": [["[3, 1, 4, 1]", "3"], ["[2, 'x', [1], 0, True]", "2"], ["['b', 'a', 5, 'c']", "'c'"]], "outputs": ["[1, 1]", "[0, True]", "['b', 'a']"]}
{"id": "llmlist_24", "header": "def filter_greater_than(lst, threshold):", "description": "Return a new list of elements > threshold.", "code": "def filter_greater_than(lst, threshold):\n    result = []\n    index = 0\n    length = len(lst)\n    while index < length:\n        item = lst[index]\n        comparable = True\n        try:\n            _ = item > threshold\n        except Exception:\n            comparable = False\n        if comparable:\n            if item > threshold:\n                result.append(item)\n        index += 1\n    return result", "inputs": [["[1, 2, 3]", "2"], ["[True, False, 2]", "1"], ["[[1], 0, [0, 1], 5]", "1"]], "outputs": ["[3]", "[2]", "[5]"]}
{"id": "llmlist_25", "header": "def filter_equal(lst, value):", "description": "Return a new list of elements equal to value.", "code": "def filter_equal(lst, value):\n    result = []\n    try:\n        import math\n        value_is_nan = isinstance(value, float) and math.isnan(value)\n    except Exception:\n        value_is_nan = False\n        math = None\n    for i in range(len(lst)):\n        item = lst[i]\n        match = False\n        if value_is_nan and math is not None:\n            try:\n                match = isinstance(item, float) and math.isnan(item)\n            except Exception:\n                match = False\n        else:\n            try:\n                match = item == value\n            except Exception:\n                match = False\n        if match:\n            result.append(item)\n    return result", "inputs": [["[1, 2, 1, 3]", "1"], ["['a', 'b']", "'c'"], ["[True, False, 1, 0, None]", "True"]], "outputs": ["[1, 1]", "[]", "[True, 1]"]}
{"id": "llmlist_26", "header": "def remove_value(lst, value):", "description": "Return a new list with all occurrences of value removed.", "code": "def remove_value(lst, value):\n    result = []\n    index = 0\n    length = len(lst)\n    while index < length:\n        item = lst[index]\n        if item != value:\n            result.append(item)\n        index += 1\n    return result", "inputs": [["[1, 2, 3, 2]", "2"], ["[4, 5, 6]", "7"], ["[1, True, 0, False, 1]", "True"]], "outputs": ["[1, 3]", "[4, 5, 6]", "[0, False]"]}
{"id": "llmlist_27", "header": "def map_add(lst, k):", "description": "Return a new list where k is added to each element.", "code": "def map_add(lst, k):\n    result = []\n    for i in range(len(lst)):\n        result.append(lst[i] + k)\n    return result", "inputs": [["[1, 2, 3]", "0"], ["[-5, 0, 7]", "3"], ["[10, -2]", "-4"]], "outputs": ["[1, 2, 3]", "[-2, 3, 10]", "[6, -6]"]}
{"id": "llmlist_28", "header": "def map_subtract(lst, k):", "description": "Return a new list where k is subtracted from each element.", "code": "def map_subtract(lst, k):\n    if isinstance(k, bool) or not isinstance(k, (int, float)):\n        raise TypeError(\"k must be a number\")\n    if not isinstance(lst, list):\n        raise TypeError(\"lst must be a list\")\n    result = []\n    idx = 0\n    n = len(lst)\n    while idx < n:\n        x = lst[idx]\n        if isinstance(x, bool) or not isinstance(x, (int, float)):\n            raise TypeError(\"all elements of lst must be numbers\")\n        result.append(x - k)\n        idx += 1\n    return result", "inputs": [["[1, 2, 3]", "1"], ["[0, -5, 10]", "0"], ["[-2, 4, 7]", "-3"]], "outputs": ["[0, 1, 2]", "[0, -5, 10]", "[1, 7, 10]"]}
{"id": "llmlist_29", "header": "def map_multiply(lst, k):", "description": "Return a new list where each element is multiplied by k.", "code": "def map_multiply(lst, k):\n    n = len(lst)\n    result = [None] * n\n    for i in range(n):\n        result[i] = lst[i] * k\n    return result", "inputs": [["[1, 2, 3]", "2"], ["[-1, 0, 4]", "0"], ["[5, -2]", "-3"]], "outputs": ["[2, 4, 6]", "[0, 0, 0]", "[-15, 6]"]}
{"id": "llmlist_30", "header": "def map_abs(lst):", "description": "Return a new list of absolute values of elements.", "code": "def map_abs(lst):\n    result = []\n    for item in lst:\n        if isinstance(item, bool):\n            x = 1 if item else 0\n        elif isinstance(item, (int, float)):\n            x = item\n        else:\n            raise TypeError(\"Unsupported element type\")\n        if x < 0:\n            y = -x\n        else:\n            y = x + 0\n        if y == 0:\n            y = 0.0 if isinstance(x, float) else 0\n        result.append(y)\n    return result", "inputs": [["[1, -2, 0]"], ["[True, False, 2]"], ["[-5, True, 3]"]], "outputs": ["[1, 2, 0]", "[1, 0, 2]", "[5, 1, 3]"]}
{"id": "llmlist_31", "header": "def map_negate(lst):", "description": "Return a new list where each element is negated.", "code": "def map_negate(lst):\n    out = []\n    for i in range(len(lst)):\n        val = lst[i]\n        out.append(-val)\n    return out", "inputs": [["[1, 2, 3]"], ["[0]"], ["[-1, -2, 5]"]], "outputs": ["[-1, -2, -3]", "[0]", "[1, 2, -5]"]}
{"id": "llmlist_32", "header": "def clamp(lst, low, high):", "description": "Return a new list where each element is clamped to [low, high].", "code": "def clamp(lst, low, high):\n    if low > high:\n        raise ValueError(\"low cannot be greater than high\")\n    result = []\n    for x in lst:\n        v = x\n        if v < low:\n            v = low\n        elif v > high:\n            v = high\n        result.append(v)\n    return result", "inputs": [["[0, 5, 10, 15]", "3", "12"], ["[7, 7, 7]", "7", "7"], ["[-5, -1, 0, 2]", "-3", "1"]], "outputs": ["[3, 5, 10, 12]", "[7, 7, 7]", "[-3, -1, 0, 1]"]}
{"id": "llmlist_33", "header": "def pow_int(lst, exp):", "description": "Return a new list where each element is raised to integer power exp.", "code": "def pow_int(lst, exp):\n    if type(exp) is not int:\n        raise TypeError(\"exp must be an int\")\n    if not isinstance(lst, list):\n        raise TypeError(\"lst must be a list\")\n\n    def _pow_pos(base, n):\n        result = 1.0 if isinstance(base, float) else 1\n        b = base\n        k = n\n        while k > 0:\n            if k & 1:\n                result = result * b\n            b = b * b\n            k >>= 1\n        return result\n\n    def _ipow(base, n):\n        if n == 0:\n            return 1.0 if isinstance(base, float) else 1\n        if n > 0:\n            return _pow_pos(base, n)\n        if base == 0 or base == 0.0:\n            raise ZeroDivisionError(\"0 cannot be raised to a negative power\")\n        pos = _pow_pos(base, -n)\n        return 1.0 / float(pos)\n\n    out = []\n    for x in lst:\n        if type(x) is bool or not isinstance(x, (int, float)):\n            raise TypeError(\"list elements must be int or float\")\n        out.append(_ipow(x, exp))\n    return out", "inputs": [["[2, 3, 0]", "3"], ["[5, -2]", "0"], ["[-1, 2, 3]", "-2"]], "outputs": ["[8, 27, 0]", "[1, 1]", "[1.0, 0.25, 0.1111111111111111]"]}
{"id": "llmlist_34", "header": "def sum_list(lst):", "description": "Return the sum of the elements in lst.", "code": "def sum_list(lst):\n    total = 0\n    for x in lst:\n        if not isinstance(x, (int, float, bool)):\n            raise TypeError(\"All elements must be numeric\")\n        total += x\n    return total", "inputs": [["[1, 2, 3]"], ["[-5, 0, 10]"], ["[True, False, 2]"]], "outputs": ["6", "5", "3"]}
{"id": "llmlist_35", "header": "def product_list(lst):", "description": "Return the product of the elements in lst (1 for empty).", "code": "def product_list(lst):\n    result = 1\n    for x in lst:\n        result = result * x\n    return result", "inputs": [["[4, 0, 5]"], ["[-1, -2, 3]"], ["[7]"]], "outputs": ["0", "6", "7"]}
{"id": "llmlist_36", "header": "def min_value(lst):", "description": "Return the smallest element in lst.", "code": "def min_value(lst):\n    if lst is None:\n        raise TypeError(\"lst is None\")\n    try:\n        n = len(lst)\n    except Exception:\n        lst = list(lst)\n        n = len(lst)\n    if n == 0:\n        raise ValueError(\"min_value() arg is an empty sequence\")\n    m = lst[0]\n    for i in range(1, n):\n        v = lst[i]\n        if v < m:\n            m = v\n    return m", "inputs": [["[3, 1, 2]"], ["[-1, -5, -3]"], ["[7]"]], "outputs": ["1", "-5", "7"]}
{"id": "llmlist_37", "header": "def max_value(lst):", "description": "Return the largest element in lst.", "code": "def max_value(lst):\n    if not lst:\n        raise ValueError(\"max_value() arg is an empty sequence\")\n    m = lst[0]\n    i = 1\n    n = len(lst)\n    while i < n:\n        v = lst[i]\n        if v > m:\n            m = v\n        i += 1\n    return m", "inputs": [["[3]"], ["[2, 2, 2]"], ["[-5, -1, -3, -4]"]], "outputs": ["3", "2", "-1"]}
{"id": "llmlist_38", "header": "def argmin_index(lst):", "description": "Return the index of the first occurrence of the minimum value.", "code": "def argmin_index(lst):\n    if not lst:\n        raise ValueError(\"argmin_index() arg is an empty sequence\")\n    min_idx = 0\n    min_val = lst[0]\n    i = 1\n    n = len(lst)\n    while i < n:\n        v = lst[i]\n        if v < min_val:\n            min_val = v\n            min_idx = i\n        i += 1\n    return min_idx", "inputs": [["[1, 2, 3]"], ["[3, 1, 1, 2]"], ["[5, 4, 3, 2]"]], "outputs": ["0", "1", "3"]}
{"id": "llmlist_39", "header": "def argmax_index(lst):", "description": "Return the index of the first occurrence of the maximum value.", "code": "def argmax_index(lst):\n    found = False\n    max_val = None\n    max_idx = -1\n    for idx, val in enumerate(lst):\n        if not found:\n            max_val = val\n            max_idx = idx\n            found = True\n        else:\n            if val > max_val:\n                max_val = val\n                max_idx = idx\n    if not found:\n        raise ValueError(\"argmax_index() arg is an empty sequence\")\n    return max_idx", "inputs": [["[3, 1, 2]"], ["[1, 5, 5, 2]"], ["[-3, -1, -2]"]], "outputs": ["0", "1", "1"]}
{"id": "llmlist_40", "header": "def is_sorted_ascending(lst):", "description": "Return True if lst is nondecreasing.", "code": "def is_sorted_ascending(lst):\n    n = len(lst)\n    i = 1\n    while i < n:\n        a = lst[i - 1]\n        b = lst[i]\n        try:\n            if b < a:\n                return False\n        except TypeError:\n            return False\n        i += 1\n    return True", "inputs": [["[1, 1, 2]"], ["[3, 2, 1]"], ["[1, 'a']"]], "outputs": ["True", "False", "False"]}
{"id": "llmlist_41", "header": "def is_sorted_strict_ascending(lst):", "description": "Return True if lst is strictly increasing.", "code": "def is_sorted_strict_ascending(lst):\n    n = len(lst)\n    if n <= 1:\n        return True\n    prev = lst[0]\n    i = 1\n    while i < n:\n        curr = lst[i]\n        try:\n            if not (prev < curr):\n                return False\n        except Exception:\n            return False\n        prev = curr\n        i += 1\n    return True", "inputs": [["[7]"], ["[1, 2, 3]"], ["[1, 2, 'a']"]], "outputs": ["True", "True", "False"]}
{"id": "llmlist_42", "header": "def sort_ascending(lst):", "description": "Return a new list with elements sorted in nondecreasing order.", "code": "def sort_ascending(lst):\n    def merge(left, right):\n        i = 0\n        j = 0\n        merged = []\n        len_left = len(left)\n        len_right = len(right)\n        while i < len_left and j < len_right:\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        if i < len_left:\n            merged.extend(left[i:])\n        if j < len_right:\n            merged.extend(right[j:])\n        return merged\n    def mergesort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = mergesort(arr[:mid])\n        right = mergesort(arr[mid:])\n        return merge(left, right)\n    return mergesort(list(lst))", "inputs": [["[3, 1, 2]"], ["[5, 5, 2, 2]"], ["[-1, 0, -3, 2]"]], "outputs": ["[1, 2, 3]", "[2, 2, 5, 5]", "[-3, -1, 0, 2]"]}
{"id": "llmlist_43", "header": "def sort_descending(lst):", "description": "Return a new list with elements sorted in nonincreasing order.", "code": "def sort_descending(lst):\n    arr = list(lst)\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] < key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr", "inputs": [["[1, 2, 3]"], ["[5, 5, 2, 2, -1]"], ["[9, 4, 0, -3]"]], "outputs": ["[3, 2, 1]", "[5, 5, 2, 2, -1]", "[9, 4, 0, -3]"]}
{"id": "llmlist_44", "header": "def stable_partition_even_odd(lst):", "description": "Return a new list with all even numbers first, preserving order.", "code": "def stable_partition_even_odd(lst):\n    evens = []\n    odds = []\n    for i in range(len(lst)):\n        x = lst[i]\n        if isinstance(x, int):\n            if x % 2 == 0:\n                evens.append(x)\n            else:\n                odds.append(x)\n        else:\n            odds.append(x)\n    return evens + odds", "inputs": [["[3, 2, 4, 1]"], ["[0, True, 3, (7,)]"], ["[(1,), -2, -3, 6]"]], "outputs": ["[2, 4, 3, 1]", "[0, True, 3, (7,)]", "[-2, 6, (1,), -3]"]}
{"id": "llmlist_45", "header": "def partition_by_value(lst, pivot):", "description": "Return a new list with elements < pivot, then == pivot, then > pivot.", "code": "def partition_by_value(lst, pivot):\n    less = []\n    equal = []\n    greater = []\n    for x in lst:\n        if x < pivot:\n            less.append(x)\n        elif x == pivot:\n            equal.append(x)\n        else:\n            greater.append(x)\n    result = []\n    for group in (less, equal, greater):\n        for item in group:\n            result.append(item)\n    return result", "inputs": [["[3, 1, 4, 3, 2]", "3"], ["[5, 5, 5]", "5"], ["[0, -1, 2]", "1"]], "outputs": ["[1, 2, 3, 3, 4]", "[5, 5, 5]", "[0, -1, 2]"]}
{"id": "llmlist_46", "header": "def binary_search(lst, value):", "description": "Return index of value in a sorted lst, or -1 if not found.", "code": "def binary_search(lst, value):\n    left = 0\n    right = len(lst)\n    while left < right:\n        mid = left + (right - left) // 2\n        if lst[mid] < value:\n            left = mid + 1\n        else:\n            right = mid\n    if left < len(lst) and lst[left] == value:\n        return left\n    return -1", "inputs": [["[1, 3, 5, 7]", "5"], ["[1, 2, 4, 4, 4, 5]", "4"], ["[2, 4, 6, 8]", "3"]], "outputs": ["2", "2", "-1"]}
{"id": "llmlist_47", "header": "def lower_bound(lst, value):", "description": "Return first index i where lst[i] >= value in sorted lst.", "code": "def lower_bound(lst, value):\n    left = 0\n    right = len(lst)\n    while left < right:\n        mid = (left + right) // 2\n        if lst[mid] < value:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "inputs": [["[1, 2, 4, 5]", "0"], ["[1, 2, 2, 2, 3]", "2"], ["[1, 3, 5]", "6"]], "outputs": ["0", "1", "3"]}
{"id": "llmlist_48", "header": "def upper_bound(lst, value):", "description": "Return first index i where lst[i] > value in sorted lst.", "code": "def upper_bound(lst, value):\n    lo = 0\n    hi = len(lst)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if lst[mid] <= value:\n            lo = mid + 1\n        else:\n            hi = mid\n    return lo", "inputs": [["[2, 3, 4]", "1"], ["[1, 1, 2, 2]", "1"], ["[1, 3, 5]", "5"]], "outputs": ["0", "2", "3"]}
{"id": "llmlist_49", "header": "def rotate_left(lst, k):", "description": "Return a new list rotated left by k positions.", "code": "def rotate_left(lst, k):\n    n = len(lst)\n    if n == 0:\n        return []\n    k = int(k) % n\n    if k == 0:\n        result = []\n        for i in range(n):\n            result.append(lst[i])\n        return result\n    result = []\n    i = k\n    while i < n:\n        result.append(lst[i])\n        i += 1\n    i = 0\n    while i < k:\n        result.append(lst[i])\n        i += 1\n    return result", "inputs": [["[1, 2, 3]", "0"], ["[4, 5, 6, 7]", "6"], ["[8, 9]", "-1"]], "outputs": ["[1, 2, 3]", "[6, 7, 4, 5]", "[9, 8]"]}
{"id": "llmlist_50", "header": "def rotate_right(lst, k):", "description": "Return a new list rotated right by k positions.", "code": "def rotate_right(lst, k):\n    n = len(lst)\n    if n == 0:\n        return []\n    k = k % n\n    if k == 0:\n        return lst[:]\n    return lst[-k:] + lst[:-k]", "inputs": [["[1, 2, 3]", "6"], ["[4, 5, 6, 7]", "2"], ["[9, 8, 7]", "-1"]], "outputs": ["[1, 2, 3]", "[6, 7, 4, 5]", "[8, 7, 9]"]}
{"id": "llmlist_51", "header": "def shift_left_fill(lst, k, fill):", "description": "Return a new list shifted left by k, filling vacated spots with fill.", "code": "def shift_left_fill(lst, k, fill):\n    n = len(lst)\n    if n == 0:\n        return []\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer\")\n    if k <= 0:\n        return list(lst)\n    if k >= n:\n        return [fill] * n\n    res = [None] * n\n    i = 0\n    while i < n - k:\n        res[i] = lst[i + k]\n        i += 1\n    while i < n:\n        res[i] = fill\n        i += 1\n    return res", "inputs": [["[1, 2, 3]", "1", "0"], ["[5, 6]", "0", "True"], ["[9, 8, 7]", "5", "1"]], "outputs": ["[2, 3, 0]", "[5, 6]", "[1, 1, 1]"]}
{"id": "llmlist_52", "header": "def shift_right_fill(lst, k, fill):", "description": "Return a new list shifted right by k, filling vacated spots with fill.", "code": "def shift_right_fill(lst, k, fill):\n    n = len(lst)\n    if n == 0:\n        return []\n    if not isinstance(k, int):\n        try:\n            k = int(k)\n        except Exception:\n            k = 0\n    if k <= 0:\n        return list(lst)\n    if k >= n:\n        return [fill] * n\n    res = [fill] * n\n    for i in range(n - 1, -1, -1):\n        dest = i + k\n        if dest < n:\n            res[dest] = lst[i]\n    return res", "inputs": [["[1, 2, 3]", "1", "0"], ["[4, 5]", "5", "9"], ["[7, 8]", "[2, 3]", "1"]], "outputs": ["[0, 1, 2]", "[9, 9]", "[7, 8]"]}
{"id": "llmlist_53", "header": "def take(lst, n):", "description": "Return the first n elements (or all if n exceeds length).", "code": "def take(lst, n):\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        return []\n    result = []\n    count = 0\n    length = 0\n    for _ in lst:\n        length += 1\n    limit = n if n < length else length\n    for item in lst:\n        if count >= limit:\n            break\n        result.append(item)\n        count += 1\n    return result", "inputs": [["[1, 2, 3]", "2"], ["[4, 5]", "5"], ["[7, 8, 9]", "0"]], "outputs": ["[1, 2]", "[4, 5]", "[]"]}
{"id": "llmlist_54", "header": "def drop(lst, n):", "description": "Return lst without the first n elements (or empty if n exceeds length).", "code": "def drop(lst, n):\n    if not isinstance(lst, list):\n        raise TypeError(\"lst must be a list\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    L = len(lst)\n    if n <= 0:\n        start = 0\n    elif n >= L:\n        return []\n    else:\n        start = n\n    result = []\n    i = start\n    while i < L:\n        result.append(lst[i])\n        i += 1\n    return result", "inputs": [["[1, 2, 3]", "-1"], ["[9, 8, 7]", "2"], ["[4, 5]", "2"]], "outputs": ["[1, 2, 3]", "[7]", "[]"]}
{"id": "llmlist_55", "header": "def take_while_positive(lst):", "description": "Return the longest prefix of lst with positive numbers.", "code": "def take_while_positive(lst):\n    count = 0\n    for x in lst:\n        comparable = True\n        positive = False\n        try:\n            positive = x > 0\n        except Exception:\n            comparable = False\n        if comparable and positive:\n            count += 1\n        else:\n            break\n    return lst[:count]", "inputs": [["[1, 2, 3]"], ["[0, 1, 2]"], ["[4, 'a', 5]"]], "outputs": ["[1, 2, 3]", "[]", "[4]"]}
{"id": "llmlist_56", "header": "def drop_while_positive(lst):", "description": "Return lst with the longest positive-number prefix removed.", "code": "def drop_while_positive(lst):\n    n = len(lst)\n    i = 0\n    while i < n:\n        x = lst[i]\n        is_number = isinstance(x, (int, float)) and not isinstance(x, bool)\n        if not is_number:\n            break\n        if x > 0:\n            i += 1\n            continue\n        break\n    return lst[i:]", "inputs": [["[1, 2, 3]"], ["[5, 2, 0, -1]"], ["[7, 'x', 8]"]], "outputs": ["[]", "[0, -1]", "['x', 8]"]}
{"id": "llmlist_57", "header": "def prefix_sums(lst):", "description": "Return a new list of running sums.", "code": "def prefix_sums(lst):\n    result = []\n    total = 0\n    for x in lst:\n        if isinstance(x, bool):\n            raise TypeError(\"Boolean values are not supported\")\n        if not isinstance(x, (int, float)):\n            raise TypeError(\"All elements must be int or float\")\n        total = total + x\n        result.append(total)\n    return result", "inputs": [["[1, 2, 3]"], ["[0, -1, 5]"], ["[7]"]], "outputs": ["[1, 3, 6]", "[0, -1, 4]", "[7]"]}
{"id": "llmlist_58", "header": "def prefix_max(lst):", "description": "Return a new list where each element is the max up to that index.", "code": "def prefix_max(lst):\n    result = []\n    n = len(lst)\n    if n == 0:\n        return result\n    current_max = lst[0]\n    result.append(current_max)\n    i = 1\n    while i < n:\n        x = lst[i]\n        if x > current_max:\n            current_max = x\n        result.append(current_max)\n        i += 1\n    return result", "inputs": [["[1, 2, 3, 4]"], ["[7, 3, 3, 1]"], ["[-2, 0, -1, 5]"]], "outputs": ["[1, 2, 3, 4]", "[7, 7, 7, 7]", "[-2, 0, 0, 5]"]}
{"id": "llmlist_59", "header": "def prefix_min(lst):", "description": "Return a new list where each element is the min up to that index.", "code": "def prefix_min(lst):\n    n = len(lst)\n    result = []\n    if n == 0:\n        return result\n    current_min = lst[0]\n    result.append(current_min)\n    i = 1\n    while i < n:\n        val = lst[i]\n        if val < current_min:\n            current_min = val\n        result.append(current_min)\n        i += 1\n    return result", "inputs": [["[5]"], ["[5, 4, 3, 2]"], ["[3, 3, -1, 2, -1]"]], "outputs": ["[5]", "[5, 4, 3, 2]", "[3, 3, -1, -1, -1]"]}
{"id": "llmlist_60", "header": "def diff_adjacent(lst):", "description": "Return a new list of differences lst[i+1] - lst[i].", "code": "def diff_adjacent(lst):\n    result = []\n    n = len(lst)\n    if n <= 1:\n        return result\n    i = 0\n    while i < n - 1:\n        a = lst[i]\n        b = lst[i + 1]\n        result.append(b - a)\n        i += 1\n    return result", "inputs": [["[5]"], ["[1, 4]"], ["[3, -1, -1, 2]"]], "outputs": ["[]", "[3]", "[-4, 0, 3]"]}
{"id": "llmlist_61", "header": "def pair_sums(lst):", "description": "Return a new list of sums of adjacent pairs.", "code": "def pair_sums(lst):\n    result = []\n    length = len(lst)\n    index = 0\n    while index + 1 < length:\n        left = lst[index]\n        right = lst[index + 1]\n        total = left + right\n        result.append(total)\n        index += 1\n    return result", "inputs": [["[1]"], ["[2, 3]"], ["[1, -1, 0, 5]"]], "outputs": ["[]", "[5]", "[0, -1, 5]"]}
{"id": "llmlist_62", "header": "def window_sums(lst, w):", "description": "Return a new list of sums over each window of size w.", "code": "def window_sums(lst, w):\n    if not isinstance(w, int):\n        raise TypeError(\"w must be an integer\")\n    if w <= 0:\n        return []\n    n = len(lst)\n    if w > n:\n        return []\n    s = 0\n    i = 0\n    while i < w:\n        s += lst[i]\n        i += 1\n    res = [s]\n    i = w\n    while i < n:\n        s += lst[i]\n        s -= lst[i - w]\n        res.append(s)\n        i += 1\n    return res", "inputs": [["[1, 2, 3, 4]", "2"], ["[1, 0, 2]", "3"], ["[7, 8]", "0"]], "outputs": ["[3, 5, 7]", "[3]", "[]"]}
{"id": "llmlist_63", "header": "def window_max(lst, w):", "description": "Return a new list of maximums over each window of size w.", "code": "def window_max(lst, w):\n    if not isinstance(w, int) or w < 1:\n        raise ValueError(\"w must be a positive integer\")\n    n = len(lst)\n    if w > n:\n        return []\n    from collections import deque\n    q = deque()\n    out = []\n    for i, x in enumerate(lst):\n        while q and q[0] <= i - w:\n            q.popleft()\n        while q and lst[q[-1]] <= x:\n            q.pop()\n        q.append(i)\n        if i >= w - 1:\n            out.append(lst[q[0]])\n    return out", "inputs": [["[1, 3, 3, 2]", "2"], ["[4, 1, 6]", "1"], ["[7, 1]", "3"]], "outputs": ["[3, 3, 3]", "[4, 1, 6]", "[]"]}
{"id": "llmlist_64", "header": "def interleave(lst, other):", "description": "Return a new list by alternating elements from lst and other.", "code": "def interleave(lst, other):\n    result = []\n    i = 0\n    j = 0\n    len1 = len(lst)\n    len2 = len(other)\n    while i < len1 and j < len2:\n        result.append(lst[i])\n        result.append(other[j])\n        i += 1\n        j += 1\n    while i < len1:\n        result.append(lst[i])\n        i += 1\n    while j < len2:\n        result.append(other[j])\n        j += 1\n    return result", "inputs": [["[1, 2]", "[3, 4]"], ["[1, 2, 3]", "[9]"], ["[7]", "[8, 9, 10]"]], "outputs": ["[1, 3, 2, 4]", "[1, 9, 2, 3]", "[7, 8, 9, 10]"]}
{"id": "llmlist_65", "header": "def zip_sum(lst, other):", "description": "Return a new list where each element is lst[i] + other[i] up to min length.", "code": "def zip_sum(lst, other):\n    a_len = len(lst)\n    b_len = len(other)\n    if a_len <= b_len:\n        limit = a_len\n    else:\n        limit = b_len\n    result = []\n    i = 0\n    while i < limit:\n        result.append(lst[i] + other[i])\n        i += 1\n    return result", "inputs": [["[1, 2]", "[3, 4]"], ["[1, -2]", "[0, 3, 4]"], ["[10, 20, 30]", "[1, -1]"]], "outputs": ["[4, 6]", "[1, 1]", "[11, 19]"]}
{"id": "llmlist_66", "header": "def zip_diff(lst, other):", "description": "Return a new list where each element is lst[i] - other[i] up to min length.", "code": "def zip_diff(lst, other):\n    res = []\n    len1 = len(lst)\n    len2 = len(other)\n    n = len1 if len1 < len2 else len2\n    i = 0\n    while i < n:\n        a = lst[i]\n        b = other[i]\n        res.append(a - b)\n        i += 1\n    return res", "inputs": [["[1, 2, 3]", "[3, 2, 1]"], ["[5, 0, -1, 4]", "[2, 2]"], ["[7]", "[10, -3, 0]"]], "outputs": ["[-2, 0, 2]", "[3, -2]", "[-3]"]}
{"id": "llmlist_67", "header": "def union_ordered(lst, other):", "description": "Return unique elements from lst then other, preserving first appearance.", "code": "def union_ordered(lst, other):\n    result = []\n    for seq in (lst, other):\n        i = 0\n        while i < len(seq):\n            x = seq[i]\n            found = False\n            j = 0\n            while j < len(result):\n                if result[j] == x:\n                    found = True\n                    break\n                j += 1\n            if not found:\n                result.append(x)\n            i += 1\n    return result", "inputs": [["[1, 2, 2, 3]", "[3, 4, 1]"], ["[True, 0, 1]", "[False, 1, True, 2]"], ["[-1, -2, -1, 0]", "[0, -3, -2]"]], "outputs": ["[1, 2, 3, 4]", "[True, 0, 2]", "[-1, -2, 0, -3]"]}
{"id": "llmlist_68", "header": "def intersection_ordered(lst, other):", "description": "Return unique elements appearing in both, in order of first appearance in lst.", "code": "def intersection_ordered(lst, other):\n    def contains(seq, item):\n        for v in seq:\n            if v == item:\n                return True\n        return False\n    other_list = list(other)\n    result = []\n    for x in lst:\n        if not contains(result, x) and contains(other_list, x):\n            result.append(x)\n    return result", "inputs": [["[1, 2, 3, 2, 1]", "[3, 3, 1]"], ["[9, 8]", "[1, 2]"], ["[True, 1, 0, False]", "(1, 0)"]], "outputs": ["[1, 3]", "[]", "[True, 0]"]}
{"id": "llmlist_69", "header": "def difference_ordered(lst, other):", "description": "Return elements of lst not in other, preserving order.", "code": "def difference_ordered(lst, other):\n    result = []\n    other_list = list(other)\n    try:\n        other_set = set(other_list)\n        for item in lst:\n            if item not in other_set:\n                result.append(item)\n    except TypeError:\n        for item in lst:\n            found = False\n            for o in other_list:\n                if item == o:\n                    found = True\n                    break\n            if not found:\n                result.append(item)\n    return result", "inputs": [["[1, 2, 3, 2, 4]", "(2, 5)"], ["[[1], [3], [1]]", "[[1], [2]]"], ["[0, 1, True, 2, False]", "[False, True]"]], "outputs": ["[1, 3, 4]", "[[3]]", "[2]"]}
{"id": "llmlist_70", "header": "def symmetric_difference_ordered(lst, other):", "description": "Return elements appearing in exactly one of lst or other, in order encountered.", "code": "def symmetric_difference_ordered(lst, other):\n    out = []\n    def contains(seq, x):\n        for y in seq:\n            if y == x:\n                return True\n        return False\n    def already_added(seq, x):\n        for y in seq:\n            if y == x:\n                return True\n        return False\n    for x in lst:\n        if not contains(other, x) and not already_added(out, x):\n            out.append(x)\n    for x in other:\n        if not contains(lst, x) and not already_added(out, x):\n            out.append(x)\n    return out", "inputs": [["[1, 2, 3]", "[3, 4, 2]"], ["[1, 1, 2]", "[2, 3, 3]"], ["[True, 0, 2, False]", "[1, False, 3, 0]"]], "outputs": ["[1, 4]", "[1, 3]", "[2, 3]"]}
{"id": "llmlist_71", "header": "def repeat_each(lst, times):", "description": "Return a new list with each element repeated 'times' times.", "code": "def repeat_each(lst, times):\n    if not isinstance(times, int):\n        raise TypeError(\"times must be an integer\")\n    if times < 0:\n        raise ValueError(\"times must be non-negative\")\n    result = []\n    if times == 0 or not lst:\n        return result\n    for i in range(len(lst)):\n        item = lst[i]\n        for _ in range(times):\n            result.append(item)\n    return result", "inputs": [["[1, 2]", "3"], ["[7, 8, 9]", "1"], ["[4]", "0"]], "outputs": ["[1, 1, 1, 2, 2, 2]", "[7, 8, 9]", "[]"]}
{"id": "llmlist_72", "header": "def expand_by_counts(values, counts):", "description": "Return a new list by repeating values[i] counts[i] times.", "code": "def expand_by_counts(values, counts):\n    if not isinstance(values, list) or not isinstance(counts, list):\n        raise TypeError(\"values and counts must be lists\")\n    if len(values) != len(counts):\n        raise ValueError(\"values and counts must have the same length\")\n    result = []\n    i = 0\n    n = len(values)\n    while i < n:\n        c = counts[i]\n        if not isinstance(c, int):\n            raise TypeError(\"counts must contain integers\")\n        if c < 0:\n            raise ValueError(\"counts must be non-negative\")\n        j = 0\n        while j < c:\n            result.append(values[i])\n            j += 1\n        i += 1\n    return result", "inputs": [["[1, 2, 3]", "[1, 2, 1]"], ["['a', 'b']", "[0, 3]"], ["[True, False]", "[2, 1]"]], "outputs": ["[1, 2, 2, 3]", "['b', 'b', 'b']", "[True, True, False]"]}
{"id": "llmlist_73", "header": "def compress_by_mask(lst, mask):", "description": "Return a new list keeping lst[i] where mask[i] is truthy (nonzero).", "code": "def compress_by_mask(lst, mask):\n    result = []\n    len_lst = len(lst)\n    len_mask = len(mask)\n    limit = len_lst if len_lst <= len_mask else len_mask\n    i = 0\n    while i < limit:\n        current_mask_value = mask[i]\n        take = True if current_mask_value else False\n        if take:\n            result.append(lst[i])\n        i += 1\n    return result", "inputs": [["[1, 2, 3]", "[0, 1, -1]"], ["[4, 5, 6, 7]", "[1, 0]"], ["[8, 9]", "[0, 0, 1, 1]"]], "outputs": ["[2, 3]", "[4]", "[]"]}
{"id": "llmlist_74", "header": "def indices_where_equal(lst, value):", "description": "Return a list of indices where lst[i] == value.", "code": "def indices_where_equal(lst, value):\n    result = []\n    length = 0\n    for _ in lst:\n        length += 1\n    i = 0\n    while i < length:\n        item = lst[i]\n        is_equal = False\n        try:\n            if item == value:\n                is_equal = True\n        except Exception:\n            is_equal = False\n        if is_equal:\n            result.append(i)\n        i += 1\n    return result", "inputs": [["[1, 2, 1]", "1"], ["['a', 'b']", "'c'"], ["[True, 1, 0, False]", "1"]], "outputs": ["[0, 2]", "[]", "[0, 1]"]}
{"id": "llmlist_75", "header": "def indices_where_even(lst):", "description": "Return a list of indices where elements are even.", "code": "def indices_where_even(lst):\n    result = []\n    i = 0\n    while i < len(lst):\n        val = lst[i]\n        is_even = False\n        try:\n            if isinstance(val, bool):\n                is_even = False\n            else:\n                remainder = val % 2\n                if remainder == 0:\n                    is_even = True\n        except Exception:\n            is_even = False\n        if is_even:\n            result.append(i)\n        i += 1\n    return result", "inputs": [["[0, 1, 2]"], ["[-3, -2, 5, 8]"], ["[True, False, 'x', 7]"]], "outputs": ["[0, 2]", "[1, 3]", "[]"]}
{"id": "llmlist_76", "header": "def move_element(lst, from_index, to_index):", "description": "Return a new list with the element moved to a new position.", "code": "def move_element(lst, from_index, to_index):\n    n = len(lst)\n    if n == 0:\n        return []\n    result = list(lst)\n    fi = from_index\n    if fi < 0:\n        fi += n\n    if fi < 0:\n        fi = 0\n    if fi >= n:\n        fi = n - 1\n    ti = to_index\n    if ti < 0:\n        ti += n\n    if ti < 0:\n        ti = 0\n    if ti >= n:\n        ti = n - 1\n    if fi == ti:\n        return result\n    elem = result.pop(fi)\n    if fi < ti:\n        ti -= 1\n    result.insert(ti, elem)\n    return result", "inputs": [["[1, 2, 3]", "7", "100"], ["[1, 2, 3, 4]", "1", "3"], ["[10, 20, 30, 40]", "-1", "-10"]], "outputs": ["[1, 2, 3]", "[1, 3, 2, 4]", "[40, 10, 20, 30]"]}
{"id": "llmlist_77", "header": "def swap_indices(lst, i, j):", "description": "Return a new list with elements at i and j swapped.", "code": "def swap_indices(lst, i, j):\n    if not isinstance(i, int) or not isinstance(j, int):\n        raise TypeError(\"Indices must be integers\")\n    if not isinstance(lst, list):\n        lst = list(lst)\n    n = len(lst)\n    ii = i + n if i < 0 else i\n    jj = j + n if j < 0 else j\n    if ii < 0 or ii >= n or jj < 0 or jj >= n:\n        raise IndexError(\"Index out of range\")\n    new_list = lst[:]\n    if ii != jj:\n        temp = new_list[ii]\n        new_list[ii] = new_list[jj]\n        new_list[jj] = temp\n    return new_list", "inputs": [["[1, 2, 3]", "0", "2"], ["[1, 2, 3, 4]", "-1", "-3"], ["(1, 2, 3)", "1", "1"]], "outputs": ["[3, 2, 1]", "[1, 4, 3, 2]", "[1, 2, 3]"]}
{"id": "llmlist_78", "header": "def distinct_count(lst):", "description": "Return the number of distinct values in lst.", "code": "def distinct_count(lst):\n    count = 0\n    seen_hashable = {}\n    seen_unhashable = []\n    for item in lst:\n        try:\n            h = hash(item)\n        except Exception:\n            found = False\n            for s in seen_unhashable:\n                if item == s:\n                    found = True\n                    break\n            if not found:\n                seen_unhashable.append(item)\n                count += 1\n        else:\n            if item not in seen_hashable:\n                seen_hashable[item] = True\n                count += 1\n    return count", "inputs": [["[1, True, 0, False, 2, 1]"], ["[[1, 2], [1, 2], [1, 3], []]"], ["[[1], (1,), [1], \"x\", None]"]], "outputs": ["3", "3", "4"]}
{"id": "llmlist_79", "header": "def mode_value(lst):", "description": "Return the value with the highest frequency; first such in case of tie.", "code": "def mode_value(lst):\n    if not lst:\n        return None\n    counts = {}\n    for x in lst:\n        counts[x] = counts.get(x, 0) + 1\n    max_count = 0\n    for v in counts.values():\n        if v > max_count:\n            max_count = v\n    for x in lst:\n        if counts.get(x, 0) == max_count:\n            return x", "inputs": [["[1, 2, 3]"], ["[2, 2, 1]"], ["[1, 2, 2, 1, 3]"]], "outputs": ["1", "2", "1"]}
{"id": "llmlist_80", "header": "def mean_floor(lst):", "description": "Return the floor of the average of elements (0 if empty).", "code": "def mean_floor(lst):\n    count = 0\n    total = 0.0\n    for x in lst:\n        if isinstance(x, bool):\n            x = int(x)\n        elif isinstance(x, (int, float)):\n            pass\n        else:\n            raise TypeError(\"All elements must be numeric\")\n        total += float(x)\n        count += 1\n    if count == 0:\n        return 0\n    avg = total / count\n    i = int(avg)\n    if avg < 0 and avg != i:\n        return i - 1\n    return i", "inputs": [["[-1, 0]"], ["[True, False, 3]"], ["[2, 4]"]], "outputs": ["-1", "1", "3"]}
{"id": "llmlist_81", "header": "def median_for_sorted(lst):", "description": "Return the middle element for odd-length sorted lst, or lower middle for even.", "code": "def median_for_sorted(lst):\n    n = len(lst)\n    if n == 0:\n        raise ValueError(\"median_for_sorted() arg is an empty sequence\")\n    if n % 2 == 0:\n        idx = n // 2 - 1\n    else:\n        idx = n // 2\n    return lst[idx]", "inputs": [["[1, 3, 5]"], ["[2, 4, 6, 8]"], ["[7]"]], "outputs": ["3", "4", "7"]}
{"id": "llmlist_82", "header": "def range_span(lst):", "description": "Return max(lst) - min(lst) or 0 if empty.", "code": "def range_span(lst):\n    if not lst:\n        return 0\n    iterator = iter(lst)\n    try:\n        first = next(iterator)\n    except StopIteration:\n        return 0\n    current_min = first\n    current_max = first\n    for value in iterator:\n        if value < current_min:\n            current_min = value\n        elif value > current_max:\n            current_max = value\n    return current_max - current_min", "inputs": [["[5]"], ["[3, -2, 3]"], ["[10, 7, 8, 1]"]], "outputs": ["0", "5", "9"]}
{"id": "llmlist_83", "header": "def normalize_min_zero(lst):", "description": "Return a new list with min value subtracted from each element.", "code": "def normalize_min_zero(lst):\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list\")\n    n = len(lst)\n    if n == 0:\n        return []\n    for x in lst:\n        if isinstance(x, bool) or not isinstance(x, (int, float)):\n            raise TypeError(\"All elements must be int or float\")\n    min_val = lst[0]\n    i = 1\n    while i < n:\n        v = lst[i]\n        if v < min_val:\n            min_val = v\n        i += 1\n    result = []\n    for v in lst:\n        result.append(v - min_val)\n    return result", "inputs": [["[1, 3, 2]"], ["[-5, -1, 0]"], ["[7, 7, 7]"]], "outputs": ["[0, 2, 1]", "[0, 4, 5]", "[0, 0, 0]"]}
{"id": "llmlist_84", "header": "def remove_negatives(lst):", "description": "Return a new list with negative numbers removed.", "code": "def remove_negatives(lst):\n    result = []\n    for index in range(len(lst)):\n        item = lst[index]\n        if isinstance(item, (int, float)):\n            if item >= 0:\n                result.append(item)\n        else:\n            result.append(item)\n    return result", "inputs": [["[-1, 0, 2, -3]"], ["['a', -5, 3, [-1], True]"], ["[-2, -1]"]], "outputs": ["[0, 2]", "['a', 3, [-1], True]", "[]"]}
{"id": "llmlist_85", "header": "def keep_negatives(lst):", "description": "Return a new list with only negative numbers.", "code": "def keep_negatives(lst):\n    result = []\n    for x in lst:\n        is_bool = isinstance(x, bool)\n        is_number = isinstance(x, (int, float))\n        if is_number and not is_bool:\n            if x < 0:\n                result.append(x)\n    return result", "inputs": [["[-1, 0, 2, -3]"], ["[True, -2, False, 5]"], ["[\"x\", -4, [1], 3]"]], "outputs": ["[-1, -3]", "[-2]", "[-4]"]}
{"id": "llmlist_86", "header": "def signs(lst):", "description": "Return a new list mapping negatives to -1, zeros to 0, positives to 1.", "code": "def signs(lst):\n    result = []\n    for x in lst:\n        if x > 0:\n            result.append(1)\n        elif x < 0:\n            result.append(-1)\n        else:\n            result.append(0)\n    return result", "inputs": [["[1, -1, 0]"], ["[0, 0, 0]"], ["[-5, 2, -3]"]], "outputs": ["[1, -1, 0]", "[0, 0, 0]", "[-1, 1, -1]"]}
{"id": "llmlist_87", "header": "def bounded_increase(lst, step):", "description": "Return a new list where each element increases by at most 'step' from previous.", "code": "def bounded_increase(lst, step):\n    if not isinstance(lst, list):\n        raise TypeError(\"lst must be a list\")\n    try:\n        s = float(step)\n    except Exception:\n        raise TypeError(\"step must be a number\")\n    if len(lst) == 0:\n        return []\n    if s < 0:\n        s = 0.0\n    result = []\n    prev = lst[0]\n    result.append(prev)\n    i = 1\n    while i < len(lst):\n        curr = lst[i]\n        allowed_max = prev + s\n        if curr > allowed_max:\n            val = allowed_max\n        else:\n            val = curr\n        result.append(val)\n        prev = val\n        i += 1\n    return result", "inputs": [["[1, 10, 15]", "3"], ["[5, 6, 8, 7]", "2"], ["[-3, -2, -1, 0]", "-5"]], "outputs": ["[1, 4.0, 7.0]", "[5, 6, 8, 7]", "[-3, -3.0, -3.0, -3.0]"]}
{"id": "llmlist_88", "header": "def group_consecutive_equals(lst):", "description": "Return a list of group sizes of consecutive equal runs.", "code": "def group_consecutive_equals(lst):\n    result = []\n    if not lst:\n        return result\n    current = lst[0]\n    count = 1\n    i = 1\n    n = len(lst)\n    while i < n:\n        if lst[i] == current:\n            count += 1\n        else:\n            result.append(count)\n            current = lst[i]\n            count = 1\n        i += 1\n    result.append(count)\n    return result", "inputs": [["[7]"], ["[2, 2, 2]"], ["[1, 1, 2, 3, 3, 3, 2, 2, 1]"]], "outputs": ["[1]", "[3]", "[2, 1, 3, 2, 1]"]}
{"id": "llmlist_89", "header": "def expand_run_length(values, lengths):", "description": "Return a new list expanding each value by its run length.", "code": "def expand_run_length(values, lengths):\n    if not isinstance(values, list) or not isinstance(lengths, list):\n        raise TypeError(\"values and lengths must be lists\")\n    if len(values) != len(lengths):\n        raise ValueError(\"values and lengths must have the same length\")\n    result = []\n    idx = 0\n    total = len(values)\n    while idx < total:\n        length = lengths[idx]\n        if not isinstance(length, int):\n            raise TypeError(\"run lengths must be integers\")\n        if length < 0:\n            raise ValueError(\"run lengths must be non-negative\")\n        count = 0\n        while count < length:\n            result.append(values[idx])\n            count += 1\n        idx += 1\n    return result", "inputs": [["[1, 2, 3]", "[2, 1, 3]"], ["[True, 0, 3]", "[1, 0, 2]"], ["[5, 6]", "[0, 0]"]], "outputs": ["[1, 1, 2, 3, 3, 3]", "[True, 3, 3]", "[]"]}
{"id": "llmlist_90", "header": "def strip_leading_value(lst, value):", "description": "Return lst with leading value occurrences removed.", "code": "def strip_leading_value(lst, value):\n    def equals(a, b):\n        if isinstance(a, float) and isinstance(b, float):\n            if a != a and b != b:\n                return True\n        return a == b\n\n    length = len(lst)\n    start = 0\n    while start < length and equals(lst[start], value):\n        start += 1\n    return lst[start:]", "inputs": [["[1, 1, 2, 1]", "1"], ["[0, 1, 2]", "3"], ["[True, True]", "True"]], "outputs": ["[2, 1]", "[0, 1, 2]", "[]"]}
{"id": "llmlist_91", "header": "def strip_trailing_value(lst, value):", "description": "Return lst with trailing value occurrences removed.", "code": "def strip_trailing_value(lst, value):\n    n = len(lst)\n    i = n - 1\n    while i >= 0 and lst[i] == value:\n        i -= 1\n    if i < 0:\n        return []\n    return lst[:i + 1]", "inputs": [["[1, 2, 3, 0, 0]", "0"], ["[5, 5, 5]", "5"], ["[7, 5, 7]", "5"]], "outputs": ["[1, 2, 3]", "[]", "[7, 5, 7]"]}
{"id": "llmlist_92", "header": "def pad_left(lst, total_length, fill):", "description": "Return a new list padded on the left to total_length with fill.", "code": "def pad_left(lst, total_length, fill):\n    if not isinstance(total_length, int):\n        raise TypeError(\"total_length must be an int\")\n    if total_length < 0:\n        raise ValueError(\"total_length must be non-negative\")\n    source = list(lst)\n    current_len = len(source)\n    if current_len >= total_length:\n        return list(source)\n    pad_count = total_length - current_len\n    pad = []\n    i = 0\n    while i < pad_count:\n        pad.append(fill)\n        i += 1\n    return pad + source", "inputs": [["[1, 2]", "5", "[0]"], ["[True, False]", "2", "True"], ["[[1], [2]]", "0", "7"]], "outputs": ["[[0], [0], [0], 1, 2]", "[True, False]", "[[1], [2]]"]}
{"id": "llmlist_93", "header": "def pad_right(lst, total_length, fill):", "description": "Return a new list padded on the right to total_length with fill.", "code": "def pad_right(lst, total_length, fill):\n    current_len = len(lst)\n    if current_len >= total_length:\n        return list(lst)\n    result = list(lst)\n    needed = total_length - current_len\n    i = 0\n    while i < needed:\n        result.append(fill)\n        i += 1\n    return result", "inputs": [["[1, 2, 3]", "2", "0"], ["[1, 2]", "2", "7"], ["[4]", "3", "True"]], "outputs": ["[1, 2, 3]", "[1, 2]", "[4, True, True]"]}
{"id": "llmlist_94", "header": "def bounded_clip_changes(lst, limit):", "description": "Return a new list where difference between consecutive elements is limited to +/-limit.", "code": "def bounded_clip_changes(lst, limit):\n    if not lst:\n        return []\n    lim = limit if limit >= 0 else -limit\n    out = [lst[0]]\n    for i in range(1, len(lst)):\n        prev = out[-1]\n        cur = lst[i]\n        delta = cur - prev\n        if delta > lim:\n            out.append(prev + lim)\n        elif delta < -lim:\n            out.append(prev - lim)\n        else:\n            out.append(cur)\n    return out", "inputs": [["[1, 5, 7, 6, 20]", "3"], ["[10, 0, 15, -5]", "-2"], ["[3, 4, 2]", "0"]], "outputs": ["[1, 4, 7, 6, 9]", "[10, 8, 10, 8]", "[3, 3, 3]"]}
{"id": "llmlist_95", "header": "def next_permutation(lst):", "description": "Return the next lexicographic permutation of lst or the same list if none.", "code": "def next_permutation(lst):\n    n = len(lst)\n    if n < 2:\n        return lst[:]\n    a = lst[:]\n    i = n - 2\n    while i >= 0 and not (a[i] < a[i + 1]):\n        i -= 1\n    if i < 0:\n        return lst[:]\n    j = n - 1\n    while not (a[i] < a[j]):\n        j -= 1\n    a[i], a[j] = a[j], a[i]\n    left = i + 1\n    right = n - 1\n    while left < right:\n        a[left], a[right] = a[right], a[left]\n        left += 1\n        right -= 1\n    return a", "inputs": [["[1]"], ["[1, 2, 3]"], ["[3, 2, 1]"]], "outputs": ["[1]", "[1, 3, 2]", "[3, 2, 1]"]}
{"id": "llmlist_96", "header": "def previous_permutation(lst):", "description": "Return the previous lexicographic permutation of lst or the same list if none.", "code": "def previous_permutation(lst):\n    n = len(lst)\n    if n < 2:\n        return lst\n    i = n - 1\n    while i > 0 and lst[i - 1] <= lst[i]:\n        i -= 1\n    if i == 0:\n        return lst\n    res = list(lst)\n    pivot = i - 1\n    j = n - 1\n    while j >= i and res[j] >= res[pivot]:\n        j -= 1\n    res[pivot], res[j] = res[j], res[pivot]\n    left = i\n    right = n - 1\n    while left < right:\n        res[left], res[right] = res[right], res[left]\n        left += 1\n        right -= 1\n    return res", "inputs": [["[1]"], ["[1,1,2]"], ["[2,1,3,4]"]], "outputs": ["[1]", "[1, 1, 2]", "[1, 4, 3, 2]"]}
{"id": "llmlist_97", "header": "def kth_smallest(lst, k):", "description": "Return the kth smallest element (0-based) assuming 0 <= k < len(lst).", "code": "def kth_smallest(lst, k):\n    def select(arr, k):\n        n = len(arr)\n        if n <= 5:\n            a = arr[:]\n            a.sort()\n            return a[k]\n        groups = []\n        for i in range(0, n, 5):\n            g = arr[i:i+5]\n            g.sort()\n            groups.append(g[len(g)//2])\n        pivot = select(groups, len(groups)//2)\n        lows = []\n        highs = []\n        pivots = []\n        for x in arr:\n            if x < pivot:\n                lows.append(x)\n            elif x > pivot:\n                highs.append(x)\n            else:\n                pivots.append(x)\n        if k < len(lows):\n            return select(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivot\n        else:\n            return select(highs, k - len(lows) - len(pivots))\n    return select(lst, k)", "inputs": [["[3, 1, 2, 0, -1]", "2"], ["[5, 1, 3, 2, 4, 6, 7, 5, 5]", "5"], ["[9, 8, 7, 6, 5, 4, 3, 2, 1]", "8"]], "outputs": ["1", "5", "9"]}
{"id": "llmlist_98", "header": "def remove_outside_range(lst, low, high):", "description": "Return a new list keeping only elements in [low, high].", "code": "def remove_outside_range(lst, low, high):\n    result = []\n    if low > high:\n        return result\n    for i in range(len(lst)):\n        x = lst[i]\n        ok_low = False\n        ok_high = False\n        try:\n            ok_low = x >= low\n        except Exception:\n            ok_low = False\n        if ok_low:\n            try:\n                ok_high = x <= high\n            except Exception:\n                ok_high = False\n        if ok_low and ok_high:\n            result.append(x)\n    return result", "inputs": [["[1, 2, 3, 4]", "2", "3"], ["[1, 2]", "5", "0"], ["[0, 'a', None, 5, 10]", "0", "10"]], "outputs": ["[2, 3]", "[]", "[0, 5, 10]"]}
{"id": "llmlist_99", "header": "def stable_unique_by_first_occurrence(lst):", "description": "Return a new list removing later duplicates, keeping first occurrences only.", "code": "def stable_unique_by_first_occurrence(lst):\n    result = []\n    seen_hashable = set()\n    unhashables = []\n    for item in lst:\n        is_hashable = True\n        try:\n            hash(item)\n        except Exception:\n            is_hashable = False\n        if is_hashable:\n            if item in seen_hashable:\n                continue\n            seen_hashable.add(item)\n            result.append(item)\n        else:\n            duplicate = False\n            for existing in unhashables:\n                if existing is item or existing == item:\n                    duplicate = True\n                    break\n            if duplicate:\n                continue\n            unhashables.append(item)\n            result.append(item)\n    return result", "inputs": [["[1, True, 1, 2, True, 'a', 'a', 0, False, 0]"], ["[[1, 2], [1, 2], [3], [3], [1, 2]]"], ["[('x', 1), ('x', 1), [0, 0], [0, 0], ('y', 2), [1], [1]]"]], "outputs": ["[1, 2, 'a', 0]", "[[1, 2], [3]]", "[('x', 1), [0, 0], ('y', 2), [1]]"]}
{"id": "llmlist_100", "header": "def bubble_sort(lst):", "description": "Return a new list with the elements of lst sorted ascending using bubble sort.", "code": "def bubble_sort(lst):\n    a = list(lst)\n    n = len(a)\n    if n < 2:\n        return a\n    end = n - 1\n    while end > 0:\n        swapped = False\n        last_swap = 0\n        i = 0\n        while i < end:\n            if a[i] > a[i + 1]:\n                a[i], a[i + 1] = a[i + 1], a[i]\n                swapped = True\n                last_swap = i\n            i += 1\n        if not swapped:\n            break\n        end = last_swap\n    return a", "inputs": [["[7]"], ["[1, 1, 2, 2]"], ["[5, -1, 3, -2, 0]"]], "outputs": ["[7]", "[1, 1, 2, 2]", "[-2, -1, 0, 3, 5]"]}
{"id": "llmlist_101", "header": "def selection_sort(lst):", "description": "Return a new list with the elements of lst sorted ascending using selection sort.", "code": "def selection_sort(lst):\n    n = len(lst)\n    result = [None] * n\n    i = 0\n    while i < n:\n        result[i] = lst[i]\n        i += 1\n    i = 0\n    while i < n - 1:\n        min_idx = i\n        j = i + 1\n        while j < n:\n            if result[j] < result[min_idx]:\n                min_idx = j\n            j += 1\n        if min_idx != i:\n            temp = result[i]\n            result[i] = result[min_idx]\n            result[min_idx] = temp\n        i += 1\n    return result", "inputs": [["[3, 1, 2]"], ["[1, 1, 0, -1]"], ["[5]"]], "outputs": ["[1, 2, 3]", "[-1, 0, 1, 1]", "[5]"]}
{"id": "llmlist_102", "header": "def insertion_sort(lst):", "description": "Return a new list with the elements of lst sorted ascending using insertion sort.", "code": "def insertion_sort(lst):\n    result = list(lst)\n    n = len(result)\n    for i in range(1, n):\n        key = result[i]\n        j = i - 1\n        while j >= 0 and result[j] > key:\n            result[j + 1] = result[j]\n            j -= 1\n        result[j + 1] = key\n    return result", "inputs": [["[3, -1, 2, 0]"], ["[1, 1, 2, 2]"], ["[5, 4, 3]"]], "outputs": ["[-1, 0, 2, 3]", "[1, 1, 2, 2]", "[3, 4, 5]"]}
{"id": "llmlist_103", "header": "def merge_sort(lst):", "description": "Return a new list with the elements of lst sorted ascending using merge sort.", "code": "def merge_sort(lst):\n    n = len(lst)\n    if n <= 1:\n        return lst[:]\n    mid = n // 2\n    left = merge_sort(lst[:mid])\n    right = merge_sort(lst[mid:])\n    i = 0\n    j = 0\n    merged = []\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n    while i < len(left):\n        merged.append(left[i])\n        i += 1\n    while j < len(right):\n        merged.append(right[j])\n        j += 1\n    return merged", "inputs": [["[5]"], ["[3, 1, 2, 2]"], ["[0, -2, 4, -1]"]], "outputs": ["[5]", "[1, 2, 2, 3]", "[-2, -1, 0, 4]"]}
{"id": "llmlist_104", "header": "def quick_sort(lst):", "description": "Return a new list with the elements of lst sorted ascending using quick sort (deterministic pivot).", "code": "def quick_sort(lst):\n    n = len(lst)\n    if n <= 1:\n        return lst[:]\n    pivot_index = n // 2\n    pivot = lst[pivot_index]\n    left = []\n    equal = []\n    right = []\n    i = 0\n    while i < n:\n        v = lst[i]\n        if v < pivot:\n            left.append(v)\n        elif v > pivot:\n            right.append(v)\n        else:\n            equal.append(v)\n        i += 1\n    left_sorted = quick_sort(left) if len(left) > 1 else left[:]\n    right_sorted = quick_sort(right) if len(right) > 1 else right[:]\n    result = []\n    result.extend(left_sorted)\n    result.extend(equal)\n    result.extend(right_sorted)\n    return result", "inputs": [["[5]"], ["[3, 1, 3, 2, 3]"], ["[9, -1, 4, -5, 0]"]], "outputs": ["[5]", "[1, 2, 3, 3, 3]", "[-5, -1, 0, 4, 9]"]}
{"id": "llmlist_105", "header": "def heap_sort(lst):", "description": "Return a new list with the elements of lst sorted ascending using heap sort implemented explicitly.", "code": "def heap_sort(lst):\n    a = list(lst)\n    n = len(a)\n    if n < 2:\n        return a\n    def sift_down(a, start, end):\n        root = start\n        while True:\n            child = 2 * root + 1\n            if child > end:\n                break\n            if child + 1 <= end and a[child] < a[child + 1]:\n                child += 1\n            if a[root] < a[child]:\n                a[root], a[child] = a[child], a[root]\n                root = child\n            else:\n                break\n    for start in range((n // 2) - 1, -1, -1):\n        sift_down(a, start, n - 1)\n    for end in range(n - 1, 0, -1):\n        a[0], a[end] = a[end], a[0]\n        sift_down(a, 0, end - 1)\n    return a", "inputs": [["[3, 1, 2]"], ["[5, 5, 3, 5, 1]"], ["[-2, 0, -1, 3]"]], "outputs": ["[1, 2, 3]", "[1, 3, 5, 5, 5]", "[-2, -1, 0, 3]"]}
{"id": "llmlist_106", "header": "def shell_sort(lst):", "description": "Return a new list with the elements of lst sorted ascending using shell sort (gap sequence halving).", "code": "def shell_sort(lst):\n    a = list(lst)\n    n = len(a)\n    gap = n // 2\n    while gap > 0:\n        i = gap\n        while i < n:\n            temp = a[i]\n            j = i\n            while j >= gap and a[j - gap] > temp:\n                a[j] = a[j - gap]\n                j -= gap\n            a[j] = temp\n            i += 1\n        gap //= 2\n    return a", "inputs": [["[4, 3, 2, 1]"], ["[3, 1, 2, 1]"], ["[-2, 0, -1, 3]"]], "outputs": ["[1, 2, 3, 4]", "[1, 1, 2, 3]", "[-2, -1, 0, 3]"]}
{"id": "llmlist_107", "header": "def counting_sort(lst):", "description": "Return a new list with the elements of lst sorted ascending using counting sort; assume all values are non-negative and small.", "code": "def counting_sort(lst):\n    n = len(lst)\n    if n == 0:\n        return []\n    m = lst[0]\n    for i in range(1, n):\n        v = lst[i]\n        if v > m:\n            m = v\n    counts = [0] * (m + 1)\n    for v in lst:\n        if v < 0:\n            raise ValueError(\"All values must be non-negative\")\n        counts[v] += 1\n    result = [0] * n\n    idx = 0\n    for value in range(len(counts)):\n        c = counts[value]\n        for _ in range(c):\n            result[idx] = value\n            idx += 1\n    return result", "inputs": [], "outputs": []}
{"id": "llmlist_108", "header": "def radix_sort(lst):", "description": "Return a new list with the elements of lst sorted ascending using LSD radix sort for non-negative integers.", "code": "def radix_sort(lst):\n    base = 10\n    items = list(lst)\n    if not items:\n        return []\n    max_val = items[0]\n    for x in items:\n        if x > max_val:\n            max_val = x\n    exp = 1\n    while exp <= max_val:\n        counts = [0] * base\n        for x in items:\n            d = (x // exp) % base\n            counts[d] += 1\n        total = 0\n        for i in range(base):\n            c = counts[i]\n            counts[i] = total\n            total += c\n        output = [0] * len(items)\n        for x in items:\n            d = (x // exp) % base\n            pos = counts[d]\n            output[pos] = x\n            counts[d] = pos + 1\n        items = output\n        exp *= base\n    return items", "inputs": [["[5, 0, 2, 0, 9]"], ["[170, 45, 75, 90, 802]"], ["[3, 3, 2, 2, 1]"]], "outputs": ["[0, 0, 2, 5, 9]", "[45, 75, 90, 170, 802]", "[1, 2, 2, 3, 3]"]}
{"id": "llmlist_109", "header": "def cocktail_shaker_sort(lst):", "description": "Return a new list sorted ascending using cocktail shaker sort (bidirectional bubble).", "code": "def cocktail_shaker_sort(lst):\n    arr = list(lst)\n    n = len(arr)\n    if n < 2:\n        return arr\n    start = 0\n    end = n - 1\n    while True:\n        swapped = False\n        i = start\n        while i < end:\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n            i += 1\n        if not swapped:\n            break\n        swapped = False\n        i = end - 1\n        while i >= start:\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n            i -= 1\n        if not swapped:\n            break\n        start += 1\n        end -= 1\n    return arr", "inputs": [["[1, 2, 3]"], ["[5, 4, 3, 2, 1]"], ["[3, -1, 2, -1, 0]"]], "outputs": ["[1, 2, 3]", "[1, 2, 3, 4, 5]", "[-1, -1, 0, 2, 3]"]}
{"id": "llmlist_110", "header": "def linear_search(lst, target):", "description": "Return the index of target in lst using linear search, or -1 if not found.", "code": "def linear_search(lst, target):\n    n = len(lst)\n    i = 0\n    while i < n:\n        if lst[i] == target:\n            return i\n        i += 1\n    return -1", "inputs": [["[5, 2, 3]", "5"], ["[1, 2, 2, 3]", "2"], ["[7, 8, 9]", "4"]], "outputs": ["0", "1", "-1"]}
{"id": "llmlist_111", "header": "def binary_search(sorted_lst, target):", "description": "Return the index of target in sorted_lst using binary search, or -1 if not found; sorted_lst is ascending.", "code": "def binary_search(sorted_lst, target):\n    left = 0\n    right = len(sorted_lst) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        mid_val = sorted_lst[mid]\n        if mid_val == target:\n            return mid\n        if mid_val < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "inputs": [["[1, 3, 5, 7, 9]", "7"], ["[2, 4, 6, 8]", "5"], ["[10]", "10"]], "outputs": ["3", "-1", "0"]}