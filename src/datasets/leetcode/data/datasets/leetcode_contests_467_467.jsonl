{"id": "contest467_q4012_s0", "question_id": 4012, "function_name": "earliestTime", "code": "def earliestTime(tasks: List[List[int]]) -> int:\n        res = inf\n        for s, t in tasks:\n            res = min(res, s + t)\n        return res", "input": "earliestTime(tasks=[[1,6],[2,3]])", "output": "5", "correct_condition": "earliestTime(tasks=[[1,6],[2,3]]) == 5", "contest_id": "weekly-contest-467", "contest_date": "2025-09-14T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 5, "coverage": null}, "submission_id": 1769944892}
{"id": "contest467_q4012_s1", "question_id": 4012, "function_name": "earliestTime", "code": "def earliestTime(tasks: List[List[int]]) -> int:\n    return min(t[0] + t[1] for t in tasks)", "input": "earliestTime(tasks=[[1,6],[2,3]])", "output": "5", "correct_condition": "earliestTime(tasks=[[1,6],[2,3]]) == 5", "contest_id": "weekly-contest-467", "contest_date": "2025-09-14T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 2, "coverage": null}, "submission_id": 1769946189}
{"id": "contest467_q4012_s2", "question_id": 4012, "function_name": "earliestTime", "code": "def earliestTime(tasks: List[List[int]]) -> int:\n        return min([x+y for x,y in tasks])", "input": "earliestTime(tasks=[[1,6],[2,3]])", "output": "5", "correct_condition": "earliestTime(tasks=[[1,6],[2,3]]) == 5", "contest_id": "weekly-contest-467", "contest_date": "2025-09-14T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 2, "coverage": null}, "submission_id": 1769945503}
{"id": "contest467_q3997_s0", "question_id": 3997, "function_name": "maxKDistinct", "code": "def maxKDistinct(nums: List[int], k: int) -> List[int]:\n        res = []\n        nums.sort(reverse=True)\n        seen = set()\n        taken = 0\n        for i, v in enumerate(nums):\n            if taken == k:\n                break\n            if v in seen:\n                continue\n            seen.add(v)\n            res.append(v)\n            taken += 1\n\n        return res\n            ", "input": "maxKDistinct(nums=[84,93,100,77,90], k=3)", "output": "[100, 93, 90]", "correct_condition": "maxKDistinct(nums=[84,93,100,77,90], k=3) == [100, 93, 90]", "contest_id": "weekly-contest-467", "contest_date": "2025-09-14T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 16, "coverage": null}, "submission_id": 1769946197}
{"id": "contest467_q3997_s1", "question_id": 3997, "function_name": "maxKDistinct", "code": "def maxKDistinct(nums: List[int], k: int) -> List[int]:\n    nums = list(set(nums))\n    nums.sort(key=lambda i: -i)\n    return nums[0: k]", "input": "maxKDistinct(nums=[84,93,100,77,90], k=3)", "output": "[100, 93, 90]", "correct_condition": "maxKDistinct(nums=[84,93,100,77,90], k=3) == [100, 93, 90]", "contest_id": "weekly-contest-467", "contest_date": "2025-09-14T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 4, "coverage": null}, "submission_id": 1769954176}
{"id": "contest467_q3997_s2", "question_id": 3997, "function_name": "maxKDistinct", "code": "def maxKDistinct(nums: List[int], k: int) -> List[int]:\n        res = []\n        nums.sort()\n        while len(res) < k and nums:\n            x = nums.pop()\n            if not res or x != res[-1]:\n                res.append(x)\n        return sorted(res,reverse=True)", "input": "maxKDistinct(nums=[84,93,100,77,90], k=3)", "output": "[100, 93, 90]", "correct_condition": "maxKDistinct(nums=[84,93,100,77,90], k=3) == [100, 93, 90]", "contest_id": "weekly-contest-467", "contest_date": "2025-09-14T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 8, "coverage": null}, "submission_id": 1769949793}
{"id": "contest467_q3873_s0", "question_id": 3873, "function_name": "subsequenceSumAfterCapping", "code": "def subsequenceSumAfterCapping(nums: List[int], k: int) -> List[bool]:\n        c = Counter(nums)\n        n = len(nums)\n        pf = [0] * (n+1)\n        pf[0] = 1\n        fullMask = (1 << (k+1)) - 1\n        # print(f'{fullMask=}')\n\n        for v in range(1, n + 1):\n            dp = pf[v-1]\n            count = c[v]\n\n            pp = 1\n            while count > 0:\n                take = min(pp, count)\n                dp = (dp | (dp << (v*take)) & fullMask) & fullMask\n                count -= take\n                pp <<= 1\n\n            pf[v] = dp\n\n        suff = [0] * (n + 2)\n        for v in range(n, 0, -1):\n            suff[v] = suff[v+1] + c[v]\n\n        res = [False]*n\n\n        for x in range(1, n + 1):\n            dp = pf[x-1]\n            nxt = suff[x]\n            big = min(nxt, k // x)\n            noFail = False\n            for j in range(big + 1):\n                tmp = k - (j * x)\n                if (dp >> tmp) & 1:\n                    noFail = True\n                    break\n            res[x-1] = noFail\n\n        return res", "input": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5)", "output": "[False, False, True, True]", "correct_condition": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5) == [False, False, True, True]", "contest_id": "weekly-contest-467", "contest_date": "2025-09-14T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 40, "coverage": null}, "submission_id": 1769967201}
{"id": "contest467_q3873_s1", "question_id": 3873, "function_name": "subsequenceSumAfterCapping", "code": "def subsequenceSumAfterCapping(nums: List[int], k: int) -> List[bool]:\n    n = len(nums)\n    freq = [0] * (n + 1)\n    for a in nums:\n        if 1 <= a <= n:\n            freq[a] += 1\n\n    ans = [False] * n\n    dp = 1\n    mask = (1 << (k + 1)) - 1\n\n    cnt_le = 0\n    for x in range(1, n + 1):\n        for _ in range(freq[x]):\n            dp = (dp | (dp << x)) & mask\n        cnt_le += freq[x]\n\n        m_x = n - cnt_le\n\n        possible = False\n        max_j = min(m_x, k // x)\n        for j in range(max_j + 1):\n            s = k - j * x\n            if (dp >> s) & 1:  # sum s is achievable using values \u2264 x\n                possible = True\n                break\n        ans[x - 1] = possible\n\n    return ans", "input": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5)", "output": "[False, False, True, True]", "correct_condition": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5) == [False, False, True, True]", "contest_id": "weekly-contest-467", "contest_date": "2025-09-14T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 29, "coverage": null}, "submission_id": 1769967950}
{"id": "contest467_q3873_s2", "question_id": 3873, "function_name": "subsequenceSumAfterCapping", "code": "def subsequenceSumAfterCapping(nums: List[int], k: int) -> List[bool]:\n        K = k\n        nums.sort()\n        N = len(nums)\n        dp = [0]*(k+1)\n        j = 0\n        dp[0] = 1\n\n        Z = 1\n        res = []\n        for i in range(1,N+1):\n            while j < len(nums) and nums[j] < i:\n                Z |= (Z << nums[j])\n                j += 1\n            remaining_count = len(nums)-j\n            max_cap = i\n            ans = False\n            for g in range(K,-1,-i):\n                diff = k-g\n                if remaining_count*max_cap >= diff:\n                    if ((1<<g)&Z) > 0:\n                        ans = True\n                        break\n                else:\n                    break\n            res.append(ans)\n        return res\n            \n                    \n            \n\n        ", "input": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5)", "output": "[False, False, True, True]", "correct_condition": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5) == [False, False, True, True]", "contest_id": "weekly-contest-467", "contest_date": "2025-09-14T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 32, "coverage": null}, "submission_id": 1769965337}
{"id": "contest467_q4027_s0", "question_id": 4027, "function_name": "countStableSubsequences", "code": "def countStableSubsequences(nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        res = 0\n\n        @cache\n        def dp(i, pp, p):\n            if i == len(nums):\n                return 1\n            ifSkip = dp(i + 1, pp, p)\n            v = nums[i]\n            if v % 2 == pp == p:\n                return ifSkip\n            ifTake = dp(i + 1, p, v % 2)\n            return (ifSkip + ifTake) % MOD\n\n        res = dp(0, -1, -1)\n        dp.cache_clear()\n        return res - 1", "input": "countStableSubsequences(nums=[1,3,5])", "output": "6", "correct_condition": "countStableSubsequences(nums=[1,3,5]) == 6", "contest_id": "weekly-contest-467", "contest_date": "2025-09-14T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 18, "coverage": null}, "submission_id": 1769952969}
{"id": "contest467_q4027_s1", "question_id": 4027, "function_name": "countStableSubsequences", "code": "def countStableSubsequences(nums: List[int]) -> int:\n    MOD = 1_000_000_007\n    E1 = E2 = O1 = O2 = 0\n\n    for a in nums:\n        if a % 2 == 0:\n            newE1 = (E1 + O1 + O2 + 1) % MOD\n            newE2 = (E2 + E1) % MOD\n            E1, E2 = newE1, newE2\n        else:\n            newO1 = (O1 + E1 + E2 + 1) % MOD\n            newO2 = (O2 + O1) % MOD\n            O1, O2 = newO1, newO2\n    return (E1 + E2 + O1 + O2) % MOD", "input": "countStableSubsequences(nums=[1,3,5])", "output": "6", "correct_condition": "countStableSubsequences(nums=[1,3,5]) == 6", "contest_id": "weekly-contest-467", "contest_date": "2025-09-14T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 14, "coverage": null}, "submission_id": 1769973511}
{"id": "contest467_q4027_s2", "question_id": 4027, "function_name": "countStableSubsequences", "code": "def countStableSubsequences(nums: List[int]) -> int:\n        modulo = 10**9 + 7\n\n        nums = [x%2 for x in nums]\n\n        @lru_cache(None)\n        def recur_fn(i,prev,count):\n            if i == len(nums):\n                return 0\n            else:\n                res = 0\n                if nums[i] == prev and count == 1:\n                    res += 1 + recur_fn(i+1,prev,count+1)\n                    if res >= modulo:\n                        res %= modulo\n                if nums[i] != prev:\n                    res += 1+ recur_fn(i+1,nums[i],1)\n                    if res >= modulo:\n                        res %= modulo\n                res += recur_fn(i+1,prev,count)\n                if res >= modulo:\n                    res %= modulo\n                return res \n\n        ans = 0\n        for i in range(len(nums)):\n            ans += 1 + recur_fn(i+1,nums[i],1)\n            #print('ans',ans)\n            if ans >= modulo:\n                ans %= modulo\n            \n        recur_fn.cache_clear()\n        return ans%modulo", "input": "countStableSubsequences(nums=[1,3,5])", "output": "6", "correct_condition": "countStableSubsequences(nums=[1,3,5]) == 6", "contest_id": "weekly-contest-467", "contest_date": "2025-09-14T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 33, "coverage": null}, "submission_id": 1769974365}
