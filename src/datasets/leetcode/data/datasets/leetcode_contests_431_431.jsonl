{"id": "contest431_q3702_s0", "question_id": 3702, "function_name": "maxLength", "code": "class Solution:\n    def maxLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for l in range(n):\n            a = 1\n            b = 1\n            c = 0\n            for r in range(l, n):\n                a *= nums[r]\n                b = lcm(b, nums[r])\n                c = gcd(c, nums[r])\n                if a == b * c:\n                    ans = max(ans, r - l + 1)\n        return ans\n                \n        ", "input": "maxLength(nums=[1,2,1,2,1,1,1])", "output": "5", "correct_condition": "maxLength(nums=[1,2,1,2,1,1,1]) == 5", "contest_id": "weekly-contest-431", "contest_date": "2025-01-05T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 17, "coverage": null}, "submission_id": 1497983046}
{"id": "contest431_q3702_s1", "question_id": 3702, "function_name": "maxLength", "code": "class Solution:\n    def maxLength(self, nums: List[int]) -> int:\n        ans = 1\n        run = 1\n        for l in range(len(nums)):\n            for r in range(l, len(nums)):\n                a = nums[l:r+1]\n                prod = 1\n                g = nums[l]\n                lc = nums[l]\n                for v in a:\n                    g = gcd(g, v)\n                    lc = lcm(lc, v)\n                    prod *= v\n                if g * lc == prod:\n                    ans = max(ans, r - l + 1)\n        return ans", "input": "maxLength(nums=[1,2,1,2,1,1,1])", "output": "5", "correct_condition": "maxLength(nums=[1,2,1,2,1,1,1]) == 5", "contest_id": "weekly-contest-431", "contest_date": "2025-01-05T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 17, "coverage": null}, "submission_id": 1497983616}
{"id": "contest431_q3702_s2", "question_id": 3702, "function_name": "maxLength", "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nimport math\nclass Solution:\n    def maxLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        maxi = 1 \n        for i in range(n):\n            cur1 = nums[i]\n            cur2 = nums[i]\n            prod = nums[i]\n            \n            for j in range(i + 1, n):\n                cur1 = math.gcd(cur1, nums[j])\n                cur2 = (cur2 * nums[j]) // math.gcd(cur2, nums[j])\n                prod *= nums[j]\n                if prod == cur1 * cur2:\n                    lens = j - i + 1\n                    if lens > maxi:\n                        maxi = lens\n        return maxi", "input": "maxLength(nums=[1,2,1,2,1,1,1])", "output": "5", "correct_condition": "maxLength(nums=[1,2,1,2,1,1,1]) == 5", "contest_id": "weekly-contest-431", "contest_date": "2025-01-05T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 219, "coverage": null}, "submission_id": 1498014620}
{"id": "contest431_q3634_s0", "question_id": 3634, "function_name": "calculateScore", "code": "class Solution:\n    def calculateScore(self, s: str) -> int:\n        g = [[] for _ in range(26)]\n        ans = 0\n        for i, x in enumerate(s):\n            x = ord(x) - 97\n            if g[25 - x]:\n                ans += i - g[25 - x].pop()\n            else:\n                g[x].append(i)\n        return ans\n        ", "input": "calculateScore(s=\"aczzx\")", "output": "5", "correct_condition": "calculateScore(s=\"aczzx\") == 5", "contest_id": "weekly-contest-431", "contest_date": "2025-01-05T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 12, "coverage": null}, "submission_id": 1497985461}
{"id": "contest431_q3634_s1", "question_id": 3634, "function_name": "calculateScore", "code": "class Solution:\n    def calculateScore(self, s: str) -> int:\n        def mir(c):\n            return chr(ord('a') + (25 - (ord(c) - ord('a'))))\n        seen = defaultdict(list)\n        ans = 0\n        for i in range(len(s)):\n            c1 = mir(s[i])\n            if seen[c1]:\n                ans += i - seen[c1][-1]\n                seen[c1].pop()\n            else: seen[s[i]].append(i)\n        return ans", "input": "calculateScore(s=\"aczzx\")", "output": "5", "correct_condition": "calculateScore(s=\"aczzx\") == 5", "contest_id": "weekly-contest-431", "contest_date": "2025-01-05T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 13, "coverage": null}, "submission_id": 1497985549}
{"id": "contest431_q3634_s2", "question_id": 3634, "function_name": "calculateScore", "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nclass Solution:\n    def calculateScore(self, s: str) -> int:\n        ls = {chr(i): [] for i in range(ord('a'), ord('z') + 1)}\n        score = 0\n        for i, c in enumerate(s):\n            cm = chr(ord('a') + (ord('z') - ord(c)))\n            if ls[cm]:\n                j = ls[cm].pop()\n                score += i - j\n            else:\n                ls[c].append(i)\n        return score", "input": "calculateScore(s=\"aczzx\")", "output": "5", "correct_condition": "calculateScore(s=\"aczzx\") == 5", "contest_id": "weekly-contest-431", "contest_date": "2025-01-05T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 212, "coverage": null}, "submission_id": 1498013955}
{"id": "contest431_q3715_s0", "question_id": 3715, "function_name": "maximumCoins", "code": "class Solution:\n    def maximumCoins(self, coins: List[List[int]], k: int) -> int:\n        coins.sort()\n        n = len(coins)\n        def f(p):\n            ret = tot = 0\n            j = 0\n            for i in range(n):\n                while j < n and p[j][1] - p[i][0] + 1 <= k:\n                    tot += (p[j][1] - p[j][0] + 1) * p[j][2]\n                    j += 1\n                cur = tot\n                if j < n and p[j][0] - p[i][0] + 1 <= k:\n                    cur += (p[i][0] + k - p[j][0]) * p[j][2]\n                if cur > ret:\n                    ret = cur\n                if i == j:\n                    j += 1\n                else:\n                    tot -= (p[i][1] - p[i][0] + 1) * p[i][2]\n            return ret\n        ans = f(coins)\n        coins.reverse()\n        m = 10 ** 9 + 1\n        for it in coins:\n            it[0], it[1] = m - it[1], m - it[0]\n        ans = max(ans, f(coins))\n        return ans\n                    \n                ", "input": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4)", "output": "10", "correct_condition": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4) == 10", "contest_id": "weekly-contest-431", "contest_date": "2025-01-05T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 30, "coverage": null}, "submission_id": 1498002559}
{"id": "contest431_q3715_s1", "question_id": 3715, "function_name": "maximumCoins", "code": "class Solution:\n    def maximumCoins(self, coins: List[List[int]], k: int) -> int:\n        coins.sort()\n        ans = 0\n        for _ in range(2):\n            cnt = 0\n            r = 0\n            # print(coins)\n            for l in range(len(coins)):\n                while r+1 < len(coins) and coins[r][1]-coins[l][0]+1 <= k:\n                    cnt += (coins[r][1]-coins[r][0]+1 ) * coins[r][2]\n                    r += 1\n                add = min(coins[r][1]+1, coins[l][0] + k) - coins[r][0]\n                add = max(add, 0)\n                add *= coins[r][2]\n                # add = (k - ((0 if r == 0 else coins[r-1][1])-coins[l][0]+1)) * coins[r][2]\n                ans = max(ans, cnt + add)\n                # print(l, r, add / coins[r][2], cnt + add)\n                cnt -= (coins[l][1]-coins[l][0]+1 ) * coins[l][2]\n            for i in range(len(coins)):\n                coins[i][0] *= -1\n                coins[i][1] *= -1\n                coins[i][0], coins[i][1] = coins[i][1], coins[i][0]\n            coins.sort()\n        return ans", "input": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4)", "output": "10", "correct_condition": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4) == 10", "contest_id": "weekly-contest-431", "contest_date": "2025-01-05T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 25, "coverage": null}, "submission_id": 1498001804}
{"id": "contest431_q3715_s2", "question_id": 3715, "function_name": "maximumCoins", "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nfrom bisect import bisect_right\nfrom dataclasses import dataclass\n\n@dataclass\nclass Interval:\n    start: int\n    end: int\n    ci: int\n    psum: int = 0\n\nclass Solution:\n    def maximumCoins(self, coins: List[List[int]], k: int) -> int:\n        coins.sort(key=lambda x: x[0])\n        intervals: List[Interval] = []\n        for seg in coins:\n            li, ri, val1 = seg\n            intervals.append(Interval(start=li, end=ri, ci=val1))\n        \n        pref = 0\n        for interval in intervals:\n            lenx = interval.end - interval.start + 1\n            tot = lenx * interval.ci\n            pref += tot\n            interval.psum = pref\n\n        starts = [interval.start for interval in intervals]\n        \n        def getSum(x: int) -> int:\n            if not intervals or x < intervals[0].start:\n                return 0\n            idx = bisect_right(starts, x) - 1\n            if idx < 0:\n                return 0\n            sval = intervals[idx].psum\n            if idx > 0:\n                sval -= intervals[idx - 1].psum\n            overlap = min(x, intervals[idx].end) - intervals[idx].start + 1\n            if overlap > 0:\n                sval = intervals[idx].psum - (intervals[idx -1].psum if idx >0 else 0)\n                sval = (overlap) * intervals[idx].ci\n            else:\n                sval = 0\n            tsum = 0\n            if idx >=0:\n                tsum = intervals[idx].psum - (intervals[idx -1].psum if idx >0 else 0)\n                tsum = (min(x, intervals[idx].end) - intervals[idx].start +1) * intervals[idx].ci\n                if idx >0:\n                    tsum += intervals[idx-1].psum\n            return tsum\n        \n        def get_sum(x):\n            if not intervals or x < intervals[0].start:\n                return 0\n            idx = bisect_right(starts, x) - 1\n            if idx < 0:\n                return 0\n            prevs = intervals[idx -1].psum if idx > 0 else 0\n            overlap = min(x, intervals[idx].end) - intervals[idx].start + 1\n            if overlap < 0:\n                overlap = 0\n            return prevs + overlap * intervals[idx].ci\n        \n        st = set()\n        for seg in coins:\n            li, ri, _ = seg\n            st.add(li)\n            x = ri - k + 1\n            if 1 <= x <= ri:\n                st.add(x)\n        \n        st = sorted(st)\n\n        maxi = 0\n        for x in st:\n            sw = x\n            send = x + k -1\n            sum1 = get_sum(send)\n            sum0 = get_sum(sw -1)\n            tot = sum1 - sum0\n            if tot > maxi:\n                maxi = tot\n        \n        return maxi\n", "input": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4)", "output": "10", "correct_condition": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4) == 10", "contest_id": "weekly-contest-431", "contest_date": "2025-01-05T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 283, "coverage": null}, "submission_id": 1498021486}
{"id": "contest431_q3562_s0", "question_id": 3562, "function_name": "maximumWeight", "code": "class Solution:\n    def maximumWeight(self, p: List[List[int]]) -> List[int]:\n        a = []\n        for i, it in enumerate(p):\n            it.append(i)\n            a += [it[0], it[1]]\n        mp = {x: i + 1 for i, x in enumerate(sorted(set(a)))}\n        p.sort(key=lambda it:it[1])\n        for it in p:\n            it[0] = mp[it[0]]\n            it[1] = mp[it[1]]\n        f = [[[0, []] for _ in range(5)]]\n        pr = 0\n        for it in p:\n            l, r, w, i = it\n            while pr < r:\n                f.append(f[pr][:])\n                pr += 1\n            for k in range(4):\n                v, b = f[l - 1][k]\n                b = b[::] + [i]\n                b.sort()\n                v -= w\n                f[r][k + 1] = min(f[r][k + 1], [v, b])\n        return f[-1][4][1]", "input": "maximumWeight(p=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]])", "output": "[2, 3]", "correct_condition": "maximumWeight(p=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]) == [2, 3]", "contest_id": "weekly-contest-431", "contest_date": "2025-01-05T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 25, "coverage": null}, "submission_id": 1498025769}
{"id": "contest431_q3562_s1", "question_id": 3562, "function_name": "maximumWeight", "code": "class Solution:\n    def maximumWeight(self, intervals: List[List[int]]) -> List[int]:\n        locations = set()\n        for l, r, w in intervals:\n            locations.add(l)\n            locations.add(r+1)\n        locations = sorted(list(locations))\n        to_idx = dict()\n        for i, x in enumerate(locations):\n            to_idx[x] = i\n        nxt = [[] for i in range(len(locations))]\n        for i, (l, r, w) in enumerate(intervals):\n            nxt[to_idx[l]].append((to_idx[r+1], w, i))\n        @cache\n        def dp(idx, left):\n            res = (10 ** 12, [])\n            if idx >= len(locations) or left == 0: return res\n            \n            res = min(res, dp(idx + 1, left))\n            for r, w, i in nxt[idx]:\n                (a, ls) = dp(r, left-1)\n                a -= w\n                ls1 = ls.copy()\n                ls1.append(i)\n                ls1.sort()\n                res = min(res, (a, ls1))\n            return res\n        w, ls = dp(0, 4)\n        return ls\n            ", "input": "maximumWeight(intervals=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]])", "output": "[2, 3]", "correct_condition": "maximumWeight(intervals=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]) == [2, 3]", "contest_id": "weekly-contest-431", "contest_date": "2025-01-05T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 30, "coverage": null}, "submission_id": 1498015639}
{"id": "contest431_q3562_s2", "question_id": 3562, "function_name": "maximumWeight", "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nfrom bisect import bisect_right\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass Interval:\n    start: int\n    end: int\n    weight: int\n    ind: int\n    psum: int = 0\n\nclass Solution:\n    def maximumWeight(self, intervals: List[List[int]]) -> List[int]:\n        n = len(intervals)\n        sit = []\n        for i in range(n):\n            l, r, w = intervals[i]\n            sit.append(Interval(start=l, end=r, weight=w, ind=i))\n        \n        sit.sort(key=lambda x: (x.end, x.start))\n        last = [-1] * n\n        etime = [interval.end for interval in sit]\n        for i in range(n):\n            j = bisect_right(etime, sit[i].start - 1) - 1\n            last[i] = j \n        dp = [ [ (0, []) for _ in range(5) ] for _ in range(n+1) ]\n        \n        for i in range(1, n+1):\n            curr = sit[i-1]\n            for k in range(0, 5):\n                if k == 0:\n                    dp[i][k] = (0, [])\n                else:\n                    wt1, st1 = dp[i-1][k]\n                    if last[i-1] != -1 and k-1 >=0:\n                        wtp, stp = dp[last[i-1]+1][k-1]\n                    elif last[i-1] == -1 and k-1 >=0:\n                        wtp, stp = dp[0][k-1]\n                    else:\n                        wtp, stp = (0, [])\n                    \n                    wto = wtp + curr.weight\n                    sto = stp + [curr.ind]\n                    \n                    if wt1 > wto:\n                        dp[i][k] = (wt1, st1)\n                    elif wt1 < wto:\n                        dp[i][k] = (wto, sto)\n                    else:\n                        sst1 = sorted(st1)\n                        sst2 = sorted(sto)\n                        if sst1 < sst2:\n                            dp[i][k] = (wt1, st1)\n                        else:\n                            dp[i][k] = (wto, sto)\n        bwt = 0\n        bst = []\n        for k in range(1, 5):\n            currwt, currst = dp[n][k]\n            if currwt > bwt:\n                bwt = currwt\n                bst = currst\n            elif currwt == bwt:\n                if not bst:\n                    bst = currst\n                else:\n                    sbest = sorted(bst)\n                    scurr = sorted(currst)\n                    if scurr < sbest:\n                        bst = currst\n        \n        bsrt = sorted(bst)\n        return bsrt\n", "input": "maximumWeight(intervals=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]])", "output": "[2, 3]", "correct_condition": "maximumWeight(intervals=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]) == [2, 3]", "contest_id": "weekly-contest-431", "contest_date": "2025-01-05T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 273, "coverage": null}, "submission_id": 1498028040}
