{
  "id": "contest438_q3768_s1",
  "question_id": 3768,
  "function_name": "hasSameDigits",
  "code": "def hasSameDigits(s: str) -> bool:\n        while len(s)!=2:\n            res=\"\"\n            for i in range(1,len(s)):\n                res+=str(int(s[i])+int(s[i-1]))[-1]\n            s=res\n        return len(set(s))==1",
  "input": "hasSameDigits(s=\"3902\")",
  "output": "True",
  "correct_condition": "hasSameDigits(s=\"3902\") == True",
  "contest_id": "weekly-contest-438",
  "contest_date": "2025-02-23T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1552268304,
  "mutated_code": "def hasSameDigits(s: str) -> bool:\n    while len(s) != 2:\n        res = ''\n        for i in range(1, len(s)):\n            res += str(int(s[i]) - int(s[i - 1]))[-1]\n        s = res\n    return len(set(s)) == 1",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest432_q3708_s1",
  "question_id": 3708,
  "function_name": "zigzagTraversal",
  "code": "def zigzagTraversal(grid: List[List[int]]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n\n        r = 1\n        i, j = 0, 0\n        res = []\n        \n        while i < m:\n            res.append(grid[i][j])\n            if r:\n                j += 2\n                if j >= n:\n                    i += 1\n                    j = n - 1 - (j - n)\n                    r = 1 - r\n            else:\n                j -= 2\n                if j < 0:\n                    i += 1\n                    j = 0 - j - 1\n                    r = 1 - r\n\n        return res",
  "input": "zigzagTraversal(grid=[[1,2],[3,4]])",
  "output": "[1, 4]",
  "correct_condition": "zigzagTraversal(grid=[[1,2],[3,4]]) == [1, 4]",
  "contest_id": "weekly-contest-432",
  "contest_date": "2025-01-12T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 23,
    "coverage": null
  },
  "submission_id": 1505650015,
  "mutated_code": "def zigzagTraversal(grid: List[List[int]]) -> List[int]:\n    m, n = (len(grid), len(grid[0]))\n    r = 1\n    i, j = (1, 0)\n    res = []\n    while i < m:\n        res.append(grid[i][j])\n        if r:\n            j += 2\n            if j >= n:\n                i += 1\n                j = n - 1 - (j - n)\n                r = 1 - r\n        else:\n            j -= 2\n            if j < 0:\n                i += 1\n                j = 0 - j - 1\n                r = 1 - r\n    return res",
  "mutated_output": "[3]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest448_q3859_s1",
  "question_id": 3859,
  "function_name": "maxProduct",
  "code": "def maxProduct(n: int) -> int:\n        s = str(n)\n        arr = sorted(int(_) for _ in s)\n        return arr[-1] * arr[-2]\n",
  "input": "maxProduct(n=31)",
  "output": "3",
  "correct_condition": "maxProduct(n=31) == 3",
  "contest_id": "weekly-contest-448",
  "contest_date": "2025-05-04T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 4,
    "coverage": null
  },
  "submission_id": 1624852966,
  "mutated_code": "def maxProduct(n: int) -> int:\n    s = str(n)\n    arr = sorted((int(_) for _ in s))\n    return arr[-2] * arr[-2]",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest445_q3830_s0",
  "question_id": 3830,
  "function_name": "findClosest",
  "code": "def findClosest(x: int, y: int, z: int) -> int:\n        if abs(z-x) < abs(z-y):\n            return 1\n        elif abs(z-y) < abs(z-x):\n            return 2\n        return 0\n",
  "input": "findClosest(x=2, y=7, z=4)",
  "output": "1",
  "correct_condition": "findClosest(x=2, y=7, z=4) == 1",
  "contest_id": "weekly-contest-445",
  "contest_date": "2025-04-13T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 6,
    "coverage": null
  },
  "submission_id": 1605121226,
  "mutated_code": "def findClosest(x: int, y: int, z: int) -> int:\n    if abs(z + x) < abs(z - y):\n        return 1\n    elif abs(z - y) < abs(z - x):\n        return 2\n    return 0",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q3997_s2",
  "question_id": 3997,
  "function_name": "maxKDistinct",
  "code": "def maxKDistinct(nums: List[int], k: int) -> List[int]:\n        res = []\n        nums.sort()\n        while len(res) < k and nums:\n            x = nums.pop()\n            if not res or x != res[-1]:\n                res.append(x)\n        return sorted(res,reverse=True)",
  "input": "maxKDistinct(nums=[84,93,100,77,90], k=3)",
  "output": "[100, 93, 90]",
  "correct_condition": "maxKDistinct(nums=[84,93,100,77,90], k=3) == [100, 93, 90]",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 8,
    "coverage": null
  },
  "submission_id": 1769949793,
  "mutated_code": "def maxKDistinct(nums: List[int], k: int) -> List[int]:\n    res = []\n    nums.sort()\n    while len(res) <= k and nums:\n        x = nums.pop()\n        if not res or x != res[-1]:\n            res.append(x)\n    return sorted(res, reverse=True)",
  "mutated_output": "[100, 93, 90, 84]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest434_q3704_s2",
  "question_id": 3704,
  "function_name": "countPartitions",
  "code": "def countPartitions(nums: List[int]) -> int:\n        total = sum(nums)\n        if total % 2 != 0:\n            return 0\n        return len(nums) - 1",
  "input": "countPartitions(nums=[10,10,3,7,6])",
  "output": "4",
  "correct_condition": "countPartitions(nums=[10,10,3,7,6]) == 4",
  "contest_id": "weekly-contest-434",
  "contest_date": "2025-01-26T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 5,
    "coverage": null
  },
  "submission_id": 1520580436,
  "mutated_code": "def countPartitions(nums: List[int]) -> int:\n    total = sum(nums)\n    if total // 2 != 0:\n        return 0\n    return len(nums) - 1",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest455_q3914_s1",
  "question_id": 3914,
  "function_name": "checkPrimeFrequency",
  "code": "def checkPrimeFrequency(nums: List[int]) -> bool:\n        cnt = Counter(nums)\n\n        def isPrime(x):\n            if x < 2:\n                return False\n            for i in range(2, int(x**0.5) + 1):\n                if x % i == 0:\n                    return False\n            return True\n\n        for v in cnt.values():\n            if isPrime(v):\n                return True\n        return False\n",
  "input": "checkPrimeFrequency(nums=[1,2,3,4,5,4])",
  "output": "True",
  "correct_condition": "checkPrimeFrequency(nums=[1,2,3,4,5,4]) == True",
  "contest_id": "weekly-contest-455",
  "contest_date": "2025-06-22T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1672123316,
  "mutated_code": "def checkPrimeFrequency(nums: List[int]) -> bool:\n    cnt = Counter(nums)\n\n    def isPrime(x):\n        if x <= 2:\n            return False\n        for i in range(2, int(x ** 0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n    for v in cnt.values():\n        if isPrime(v):\n            return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest433_q3731_s2",
  "question_id": 3731,
  "function_name": "subarraySum",
  "code": "def subarraySum(nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            start = max(0, i - nums[i])\n            s = 0\n            for j in range(start, i + 1):\n                s += nums[j]\n            ans += s\n        return ans",
  "input": "subarraySum(nums=[2,3,1])",
  "output": "11",
  "correct_condition": "subarraySum(nums=[2,3,1]) == 11",
  "contest_id": "weekly-contest-433",
  "contest_date": "2025-01-19T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 10,
    "coverage": null
  },
  "submission_id": 1513080952,
  "mutated_code": "def subarraySum(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        start = max(0, i + nums[i])\n        s = 0\n        for j in range(start, i + 1):\n            s += nums[j]\n        ans += s\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest454_q3893_s0",
  "question_id": 3893,
  "function_name": "generateTag",
  "code": "def generateTag(s: str) -> str:\n        w = s.split()\n        if not w: return \"#\"\n        t = w[0].lower() + ''.join(x.capitalize() for x in w[1:])\n        t = ''.join(c for c in t if c.isalpha())\n        return '#' + t[:99]",
  "input": "generateTag(s=\"Leetcode daily streak achieved\")",
  "output": "'#leetcodeDailyStreakAchieved'",
  "correct_condition": "generateTag(s=\"Leetcode daily streak achieved\") == '#leetcodeDailyStreakAchieved'",
  "contest_id": "weekly-contest-454",
  "contest_date": "2025-06-15T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 6,
    "coverage": null
  },
  "submission_id": 1664365781,
  "mutated_code": "def generateTag(s: str) -> str:\n    w = s.split()\n    if not w:\n        return '#'\n    t = w[1].lower() + ''.join((x.capitalize() for x in w[1:]))\n    t = ''.join((c for c in t if c.isalpha()))\n    return '#' + t[:99]",
  "mutated_output": "'#dailyDailyStreakAchieved'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest466_q3998_s2",
  "question_id": 3998,
  "function_name": "minOperations",
  "code": "def minOperations(nums: List[int]) -> int:\n        x = nums[0]\n        for v in nums[1:]:\n            if v != x:\n                return 1\n        return 0",
  "input": "minOperations(nums=[1,2])",
  "output": "1",
  "correct_condition": "minOperations(nums=[1,2]) == 1",
  "contest_id": "weekly-contest-466",
  "contest_date": "2025-09-07T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 6,
    "coverage": null
  },
  "submission_id": 1762065504,
  "mutated_code": "def minOperations(nums: List[int]) -> int:\n    x = nums[0]\n    for v in nums[1:]:\n        if v == x:\n            return 1\n    return 0",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest448_q3859_s0",
  "question_id": 3859,
  "function_name": "maxProduct",
  "code": "def maxProduct(n: int) -> int:\n        l = []\n        while n:\n            l.append(n % 10)\n            n = n//10\n        l.sort()\n        return l[-1] * l[-2]",
  "input": "maxProduct(n=31)",
  "output": "3",
  "correct_condition": "maxProduct(n=31) == 3",
  "contest_id": "weekly-contest-448",
  "contest_date": "2025-05-04T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1624858658,
  "mutated_code": "def maxProduct(n: int) -> int:\n    l = []\n    while n:\n        l.append(n // 10)\n        n = n // 10\n    l.sort()\n    return l[-1] * l[-2]",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest433_q3731_s0",
  "question_id": 3731,
  "function_name": "subarraySum",
  "code": "def subarraySum(nums):\n        n=len(nums)\n        p=[0]*(n+1)\n        for i in range(n):\n            p[i+1]=p[i]+nums[i]\n        s1=0\n        s2=0\n        for i in range(n):\n            st=i-nums[i]\n            if st<0: st=0\n            s1+=p[i+1]\n            s2+=p[st]\n        return s1-s2",
  "input": "subarraySum(nums=[2,3,1])",
  "output": "11",
  "correct_condition": "subarraySum(nums=[2,3,1]) == 11",
  "contest_id": "weekly-contest-433",
  "contest_date": "2025-01-19T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 13,
    "coverage": null
  },
  "submission_id": 1513087537,
  "mutated_code": "def subarraySum(nums):\n    n = len(nums)\n    p = [0] * (n + 1)\n    for i in range(n):\n        p[i - 1] = p[i] + nums[i]\n    s1 = 0\n    s2 = 0\n    for i in range(n):\n        st = i - nums[i]\n        if st < 0:\n            st = 0\n        s1 += p[i + 1]\n        s2 += p[st]\n    return s1 - s2",
  "mutated_output": "-4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest449_q3871_s1",
  "question_id": 3871,
  "function_name": "minDeletion",
  "code": "def minDeletion(s: str, k: int) -> int:\n        arr = sorted(Counter(s).values())\n        n = len(arr)\n        return sum(arr[:n - k]) if n > k else 0",
  "input": "minDeletion(s=\"abc\", k=2)",
  "output": "1",
  "correct_condition": "minDeletion(s=\"abc\", k=2) == 1",
  "contest_id": "weekly-contest-449",
  "contest_date": "2025-05-11T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 4,
    "coverage": null
  },
  "submission_id": 1630586515,
  "mutated_code": "def minDeletion(s: str, k: int) -> int:\n    arr = sorted(Counter(s).values())\n    n = len(arr)\n    return sum(arr[:n + k]) if n > k else 0",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest443_q3832_s0",
  "question_id": 3832,
  "function_name": "minCosts",
  "code": "def minCosts(a: List[int]) -> List[int]:\n        res = a\n        for i in range(1, len(res)):\n            res[i] = min(res[i], res[i - 1])\n        return res",
  "input": "minCosts(a=[5,3,4,1,3,2])",
  "output": "[5, 3, 3, 1, 1, 1]",
  "correct_condition": "minCosts(a=[5,3,4,1,3,2]) == [5, 3, 3, 1, 1, 1]",
  "contest_id": "weekly-contest-443",
  "contest_date": "2025-03-30T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 5,
    "coverage": null
  },
  "submission_id": 1590604607,
  "mutated_code": "def minCosts(a: List[int]) -> List[int]:\n    res = a\n    for i in range(1, len(res)):\n        res[i] = min(res[i], res[i - 0])\n    return res",
  "mutated_output": "[5, 3, 4, 1, 3, 2]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest432_q3708_s0",
  "question_id": 3708,
  "function_name": "zigzagTraversal",
  "code": "def zigzagTraversal(grid: List[List[int]]) -> List[int]:\n        R, C = len(grid), len(grid[0])\n        ans = []\n        i, j = 0, 0\n\n        def connected(i, j, ii, jj):\n            return (i == ii and abs(j - jj) == 1) or (j == jj and abs(i - ii) == 1)\n\n        dir = 1\n        while 0 <= i < R and 0 <= j < C:\n            ans.append(grid[i][j])\n            ii = i\n            jj = j + 2 * dir\n            if 0 <= jj < C:\n                i, j = ii, jj\n            else:\n                ii = i + 1\n                jj = 0 if jj < 0 else C - 1\n                dir = -dir\n                if 0 <= ii < R and 0 <= jj < C:\n                    if connected(i, j, ii, jj):\n                        jj += dir\n                    i, j = ii, jj\n                else:\n                    break\n\n        return ans\n\n",
  "input": "zigzagTraversal(grid=[[1,2],[3,4]])",
  "output": "[1, 4]",
  "correct_condition": "zigzagTraversal(grid=[[1,2],[3,4]]) == [1, 4]",
  "contest_id": "weekly-contest-432",
  "contest_date": "2025-01-12T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 28,
    "coverage": null
  },
  "submission_id": 1505653842,
  "mutated_code": "def zigzagTraversal(grid: List[List[int]]) -> List[int]:\n    R, C = (len(grid), len(grid[0]))\n    ans = []\n    i, j = (0, 0)\n\n    def connected(i, j, ii, jj):\n        return i == ii and abs(j - jj) == 1 or (j == jj and abs(i - ii) == 1)\n    dir = 1\n    while 0 <= i < R and 0 <= j < C:\n        ans.append(grid[i][j])\n        ii = i\n        jj = j - 2 * dir\n        if 0 <= jj < C:\n            i, j = (ii, jj)\n        else:\n            ii = i + 1\n            jj = 0 if jj < 0 else C - 1\n            dir = -dir\n            if 0 <= ii < R and 0 <= jj < C:\n                if connected(i, j, ii, jj):\n                    jj += dir\n                i, j = (ii, jj)\n            else:\n                break\n    return ans",
  "mutated_output": "[1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest431_q3702_s1",
  "question_id": 3702,
  "function_name": "maxLength",
  "code": "def maxLength(nums: List[int]) -> int:\n        ans = 1\n        run = 1\n        for l in range(len(nums)):\n            for r in range(l, len(nums)):\n                a = nums[l:r+1]\n                prod = 1\n                g = nums[l]\n                lc = nums[l]\n                for v in a:\n                    g = gcd(g, v)\n                    lc = lcm(lc, v)\n                    prod *= v\n                if g * lc == prod:\n                    ans = max(ans, r - l + 1)\n        return ans",
  "input": "maxLength(nums=[1,2,1,2,1,1,1])",
  "output": "5",
  "correct_condition": "maxLength(nums=[1,2,1,2,1,1,1]) == 5",
  "contest_id": "weekly-contest-431",
  "contest_date": "2025-01-05T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 16,
    "coverage": null
  },
  "submission_id": 1497983616,
  "mutated_code": "def maxLength(nums: List[int]) -> int:\n    ans = 1\n    run = 1\n    for l in range(len(nums)):\n        for r in range(l, len(nums)):\n            a = nums[l:r + 1]\n            prod = 1\n            g = nums[l]\n            lc = nums[l]\n            for v in a:\n                g = gcd(g, v)\n                lc = lcm(lc, v)\n                prod *= v\n            if g // lc == prod:\n                ans = max(ans, r - l + 1)\n    return ans",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest462_q3973_s1",
  "question_id": 3973,
  "function_name": "reverseSubmatrix",
  "code": "def reverseSubmatrix(grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:\n        for i in range(k//2):\n            for j in range(y,y+k):\n                grid[x+i][j],grid[x+k-1-i][j] = grid[x+k-1-i][j],grid[x+i][j]\n        return grid",
  "input": "reverseSubmatrix(grid=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], x=1, y=0, k=3)",
  "output": "[[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
  "correct_condition": "reverseSubmatrix(grid=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], x=1, y=0, k=3) == [[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
  "contest_id": "weekly-contest-462",
  "contest_date": "2025-08-10T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 5,
    "coverage": null
  },
  "submission_id": 1729527513,
  "mutated_code": "def reverseSubmatrix(grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:\n    for i in range(k // 2):\n        for j in range(y, y - k):\n            grid[x + i][j], grid[x + k - 1 - i][j] = (grid[x + k - 1 - i][j], grid[x + i][j])\n    return grid",
  "mutated_output": "[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest438_q3768_s0",
  "question_id": 3768,
  "function_name": "hasSameDigits",
  "code": "def hasSameDigits(s: str) -> bool:\n        n = len(s)\n        if n == 2:\n            return (s[0] == s[1])\n        \n        digits = list(map(int, s))\n        N = n - 2\n    \n        binom_mod5 = [[0]*5 for _ in range(5)]\n        for i in range(5):\n            binom_mod5[i][0] = 1\n            for j in range(1, i+1):\n                from math import comb\n                binom_mod5[i][j] = comb(i, j) % 5\n        \n        combine_map = {}\n        for x in range(10):\n            pair = (x % 2, x % 5)\n            combine_map[pair] = x\n        \n        def binom_mod2(n, k):\n            return 1 if (k & ~n) == 0 else 0\n        \n        def binom_mod5_func(n, k):\n            res = 1\n            while n > 0 or k > 0:\n                n5 = n % 5\n                k5 = k % 5\n                if k5 > n5:\n                    return 0\n                res = (res * binom_mod5[n5][k5]) % 5\n                n //= 5\n                k //= 5\n            return res\n        \n        def binom_mod10(n, k):\n            b2 = binom_mod2(n, k)\n            b5 = binom_mod5_func(n, k)\n            return combine_map[(b2, b5)]\n        \n        binom_table = [0]*(N+1)\n        for k in range(N+1):\n            binom_table[k] = binom_mod10(N, k)\n        d0 = 0\n        d1 = 0\n        for m in range(N+1):\n            c = binom_table[m]\n            d0 = (d0 + digits[m]*c) % 10\n            d1 = (d1 + digits[m+1]*c) % 10    \n        return (d0 == d1)\n",
  "input": "hasSameDigits(s=\"3902\")",
  "output": "True",
  "correct_condition": "hasSameDigits(s=\"3902\") == True",
  "contest_id": "weekly-contest-438",
  "contest_date": "2025-02-23T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 50,
    "coverage": null
  },
  "submission_id": 1552284205,
  "mutated_code": "def hasSameDigits(s: str) -> bool:\n    n = len(s)\n    if n == 2:\n        return s[0] == s[1]\n    digits = list(map(int, s))\n    N = n - 2\n    binom_mod5 = [[0] * 5 for _ in range(5)]\n    for i in range(5):\n        binom_mod5[i][0] = 1\n        for j in range(1, i - 1):\n            from math import comb\n            binom_mod5[i][j] = comb(i, j) % 5\n    combine_map = {}\n    for x in range(10):\n        pair = (x % 2, x % 5)\n        combine_map[pair] = x\n\n    def binom_mod2(n, k):\n        return 1 if k & ~n == 0 else 0\n\n    def binom_mod5_func(n, k):\n        res = 1\n        while n > 0 or k > 0:\n            n5 = n % 5\n            k5 = k % 5\n            if k5 > n5:\n                return 0\n            res = res * binom_mod5[n5][k5] % 5\n            n //= 5\n            k //= 5\n        return res\n\n    def binom_mod10(n, k):\n        b2 = binom_mod2(n, k)\n        b5 = binom_mod5_func(n, k)\n        return combine_map[b2, b5]\n    binom_table = [0] * (N + 1)\n    for k in range(N + 1):\n        binom_table[k] = binom_mod10(N, k)\n    d0 = 0\n    d1 = 0\n    for m in range(N + 1):\n        c = binom_table[m]\n        d0 = (d0 + digits[m] * c) % 10\n        d1 = (d1 + digits[m + 1] * c) % 10\n    return d0 == d1",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q4012_s1",
  "question_id": 4012,
  "function_name": "earliestTime",
  "code": "def earliestTime(tasks: List[List[int]]) -> int:\n    return min(t[0] + t[1] for t in tasks)",
  "input": "earliestTime(tasks=[[1,6],[2,3]])",
  "output": "5",
  "correct_condition": "earliestTime(tasks=[[1,6],[2,3]]) == 5",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 2,
    "coverage": null
  },
  "submission_id": 1769946189,
  "mutated_code": "def earliestTime(tasks: List[List[int]]) -> int:\n    return min((t[0] - t[1] for t in tasks))",
  "mutated_output": "-5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest445_q3830_s1",
  "question_id": 3830,
  "function_name": "findClosest",
  "code": "def findClosest(x: int, y: int, z: int) -> int:\n        if abs(z - y) == abs(z - x):\n            return 0\n        elif abs(z - y) < abs(z - x):\n            return 2\n        else:\n            return 1",
  "input": "findClosest(x=2, y=7, z=4)",
  "output": "1",
  "correct_condition": "findClosest(x=2, y=7, z=4) == 1",
  "contest_id": "weekly-contest-445",
  "contest_date": "2025-04-13T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1605117709,
  "mutated_code": "def findClosest(x: int, y: int, z: int) -> int:\n    if abs(z - y) == abs(z - x):\n        return 0\n    elif abs(z - y) < abs(z + x):\n        return 2\n    else:\n        return 1",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest449_q3871_s2",
  "question_id": 3871,
  "function_name": "minDeletion",
  "code": "def minDeletion(s: str, k: int) -> int:\n        freq = {}\n        for ch in s:\n            freq[ch] = freq.get(ch, 0) + 1\n\n        if len(freq) <= k:\n            return 0\n\n        sorted_freqs = sorted(freq.values(), reverse=True)\n        keep_count = sum(sorted_freqs[:k])\n        return len(s) - keep_count",
  "input": "minDeletion(s=\"abc\", k=2)",
  "output": "1",
  "correct_condition": "minDeletion(s=\"abc\", k=2) == 1",
  "contest_id": "weekly-contest-449",
  "contest_date": "2025-05-11T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 11,
    "coverage": null
  },
  "submission_id": 1630586123,
  "mutated_code": "def minDeletion(s: str, k: int) -> int:\n    freq = {}\n    for ch in s:\n        freq[ch] = freq.get(ch, 0) - 1\n    if len(freq) <= k:\n        return 0\n    sorted_freqs = sorted(freq.values(), reverse=True)\n    keep_count = sum(sorted_freqs[:k])\n    return len(s) - keep_count",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest461_q3952_s0",
  "question_id": 3952,
  "function_name": "isTrionic",
  "code": "def isTrionic(a: list[int]) -> bool:\n        n = len(a)\n        if n < 3:\n            return False\n        p = 0\n        f1 = f2 = f3 = False\n        for i in range(1, n):\n            u, v = a[i - 1], a[i]\n            if v == u:\n                return False\n            if p == 0:\n                if v > u:\n                    f1 = True\n                else:\n                    if not f1:\n                        return False\n                    p = 1\n                    f2 = True\n            elif p == 1:\n                if v < u:\n                    f2 = True\n                else:\n                    if not f2:\n                        return False\n                    p = 2\n                    f3 = True\n            else:\n                if v > u:\n                    f3 = True\n                else:\n                    return False\n        return p == 2 and f1 and f2 and f3",
  "input": "isTrionic(a=[1,3,5,4,2,6])",
  "output": "True",
  "correct_condition": "isTrionic(a=[1,3,5,4,2,6]) == True",
  "contest_id": "weekly-contest-461",
  "contest_date": "2025-08-03T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 32,
    "coverage": null
  },
  "submission_id": 1721337202,
  "mutated_code": "def isTrionic(a: list[int]) -> bool:\n    n = len(a)\n    if n < 3:\n        return False\n    p = 0\n    f1 = f2 = f3 = False\n    for i in range(1, n):\n        u, v = (a[i + 1], a[i])\n        if v == u:\n            return False\n        if p == 0:\n            if v > u:\n                f1 = True\n            else:\n                if not f1:\n                    return False\n                p = 1\n                f2 = True\n        elif p == 1:\n            if v < u:\n                f2 = True\n            else:\n                if not f2:\n                    return False\n                p = 2\n                f3 = True\n        elif v > u:\n            f3 = True\n        else:\n            return False\n    return p == 2 and f1 and f2 and f3",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q3997_s0",
  "question_id": 3997,
  "function_name": "maxKDistinct",
  "code": "def maxKDistinct(nums: List[int], k: int) -> List[int]:\n        res = []\n        nums.sort(reverse=True)\n        seen = set()\n        taken = 0\n        for i, v in enumerate(nums):\n            if taken == k:\n                break\n            if v in seen:\n                continue\n            seen.add(v)\n            res.append(v)\n            taken += 1\n\n        return res\n            ",
  "input": "maxKDistinct(nums=[84,93,100,77,90], k=3)",
  "output": "[100, 93, 90]",
  "correct_condition": "maxKDistinct(nums=[84,93,100,77,90], k=3) == [100, 93, 90]",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 16,
    "coverage": null
  },
  "submission_id": 1769946197,
  "mutated_code": "def maxKDistinct(nums: List[int], k: int) -> List[int]:\n    res = []\n    nums.sort(reverse=True)\n    seen = set()\n    taken = 0\n    for i, v in enumerate(nums):\n        if taken != k:\n            break\n        if v in seen:\n            continue\n        seen.add(v)\n        res.append(v)\n        taken += 1\n    return res",
  "mutated_output": "[]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest437_q3709_s2",
  "question_id": 3709,
  "function_name": "hasSpecialSubstring",
  "code": "def hasSpecialSubstring(s: str, k: int) -> bool:\n        n = len(s)\n        for i in range(n - k + 1):\n            c = s[i]\n            if all(s[i + j] == c for j in range(k)):\n                if (i == 0 or s[i - 1] != c) and (i + k == n or s[i + k] != c):\n                    return True\n        return False",
  "input": "hasSpecialSubstring(s=\"aaabaaa\", k=3)",
  "output": "True",
  "correct_condition": "hasSpecialSubstring(s=\"aaabaaa\", k=3) == True",
  "contest_id": "weekly-contest-437",
  "contest_date": "2025-02-16T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 8,
    "coverage": null
  },
  "submission_id": 1544547904,
  "mutated_code": "def hasSpecialSubstring(s: str, k: int) -> bool:\n    n = len(s)\n    for i in range(n - k + 1):\n        c = s[i]\n        if all((s[i + j] != c for j in range(k))):\n            if (i == 0 or s[i - 1] != c) and (i + k == n or s[i + k] != c):\n                return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest451_q3879_s0",
  "question_id": 3879,
  "function_name": "minCuttingCost",
  "code": "def minCuttingCost(n: int, m: int, k: int) -> int:\n    return (n - k) * k * (n > k) + (m - k) * k * (m > k)\n",
  "input": "minCuttingCost(n=6, m=5, k=5)",
  "output": "5",
  "correct_condition": "minCuttingCost(n=6, m=5, k=5) == 5",
  "contest_id": "weekly-contest-451",
  "contest_date": "2025-05-25T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 2,
    "coverage": null
  },
  "submission_id": 1643574218,
  "mutated_code": "def minCuttingCost(n: int, m: int, k: int) -> int:\n    return (n - k) // k * (n > k) + (m - k) * k * (m > k)",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest462_q3973_s2",
  "question_id": 3973,
  "function_name": "reverseSubmatrix",
  "code": "def reverseSubmatrix(grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:\n        for i in range(k // 2):\n            m = x + i\n            n = x + k - 1 - i\n            grid[m][y:y + k], grid[n][y:y + k] = grid[n][y:y + k], grid[m][y:y + k]\n        return grid",
  "input": "reverseSubmatrix(grid=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], x=1, y=0, k=3)",
  "output": "[[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
  "correct_condition": "reverseSubmatrix(grid=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], x=1, y=0, k=3) == [[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
  "contest_id": "weekly-contest-462",
  "contest_date": "2025-08-10T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 6,
    "coverage": null
  },
  "submission_id": 1729527363,
  "mutated_code": "def reverseSubmatrix(grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:\n    for i in range(k // 2):\n        m = x + i\n        n = x - k - 1 - i\n        grid[m][y:y + k], grid[n][y:y + k] = (grid[n][y:y + k], grid[m][y:y + k])\n    return grid",
  "mutated_output": "[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 4,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3817_s2",
  "question_id": 3817,
  "function_name": "maxContainers",
  "code": "def maxContainers(n: int, w: int, maxWeight: int) -> int:\n        return min(maxWeight // w, n * n)",
  "input": "maxContainers(n=2, w=3, maxWeight=15)",
  "output": "4",
  "correct_condition": "maxContainers(n=2, w=3, maxWeight=15) == 4",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 2,
    "coverage": null
  },
  "submission_id": 1582820286,
  "mutated_code": "def maxContainers(n: int, w: int, maxWeight: int) -> int:\n    return min(maxWeight // w, n // n)",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest455_q3914_s2",
  "question_id": 3914,
  "function_name": "checkPrimeFrequency",
  "code": "def checkPrimeFrequency(nums: List[int]) -> bool:\n        # frequency map\n        freq = Counter(nums)\n\n        # find if n is prime\n        def is_prime(n: int) -> bool:\n            if n <= 1:\n                return False\n            if n <= 3:\n                return True\n            if n % 2 == 0:\n                return False\n            limit = isqrt(n)\n            for d in range(3, limit + 1, 2):\n                if n % d == 0:\n                    return False\n            return True\n\n        for f in freq.values():\n            if is_prime(f):\n                return True\n        return False",
  "input": "checkPrimeFrequency(nums=[1,2,3,4,5,4])",
  "output": "True",
  "correct_condition": "checkPrimeFrequency(nums=[1,2,3,4,5,4]) == True",
  "contest_id": "weekly-contest-455",
  "contest_date": "2025-06-22T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 22,
    "coverage": null
  },
  "submission_id": 1672125677,
  "mutated_code": "def checkPrimeFrequency(nums: List[int]) -> bool:\n    freq = Counter(nums)\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return False\n        if n % 2 == 0:\n            return False\n        limit = isqrt(n)\n        for d in range(3, limit + 1, 2):\n            if n % d == 0:\n                return False\n        return True\n    for f in freq.values():\n        if is_prime(f):\n            return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "keyword",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest443_q3832_s1",
  "question_id": 3832,
  "function_name": "minCosts",
  "code": "def minCosts(cost: List[int]) -> List[int]:\n        for i in range(1, len(cost)):\n            if cost[i] > cost[i-1]:\n                cost[i] = cost[i-1]\n        return cost",
  "input": "minCosts(cost=[5,3,4,1,3,2])",
  "output": "[5, 3, 3, 1, 1, 1]",
  "correct_condition": "minCosts(cost=[5,3,4,1,3,2]) == [5, 3, 3, 1, 1, 1]",
  "contest_id": "weekly-contest-443",
  "contest_date": "2025-03-30T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 5,
    "coverage": null
  },
  "submission_id": 1590616291,
  "mutated_code": "def minCosts(cost: List[int]) -> List[int]:\n    for i in range(1, len(cost)):\n        if cost[i] > cost[i - 1]:\n            cost[i] = cost[i + 1]\n    return cost",
  "mutated_output": "[5, 3, 1, 1, 2, 2]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest462_q3973_s0",
  "question_id": 3973,
  "function_name": "reverseSubmatrix",
  "code": "def reverseSubmatrix(g: List[List[int]], a: int, b: int, s: int) -> List[List[int]]:\n        r, c, k = a, b, s\n        tmp = [g[r + i][c:c + k] for i in range(k)]\n        for i, v in enumerate(reversed(tmp)):\n            g[r + i][c:c + k] = v\n        return g\n",
  "input": "reverseSubmatrix(g=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], a=1, b=0, s=3)",
  "output": "[[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
  "correct_condition": "reverseSubmatrix(g=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], a=1, b=0, s=3) == [[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
  "contest_id": "weekly-contest-462",
  "contest_date": "2025-08-10T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 6,
    "coverage": null
  },
  "submission_id": 1729547666,
  "mutated_code": "def reverseSubmatrix(g: List[List[int]], a: int, b: int, s: int) -> List[List[int]]:\n    r, c, k = (a, b, s)\n    tmp = [g[r - i][c:c + k] for i in range(k)]\n    for i, v in enumerate(reversed(tmp)):\n        g[r + i][c:c + k] = v\n    return g",
  "mutated_output": "[[1, 2, 3, 4], [13, 14, 15, 8], [1, 2, 3, 12], [5, 6, 7, 16]]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest439_q3705_s2",
  "question_id": 3705,
  "function_name": "largestInteger",
  "code": "def largestInteger(nums: List[int], k: int) -> int:\n        freq = defaultdict(int)\n        n = len(nums)\n\n        for i in range(n - k + 1):\n            subarray = nums[i:i + k]\n            unique_elements = set(subarray)\n            for num in unique_elements:\n                freq[num] += 1\n\n        result = -1\n        for num, count in freq.items():\n            if count == 1:\n                result = max(result, num)\n\n        return result",
  "input": "largestInteger(nums=[3,9,2,1,7], k=3)",
  "output": "7",
  "correct_condition": "largestInteger(nums=[3,9,2,1,7], k=3) == 7",
  "contest_id": "weekly-contest-439",
  "contest_date": "2025-03-02T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 16,
    "coverage": null
  },
  "submission_id": 1559813970,
  "mutated_code": "def largestInteger(nums: List[int], k: int) -> int:\n    freq = defaultdict(int)\n    n = len(nums)\n    for i in range(n - k - 1):\n        subarray = nums[i:i + k]\n        unique_elements = set(subarray)\n        for num in unique_elements:\n            freq[num] += 1\n    result = -1\n    for num, count in freq.items():\n        if count == 1:\n            result = max(result, num)\n    return result",
  "mutated_output": "9",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest431_q3702_s0",
  "question_id": 3702,
  "function_name": "maxLength",
  "code": "def maxLength(nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for l in range(n):\n            a = 1\n            b = 1\n            c = 0\n            for r in range(l, n):\n                a *= nums[r]\n                b = lcm(b, nums[r])\n                c = gcd(c, nums[r])\n                if a == b * c:\n                    ans = max(ans, r - l + 1)\n        return ans\n                \n        ",
  "input": "maxLength(nums=[1,2,1,2,1,1,1])",
  "output": "5",
  "correct_condition": "maxLength(nums=[1,2,1,2,1,1,1]) == 5",
  "contest_id": "weekly-contest-431",
  "contest_date": "2025-01-05T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 16,
    "coverage": null
  },
  "submission_id": 1497983046,
  "mutated_code": "def maxLength(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for l in range(n):\n        a = 1\n        b = 1\n        c = 0\n        for r in range(l, n):\n            a *= nums[r]\n            b = lcm(b, nums[r])\n            c = gcd(c, nums[r])\n            if a == b * c:\n                ans = max(ans, r - l - 1)\n    return ans",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest435_q3753_s1",
  "question_id": 3753,
  "function_name": "maxDifference",
  "code": "def maxDifference(s: str) -> int:\n        count = [0] * 26\n        for c in s:\n            count[ord(c) - ord('a')] += 1\n        odd = -1\n        even = float('inf')\n        for x in count:\n            if x:\n                if x % 2 == 0:\n                    even = min(even, x)\n                else:\n                    odd = max(odd, x)\n        return odd - even\n\n",
  "input": "maxDifference(s=\"aaaaabbc\")",
  "output": "3",
  "correct_condition": "maxDifference(s=\"aaaaabbc\") == 3",
  "contest_id": "weekly-contest-435",
  "contest_date": "2025-02-02T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1528102981,
  "mutated_code": "def maxDifference(s: str) -> int:\n    count = [0] * 26\n    for c in s:\n        count[ord(c) - ord('a')] += 1\n    odd = -1\n    even = float('inf')\n    for x in count:\n        if x:\n            if x // 2 == 0:\n                even = min(even, x)\n            else:\n                odd = max(odd, x)\n    return odd - even",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest461_q3952_s2",
  "question_id": 3952,
  "function_name": "isTrionic",
  "code": "def isTrionic(nums: List[int]) -> bool:\n        prev = -1\n        for i in range(1, len(nums)):\n            a = nums[i-1]\n            b = nums[i]\n            if a == b:\n                return False\n            if a > b:\n                if i == 1:\n                    return False\n                if prev != -1 and prev != i-1:\n                    return False\n                prev = i\n        return prev != -1 and prev < len(nums) - 1",
  "input": "isTrionic(nums=[1,3,5,4,2,6])",
  "output": "True",
  "correct_condition": "isTrionic(nums=[1,3,5,4,2,6]) == True",
  "contest_id": "weekly-contest-461",
  "contest_date": "2025-08-03T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1721315243,
  "mutated_code": "def isTrionic(nums: List[int]) -> bool:\n    prev = -1\n    for i in range(1, len(nums)):\n        a = nums[i + 1]\n        b = nums[i]\n        if a == b:\n            return False\n        if a > b:\n            if i == 1:\n                return False\n            if prev != -1 and prev != i - 1:\n                return False\n            prev = i\n    return prev != -1 and prev < len(nums) - 1",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest441_q3788_s0",
  "question_id": 3788,
  "function_name": "maxSum",
  "code": "def maxSum(a: List[int]) -> int:\n        s = {x for x in a if x > 0}\n        return sum(s) if s else max(a)\n",
  "input": "maxSum(a=[1,2,3,4,5])",
  "output": "15",
  "correct_condition": "maxSum(a=[1,2,3,4,5]) == 15",
  "contest_id": "weekly-contest-441",
  "contest_date": "2025-03-16T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 3,
    "coverage": null
  },
  "submission_id": 1575094028,
  "mutated_code": "def maxSum(a: List[int]) -> int:\n    s = {x for x in a if x > 1}\n    return sum(s) if s else max(a)",
  "mutated_output": "14",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest447_q3819_s2",
  "question_id": 3819,
  "function_name": "countCoveredBuildings",
  "code": "def countCoveredBuildings(n: int, buildings: List[List[int]]) -> int:\n        rows = {}\n        cols = {}\n        for x, y in buildings:\n            rows.setdefault(x, []).append(y)\n            cols.setdefault(y, []).append(x)\n        for r in rows:\n            rows[r].sort()\n        for c in cols:\n            cols[c].sort()\n\n        covered = 0\n        for x, y in buildings:\n            ys = rows[x]\n            i = bisect.bisect_left(ys, y)\n            has_left  = (i > 0)\n            has_right = (i+1 < len(ys))\n\n            xs = cols[y]\n            j = bisect.bisect_left(xs, x)\n            has_up    = (j > 0)\n            has_down  = (j+1 < len(xs))\n\n            if has_left and has_right and has_up and has_down:\n                covered += 1\n\n        return covered",
  "input": "countCoveredBuildings(n=3, buildings=[[1,2],[2,2],[3,2],[2,1],[2,3]])",
  "output": "1",
  "correct_condition": "countCoveredBuildings(n=3, buildings=[[1,2],[2,2],[3,2],[2,1],[2,3]]) == 1",
  "contest_id": "weekly-contest-447",
  "contest_date": "2025-04-27T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 27,
    "coverage": null
  },
  "submission_id": 1618870819,
  "mutated_code": "def countCoveredBuildings(n: int, buildings: List[List[int]]) -> int:\n    rows = {}\n    cols = {}\n    for x, y in buildings:\n        rows.setdefault(x, []).append(y)\n        cols.setdefault(y, []).append(x)\n    for r in rows:\n        rows[r].sort()\n    for c in cols:\n        cols[c].sort()\n    covered = 0\n    for x, y in buildings:\n        ys = rows[x]\n        i = bisect.bisect_left(ys, y)\n        has_left = i > 0\n        has_right = i + 1 < len(ys)\n        xs = cols[y]\n        j = bisect.bisect_left(xs, x)\n        has_up = j > 0\n        has_down = j + 1 < len(xs)\n        if has_left or has_right or has_up or has_down:\n            covered += 1\n    return covered",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "logical",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest440_q3759_s2",
  "question_id": 3759,
  "function_name": "findMaxSum",
  "code": "def findMaxSum(a: List[int], b: List[int], k: int) -> List[int]:\n        n = len(a)\n        P = sorted(zip(a, b, range(n)), key=lambda x: x[0])\n        R = [0] * n\n        h, s = [], 0\n        i = 0\n        while i < n:\n            j = i\n            while j < n and P[j][0] == P[i][0]:\n                R[P[j][2]] = s\n                j += 1\n            for _, y, _ in P[i:j]:\n                if len(h) < k:\n                    heapq.heappush(h, y)\n                    s += y\n                elif y > h[0]:\n                    s += y - h[0]\n                    heapq.heapreplace(h, y)\n            i = j\n        return R",
  "input": "findMaxSum(a=[4,2,1,5,3], b=[10,20,30,40,50], k=2)",
  "output": "[80, 30, 0, 80, 50]",
  "correct_condition": "findMaxSum(a=[4,2,1,5,3], b=[10,20,30,40,50], k=2) == [80, 30, 0, 80, 50]",
  "contest_id": "weekly-contest-440",
  "contest_date": "2025-03-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 20,
    "coverage": null
  },
  "submission_id": 1567577211,
  "mutated_code": "def findMaxSum(a: List[int], b: List[int], k: int) -> List[int]:\n    n = len(a)\n    P = sorted(zip(a, b, range(n)), key=lambda x: x[0])\n    R = [0] * n\n    h, s = ([], 0)\n    i = 0\n    while i < n:\n        j = i\n        while j < n and P[j][0] == P[i][0]:\n            R[P[j][2]] = s\n            j += 1\n        for _, y, _ in P[i:j]:\n            if len(h) < k:\n                heapq.heappush(h, y)\n                s += y\n            elif y > h[0]:\n                s += y + h[0]\n                heapq.heapreplace(h, y)\n        i = j\n    return R",
  "mutated_output": "[120, 30, 0, 120, 50]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest443_q3793_s0",
  "question_id": 3793,
  "function_name": "longestPalindrome",
  "code": "def longestPalindrome(s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        palS = [[False] * n for _ in range(n)]\n        for i in range(n):\n            palS[i][i] = True\n        for i in range(n - 1):\n            palS[i][i + 1] = (s[i] == s[i + 1])\n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                palS[i][j] = (s[i] == s[j] and palS[i + 1][j - 1])\n        left_pal = [0] * n\n        for i in range(n):\n            mx = 0\n            for j in range(i, n):\n                if palS[i][j]:\n                    cur = j - i + 1\n                    if cur > mx:\n                        mx = cur\n            left_pal[i] = mx\n        longest_s = max(left_pal) if n else 0\n\n        palT = [[False] * m for _ in range(m)]\n        for i in range(m):\n            palT[i][i] = True\n        for i in range(m - 1):\n            palT[i][i + 1] = (t[i] == t[i + 1])\n        for length in range(3, m + 1):\n            for i in range(m - length + 1):\n                j = i + length - 1\n                palT[i][j] = (t[i] == t[j] and palT[i + 1][j - 1])\n        right_pal = [0] * m\n        for j in range(m):\n            mx = 0\n            for i in range(j + 1):\n                if palT[i][j]:\n                    cur = j - i + 1\n                    if cur > mx:\n                        mx = cur\n            right_pal[j] = mx\n        longest_t = max(right_pal) if m else 0\n\n        best = max(longest_s, longest_t)\n        R = t[::-1]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == R[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    L = dp[i][j]\n                    extra1 = left_pal[i] if i < n else 0\n                    cand1 = 2 * L + extra1\n                    if cand1 > best:\n                        best = cand1\n                    p = m - j\n                    extra2 = right_pal[p - 1] if p > 0 else 0\n                    cand2 = 2 * L + extra2\n                    if cand2 > best:\n                        best = cand2\n                else:\n                    dp[i][j] = 0\n        return best",
  "input": "longestPalindrome(s=\"a\", t=\"a\")",
  "output": "2",
  "correct_condition": "longestPalindrome(s=\"a\", t=\"a\") == 2",
  "contest_id": "weekly-contest-443",
  "contest_date": "2025-03-30T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 62,
    "coverage": null
  },
  "submission_id": 1590627738,
  "mutated_code": "def longestPalindrome(s: str, t: str) -> int:\n    n, m = (len(s), len(t))\n    palS = [[False] * n for _ in range(n)]\n    for i in range(n):\n        palS[i][i] = True\n    for i in range(n - 1):\n        palS[i][i + 1] = s[i] == s[i + 1]\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            palS[i][j] = s[i] == s[j] and palS[i + 1][j - 1]\n    left_pal = [0] * n\n    for i in range(n):\n        mx = 0\n        for j in range(i, n):\n            if palS[i][j]:\n                cur = j - i + 1\n                if cur > mx:\n                    mx = cur\n        left_pal[i] = mx\n    longest_s = max(left_pal) if n else 0\n    palT = [[False] * m for _ in range(m)]\n    for i in range(m):\n        palT[i][i] = True\n    for i in range(m - 1):\n        palT[i][i + 1] = t[i] == t[i + 1]\n    for length in range(3, m + 1):\n        for i in range(m - length + 1):\n            j = i + length - 1\n            palT[i][j] = t[i] == t[j] and palT[i + 1][j - 1]\n    right_pal = [0] * m\n    for j in range(m):\n        mx = 0\n        for i in range(j + 1):\n            if palT[i][j]:\n                cur = j - i + 1\n                if cur > mx:\n                    mx = cur\n        right_pal[j] = mx\n    longest_t = max(right_pal) if m else 0\n    best = max(longest_s, longest_t)\n    R = t[::-1]\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n - 1):\n        for j in range(1, m + 1):\n            if s[i - 1] == R[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                L = dp[i][j]\n                extra1 = left_pal[i] if i < n else 0\n                cand1 = 2 * L + extra1\n                if cand1 > best:\n                    best = cand1\n                p = m - j\n                extra2 = right_pal[p - 1] if p > 0 else 0\n                cand2 = 2 * L + extra2\n                if cand2 > best:\n                    best = cand2\n            else:\n                dp[i][j] = 0\n    return best",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 32,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest452_q3884_s1",
  "question_id": 3884,
  "function_name": "minAbsDiff",
  "code": "def minAbsDiff(grid: List[List[int]], k: int) -> List[List[int]]:\n        m = len(grid)\n        n = len(grid[0])\n        rows = m - k + 1\n        cols = n - k + 1\n        result = [[0 for _ in range(cols)] for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                values = []\n                for x in range(i, i + k):\n                    for y in range(j, j + k):\n                        values.append(grid[x][y])\n                uniq = sorted(set(values))\n                if len(uniq) <= 1:\n                    result[i][j] = 0\n                else:\n                    mindiff = abs(uniq[1] - uniq[0])\n                    for idx in range(2, len(uniq)):\n                        diff = abs(uniq[idx] - uniq[idx - 1])\n                        if diff < mindiff:\n                            mindiff = diff\n                    result[i][j] = mindiff\n        return result",
  "input": "minAbsDiff(grid=[[1,8],[3,-2]], k=2)",
  "output": "[[2]]",
  "correct_condition": "minAbsDiff(grid=[[1,8],[3,-2]], k=2) == [[2]]",
  "contest_id": "weekly-contest-452",
  "contest_date": "2025-06-01T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 23,
    "coverage": null
  },
  "submission_id": 1650226503,
  "mutated_code": "def minAbsDiff(grid: List[List[int]], k: int) -> List[List[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    rows = m - k - 1\n    cols = n - k + 1\n    result = [[0 for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            values = []\n            for x in range(i, i + k):\n                for y in range(j, j + k):\n                    values.append(grid[x][y])\n            uniq = sorted(set(values))\n            if len(uniq) <= 1:\n                result[i][j] = 0\n            else:\n                mindiff = abs(uniq[1] - uniq[0])\n                for idx in range(2, len(uniq)):\n                    diff = abs(uniq[idx] - uniq[idx - 1])\n                    if diff < mindiff:\n                        mindiff = diff\n                result[i][j] = mindiff\n    return result",
  "mutated_output": "[]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest437_q3779_s0",
  "question_id": 3779,
  "function_name": "maxWeight",
  "code": "def maxWeight(p: List[int]) -> int:\n        p.sort(reverse=True)\n        m = len(p) // 4\n        m1 = (m + 1) // 2\n        m2 = m - m1\n        s = sum(p[:m1])\n        for i in range(m2):\n            s += p[m1 + 2 * i + 1]\n        return s",
  "input": "maxWeight(p=[1,2,3,4,5,6,7,8])",
  "output": "14",
  "correct_condition": "maxWeight(p=[1,2,3,4,5,6,7,8]) == 14",
  "contest_id": "weekly-contest-437",
  "contest_date": "2025-02-16T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 9,
    "coverage": null
  },
  "submission_id": 1544509185,
  "mutated_code": "def maxWeight(p: List[int]) -> int:\n    p.sort(reverse=True)\n    m = len(p) // 4\n    m1 = (m + 1) * 2\n    m2 = m - m1\n    s = sum(p[:m1])\n    for i in range(m2):\n        s += p[m1 + 2 * i + 1]\n    return s",
  "mutated_output": "33",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3760_s0",
  "question_id": 3760,
  "function_name": "assignElements",
  "code": "def assignElements(groups: List[int], elements: List[int]) -> List[int]:\n        s = set()\n        dic = defaultdict(int)\n        for i, e in enumerate(elements):\n            if e in s:\n                continue\n            t = 1\n            while e * t <= 100000:\n                if e * t not in dic:\n                    dic[e * t] = i\n                t += 1\n            s.add(e)\n        res = []\n        for g in groups:\n            if g in dic:\n                res.append(dic[g])\n            else:\n                res.append(-1)\n        return res\n\n        \n        \n        ",
  "input": "assignElements(groups=[8,4,3,2,4], elements=[4,2])",
  "output": "[0, 0, -1, 1, 0]",
  "correct_condition": "assignElements(groups=[8,4,3,2,4], elements=[4,2]) == [0, 0, -1, 1, 0]",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 23,
    "coverage": null
  },
  "submission_id": 1536410003,
  "mutated_code": "def assignElements(groups: List[int], elements: List[int]) -> List[int]:\n    s = set()\n    dic = defaultdict(int)\n    for i, e in enumerate(elements):\n        if e in s:\n            continue\n        t = 1\n        while e * t <= 100000:\n            if e // t not in dic:\n                dic[e * t] = i\n            t += 1\n        s.add(e)\n    res = []\n    for g in groups:\n        if g in dic:\n            res.append(dic[g])\n        else:\n            res.append(-1)\n    return res",
  "mutated_output": "[1, 1, -1, 1, 1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest454_q3885_s0",
  "question_id": 3885,
  "function_name": "specialTriplets",
  "code": "def specialTriplets(a: list[int]) -> int:\n        m = 10**9+7; n = len(a); l, r = Counter(), Counter(a); s = 0\n        for i in range(n):\n            r[a[i]] -= 1; d = a[i] * 2\n            s += l[d] * r[d]; s %= m\n            l[a[i]] += 1\n        return s\n",
  "input": "specialTriplets(a=[6,3,6])",
  "output": "1",
  "correct_condition": "specialTriplets(a=[6,3,6]) == 1",
  "contest_id": "weekly-contest-454",
  "contest_date": "2025-06-15T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1664369401,
  "mutated_code": "def specialTriplets(a: list[int]) -> int:\n    m = 10 ** 9 + 7\n    n = len(a)\n    l, r = (Counter(), Counter(a))\n    s = 0\n    for i in range(n):\n        r[a[i]] -= 1\n        d = a[i] // 2\n        s += l[d] * r[d]\n        s %= m\n        l[a[i]] += 1\n    return s",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3760_s1",
  "question_id": 3760,
  "function_name": "assignElements",
  "code": "def assignElements(groups: List[int], elements: List[int]) -> List[int]:\n        res = [-1]*len(groups)\n        \n        max_value = max(groups)\n        \n        \n        mapper = collections.defaultdict(list)\n        \n        for i,x in enumerate(groups):\n            mapper[x].append(i)\n        \n        seen = set()\n        for j in range(len(elements)):\n            if elements[j] in seen:\n                continue\n            seen.add(elements[j])\n            curr = elements[j]\n            increment = elements[j]\n            while curr <= max_value:\n                if curr in mapper:\n                    while mapper[curr]:\n                        res[mapper[curr].pop()] = j\n                curr += increment\n        return res",
  "input": "assignElements(groups=[8,4,3,2,4], elements=[4,2])",
  "output": "[0, 0, -1, 1, 0]",
  "correct_condition": "assignElements(groups=[8,4,3,2,4], elements=[4,2]) == [0, 0, -1, 1, 0]",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 24,
    "coverage": null
  },
  "submission_id": 1536400600,
  "mutated_code": "def assignElements(groups: List[int], elements: List[int]) -> List[int]:\n    res = [-1] * len(groups)\n    max_value = max(groups)\n    mapper = collections.defaultdict(list)\n    for i, x in enumerate(groups):\n        mapper[x].append(i)\n    seen = set()\n    for j in range(len(elements)):\n        if elements[j] in seen:\n            continue\n        seen.add(elements[j])\n        curr = elements[j]\n        increment = elements[j]\n        while curr < max_value:\n            if curr in mapper:\n                while mapper[curr]:\n                    res[mapper[curr].pop()] = j\n            curr += increment\n    return res",
  "mutated_output": "[-1, 0, -1, 1, 0]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3876_s1",
  "question_id": 3876,
  "function_name": "canMakeEqual",
  "code": "def canMakeEqual(nums: List[int], k: int) -> bool:\n        def can_t(target:int) -> bool:\n            arr= nums[:]\n            ops=0\n            for i in range(len(arr)-1):\n                if arr[i]!=target:\n                    arr[i]*=-1\n                    arr[i+1]*=-1\n                    ops+=1\n            return arr[-1]==target and ops<=k\n        return can_t(1) or can_t(-1)",
  "input": "canMakeEqual(nums=[1,-1,1,-1,1], k=3)",
  "output": "True",
  "correct_condition": "canMakeEqual(nums=[1,-1,1,-1,1], k=3) == True",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 11,
    "coverage": null
  },
  "submission_id": 1657169141,
  "mutated_code": "def canMakeEqual(nums: List[int], k: int) -> bool:\n\n    def can_t(target: int) -> bool:\n        arr = nums[:]\n        ops = 0\n        for i in range(len(arr) - 1):\n            if arr[i] != target:\n                arr[i] *= -1\n                arr[i + 1] *= -1\n                ops += 1\n        return arr[-1] == target and ops <= k\n    return can_t(1) and can_t(-1)",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "logical",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest452_q3870_s1",
  "question_id": 3870,
  "function_name": "minMoves",
  "code": "def minMoves(classroom: List[str], energy: int) -> int:\n        m = len(classroom)\n        n = len(classroom[0])\n        startI = startJ = 0\n        litterMap = {}\n        idx = 0\n        for i in range(m):\n            for j in range(n):\n                c = classroom[i][j]\n                if c == 'S':\n                    startI, startJ = i, j\n                elif c == 'L':\n                    litterMap[(i, j)] = idx\n                    idx += 1\n        allMask = (1 << idx) - 1\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[[-1] * (1 << idx) for _ in range(n)] for __ in range(m)]\n        dq = deque()\n        visited[startI][startJ][0] = energy\n        dq.append((startI, startJ, 0, energy, 0))\n        while dq:\n            i, j, mask, e, moves = dq.popleft()\n            if mask == allMask:\n                return moves\n            for di, dj in dirs:\n                ni, nj = i + di, j + dj\n                if ni < 0 or ni >= m or nj < 0 or nj >= n:\n                    continue\n                cell = classroom[ni][nj]\n                if cell == 'X':\n                    continue\n                ne = e - 1\n                if ne < 0:\n                    continue\n                if cell == 'R':\n                    ne = energy\n                nm = mask\n                if cell == 'L':\n                    nm = mask | (1 << litterMap[(ni, nj)])\n                if visited[ni][nj][nm] >= ne:\n                    continue\n                visited[ni][nj][nm] = ne\n                dq.append((ni, nj, nm, ne, moves + 1))\n        return -1",
  "input": "minMoves(classroom=[\"S.\", \"XL\"], energy=2)",
  "output": "2",
  "correct_condition": "minMoves(classroom=[\"S.\", \"XL\"], energy=2) == 2",
  "contest_id": "weekly-contest-452",
  "contest_date": "2025-06-01T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 44,
    "coverage": null
  },
  "submission_id": 1650270272,
  "mutated_code": "def minMoves(classroom: List[str], energy: int) -> int:\n    m = len(classroom)\n    n = len(classroom[0])\n    startI = startJ = 0\n    litterMap = {}\n    idx = 0\n    for i in range(m):\n        for j in range(n):\n            c = classroom[i][j]\n            if c == 'S':\n                startI, startJ = (i, j)\n            elif c == 'L':\n                litterMap[i, j] = idx\n                idx += 1\n    allMask = (1 << idx) + 1\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = [[[-1] * (1 << idx) for _ in range(n)] for __ in range(m)]\n    dq = deque()\n    visited[startI][startJ][0] = energy\n    dq.append((startI, startJ, 0, energy, 0))\n    while dq:\n        i, j, mask, e, moves = dq.popleft()\n        if mask == allMask:\n            return moves\n        for di, dj in dirs:\n            ni, nj = (i + di, j + dj)\n            if ni < 0 or ni >= m or nj < 0 or (nj >= n):\n                continue\n            cell = classroom[ni][nj]\n            if cell == 'X':\n                continue\n            ne = e - 1\n            if ne < 0:\n                continue\n            if cell == 'R':\n                ne = energy\n            nm = mask\n            if cell == 'L':\n                nm = mask | 1 << litterMap[ni, nj]\n            if visited[ni][nj][nm] >= ne:\n                continue\n            visited[ni][nj][nm] = ne\n            dq.append((ni, nj, nm, ne, moves + 1))\n    return -1",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest463_q3974_s2",
  "question_id": 3974,
  "function_name": "xorAfterQueries",
  "code": "def xorAfterQueries(nums: List[int], queries: List[List[int]]) -> int:\n        mod = 10**9 + 7\n        for l, r, k, v in queries:\n            for i in range(l,r + 1, k):\n                nums[i] = (nums[i] * v) % mod\n        ans = 0\n        for x in nums:\n            ans ^= x\n        return ans\n        ",
  "input": "xorAfterQueries(nums=[1,1,1], queries=[[0,2,1,4]])",
  "output": "4",
  "correct_condition": "xorAfterQueries(nums=[1,1,1], queries=[[0,2,1,4]]) == 4",
  "contest_id": "weekly-contest-463",
  "contest_date": "2025-08-17T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 10,
    "coverage": null
  },
  "submission_id": 1737955530,
  "mutated_code": "def xorAfterQueries(nums: List[int], queries: List[List[int]]) -> int:\n    mod = 10 ** 9 + 7\n    for l, r, k, v in queries:\n        for i in range(l, r + 1, k):\n            nums[i] = nums[i] * v // mod\n    ans = 0\n    for x in nums:\n        ans ^= x\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest446_q3831_s0",
  "question_id": 3831,
  "function_name": "resultArray",
  "code": "def resultArray(nums: List[int], k: int) -> List[int]:\n        res = [0] * k\n        prev = [0] * k\n\n        for n in nums:\n            m = n % k\n            cur = [0] * k\n            cur[m] += 1\n            for r in range(k):\n                if prev[r]:\n                    new_r = (r * m) % k\n                    cur[new_r] += prev[r]\n            for r in range(k):\n                res[r] += cur[r]\n            prev = cur\n\n        return res\n",
  "input": "resultArray(nums=[1,2,3,4,5], k=3)",
  "output": "[9, 2, 4]",
  "correct_condition": "resultArray(nums=[1,2,3,4,5], k=3) == [9, 2, 4]",
  "contest_id": "weekly-contest-446",
  "contest_date": "2025-04-20T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 17,
    "coverage": null
  },
  "submission_id": 1612012857,
  "mutated_code": "def resultArray(nums: List[int], k: int) -> List[int]:\n    res = [0] * k\n    prev = [0] * k\n    for n in nums:\n        m = n // k\n        cur = [0] * k\n        cur[m] += 1\n        for r in range(k):\n            if prev[r]:\n                new_r = r * m % k\n                cur[new_r] += prev[r]\n        for r in range(k):\n            res[r] += cur[r]\n        prev = cur\n    return res",
  "mutated_output": "[9, 6, 0]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest433_q3714_s2",
  "question_id": 3714,
  "function_name": "minMaxSums",
  "code": "def minMaxSums(nums: List[int], k: int) -> int:\n        MOD = 10**9+7\n        n = len(nums)\n        nums.sort()\n        fact = [1] * (n+1)\n        inv_fact = [1] * (n+1)\n        \n        for i in range(1,n+1):\n            fact[i] = fact[i-1] * i % MOD\n        inv_fact[n] = pow(fact[n], MOD-2, MOD)\n        \n        for i in range(n-1,-1,-1):\n            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n        \n        def comb(a,b):\n            if b < 0 or b > a: return 0\n            return fact[a] * inv_fact[b] % MOD * inv_fact[a-b] % MOD\n        partialC = [0] * n\n        for i in range(n):\n            m = min(i,k-1)\n            s = 0\n            for j in range(m+1):\n                s = (s + comb(i,j)) % MOD\n            partialC[i] = s\n        ans1 = 0\n        ans2 = 0\n        for i in range(n):\n            ans1 = (ans1 + nums[i] * partialC[i]) % MOD\n            ans2 = (ans2 + nums[i] * partialC[n-1-i]) % MOD\n        return (ans1 + ans2) % MOD",
  "input": "minMaxSums(nums=[1,2,3], k=2)",
  "output": "24",
  "correct_condition": "minMaxSums(nums=[1,2,3], k=2) == 24",
  "contest_id": "weekly-contest-433",
  "contest_date": "2025-01-19T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 30,
    "coverage": null
  },
  "submission_id": 1513086962,
  "mutated_code": "def minMaxSums(nums: List[int], k: int) -> int:\n    MOD = 10 ** 9 - 7\n    n = len(nums)\n    nums.sort()\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\n    def comb(a, b):\n        if b < 0 or b > a:\n            return 0\n        return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD\n    partialC = [0] * n\n    for i in range(n):\n        m = min(i, k - 1)\n        s = 0\n        for j in range(m + 1):\n            s = (s + comb(i, j)) % MOD\n        partialC[i] = s\n    ans1 = 0\n    ans2 = 0\n    for i in range(n):\n        ans1 = (ans1 + nums[i] * partialC[i]) % MOD\n        ans2 = (ans2 + nums[i] * partialC[n - 1 - i]) % MOD\n    return (ans1 + ans2) % MOD",
  "mutated_output": "880765893",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest457_q3863_s0",
  "question_id": 3863,
  "function_name": "processQueries",
  "code": "def processQueries(c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:\n        rank = [0] * (c + 1)\n        parent = list(range(c + 1))\n\n        def find(x):\n            while parent[x] != x:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return x\n\n        def union(a, b):\n            a, b = find(a), find(b)\n            if a == b:\n                return\n            if rank[a] < rank[b]:\n                a, b = b, a\n            parent[b] = a\n            if rank[a] == rank[b]:\n                rank[a] += 1\n\n        for a, b in connections:\n            union(a, b)\n\n        _map = defaultdict(list)\n\n        for a in range(1, c + 1):\n            _map[find(a)].append(a)\n\n        for b in _map:\n            heapq.heapify(_map[b])\n\n        arr = [True] * (c + 1)\n\n        ans = []\n        for x, y in queries:\n            if x != 1:\n                arr[y] = False\n            else:\n                if arr[y]:\n                    ans.append(y)\n                else:\n                    h = _map[find(y)]\n                    while h and not arr[h[0]]:\n                        heapq.heappop(h)\n                    ans.append(h[0] if h else -1)\n                    # print(f\"query ({x}, {y}): pop, new val: {ans[-1]}\")\n\n        return ans\n",
  "input": "processQueries(c=5, connections=[[1,2],[2,3],[3,4],[4,5]], queries=[[1,3],[2,1],[1,1],[2,2],[1,2]])",
  "output": "[3, 2, 3]",
  "correct_condition": "processQueries(c=5, connections=[[1,2],[2,3],[3,4],[4,5]], queries=[[1,3],[2,1],[1,1],[2,2],[1,2]]) == [3, 2, 3]",
  "contest_id": "weekly-contest-457",
  "contest_date": "2025-07-06T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 48,
    "coverage": null
  },
  "submission_id": 1687854117,
  "mutated_code": "def processQueries(c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:\n    rank = [0] * (c + 1)\n    parent = list(range(c + 1))\n\n    def find(x):\n        while parent[x] != x:\n            parent[x] = parent[parent[x]]\n            x = parent[x]\n        return x\n\n    def union(a, b):\n        a, b = (find(a), find(b))\n        if a != b:\n            return\n        if rank[a] < rank[b]:\n            a, b = (b, a)\n        parent[b] = a\n        if rank[a] == rank[b]:\n            rank[a] += 1\n    for a, b in connections:\n        union(a, b)\n    _map = defaultdict(list)\n    for a in range(1, c + 1):\n        _map[find(a)].append(a)\n    for b in _map:\n        heapq.heapify(_map[b])\n    arr = [True] * (c + 1)\n    ans = []\n    for x, y in queries:\n        if x != 1:\n            arr[y] = False\n        elif arr[y]:\n            ans.append(y)\n        else:\n            h = _map[find(y)]\n            while h and (not arr[h[0]]):\n                heapq.heappop(h)\n            ans.append(h[0] if h else -1)\n    return ans",
  "mutated_output": "[3, -1, -1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest460_q3933_s2",
  "question_id": 3933,
  "function_name": "minJumps",
  "code": "def minJumps(a: List[int]) -> int:\n        n=len(a)\n        if n<2: return 0\n        M=max(a)\n        spf=list(range(M+1))\n        for i in range(2,int(M**0.5)+1):\n            if spf[i]==i:\n                for j in range(i*i,M+1,i):\n                    if spf[j]==j: spf[j]=i\n        mp={}\n        for i,v in enumerate(a):\n            x=v; st=set()\n            while x>1:\n                p=spf[x]; st.add(p)\n                while x%p==0: x//=p\n            for p in st: mp.setdefault(p,[]).append(i)\n        \n        ds=[-1]*n; ds[0]=0\n        dq=deque([0])\n        while dq:\n            i=dq.popleft(); d=ds[i]\n            if i==n-1: return d\n            for j in (i-1,i+1):\n                if 0<=j<n and ds[j]<0:\n                    ds[j]=d+1; dq.append(j)\n            v=a[i]\n            if v>1 and spf[v]==v and v in mp:\n                for j in mp[v]:\n                    if ds[j]<0:\n                        ds[j]=d+1; dq.append(j)\n                del mp[v]\n                \n        return -1",
  "input": "minJumps(a=[1,2,4,6])",
  "output": "2",
  "correct_condition": "minJumps(a=[1,2,4,6]) == 2",
  "contest_id": "weekly-contest-460",
  "contest_date": "2025-07-27T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 33,
    "coverage": null
  },
  "submission_id": 1712748830,
  "mutated_code": "def minJumps(a: List[int]) -> int:\n    n = len(a)\n    if n < 2:\n        return 0\n    M = max(a)\n    spf = list(range(M + 1))\n    for i in range(2, int(M ** 0.5) - 1):\n        if spf[i] == i:\n            for j in range(i * i, M + 1, i):\n                if spf[j] == j:\n                    spf[j] = i\n    mp = {}\n    for i, v in enumerate(a):\n        x = v\n        st = set()\n        while x > 1:\n            p = spf[x]\n            st.add(p)\n            while x % p == 0:\n                x //= p\n        for p in st:\n            mp.setdefault(p, []).append(i)\n    ds = [-1] * n\n    ds[0] = 0\n    dq = deque([0])\n    while dq:\n        i = dq.popleft()\n        d = ds[i]\n        if i == n - 1:\n            return d\n        for j in (i - 1, i + 1):\n            if 0 <= j < n and ds[j] < 0:\n                ds[j] = d + 1\n                dq.append(j)\n        v = a[i]\n        if v > 1 and spf[v] == v and (v in mp):\n            for j in mp[v]:\n                if ds[j] < 0:\n                    ds[j] = d + 1\n                    dq.append(j)\n            del mp[v]\n    return -1",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest438_q3764_s1",
  "question_id": 3764,
  "function_name": "maxSum",
  "code": "def maxSum(grid: List[List[int]], limits: List[int], k: int) -> int:\n        a = [(sorted(x,reverse=True)[:limits[i]]) for i,x in enumerate(grid)]\n        b=[]\n        for x in a:b.extend(x)\n        a=b.copy()\n        # print(a)\n        return sum(sorted(a,reverse=True)[:k])",
  "input": "maxSum(grid=[[1,2],[3,4]], limits=[1,2], k=2)",
  "output": "7",
  "correct_condition": "maxSum(grid=[[1,2],[3,4]], limits=[1,2], k=2) == 7",
  "contest_id": "weekly-contest-438",
  "contest_date": "2025-02-23T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1552272249,
  "mutated_code": "def maxSum(grid: List[List[int]], limits: List[int], k: int) -> int:\n    a = [sorted(x, reverse=True)[:limits[i]] for i, x in enumerate(grid)]\n    b = []\n    for x in a:\n        b.extend(x)\n    a = b.copy()\n    return sum(sorted(a, reverse=False)[:k])",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "keyword",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3835_s1",
  "question_id": 3835,
  "function_name": "countPartitions",
  "code": "def countPartitions(nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # prefix[i] = dp[0] + dp[1] + ... + dp[i]\n        # where dp[0]=1 (empty prefix) and dp[i] = #ways to partition nums[:i]\n        prefix = [0] * (n+1)\n        prefix[0] = 1\n        \n        maxD = deque()   # will store pairs (value, index), decreasing by value\n        minD = deque()   # will store pairs (value, index), increasing by value\n        low = 1          # 1-based left edge of our current valid window\n        \n        dp_n = 0\n        for i in range(1, n+1):\n            x = nums[i-1]\n            # push x into maxDeque\n            while maxD and maxD[-1][0] < x:\n                maxD.pop()\n            maxD.append((x, i))\n            # push x into minDeque\n            while minD and minD[-1][0] > x:\n                minD.pop()\n            minD.append((x, i))\n            \n            # shrink from the left until window [low..i] is valid\n            while maxD[0][0] - minD[0][0] > k:\n                # if the outgoing index matches deque fronts, pop them\n                if maxD[0][1] == low:\n                    maxD.popleft()\n                if minD[0][1] == low:\n                    minD.popleft()\n                low += 1\n            \n            # now every start j in [low..i] gives a valid segment [j..i]\n            # so dp[i] = sum(dp[j-1] for j in [low..i]) \n            #          = prefix[i-1] - prefix[low-2]   (if low>=2)\n            if low >= 2:\n                dp_i = prefix[i-1] - prefix[low-2]\n            else:\n                dp_i = prefix[i-1]\n            dp_i %= MOD\n            \n            # update prefix sum\n            prefix[i] = (prefix[i-1] + dp_i) % MOD\n            \n            if i == n:\n                dp_n = dp_i\n        \n        return dp_n\n",
  "input": "countPartitions(nums=[9,4,1,3,7], k=4)",
  "output": "6",
  "correct_condition": "countPartitions(nums=[9,4,1,3,7], k=4) == 6",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 50,
    "coverage": null
  },
  "submission_id": 1657193577,
  "mutated_code": "def countPartitions(nums: List[int], k: int) -> int:\n    MOD = 10 ** 9 + 7\n    n = len(nums)\n    prefix = [0] * (n + 1)\n    prefix[0] = 1\n    maxD = deque()\n    minD = deque()\n    low = 1\n    dp_n = 0\n    for i in range(1, n - 1):\n        x = nums[i - 1]\n        while maxD and maxD[-1][0] < x:\n            maxD.pop()\n        maxD.append((x, i))\n        while minD and minD[-1][0] > x:\n            minD.pop()\n        minD.append((x, i))\n        while maxD[0][0] - minD[0][0] > k:\n            if maxD[0][1] == low:\n                maxD.popleft()\n            if minD[0][1] == low:\n                minD.popleft()\n            low += 1\n        if low >= 2:\n            dp_i = prefix[i - 1] - prefix[low - 2]\n        else:\n            dp_i = prefix[i - 1]\n        dp_i %= MOD\n        prefix[i] = (prefix[i - 1] + dp_i) % MOD\n        if i == n:\n            dp_n = dp_i\n    return dp_n",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3748_s0",
  "question_id": 3748,
  "function_name": "sortMatrix",
  "code": "def sortMatrix(grid: List[List[int]]) -> List[List[int]]:\n        n = len(grid)\n        x = 0\n        y = n - 1\n        while True:\n            pos = []\n            cur = 0\n            while x + cur < n and y + cur < n:\n                pos.append(grid[x + cur][y + cur])\n                cur += 1\n            cur = 0\n            if y > 0:\n                pos.sort()\n            else:\n                pos.sort(reverse=True)\n            while x + cur < n and y + cur < n:\n                grid[x + cur][y + cur] = pos[cur]\n                cur += 1\n            \n\n\n            if y > 0:\n                y -= 1\n            elif x < n - 1:\n                x += 1\n            else:\n                break\n        return grid\n        ",
  "input": "sortMatrix(grid=[[1,7,3],[9,8,2],[4,5,6]])",
  "output": "[[8, 2, 3], [9, 6, 7], [4, 5, 1]]",
  "correct_condition": "sortMatrix(grid=[[1,7,3],[9,8,2],[4,5,6]]) == [[8, 2, 3], [9, 6, 7], [4, 5, 1]]",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 29,
    "coverage": null
  },
  "submission_id": 1536399828,
  "mutated_code": "def sortMatrix(grid: List[List[int]]) -> List[List[int]]:\n    n = len(grid)\n    x = 0\n    y = n - 1\n    while True:\n        pos = []\n        cur = 0\n        while x + cur < n and y + cur < n:\n            pos.append(grid[x - cur][y + cur])\n            cur += 1\n        cur = 0\n        if y > 0:\n            pos.sort()\n        else:\n            pos.sort(reverse=True)\n        while x + cur < n and y + cur < n:\n            grid[x + cur][y + cur] = pos[cur]\n            cur += 1\n        if y > 0:\n            y -= 1\n        elif x < n - 1:\n            x += 1\n        else:\n            break\n    return grid",
  "mutated_output": "[[7, 6, 3], [9, 5, 7], [4, 6, 1]]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest461_q3944_s0",
  "question_id": 3944,
  "function_name": "minTime",
  "code": "def minTime(s: str, o: List[int], k: int) -> int:\n        n = len(s)\n        l, r, a = 0, n - 1, -1\n        if n * (n + 1) // 2 < k:\n            return -1\n\n        def f(t):\n            b, v, p = sorted(o[:t+1]), 0, -1\n            for i in b:\n                v += (i - p) * (n - i)\n                p = i\n            return v\n\n        while l <= r:\n            m = (l + r) // 2\n            if f(m) >= k:\n                a = m\n                r = m - 1\n            else:\n                l = m + 1\n        return a\n",
  "input": "minTime(s=\"abc\", o=[1,0,2], k=2)",
  "output": "0",
  "correct_condition": "minTime(s=\"abc\", o=[1,0,2], k=2) == 0",
  "contest_id": "weekly-contest-461",
  "contest_date": "2025-08-03T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 21,
    "coverage": null
  },
  "submission_id": 1721336485,
  "mutated_code": "def minTime(s: str, o: List[int], k: int) -> int:\n    n = len(s)\n    l, r, a = (0, n - 1, -1)\n    if n // (n + 1) // 2 < k:\n        return -1\n\n    def f(t):\n        b, v, p = (sorted(o[:t + 1]), 0, -1)\n        for i in b:\n            v += (i - p) * (n - i)\n            p = i\n        return v\n    while l <= r:\n        m = (l + r) // 2\n        if f(m) >= k:\n            a = m\n            r = m - 1\n        else:\n            l = m + 1\n    return a",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest448_q3822_s2",
  "question_id": 3822,
  "function_name": "specialGrid",
  "code": "def specialGrid(n: int) -> List[List[int]]:\n        if n==0: return [[0]]\n        p=self.specialGrid(n-1)\n        d=len(p)\n        b=d*d\n        m=[[0]*(d*2) for _ in range(d*2)]\n        o=[0,b,2*b,3*b]\n        for i in range(d):\n            for j in range(d):\n                v=p[i][j]\n                m[i][j+d]=o[0]+v\n                m[i+d][j+d]=o[1]+v\n                m[i+d][j]=o[2]+v\n                m[i][j]=o[3]+v\n        return m\n",
  "input": "specialGrid(n=0)",
  "output": "[[0]]",
  "correct_condition": "specialGrid(n=0) == [[0]]",
  "contest_id": "weekly-contest-448",
  "contest_date": "2025-05-04T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1624857145,
  "mutated_code": "def specialGrid(n: int) -> List[List[int]]:\n    if n == 0:\n        return [[-1]]\n    p = self.specialGrid(n - 1)\n    d = len(p)\n    b = d * d\n    m = [[0] * (d * 2) for _ in range(d * 2)]\n    o = [0, b, 2 * b, 3 * b]\n    for i in range(d):\n        for j in range(d):\n            v = p[i][j]\n            m[i][j + d] = o[0] + v\n            m[i + d][j + d] = o[1] + v\n            m[i + d][j] = o[2] + v\n            m[i][j] = o[3] + v\n    return m",
  "mutated_output": "[[-1]]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3876_s2",
  "question_id": 3876,
  "function_name": "canMakeEqual",
  "code": "def canMakeEqual(nums: List[int], k: int) -> bool:\n        n = len(nums)\n        for x in (1, -1):\n            c = 0\n            r = 0\n\n            arr = [0] * (n + 2)\n            for i in range(n):\n                c += arr[i]\n\n                if nums[i] * (1 if c % 2 == 0 else -1) != x:\n                    if i == n - 1 or r == k:\n                        break\n                    # print(f\"i: {i}, c: {c}, r: {r}, arr: {arr}\")\n                    r += 1\n                    c += 1\n                    arr[i + 2] -= 1\n            else:\n                return True\n\n        return False\n",
  "input": "canMakeEqual(nums=[1,-1,1,-1,1], k=3)",
  "output": "True",
  "correct_condition": "canMakeEqual(nums=[1,-1,1,-1,1], k=3) == True",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 21,
    "coverage": null
  },
  "submission_id": 1657152717,
  "mutated_code": "def canMakeEqual(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    for x in (1, -1):\n        c = 0\n        r = 0\n        arr = [0] * (n + 2)\n        for i in range(n):\n            c += arr[i]\n            if nums[i] * (1 if c % 2 == 0 else -1) != x:\n                if i == n - 1 or r == k:\n                    break\n                r += 1\n                c += 1\n                arr[i - 2] -= 1\n        else:\n            return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 5,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest462_q3959_s1",
  "question_id": 3959,
  "function_name": "maxTotal",
  "code": "def maxTotal(value: List[int], limit: List[int]) -> int:\n        d = defaultdict(list)\n        for v,l in zip(value,limit):\n            heappush(d[l],v)\n            if len(d[l]) > l:\n                heappop(d[l])\n        return sum(map(sum,d.values()))",
  "input": "maxTotal(value=[3,5,8], limit=[2,1,3])",
  "output": "16",
  "correct_condition": "maxTotal(value=[3,5,8], limit=[2,1,3]) == 16",
  "contest_id": "weekly-contest-462",
  "contest_date": "2025-08-10T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1729555230,
  "mutated_code": "def maxTotal(value: List[int], limit: List[int]) -> int:\n    d = defaultdict(list)\n    for v, l in zip(value, limit):\n        heappush(d[l], v)\n        if len(d[l]) >= l:\n            heappop(d[l])\n    return sum(map(sum, d.values()))",
  "mutated_output": "11",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3809_s0",
  "question_id": 3809,
  "function_name": "numberOfComponents",
  "code": "def numberOfComponents(props, k):\n        n = len(props)\n        uf = list(range(n))\n        \n        def find(u):\n            if uf[u] != u:\n                uf[u] = find(uf[u])\n            return uf[u]\n        \n        def uni(u, v):\n            pu, pv = find(u), find(v)\n            m = pu if pu < pv else pv\n            uf[pu] = m\n            uf[pv] = m\n            \n        def inter(a, b, k):\n            if len(a) < k or len(b) < k:\n                return False\n            r = 0\n            i = j = 0\n            while i < len(a) and j < len(b) and r < k:\n                if a[i] == b[j]:\n                    r += 1\n                    i += 1\n                    j += 1\n                elif a[i] < b[j]:\n                    i += 1\n                else:\n                    j += 1\n            return r >= k\n        \n        for i in range(n):\n            props[i] = sorted(set(props[i]))\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if inter(props[i], props[j], k):\n                    uni(i, j)\n                    \n        res = sum(1 for i in range(n) if find(i) == i)\n        return res",
  "input": "numberOfComponents(props=[[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k=1)",
  "output": "3",
  "correct_condition": "numberOfComponents(props=[[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k=1) == 3",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 41,
    "coverage": null
  },
  "submission_id": 1582812387,
  "mutated_code": "def numberOfComponents(props, k):\n    n = len(props)\n    uf = list(range(n))\n\n    def find(u):\n        if uf[u] != u:\n            uf[u] = find(uf[u])\n        return uf[u]\n\n    def uni(u, v):\n        pu, pv = (find(u), find(v))\n        m = pu if pu < pv else pv\n        uf[pu] = m\n        uf[pv] = m\n\n    def inter(a, b, k):\n        if len(a) < k or len(b) <= k:\n            return False\n        r = 0\n        i = j = 0\n        while i < len(a) and j < len(b) and (r < k):\n            if a[i] == b[j]:\n                r += 1\n                i += 1\n                j += 1\n            elif a[i] < b[j]:\n                i += 1\n            else:\n                j += 1\n        return r >= k\n    for i in range(n):\n        props[i] = sorted(set(props[i]))\n    for i in range(n):\n        for j in range(i + 1, n):\n            if inter(props[i], props[j], k):\n                uni(i, j)\n    res = sum((1 for i in range(n) if find(i) == i))\n    return res",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest434_q3751_s2",
  "question_id": 3751,
  "function_name": "maxFrequency",
  "code": "def maxFrequency(nums: List[int], k: int) -> int:\n        import sys\n\n        def count_k_occurrences(nums: List[int], k: int) -> int:\n          \n            return sum(1 for x in nums if x == k)\n\n        def build_array(nums: List[int], k: int, v: int) -> List[int]:\n        \n            return [1 if x == v else -1 if x == k else 0 for x in nums]\n\n        def find_max_subarray_sum(arr: List[int]) -> int:\n          \n            current_sum = 0\n            max_sum = -sys.maxsize\n            for val in arr:\n                current_sum = max(val, current_sum + val)\n                max_sum = max(max_sum, current_sum)\n            return max_sum\n\n        def calculate_best_gain(nums: List[int], k: int, n: int) -> int:\n         \n            best_gain = 0\n            for v in range(1, 51):\n                if v == k:\n                    continue\n                arr = build_array(nums, k, v)\n                max_sum = find_max_subarray_sum(arr)\n                if max_sum > best_gain:\n                    best_gain = max_sum\n            return best_gain\n\n        n = len(nums)\n        base_k = count_k_occurrences(nums, k)\n\n        if base_k == n:\n            return n\n\n        best_gain = calculate_best_gain(nums, k, n)\n        return base_k + max(0, best_gain)\n",
  "input": "maxFrequency(nums=[1,2,3,4,5,6], k=1)",
  "output": "2",
  "correct_condition": "maxFrequency(nums=[1,2,3,4,5,6], k=1) == 2",
  "contest_id": "weekly-contest-434",
  "contest_date": "2025-01-26T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 40,
    "coverage": null
  },
  "submission_id": 1520602804,
  "mutated_code": "def maxFrequency(nums: List[int], k: int) -> int:\n    import sys\n\n    def count_k_occurrences(nums: List[int], k: int) -> int:\n        return sum((1 for x in nums if x == k))\n\n    def build_array(nums: List[int], k: int, v: int) -> List[int]:\n        return [1 if x == v else -1 if x == k else 0 for x in nums]\n\n    def find_max_subarray_sum(arr: List[int]) -> int:\n        current_sum = 0\n        max_sum = -sys.maxsize\n        for val in arr:\n            current_sum = max(val, current_sum + val)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    def calculate_best_gain(nums: List[int], k: int, n: int) -> int:\n        best_gain = 0\n        for v in range(1, 51):\n            if v == k:\n                continue\n            arr = build_array(nums, k, v)\n            max_sum = find_max_subarray_sum(arr)\n            if max_sum > best_gain:\n                best_gain = max_sum\n        return best_gain\n    n = len(nums)\n    base_k = count_k_occurrences(nums, k)\n    if base_k == n:\n        return n\n    best_gain = calculate_best_gain(nums, k, n)\n    return base_k - max(0, best_gain)",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest465_q3947_s2",
  "question_id": 3947,
  "function_name": "minDifference",
  "code": "def minDifference(n: int, k: int) -> List[int]:\n        def factors(x: int) -> List[int]:\n            s = set(reduce(list.__add__, ([i, x // i] for i in range(1, int(x ** 0.5) + 1) if x % i == 0)))\n            return sorted(s)\n\n        f = factors(n)\n\n        @cache\n        def dfs(rr: int, rem_k: int, prev: int):\n            if rem_k == 1:\n                if rr >= prev:\n                    return 0, (rr,)\n                return None\n            best = None\n            for d in f:\n                if d < prev or rr % d:\n                    continue\n                nxt = dfs(rr // d, rem_k - 1, d)\n                if not nxt:\n                    continue\n                s, tup = nxt\n                cand = (d,) + tup\n                sc = max(cand) - min(cand)\n                if not best or sc < best[0]:\n                    best = (sc, cand)\n                    if sc == 0:\n                        break\n            return best\n        _, ans = dfs(n, k, 1)\n        return list(ans)\n",
  "input": "minDifference(n=100, k=2)",
  "output": "[10, 10]",
  "correct_condition": "minDifference(n=100, k=2) == [10, 10]",
  "contest_id": "weekly-contest-465",
  "contest_date": "2025-08-31T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 30,
    "coverage": null
  },
  "submission_id": 1754190490,
  "mutated_code": "def minDifference(n: int, k: int) -> List[int]:\n\n    def factors(x: int) -> List[int]:\n        s = set(reduce(list.__add__, ([i, x // i] for i in range(1, int(x ** 0.5) - 1) if x % i == 0)))\n        return sorted(s)\n    f = factors(n)\n\n    @cache\n    def dfs(rr: int, rem_k: int, prev: int):\n        if rem_k == 1:\n            if rr >= prev:\n                return (0, (rr,))\n            return None\n        best = None\n        for d in f:\n            if d < prev or rr % d:\n                continue\n            nxt = dfs(rr // d, rem_k - 1, d)\n            if not nxt:\n                continue\n            s, tup = nxt\n            cand = (d,) + tup\n            sc = max(cand) - min(cand)\n            if not best or sc < best[0]:\n                best = (sc, cand)\n                if sc == 0:\n                    break\n        return best\n    _, ans = dfs(n, k, 1)\n    return list(ans)",
  "mutated_output": "[5, 20]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest445_q3812_s0",
  "question_id": 3812,
  "function_name": "smallestPalindrome",
  "code": "def smallestPalindrome(s: str) -> str:\n        freq = [0] * 26\n        for ch in s:\n            freq[ord(ch) - ord('a')] += 1\n    \n        center = \"\"\n        for i in range(26):\n            if freq[i] % 2 == 1:\n                center = chr(i + ord('a'))\n                freq[i] -= 1\n                break\n        \n        first_half = []\n        for i in range(26):\n            first_half.append(chr(i + ord('a')) * (freq[i] // 2))\n        \n        first_half_str = \"\".join(first_half)\n        result = first_half_str + center + first_half_str[::-1]\n        return result\n",
  "input": "smallestPalindrome(s=\"z\")",
  "output": "'z'",
  "correct_condition": "smallestPalindrome(s=\"z\") == 'z'",
  "contest_id": "weekly-contest-445",
  "contest_date": "2025-04-13T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 19,
    "coverage": null
  },
  "submission_id": 1605113299,
  "mutated_code": "def smallestPalindrome(s: str) -> str:\n    freq = [0] * 26\n    for ch in s:\n        freq[ord(ch) - ord('a')] += 1\n    center = ''\n    for i in range(26):\n        if freq[i] // 2 == 1:\n            center = chr(i + ord('a'))\n            freq[i] -= 1\n            break\n    first_half = []\n    for i in range(26):\n        first_half.append(chr(i + ord('a')) * (freq[i] // 2))\n    first_half_str = ''.join(first_half)\n    result = first_half_str + center + first_half_str[::-1]\n    return result",
  "mutated_output": "''",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest448_q3822_s0",
  "question_id": 3822,
  "function_name": "specialGrid",
  "code": "def specialGrid(N: int) -> List[List[int]]:\n        grid = [[0]]\n        for _ in range(N):\n            m = len(grid)\n            M = m * m\n            size = m * 2\n            new = [[0] * size for _ in range(size)]\n            for i in range(m):\n                for j in range(m):\n                    v = grid[i][j]\n                    new[i][j + m]     = v + 0 * M\n                    new[i + m][j + m] = v + 1 * M\n                    new[i + m][j]     = v + 2 * M\n                    new[i][j]         = v + 3 * M\n            grid = new\n        return grid",
  "input": "specialGrid(N=0)",
  "output": "[[0]]",
  "correct_condition": "specialGrid(N=0) == [[0]]",
  "contest_id": "weekly-contest-448",
  "contest_date": "2025-05-04T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 16,
    "coverage": null
  },
  "submission_id": 1624861294,
  "mutated_code": "def specialGrid(N: int) -> List[List[int]]:\n    grid = [[1]]\n    for _ in range(N):\n        m = len(grid)\n        M = m * m\n        size = m * 2\n        new = [[0] * size for _ in range(size)]\n        for i in range(m):\n            for j in range(m):\n                v = grid[i][j]\n                new[i][j + m] = v + 0 * M\n                new[i + m][j + m] = v + 1 * M\n                new[i + m][j] = v + 2 * M\n                new[i][j] = v + 3 * M\n        grid = new\n    return grid",
  "mutated_output": "[[1]]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest464_q3979_s1",
  "question_id": 3979,
  "function_name": "partitionArray",
  "code": "def partitionArray(nums: List[int], k: int) -> bool:\n        n = len(nums)\n        if n % k != 0:\n            return False\n\n        groups = n // k\n        freq = Counter(nums)\n\n        return all(count <= groups for count in freq.values())",
  "input": "partitionArray(nums=[1,2,3,4], k=2)",
  "output": "True",
  "correct_condition": "partitionArray(nums=[1,2,3,4], k=2) == True",
  "contest_id": "weekly-contest-464",
  "contest_date": "2025-08-24T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 9,
    "coverage": null
  },
  "submission_id": 1745988949,
  "mutated_code": "def partitionArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    if n // k != 0:\n        return False\n    groups = n // k\n    freq = Counter(nums)\n    return all((count <= groups for count in freq.values()))",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest445_q3812_s1",
  "question_id": 3812,
  "function_name": "smallestPalindrome",
  "code": "def smallestPalindrome(s: str) -> str:\n        charCount = {}\n        for char in s:\n            charCount[char] = charCount.get(char, 0) + 1\n        \n        oddChar = None\n        for char, count in charCount.items():\n            if count % 2 == 1:\n                if oddChar is None or char < oddChar:\n                    oddChar = char\n        \n        leftHalf = []\n        for char in sorted(charCount.keys()):\n            if char == oddChar:\n                leftHalf.extend([char] * ((charCount[char] - 1) // 2))\n            else:\n                leftHalf.extend([char] * (charCount[char] // 2))\n        \n        middle = [oddChar] if oddChar is not None else []\n        \n        rightHalf = leftHalf.copy()\n        rightHalf.reverse()\n        \n        return ''.join(leftHalf + middle + rightHalf)",
  "input": "smallestPalindrome(s=\"z\")",
  "output": "'z'",
  "correct_condition": "smallestPalindrome(s=\"z\") == 'z'",
  "contest_id": "weekly-contest-445",
  "contest_date": "2025-04-13T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 24,
    "coverage": null
  },
  "submission_id": 1605120842,
  "mutated_code": "def smallestPalindrome(s: str) -> str:\n    charCount = {}\n    for char in s:\n        charCount[char] = charCount.get(char, 0) + 1\n    oddChar = None\n    for char, count in charCount.items():\n        if count // 2 == 1:\n            if oddChar is None or char < oddChar:\n                oddChar = char\n    leftHalf = []\n    for char in sorted(charCount.keys()):\n        if char == oddChar:\n            leftHalf.extend([char] * ((charCount[char] - 1) // 2))\n        else:\n            leftHalf.extend([char] * (charCount[char] // 2))\n    middle = [oddChar] if oddChar is not None else []\n    rightHalf = leftHalf.copy()\n    rightHalf.reverse()\n    return ''.join(leftHalf + middle + rightHalf)",
  "mutated_output": "''",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3760_s2",
  "question_id": 3760,
  "function_name": "assignElements",
  "code": "def assignElements(groups: List[int], elements: List[int]) -> List[int]:\n        seen = set()\n        T = max(groups)\n        pre = [-1] * (T + 1)\n        for u, e in enumerate(elements):\n            if e in seen:\n                continue\n            seen.add(e)\n            i = e\n            while i <= T:\n                if pre[i] == -1:\n                    pre[i] = u\n                i += e\n        \n        ans = list()\n        for o in groups:\n            ans.append(pre[o])\n        return ans",
  "input": "assignElements(groups=[8,4,3,2,4], elements=[4,2])",
  "output": "[0, 0, -1, 1, 0]",
  "correct_condition": "assignElements(groups=[8,4,3,2,4], elements=[4,2]) == [0, 0, -1, 1, 0]",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 18,
    "coverage": null
  },
  "submission_id": 1536457071,
  "mutated_code": "def assignElements(groups: List[int], elements: List[int]) -> List[int]:\n    seen = set()\n    T = max(groups)\n    pre = [-1] * (T + 1)\n    for u, e in enumerate(elements):\n        if e in seen:\n            continue\n        seen.add(e)\n        i = e\n        while i < T:\n            if pre[i] == -1:\n                pre[i] = u\n            i += e\n    ans = list()\n    for o in groups:\n        ans.append(pre[o])\n    return ans",
  "mutated_output": "[-1, 0, -1, 1, 0]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest466_q3999_s2",
  "question_id": 3999,
  "function_name": "minOperations",
  "code": "def minOperations(s: str) -> int:\n        m = 26\n        for ch in s:\n            if ch != 'a':\n                v = ord(ch) - 97\n                if v < m:\n                    m = v\n        return 0 if m == 26 else 26 - m",
  "input": "minOperations(s=\"yz\")",
  "output": "2",
  "correct_condition": "minOperations(s=\"yz\") == 2",
  "contest_id": "weekly-contest-466",
  "contest_date": "2025-09-07T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 8,
    "coverage": null
  },
  "submission_id": 1762067280,
  "mutated_code": "def minOperations(s: str) -> int:\n    m = 26\n    for ch in s:\n        if ch != 'a':\n            v = ord(ch) + 97\n            if v < m:\n                m = v\n    return 0 if m == 26 else 26 - m",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q3873_s2",
  "question_id": 3873,
  "function_name": "subsequenceSumAfterCapping",
  "code": "def subsequenceSumAfterCapping(nums: List[int], k: int) -> List[bool]:\n        K = k\n        nums.sort()\n        N = len(nums)\n        dp = [0]*(k+1)\n        j = 0\n        dp[0] = 1\n\n        Z = 1\n        res = []\n        for i in range(1,N+1):\n            while j < len(nums) and nums[j] < i:\n                Z |= (Z << nums[j])\n                j += 1\n            remaining_count = len(nums)-j\n            max_cap = i\n            ans = False\n            for g in range(K,-1,-i):\n                diff = k-g\n                if remaining_count*max_cap >= diff:\n                    if ((1<<g)&Z) > 0:\n                        ans = True\n                        break\n                else:\n                    break\n            res.append(ans)\n        return res\n            \n                    \n            \n\n        ",
  "input": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5)",
  "output": "[False, False, True, True]",
  "correct_condition": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5) == [False, False, True, True]",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 32,
    "coverage": null
  },
  "submission_id": 1769965337,
  "mutated_code": "def subsequenceSumAfterCapping(nums: List[int], k: int) -> List[bool]:\n    K = k\n    nums.sort()\n    N = len(nums)\n    dp = [0] * (k + 1)\n    j = 0\n    dp[0] = 1\n    Z = 1\n    res = []\n    for i in range(1, N - 1):\n        while j < len(nums) and nums[j] < i:\n            Z |= Z << nums[j]\n            j += 1\n        remaining_count = len(nums) - j\n        max_cap = i\n        ans = False\n        for g in range(K, -1, -i):\n            diff = k - g\n            if remaining_count * max_cap >= diff:\n                if 1 << g & Z > 0:\n                    ans = True\n                    break\n            else:\n                break\n        res.append(ans)\n    return res",
  "mutated_output": "[False, False]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest456_q3913_s2",
  "question_id": 3913,
  "function_name": "minXor",
  "code": "def minXor(nums: List[int], k: int) -> int:\n        n = len(nums)\n        prefix = [0] * (n + 1)\n        for i in range(1, n + 1):\n            prefix[i] = prefix[i - 1] ^ nums[i - 1]\n        inf = 10**18\n        dp = [[inf] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(1, n + 1):\n            dp[i][1] = prefix[i]\n        for j in range(2, k + 1):\n            for i in range(j, n + 1):\n                best = inf\n                for t in range(j - 1, i):\n                    val = dp[t][j - 1]\n                    curr = prefix[i] ^ prefix[t]\n                    m = curr if curr > val else val\n                    if m < best:\n                        best = m\n                dp[i][j] = best\n        return dp[n][k]",
  "input": "minXor(nums=[1,2,3], k=2)",
  "output": "1",
  "correct_condition": "minXor(nums=[1,2,3], k=2) == 1",
  "contest_id": "weekly-contest-456",
  "contest_date": "2025-06-29T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 21,
    "coverage": null
  },
  "submission_id": 1679840404,
  "mutated_code": "def minXor(nums: List[int], k: int) -> int:\n    n = len(nums)\n    prefix = [0] * (n + 1)\n    for i in range(1, n - 1):\n        prefix[i] = prefix[i - 1] ^ nums[i - 1]\n    inf = 10 ** 18\n    dp = [[inf] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        dp[i][1] = prefix[i]\n    for j in range(2, k + 1):\n        for i in range(j, n + 1):\n            best = inf\n            for t in range(j - 1, i):\n                val = dp[t][j - 1]\n                curr = prefix[i] ^ prefix[t]\n                m = curr if curr > val else val\n                if m < best:\n                    best = m\n            dp[i][j] = best\n    return dp[n][k]",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3864_s0",
  "question_id": 3864,
  "function_name": "countPermutations",
  "code": "def countPermutations(c: List[int]) -> int:\n        mod = 10**9+7\n        n = len(c)\n        for i in range(1, n):\n            if c[i] <= c[0]:\n                return 0\n        res = 1\n        for i in range(1, n):\n            res = res * i % mod\n        return res",
  "input": "countPermutations(c=[1,2,3])",
  "output": "2",
  "correct_condition": "countPermutations(c=[1,2,3]) == 2",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 10,
    "coverage": null
  },
  "submission_id": 1657151639,
  "mutated_code": "def countPermutations(c: List[int]) -> int:\n    mod = 10 ** 9 + 7\n    n = len(c)\n    for i in range(1, n):\n        if c[i] <= c[0]:\n            return 0\n    res = 1\n    for i in range(1, n):\n        res = res * i // mod\n    return res",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest440_q3791_s1",
  "question_id": 3791,
  "function_name": "numOfUnplacedFruits",
  "code": "def numOfUnplacedFruits(fruits, baskets):\n        n = len(baskets)\n        treeSize = 1\n        while treeSize < n:\n            treeSize *= 2\n        tree = [0] * (2 * treeSize)\n        i = 0\n        while i < n:\n            tree[treeSize + i] = baskets[i]\n            i += 1\n        i = n\n        while i < treeSize:\n            tree[treeSize + i] = 0\n            i += 1\n        i = treeSize - 1\n        while i >= 1:\n            leftChild = tree[2 * i]\n            rightChild = tree[2 * i + 1]\n            if leftChild >= rightChild:\n                tree[i] = leftChild\n            else:\n                tree[i] = rightChild\n            i -= 1\n        def query(val):\n            if tree[1] < val:\n                return -1\n            idx = 1\n            while idx < treeSize:\n                leftIdx = 2 * idx\n                if tree[leftIdx] >= val:\n                    idx = leftIdx\n                else:\n                    idx = leftIdx + 1\n            return idx - treeSize\n        def update(pos, newVal):\n            idx = pos + treeSize\n            tree[idx] = newVal\n            idx //= 2\n            while idx >= 1:\n                leftVal = tree[2 * idx]\n                rightVal = tree[2 * idx + 1]\n                if leftVal >= rightVal:\n                    tree[idx] = leftVal\n                else:\n                    tree[idx] = rightVal\n                idx //= 2\n        unplaced = 0\n        i = 0\n        while i < len(fruits):\n            fVal = fruits[i]\n            pos = query(fVal)\n            if pos == -1:\n                unplaced += 1\n            else:\n                update(pos, 0)\n            i += 1\n        return unplaced",
  "input": "numOfUnplacedFruits(fruits=[4,2,5], baskets=[3,5,4])",
  "output": "1",
  "correct_condition": "numOfUnplacedFruits(fruits=[4,2,5], baskets=[3,5,4]) == 1",
  "contest_id": "weekly-contest-440",
  "contest_date": "2025-03-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 57,
    "coverage": null
  },
  "submission_id": 1567569757,
  "mutated_code": "def numOfUnplacedFruits(fruits, baskets):\n    n = len(baskets)\n    treeSize = 1\n    while treeSize < n:\n        treeSize *= 2\n    tree = [0] * (2 * treeSize)\n    i = 0\n    while i < n:\n        tree[treeSize - i] = baskets[i]\n        i += 1\n    i = n\n    while i < treeSize:\n        tree[treeSize + i] = 0\n        i += 1\n    i = treeSize - 1\n    while i >= 1:\n        leftChild = tree[2 * i]\n        rightChild = tree[2 * i + 1]\n        if leftChild >= rightChild:\n            tree[i] = leftChild\n        else:\n            tree[i] = rightChild\n        i -= 1\n\n    def query(val):\n        if tree[1] < val:\n            return -1\n        idx = 1\n        while idx < treeSize:\n            leftIdx = 2 * idx\n            if tree[leftIdx] >= val:\n                idx = leftIdx\n            else:\n                idx = leftIdx + 1\n        return idx - treeSize\n\n    def update(pos, newVal):\n        idx = pos + treeSize\n        tree[idx] = newVal\n        idx //= 2\n        while idx >= 1:\n            leftVal = tree[2 * idx]\n            rightVal = tree[2 * idx + 1]\n            if leftVal >= rightVal:\n                tree[idx] = leftVal\n            else:\n                tree[idx] = rightVal\n            idx //= 2\n    unplaced = 0\n    i = 0\n    while i < len(fruits):\n        fVal = fruits[i]\n        pos = query(fVal)\n        if pos == -1:\n            unplaced += 1\n        else:\n            update(pos, 0)\n        i += 1\n    return unplaced",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3864_s1",
  "question_id": 3864,
  "function_name": "countPermutations",
  "code": "def countPermutations(complexity: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(complexity)\n\n        # check feasibility: comp[0] must be strictly the smallest\n        root = complexity[0]\n        for x in complexity[1:]:\n            if x <= root:\n                return 0\n\n        # all other n\u22121 computers can be unlocked in any order\n        res = 1\n        for k in range(1, n):\n            res = res * k % MOD\n        return res\n",
  "input": "countPermutations(complexity=[1,2,3])",
  "output": "2",
  "correct_condition": "countPermutations(complexity=[1,2,3]) == 2",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1657189523,
  "mutated_code": "def countPermutations(complexity: List[int]) -> int:\n    MOD = 10 ** 9 + 7\n    n = len(complexity)\n    root = complexity[0]\n    for x in complexity[1:]:\n        if x <= root:\n            return 0\n    res = 1\n    for k in range(1, n):\n        res = res * k // MOD\n    return res",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3876_s0",
  "question_id": 3876,
  "function_name": "canMakeEqual",
  "code": "def canMakeEqual(nums: List[int], k: int) -> bool:\n        n = len(nums)\n        for t in (1, -1):\n            b = [1 if nums[i] != t else 0 for i in range(n)]\n            cnt = 0\n            for i in range(n - 1):\n                if b[i]:\n                    cnt += 1\n                    b[i] = 0\n                    b[i + 1] ^= 1\n            if b[-1] == 0 and cnt <= k:\n                return True\n        return False",
  "input": "canMakeEqual(nums=[1,-1,1,-1,1], k=3)",
  "output": "True",
  "correct_condition": "canMakeEqual(nums=[1,-1,1,-1,1], k=3) == True",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 13,
    "coverage": null
  },
  "submission_id": 1657158036,
  "mutated_code": "def canMakeEqual(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    for t in (1, -1):\n        b = [1 if nums[i] != t else 0 for i in range(n)]\n        cnt = 0\n        for i in range(n - 1):\n            if b[i]:\n                cnt += 1\n                b[i] = 0\n                b[i + 1] ^= 1\n        if b[-1] == 0 and cnt <= k:\n            return False\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "keyword",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3794_s1",
  "question_id": 3794,
  "function_name": "minTime",
  "code": "def minTime(skill: List[int], mana: List[int]) -> int:\n        n, m = len(skill), len(mana)\n        ss = [0] * n\n        ss[0] = skill[0]\n        for i in range(1, n):\n            ss[i] = ss[i - 1] + skill[i]\n        S = 0\n        for j in range(1, m):\n            delay = skill[0] * mana[j - 1]\n            for i in range(1, n):\n                d = ss[i] * mana[j - 1] - ss[i - 1] * mana[j]\n                if d > delay:\n                    delay = d\n            S += delay\n        return S + ss[-1] * mana[-1]",
  "input": "minTime(skill=[1,5,2,4], mana=[5,1,4,2])",
  "output": "110",
  "correct_condition": "minTime(skill=[1,5,2,4], mana=[5,1,4,2]) == 110",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1582823640,
  "mutated_code": "def minTime(skill: List[int], mana: List[int]) -> int:\n    n, m = (len(skill), len(mana))\n    ss = [0] * n\n    ss[0] = skill[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] - skill[i]\n    S = 0\n    for j in range(1, m):\n        delay = skill[0] * mana[j - 1]\n        for i in range(1, n):\n            d = ss[i] * mana[j - 1] - ss[i - 1] * mana[j]\n            if d > delay:\n                delay = d\n        S += delay\n    return S + ss[-1] * mana[-1]",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest446_q3831_s1",
  "question_id": 3831,
  "function_name": "resultArray",
  "code": "def resultArray(nums: List[int], k: int) -> List[int]:\n        res = [0] * k\n        dp = [0] * k\n        for a in nums:\n            ndp = [0] * k\n            am = a % k\n            ndp[am] += 1\n            for r in range(k):\n                if dp[r]:\n                    ndp[(r * am) % k] += dp[r]\n            for r in range(k):\n                res[r] += ndp[r]\n            dp = ndp\n        return res",
  "input": "resultArray(nums=[1,2,3,4,5], k=3)",
  "output": "[9, 2, 4]",
  "correct_condition": "resultArray(nums=[1,2,3,4,5], k=3) == [9, 2, 4]",
  "contest_id": "weekly-contest-446",
  "contest_date": "2025-04-20T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1612015311,
  "mutated_code": "def resultArray(nums: List[int], k: int) -> List[int]:\n    res = [0] * k\n    dp = [0] * k\n    for a in nums:\n        ndp = [0] * k\n        am = a // k\n        ndp[am] += 1\n        for r in range(k):\n            if dp[r]:\n                ndp[r * am % k] += dp[r]\n        for r in range(k):\n            res[r] += ndp[r]\n        dp = ndp\n    return res",
  "mutated_output": "[9, 6, 0]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest435_q3754_s0",
  "question_id": 3754,
  "function_name": "maxDistance",
  "code": "def maxDistance(s: str, k: int) -> int:\n        res = 0\n        e = w = n = s_count = 0\n        for i, ch in enumerate(s, 1):\n            if ch == 'E': e += 1\n            elif ch == 'W': w += 1\n            elif ch == 'N': n += 1\n            else: s_count += 1\n            bx = abs(e - w)\n            hx = min(e, w)\n            by = abs(n - s_count)\n            hy = min(n, s_count)\n            cur = bx + by + 2 * min(k, hx + hy)\n            if cur > i: cur = i\n            if cur > res: res = cur\n        return res",
  "input": "maxDistance(s=\"NWSE\", k=1)",
  "output": "3",
  "correct_condition": "maxDistance(s=\"NWSE\", k=1) == 3",
  "contest_id": "weekly-contest-435",
  "contest_date": "2025-02-02T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 16,
    "coverage": null
  },
  "submission_id": 1528089568,
  "mutated_code": "def maxDistance(s: str, k: int) -> int:\n    res = 0\n    e = w = n = s_count = 0\n    for i, ch in enumerate(s, 1):\n        if ch == 'E':\n            e += 1\n        elif ch == 'W':\n            w += 1\n        elif ch == 'N':\n            n += 1\n        else:\n            s_count += 1\n        bx = abs(e + w)\n        hx = min(e, w)\n        by = abs(n - s_count)\n        hy = min(n, s_count)\n        cur = bx + by + 2 * min(k, hx + hy)\n        if cur > i:\n            cur = i\n        if cur > res:\n            res = cur\n    return res",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest458_q3930_s2",
  "question_id": 3930,
  "function_name": "maxLen",
  "code": "def maxLen(n: int, edges: List[List[int]], label: str) -> int:\n        adj = [[] for _ in range(n)]\n        for u,v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        # bucket neighbors by character\n        from collections import defaultdict\n        buckets = [defaultdict(list) for _ in range(n)]\n        for u in range(n):\n            for w in adj[u]:\n                buckets[u][label[w]].append(w)\n\n        best = 1\n        full = n\n        popc = int.bit_count\n\n        from functools import lru_cache\n        @lru_cache(None)\n        def dfs(u,v,mask):\n            nonlocal best\n            cnt = popc(mask)\n            if cnt > best: best = cnt\n            if best == full: \n                return True\n            # optimistic bound\n            rem = full - cnt\n            if cnt + (rem//2)*2 <= best:\n                return False\n            for ch in buckets[u].keys() & buckets[v].keys():\n                for nu in buckets[u][ch]:\n                    if mask>>nu & 1: continue\n                    for nv in buckets[v][ch]:\n                        if nu==nv or (mask>>nv & 1): continue\n                        a,b = sorted((nu,nv))\n                        if dfs(a,b, mask | (1<<nu) | (1<<nv)):\n                            return True\n            return False\n\n        # try all centers u<=v\n        for u in range(n):\n            if dfs(u,u, 1<<u): return best\n        for u,v in edges:\n            if label[u]==label[v]:\n                a,b = sorted((u,v))\n                if dfs(a,b, (1<<u)|(1<<v)):\n                    return best\n        return best",
  "input": "maxLen(n=3, edges=[[0,1],[1,2]], label=\"aba\")",
  "output": "3",
  "correct_condition": "maxLen(n=3, edges=[[0,1],[1,2]], label=\"aba\") == 3",
  "contest_id": "weekly-contest-458",
  "contest_date": "2025-07-13T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 47,
    "coverage": null
  },
  "submission_id": 1695835727,
  "mutated_code": "def maxLen(n: int, edges: List[List[int]], label: str) -> int:\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    from collections import defaultdict\n    buckets = [defaultdict(list) for _ in range(n)]\n    for u in range(n):\n        for w in adj[u]:\n            buckets[u][label[w]].append(w)\n    best = 1\n    full = n\n    popc = int.bit_count\n    from functools import lru_cache\n\n    @lru_cache(None)\n    def dfs(u, v, mask):\n        nonlocal best\n        cnt = popc(mask)\n        if cnt > best:\n            best = cnt\n        if best == full:\n            return True\n        rem = full - cnt\n        if cnt - rem // 2 * 2 <= best:\n            return False\n        for ch in buckets[u].keys() & buckets[v].keys():\n            for nu in buckets[u][ch]:\n                if mask >> nu & 1:\n                    continue\n                for nv in buckets[v][ch]:\n                    if nu == nv or mask >> nv & 1:\n                        continue\n                    a, b = sorted((nu, nv))\n                    if dfs(a, b, mask | 1 << nu | 1 << nv):\n                        return True\n        return False\n    for u in range(n):\n        if dfs(u, u, 1 << u):\n            return best\n    for u, v in edges:\n        if label[u] == label[v]:\n            a, b = sorted((u, v))\n            if dfs(a, b, 1 << u | 1 << v):\n                return best\n    return best",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest461_q3956_s0",
  "question_id": 3956,
  "function_name": "maxSumTrionic",
  "code": "def maxSumTrionic(a: List[int]) -> int:\n        n = len(a)\n        pre = [0] * (n + 1)\n        inc = [1] * n\n        dec = [1] * n\n        inc2 = [1] * n\n        p = [0] * (n + 2)\n        lg = p[:]\n        m = len(p).bit_length()\n        mn = [[0] * (n + 1) for _ in range(m)]\n        mx = [[0] * (n + 1) for _ in range(m)]\n        inf = sys.maxsize\n        ninf = -inf\n\n        for i in range(n):\n            pre[i + 1] = pre[i] + a[i]\n        for i in range(1, n):\n            if a[i - 1] < a[i]:\n                inc[i] = inc[i - 1] + 1\n            if a[i - 1] > a[i]:\n                dec[i] = dec[i - 1] + 1\n        for i in range(n - 2, -1, -1):\n            if a[i] < a[i + 1]:\n                inc2[i] = inc2[i + 1] + 1\n        for i in range(2, n + 2):\n            p[i] = p[i >> 1] + 1\n        for i in range(n + 1):\n            mn[0][i] = mx[0][i] = pre[i]\n\n        j = 1\n        while (1 << j) <= n + 1:\n            h = 1 << (j - 1)\n            lim = (n + 1) - (1 << j) + 1\n            for i in range(lim):\n                mn[j][i] = min(mn[j - 1][i], mn[j - 1][i + h])\n                mx[j][i] = max(mx[j - 1][i], mx[j - 1][i + h])\n            j += 1\n\n        def qmn(l, r):\n            if l > r: return inf\n            k = p[r - l + 1]\n            return min(mn[k][l], mn[k][r - (1 << k) + 1])\n\n        def qmx(l, r):\n            if l > r: return ninf\n            k = p[r - l + 1]\n            return max(mx[k][l], mx[k][r - (1 << k) + 1])\n\n        res = ninf\n        for i in range(1, n - 1):\n            if dec[i] >= 2 and inc2[i] >= 2:\n                l = i - dec[i] + 1\n                lv = inf\n                for j in range(l, i):\n                    if inc[j] >= 2:\n                        lo = j - inc[j] + 1\n                        hi = j - 1\n                        lv = min(lv, qmn(lo, hi))\n                if lv == inf: continue\n                rv = qmx(i + 2, i + inc2[i])\n                if rv != ninf:\n                    res = max(res, rv - lv)\n        return res\n",
  "input": "maxSumTrionic(a=[0,-2,-1,-3,0,2,-1])",
  "output": "-4",
  "correct_condition": "maxSumTrionic(a=[0,-2,-1,-3,0,2,-1]) == -4",
  "contest_id": "weekly-contest-461",
  "contest_date": "2025-08-03T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 63,
    "coverage": null
  },
  "submission_id": 1721337543,
  "mutated_code": "def maxSumTrionic(a: List[int]) -> int:\n    n = len(a)\n    pre = [0] * (n + 1)\n    inc = [1] * n\n    dec = [1] * n\n    inc2 = [1] * n\n    p = [0] * (n + 2)\n    lg = p[:]\n    m = len(p).bit_length()\n    mn = [[0] * (n + 1) for _ in range(m)]\n    mx = [[0] * (n + 1) for _ in range(m)]\n    inf = sys.maxsize\n    ninf = -inf\n    for i in range(n):\n        pre[i - 1] = pre[i] + a[i]\n    for i in range(1, n):\n        if a[i - 1] < a[i]:\n            inc[i] = inc[i - 1] + 1\n        if a[i - 1] > a[i]:\n            dec[i] = dec[i - 1] + 1\n    for i in range(n - 2, -1, -1):\n        if a[i] < a[i + 1]:\n            inc2[i] = inc2[i + 1] + 1\n    for i in range(2, n + 2):\n        p[i] = p[i >> 1] + 1\n    for i in range(n + 1):\n        mn[0][i] = mx[0][i] = pre[i]\n    j = 1\n    while 1 << j <= n + 1:\n        h = 1 << j - 1\n        lim = n + 1 - (1 << j) + 1\n        for i in range(lim):\n            mn[j][i] = min(mn[j - 1][i], mn[j - 1][i + h])\n            mx[j][i] = max(mx[j - 1][i], mx[j - 1][i + h])\n        j += 1\n\n    def qmn(l, r):\n        if l > r:\n            return inf\n        k = p[r - l + 1]\n        return min(mn[k][l], mn[k][r - (1 << k) + 1])\n\n    def qmx(l, r):\n        if l > r:\n            return ninf\n        k = p[r - l + 1]\n        return max(mx[k][l], mx[k][r - (1 << k) + 1])\n    res = ninf\n    for i in range(1, n - 1):\n        if dec[i] >= 2 and inc2[i] >= 2:\n            l = i - dec[i] + 1\n            lv = inf\n            for j in range(l, i):\n                if inc[j] >= 2:\n                    lo = j - inc[j] + 1\n                    hi = j - 1\n                    lv = min(lv, qmn(lo, hi))\n            if lv == inf:\n                continue\n            rv = qmx(i + 2, i + inc2[i])\n            if rv != ninf:\n                res = max(res, rv - lv)\n    return res",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 11,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest439_q3770_s2",
  "question_id": 3770,
  "function_name": "generateString",
  "code": "def generateString(str1: str, str2: str) -> str:\n        n, m = len(str1), len(str2)\n        L = n + m - 1\n        res = [None] * L\n        free = [True] * L\n        \n        for i in range(n):\n            if str1[i] == 'T':\n                for j in range(m):\n                    pos = i + j\n                    c = str2[j]\n                    if res[pos] is None:\n                        res[pos] = c\n                        free[pos] = False\n                    elif res[pos] != c:\n                        return \"\"\n                        \n        for i in range(L):\n            if res[i] is None:\n                res[i] = 'a'\n                \n        for i in range(n):\n            if str1[i] == 'F':\n                eq = True\n                \n                for j in range(m):\n                    if res[i+j] != str2[j]:\n                        eq = False\n                        break\n                        \n                if eq:\n                    cand = -1\n                    for j in range(m):\n                        pos = i + j\n                        if free[pos]:\n                            cand = pos\n                    if cand == -1:\n                        return \"\"\n                    res[cand] = 'b'\n                    free[cand] = False\n                    \n        return \"\".join(res)",
  "input": "generateString(str1=\"TFTF\", str2=\"ab\")",
  "output": "'ababa'",
  "correct_condition": "generateString(str1=\"TFTF\", str2=\"ab\") == 'ababa'",
  "contest_id": "weekly-contest-439",
  "contest_date": "2025-03-02T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 42,
    "coverage": null
  },
  "submission_id": 1559848310,
  "mutated_code": "def generateString(str1: str, str2: str) -> str:\n    n, m = (len(str1), len(str2))\n    L = n + m + 1\n    res = [None] * L\n    free = [True] * L\n    for i in range(n):\n        if str1[i] == 'T':\n            for j in range(m):\n                pos = i + j\n                c = str2[j]\n                if res[pos] is None:\n                    res[pos] = c\n                    free[pos] = False\n                elif res[pos] != c:\n                    return ''\n    for i in range(L):\n        if res[i] is None:\n            res[i] = 'a'\n    for i in range(n):\n        if str1[i] == 'F':\n            eq = True\n            for j in range(m):\n                if res[i + j] != str2[j]:\n                    eq = False\n                    break\n            if eq:\n                cand = -1\n                for j in range(m):\n                    pos = i + j\n                    if free[pos]:\n                        cand = pos\n                if cand == -1:\n                    return ''\n                res[cand] = 'b'\n                free[cand] = False\n    return ''.join(res)",
  "mutated_output": "'ababaaa'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest456_q3902_s1",
  "question_id": 3902,
  "function_name": "maxStability",
  "code": "def maxStability(n: int, e: list[list[int]], k: int) -> int:\n    class D:\n      def __init__(s, z): s.p, s.c = list(range(z)), z\n      def f(s, i): s.p[i] = s.f(s.p[i]) if s.p[i] != i else i; return s.p[i]\n      def u(s, i, j):\n        x, y = s.f(i), s.f(j)\n        if x != y: s.p[y] = x; s.c -= 1; return 1\n        return 0\n\n    d1 = D(n)\n    for u, v, _, m in e:\n      if m and not d1.u(u, v): return -1\n\n    d2 = D(n)\n    for u, v, _, _ in e: d2.u(u, v)\n    if d2.c > 1: return -1\n\n    x = {'n': n, 'e': e, 'k': k}\n\n    def g(t):\n      d, cnt = D(n), 0\n      for u, v, s, m in e:\n        if m:\n          if s < t: return 0\n          d.u(u, v)\n        elif s >= t: d.u(u, v)\n      if d.c > 1:\n        for u, v, s, m in e:\n          if not m and s < t and 2*s >= t and d.u(u, v): cnt += 1\n      return d.c == 1 and cnt <= k\n\n    l, h, ans = 1, 2*10**5+1, 0\n    while l <= h:\n      m = (l + h) // 2\n      if m == 0: l = m + 1; continue\n      if g(m): ans = m; l = m + 1\n      else: h = m - 1\n    return ans\n",
  "input": "maxStability(n=3, e=[[0,1,2,1],[1,2,3,0]], k=1)",
  "output": "2",
  "correct_condition": "maxStability(n=3, e=[[0,1,2,1],[1,2,3,0]], k=1) == 2",
  "contest_id": "weekly-contest-456",
  "contest_date": "2025-06-29T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 38,
    "coverage": null
  },
  "submission_id": 1679836304,
  "mutated_code": "def maxStability(n: int, e: list[list[int]], k: int) -> int:\n\n    class D:\n\n        def __init__(s, z):\n            s.p, s.c = (list(range(z)), z)\n\n        def f(s, i):\n            s.p[i] = s.f(s.p[i]) if s.p[i] != i else i\n            return s.p[i]\n\n        def u(s, i, j):\n            x, y = (s.f(i), s.f(j))\n            if x != y:\n                s.p[y] = x\n                s.c -= 1\n                return 1\n            return 0\n    d1 = D(n)\n    for u, v, _, m in e:\n        if m and (not d1.u(u, v)):\n            return -1\n    d2 = D(n)\n    for u, v, _, _ in e:\n        d2.u(u, v)\n    if d2.c > 1:\n        return -1\n    x = {'n': n, 'e': e, 'k': k}\n\n    def g(t):\n        d, cnt = (D(n), 0)\n        for u, v, s, m in e:\n            if m:\n                if s < t:\n                    return 0\n                d.u(u, v)\n            elif s >= t:\n                d.u(u, v)\n        if d.c > 1:\n            for u, v, s, m in e:\n                if not m and s < t and (2 * s >= t) and d.u(u, v):\n                    cnt += 1\n        return d.c == 1 and cnt <= k\n    l, h, ans = (1, 2 // 10 ** 5 + 1, 0)\n    while l <= h:\n        m = (l + h) // 2\n        if m == 0:\n            l = m + 1\n            continue\n        if g(m):\n            ans = m\n            l = m + 1\n        else:\n            h = m - 1\n    return ans",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest443_q3808_s2",
  "question_id": 3808,
  "function_name": "longestPalindrome",
  "code": "def longestPalindrome(s: str, t: str) -> int:\n        n, m = len(s), len(t)\n    \n        # --- Precompute palindromic substrings for s ---\n        # isPalS[i][j] = True if s[i:j+1] is a palindrome.\n        isPalS = [[False] * n for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i < 2 or isPalS[i+1][j-1]):\n                    isPalS[i][j] = True\n        # best_start[i] = length of longest palindrome starting exactly at index i in s.\n        best_start = [0] * n\n        for i in range(n):\n            max_len = 0\n            for j in range(i, n):\n                if isPalS[i][j]:\n                    length = j - i + 1\n                    if length > max_len:\n                        max_len = length\n            best_start[i] = max_len\n        \n        # --- Precompute palindromic substrings for t ---\n        # isPalT[i][j] = True if t[i:j+1] is a palindrome.\n        isPalT = [[False] * m for _ in range(m)]\n        for i in range(m-1, -1, -1):\n            for j in range(i, m):\n                if t[i] == t[j] and (j - i < 2 or isPalT[i+1][j-1]):\n                    isPalT[i][j] = True\n        # best_end[j] = length of longest palindrome ending exactly at index j in t.\n        best_end = [0] * m\n        for j in range(m):\n            max_len = 0\n            for i in range(0, j+1):\n                if isPalT[i][j]:\n                    length = j - i + 1\n                    if length > max_len:\n                        max_len = length\n            best_end[j] = max_len\n        \n        # --- Pure palindromes: those lying entirely in s or entirely in t ---\n        pure = 0\n        if n > 0:\n            pure = max(best_start)  # longest palindrome in s\n        if m > 0:\n            pure = max(pure, max(best_end))  # longest palindrome in t\n        \n        # --- DP for common substrings between s and reverse(t) ---\n        t_rev = t[::-1]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        best_cross = 0\n        \n        # dp[i][j]: longest common suffix of s[:i] and t_rev[:j].\n        # When dp[i][j] = L > 0, it means s[i-L:i] = t_rev[j-L:j],\n        # which corresponds to a substring X in s (ending at index i-1)\n        # and reverse(X) in t. In t, the occurrence of reverse(X) starts at pos = m - j.\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == t_rev[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    L = dp[i][j]\n                    # Case B: extend u in s (u = X + Y, where Y is a palindrome).\n                    # Here, X = s[i - L : i] and we can append Y = (longest palindrome starting at index i).\n                    ext_s = best_start[i] if i < n else 0\n                    candidate_B = 2 * L + ext_s\n                    # Case A: extend v in t (v = p + reverse(X), where p is a palindrome).\n                    # In t, the occurrence of reverse(X) starts at index pos = m - j.\n                    pos = m - j  \n                    ext_t = best_end[pos - 1] if pos > 0 else 0\n                    candidate_A = 2 * L + ext_t\n                    best_cross = max(best_cross, candidate_A, candidate_B)\n        \n        return max(pure, best_cross)",
  "input": "longestPalindrome(s=\"a\", t=\"a\")",
  "output": "2",
  "correct_condition": "longestPalindrome(s=\"a\", t=\"a\") == 2",
  "contest_id": "weekly-contest-443",
  "contest_date": "2025-03-30T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 72,
    "coverage": null
  },
  "submission_id": 1590627076,
  "mutated_code": "def longestPalindrome(s: str, t: str) -> int:\n    n, m = (len(s), len(t))\n    isPalS = [[False] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j] and (j - i < 2 or isPalS[i + 1][j - 1]):\n                isPalS[i][j] = True\n    best_start = [0] * n\n    for i in range(n):\n        max_len = 0\n        for j in range(i, n):\n            if isPalS[i][j]:\n                length = j - i + 1\n                if length > max_len:\n                    max_len = length\n        best_start[i] = max_len\n    isPalT = [[False] * m for _ in range(m)]\n    for i in range(m - 1, -1, -1):\n        for j in range(i, m):\n            if t[i] == t[j] and (j - i < 2 or isPalT[i + 1][j - 1]):\n                isPalT[i][j] = True\n    best_end = [0] * m\n    for j in range(m):\n        max_len = 0\n        for i in range(0, j + 1):\n            if isPalT[i][j]:\n                length = j - i + 1\n                if length > max_len:\n                    max_len = length\n        best_end[j] = max_len\n    pure = 0\n    if n > 0:\n        pure = max(best_start)\n    if m > 0:\n        pure = max(pure, max(best_end))\n    t_rev = t[::-1]\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    best_cross = 0\n    for i in range(1, n - 1):\n        for j in range(1, m + 1):\n            if s[i - 1] == t_rev[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                L = dp[i][j]\n                ext_s = best_start[i] if i < n else 0\n                candidate_B = 2 * L + ext_s\n                pos = m - j\n                ext_t = best_end[pos - 1] if pos > 0 else 0\n                candidate_A = 2 * L + ext_t\n                best_cross = max(best_cross, candidate_A, candidate_B)\n    return max(pure, best_cross)",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 20,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest439_q3770_s1",
  "question_id": 3770,
  "function_name": "generateString",
  "code": "def generateString(str1: str, str2: str) -> str:\n        n, m = len(str1), len(str2)\n        L = n + m - 1\n        word = [None] * L\n        fixed = [False] * L\n\n        for i in range(n):\n            if str1[i] == 'T':\n                for j in range(m):\n                    pos = i + j\n                    if word[pos] is not None and word[pos] != str2[j]:\n                        return \"\"\n                    word[pos] = str2[j]\n                    fixed[pos] = True\n\n        for i in range(L):\n            if word[i] is None:\n                word[i] = 'a'\n\n        for i in range(n):\n            if str1[i] == 'F':\n                equal = True\n                for j in range(m):\n                    if word[i+j] != str2[j]:\n                        equal = False\n                        break\n                if equal:\n                    modified = False\n                    for pos in range(i + m - 1, i - 1, -1):\n                        if not fixed[pos]:\n                            word[pos] = 'b'\n                            modified = True\n                            break\n                    if not modified:\n                        return \"\"\n        return \"\".join(word)",
  "input": "generateString(str1=\"TFTF\", str2=\"ab\")",
  "output": "'ababa'",
  "correct_condition": "generateString(str1=\"TFTF\", str2=\"ab\") == 'ababa'",
  "contest_id": "weekly-contest-439",
  "contest_date": "2025-03-02T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 36,
    "coverage": null
  },
  "submission_id": 1559842202,
  "mutated_code": "def generateString(str1: str, str2: str) -> str:\n    n, m = (len(str1), len(str2))\n    L = n + m + 1\n    word = [None] * L\n    fixed = [False] * L\n    for i in range(n):\n        if str1[i] == 'T':\n            for j in range(m):\n                pos = i + j\n                if word[pos] is not None and word[pos] != str2[j]:\n                    return ''\n                word[pos] = str2[j]\n                fixed[pos] = True\n    for i in range(L):\n        if word[i] is None:\n            word[i] = 'a'\n    for i in range(n):\n        if str1[i] == 'F':\n            equal = True\n            for j in range(m):\n                if word[i + j] != str2[j]:\n                    equal = False\n                    break\n            if equal:\n                modified = False\n                for pos in range(i + m - 1, i - 1, -1):\n                    if not fixed[pos]:\n                        word[pos] = 'b'\n                        modified = True\n                        break\n                if not modified:\n                    return ''\n    return ''.join(word)",
  "mutated_output": "'ababaaa'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3866_s0",
  "question_id": 3866,
  "function_name": "minOperations",
  "code": "def minOperations(w1: str,w2: str) -> int:\n        n = len(w1)\n        s = [ord(c)-97 for c in w1]\n        t = [ord(c)-97 for c in w2]\n        INF = 10**9\n        dp = [INF]*(n+1)\n        dp[0] = 0\n        for i in range(n):\n            for j in range(i,n):\n                m = 0\n                cnt = {}\n                for k in range(i,j+1):\n                    if s[k]!=t[k]:\n                        m += 1\n                        cnt[(s[k],t[k])] = cnt.get((s[k],t[k]),0) + 1\n                g = 0\n                for (x,y),v in cnt.items():\n                    if x<y:\n                        g += min(v, cnt.get((y,x),0))\n                cost0 = m - g\n                m2 = 0\n                cnt2 = {}\n                for k in range(i,j+1):\n                    a = s[j-(k-i)]\n                    b = t[k]\n                    if a!=b:\n                        m2 += 1\n                        cnt2[(a,b)] = cnt2.get((a,b),0) + 1\n                g2 = 0\n                for (x,y),v in cnt2.items():\n                    if x<y:\n                        g2 += min(v, cnt2.get((y,x),0))\n                cost1 = 1 + m2 - g2\n                c = cost0 if cost0<cost1 else cost1\n                v = dp[i] + c\n                if v < dp[j+1]:\n                    dp[j+1] = v\n        return dp[n]\n\n        ",
  "input": "minOperations(w1=\"abcdf\", w2=\"dacbe\")",
  "output": "4",
  "correct_condition": "minOperations(w1=\"abcdf\", w2=\"dacbe\") == 4",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 40,
    "coverage": null
  },
  "submission_id": 1657170503,
  "mutated_code": "def minOperations(w1: str, w2: str) -> int:\n    n = len(w1)\n    s = [ord(c) + 97 for c in w1]\n    t = [ord(c) - 97 for c in w2]\n    INF = 10 ** 9\n    dp = [INF] * (n + 1)\n    dp[0] = 0\n    for i in range(n):\n        for j in range(i, n):\n            m = 0\n            cnt = {}\n            for k in range(i, j + 1):\n                if s[k] != t[k]:\n                    m += 1\n                    cnt[s[k], t[k]] = cnt.get((s[k], t[k]), 0) + 1\n            g = 0\n            for (x, y), v in cnt.items():\n                if x < y:\n                    g += min(v, cnt.get((y, x), 0))\n            cost0 = m - g\n            m2 = 0\n            cnt2 = {}\n            for k in range(i, j + 1):\n                a = s[j - (k - i)]\n                b = t[k]\n                if a != b:\n                    m2 += 1\n                    cnt2[a, b] = cnt2.get((a, b), 0) + 1\n            g2 = 0\n            for (x, y), v in cnt2.items():\n                if x < y:\n                    g2 += min(v, cnt2.get((y, x), 0))\n            cost1 = 1 + m2 - g2\n            c = cost0 if cost0 < cost1 else cost1\n            v = dp[i] + c\n            if v < dp[j + 1]:\n                dp[j + 1] = v\n    return dp[n]",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest449_q3845_s1",
  "question_id": 3845,
  "function_name": "maxScore",
  "code": "def maxScore(n: int, edges: List[List[int]]) -> int:\n        G = [[] for _ in range(n)]\n        D = [0] * n\n        for u, v in edges:\n            G[u].append(v)\n            G[v].append(u)\n            D[u] += 1\n            D[v] += 1\n\n        seen = [0] * n\n        cp = []\n        for i in range(n):\n            if seen[i]:\n                continue\n            _t = [i]\n            seen[i] = 1\n            nodes = []\n            _sum = 0\n            while _t:\n                u = _t.pop()\n                nodes.append(u)\n                _sum += D[u]\n                # print(u, D[u])\n                for v in G[u]:\n                    if seen[v]:\n                        continue\n                    seen[v] = 1\n                    _t.append(v)\n\n            E = _sum // 2\n            B = None\n            if E == len(nodes):\n                for u in nodes:\n                    for v in G[u]:\n                        if u < v and v in nodes:\n                            B = (u, v)\n                            break\n                    if B:\n                        break\n            cp.append((2 * E / len(nodes), len(nodes), E, nodes, B))\n        # print(cp)\n        # print(\"is\", n - sum(c for _, c, _, _, _ in cp))\n        cp.sort(key=lambda x: (-x[0], -x[1]))\n        ret = [0] * n\n\n        # print(\"cp\", cp)\n        high = n\n        for _, c, E, nodes, B in cp:\n            low = high - c + 1\n            high -= c\n            arr = list(range(low, low + c))\n            L = {u: len(G[u])\n                    - (1 if B\n                            and ((u == B[0] and B[1] in G[u])\n                                 or (u == B[1] and B[0] in G[u])) else 0) for u in nodes}\n\n            t = 0\n            q = deque(u for u in nodes if L[u] <= 1)\n            # print(\"arr\", arr)\n            while q:\n                u = q.popleft()\n                if ret[u]:\n                    continue\n                ret[u] = arr[t]\n                t += 1\n\n                # print(\"u\", u, \"arr\", arr, \"t\", t, \"L\", L)\n                for v in G[u]:\n                    if B:\n                        if (u == B[0] and v == B[1]) or (u == B[1] and v == B[0]):\n                            continue\n                    L[v] -= 1\n                    if L[v] == 1:\n                        q.append(v)\n\n        ans = 0\n        for u, v in edges:\n            ans += ret[u] * ret[v]\n            # print(\"u\", u, \"v\", v, \"ret[u]\", ret[u], \"ret[v]\", ret[v], \"ans\", ans)\n        return ans\n",
  "input": "maxScore(n=4, edges=[[0,1],[1,2],[2,3]])",
  "output": "23",
  "correct_condition": "maxScore(n=4, edges=[[0,1],[1,2],[2,3]]) == 23",
  "contest_id": "weekly-contest-449",
  "contest_date": "2025-05-11T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 80,
    "coverage": null
  },
  "submission_id": 1630614540,
  "mutated_code": "def maxScore(n: int, edges: List[List[int]]) -> int:\n    G = [[] for _ in range(n)]\n    D = [0] * n\n    for u, v in edges:\n        G[u].append(v)\n        G[v].append(u)\n        D[u] += 1\n        D[v] += 1\n    seen = [0] * n\n    cp = []\n    for i in range(n):\n        if seen[i]:\n            continue\n        _t = [i]\n        seen[i] = 1\n        nodes = []\n        _sum = 0\n        while _t:\n            u = _t.pop()\n            nodes.append(u)\n            _sum += D[u]\n            for v in G[u]:\n                if seen[v]:\n                    continue\n                seen[v] = 1\n                _t.append(v)\n        E = _sum // 2\n        B = None\n        if E == len(nodes):\n            for u in nodes:\n                for v in G[u]:\n                    if u < v and v in nodes:\n                        B = (u, v)\n                        break\n                if B:\n                    break\n        cp.append((2 * E / len(nodes), len(nodes), E, nodes, B))\n    cp.sort(key=lambda x: (-x[0], -x[1]))\n    ret = [0] * n\n    high = n\n    for _, c, E, nodes, B in cp:\n        low = high - c - 1\n        high -= c\n        arr = list(range(low, low + c))\n        L = {u: len(G[u]) - (1 if B and (u == B[0] and B[1] in G[u] or (u == B[1] and B[0] in G[u])) else 0) for u in nodes}\n        t = 0\n        q = deque((u for u in nodes if L[u] <= 1))\n        while q:\n            u = q.popleft()\n            if ret[u]:\n                continue\n            ret[u] = arr[t]\n            t += 1\n            for v in G[u]:\n                if B:\n                    if u == B[0] and v == B[1] or (u == B[1] and v == B[0]):\n                        continue\n                L[v] -= 1\n                if L[v] == 1:\n                    q.append(v)\n    ans = 0\n    for u, v in edges:\n        ans += ret[u] * ret[v]\n    return ans",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 6,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest445_q3813_s0",
  "question_id": 3813,
  "function_name": "smallestPalindrome",
  "code": "def smallestPalindrome(s: str, k: int) -> str:\n        freq = [0] * 26\n        for ch in s:\n            freq[ord(ch) - ord('a')] += 1\n\n        half_counts = [count // 2 for count in freq]\n        L = sum(half_counts)\n        center = \"\"\n        for i in range(26):\n            if freq[i] % 2 == 1:\n                center = chr(i + ord('a'))\n                break\n        \n        def count_permutations(counts, cap_value):\n            total = sum(counts)\n            result = 1\n            rem = total\n            for m in counts:\n                if m > 0:\n                    result *= comb(rem, m)\n                    if result > cap_value:\n                        return cap_value\n                    rem -= m\n            return result\n\n        total_count = count_permutations(half_counts, k + 1)\n        if total_count < k:\n            return \"\"\n\n        first_half = []\n        for _ in range(L):\n            for letter in range(26):\n                if half_counts[letter] > 0:\n                    half_counts[letter] -= 1\n                    count_here = count_permutations(half_counts, k + 1)\n                    if count_here >= k:\n                        first_half.append(chr(letter + ord('a')))\n                        break\n                    else:\n                        k -= count_here\n                        half_counts[letter] += 1\n            else:\n                return \"\"\n        first_half_str = \"\".join(first_half)\n        return first_half_str + center + first_half_str[::-1]\n",
  "input": "smallestPalindrome(s=\"abba\", k=2)",
  "output": "'baab'",
  "correct_condition": "smallestPalindrome(s=\"abba\", k=2) == 'baab'",
  "contest_id": "weekly-contest-445",
  "contest_date": "2025-04-13T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 45,
    "coverage": null
  },
  "submission_id": 1605121925,
  "mutated_code": "def smallestPalindrome(s: str, k: int) -> str:\n    freq = [0] * 26\n    for ch in s:\n        freq[ord(ch) - ord('a')] += 1\n    half_counts = [count * 2 for count in freq]\n    L = sum(half_counts)\n    center = ''\n    for i in range(26):\n        if freq[i] % 2 == 1:\n            center = chr(i + ord('a'))\n            break\n\n    def count_permutations(counts, cap_value):\n        total = sum(counts)\n        result = 1\n        rem = total\n        for m in counts:\n            if m > 0:\n                result *= comb(rem, m)\n                if result > cap_value:\n                    return cap_value\n                rem -= m\n        return result\n    total_count = count_permutations(half_counts, k + 1)\n    if total_count < k:\n        return ''\n    first_half = []\n    for _ in range(L):\n        for letter in range(26):\n            if half_counts[letter] > 0:\n                half_counts[letter] -= 1\n                count_here = count_permutations(half_counts, k + 1)\n                if count_here >= k:\n                    first_half.append(chr(letter + ord('a')))\n                    break\n                else:\n                    k -= count_here\n                    half_counts[letter] += 1\n        else:\n            return ''\n    first_half_str = ''.join(first_half)\n    return first_half_str + center + first_half_str[::-1]",
  "mutated_output": "'aaababbbbbbabaaa'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q4027_s1",
  "question_id": 4027,
  "function_name": "countStableSubsequences",
  "code": "def countStableSubsequences(nums: List[int]) -> int:\n    MOD = 1_000_000_007\n    E1 = E2 = O1 = O2 = 0\n\n    for a in nums:\n        if a % 2 == 0:\n            newE1 = (E1 + O1 + O2 + 1) % MOD\n            newE2 = (E2 + E1) % MOD\n            E1, E2 = newE1, newE2\n        else:\n            newO1 = (O1 + E1 + E2 + 1) % MOD\n            newO2 = (O2 + O1) % MOD\n            O1, O2 = newO1, newO2\n    return (E1 + E2 + O1 + O2) % MOD",
  "input": "countStableSubsequences(nums=[1,3,5])",
  "output": "6",
  "correct_condition": "countStableSubsequences(nums=[1,3,5]) == 6",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1769973511,
  "mutated_code": "def countStableSubsequences(nums: List[int]) -> int:\n    MOD = 1000000007\n    E1 = E2 = O1 = O2 = 0\n    for a in nums:\n        if a // 2 == 0:\n            newE1 = (E1 + O1 + O2 + 1) % MOD\n            newE2 = (E2 + E1) % MOD\n            E1, E2 = (newE1, newE2)\n        else:\n            newO1 = (O1 + E1 + E2 + 1) % MOD\n            newO2 = (O2 + O1) % MOD\n            O1, O2 = (newO1, newO2)\n    return (E1 + E2 + O1 + O2) % MOD",
  "mutated_output": "7",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest457_q3922_s2",
  "question_id": 3922,
  "function_name": "minMoves",
  "code": "def minMoves(sx: int, sy: int, tx: int, ty: int) -> int:\n        if sx == tx and sy == ty:\n            return 0\n        if sx == 0 and sy == 0:\n            return -1\n        q = deque([(tx, ty, 0)])\n        seen = {(tx, ty)}\n        while q:\n            x, y, d = q.popleft()\n            if x == sx and y == sy:\n                return d\n            if x < sx or y < sy:\n                continue\n            if x == y:\n                for nx, ny in ((x, 0), (0, y)):\n                    if (nx, ny) not in seen:\n                        seen.add((nx, ny))\n                        q.append((nx, ny, d + 1))\n            elif x > y:\n                diff = x - y\n                if diff <= y and (diff, y) not in seen:\n                    seen.add((diff, y))\n                    q.append((diff, y, d + 1))\n                if x % 2 == 0:\n                    half = x // 2\n                    if half >= y and (half, y) not in seen:\n                        seen.add((half, y))\n                        q.append((half, y, d + 1))\n            else:\n                diff = y - x\n                if diff <= x and (x, diff) not in seen:\n                    seen.add((x, diff))\n                    q.append((x, diff, d + 1))\n                if y % 2 == 0:\n                    half = y // 2\n                    if half >= x and (x, half) not in seen:\n                        seen.add((x, half))\n                        q.append((x, half, d + 1))\n        return -1\n",
  "input": "minMoves(sx=1, sy=2, tx=5, ty=4)",
  "output": "2",
  "correct_condition": "minMoves(sx=1, sy=2, tx=5, ty=4) == 2",
  "contest_id": "weekly-contest-457",
  "contest_date": "2025-07-06T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 39,
    "coverage": null
  },
  "submission_id": 1687870593,
  "mutated_code": "def minMoves(sx: int, sy: int, tx: int, ty: int) -> int:\n    if sx == tx and sy == ty:\n        return 0\n    if sx == 0 and sy == 0:\n        return -1\n    q = deque([(tx, ty, 0)])\n    seen = {(tx, ty)}\n    while q:\n        x, y, d = q.popleft()\n        if x == sx and y == sy:\n            return d\n        if x < sx or y < sy:\n            continue\n        if x == y:\n            for nx, ny in ((x, 0), (0, y)):\n                if (nx, ny) not in seen:\n                    seen.add((nx, ny))\n                    q.append((nx, ny, d + 1))\n        elif x > y:\n            diff = x + y\n            if diff <= y and (diff, y) not in seen:\n                seen.add((diff, y))\n                q.append((diff, y, d + 1))\n            if x % 2 == 0:\n                half = x // 2\n                if half >= y and (half, y) not in seen:\n                    seen.add((half, y))\n                    q.append((half, y, d + 1))\n        else:\n            diff = y - x\n            if diff <= x and (x, diff) not in seen:\n                seen.add((x, diff))\n                q.append((x, diff, d + 1))\n            if y % 2 == 0:\n                half = y // 2\n                if half >= x and (x, half) not in seen:\n                    seen.add((x, half))\n                    q.append((x, half, d + 1))\n    return -1",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3744_s2",
  "question_id": 3744,
  "function_name": "minOperations",
  "code": "def minOperations(queries: List[List[int]]) -> int:\n        result = []\n        k = 1\n        while True:\n            low = 4 ** (k - 1)\n            high = 4 ** k - 1\n            if low > 10 ** 9:\n                break\n            result.append((low, high, k))\n            k += 1\n\n        # print(result)\n        ans = 0\n        for q in queries:\n            l = q[0]\n            r = q[1]\n            _sum = 0\n            for a, b, c in result:\n                if b >= l and a <= r:\n                    x = max(l, a)\n                    y = min(r, b)\n                    _sum += c * (y - x + 1)\n                    # print(f'x: {x}, y: {y}, c: {c}, _sum: {_sum}')\n            ans += (_sum + 1) // 2\n            # print(f'ans: {ans}')\n        # print(ans)\n        return ans",
  "input": "minOperations(queries=[[1,2],[2,4]])",
  "output": "3",
  "correct_condition": "minOperations(queries=[[1,2],[2,4]]) == 3",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 27,
    "coverage": null
  },
  "submission_id": 1582837946,
  "mutated_code": "def minOperations(queries: List[List[int]]) -> int:\n    result = []\n    k = 1\n    while True:\n        low = 4 ** (k + 1)\n        high = 4 ** k - 1\n        if low > 10 ** 9:\n            break\n        result.append((low, high, k))\n        k += 1\n    ans = 0\n    for q in queries:\n        l = q[0]\n        r = q[1]\n        _sum = 0\n        for a, b, c in result:\n            if b >= l and a <= r:\n                x = max(l, a)\n                y = min(r, b)\n                _sum += c * (y - x + 1)\n        ans += (_sum + 1) // 2\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest447_q3852_s0",
  "question_id": 3852,
  "function_name": "pathExistenceQueries",
  "code": "def pathExistenceQueries(n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[int]:\n        arr = [(nums[i], i) for i in range(n)]\n        arr.sort(key=lambda x: x[0])\n        sv = [a for a, _ in arr]\n        si = [i for _, i in arr]\n        pos = [0] * n\n        for j in range(n):\n            pos[si[j]] = j\n        comp = [0] * n\n        for i in range(1, n):\n            comp[i] = comp[i - 1] + (1 if sv[i] - sv[i - 1] > maxDiff else 0)\n        r = [0] * n\n        j = 0\n        for i in range(n):\n            while j < n and sv[j] - sv[i] <= maxDiff:\n                j += 1\n            r[i] = j - 1\n        L = n.bit_length()\n        f = [r[:]]\n        for p in range(1, L):\n            fp = [0] * n\n            for i in range(n):\n                fp[i] = f[p - 1][f[p - 1][i]]\n            f.append(fp)\n        def jump(a, b):\n            if sv[b] - sv[a] <= maxDiff:\n                return 1\n            steps, cur = 0, a\n            for p in range(L - 1, -1, -1):\n                if f[p][cur] < b:\n                    cur = f[p][cur]\n                    steps += 1 << p\n            return steps + 1 if f[0][cur] >= b else -1\n        res = []\n        for u, v in queries:\n            if u == v:\n                res.append(0)\n                continue\n            a, b = pos[u], pos[v]\n            if a > b:\n                a, b = b, a\n            if comp[a] != comp[b]:\n                res.append(-1)\n            else:\n                res.append(jump(a, b))\n        return res",
  "input": "pathExistenceQueries(n=5, nums=[1,8,3,4,2], maxDiff=3, queries=[[0,3],[2,4]])",
  "output": "[1, 1]",
  "correct_condition": "pathExistenceQueries(n=5, nums=[1,8,3,4,2], maxDiff=3, queries=[[0,3],[2,4]]) == [1, 1]",
  "contest_id": "weekly-contest-447",
  "contest_date": "2025-04-27T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 46,
    "coverage": null
  },
  "submission_id": 1618879937,
  "mutated_code": "def pathExistenceQueries(n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[int]:\n    arr = [(nums[i], i) for i in range(n)]\n    arr.sort(key=lambda x: x[0])\n    sv = [a for a, _ in arr]\n    si = [i for _, i in arr]\n    pos = [0] * n\n    for j in range(n):\n        pos[si[j]] = j\n    comp = [0] * n\n    for i in range(1, n):\n        comp[i] = comp[i - 1] + (1 if sv[i] + sv[i - 1] > maxDiff else 0)\n    r = [0] * n\n    j = 0\n    for i in range(n):\n        while j < n and sv[j] - sv[i] <= maxDiff:\n            j += 1\n        r[i] = j - 1\n    L = n.bit_length()\n    f = [r[:]]\n    for p in range(1, L):\n        fp = [0] * n\n        for i in range(n):\n            fp[i] = f[p - 1][f[p - 1][i]]\n        f.append(fp)\n\n    def jump(a, b):\n        if sv[b] - sv[a] <= maxDiff:\n            return 1\n        steps, cur = (0, a)\n        for p in range(L - 1, -1, -1):\n            if f[p][cur] < b:\n                cur = f[p][cur]\n                steps += 1 << p\n        return steps + 1 if f[0][cur] >= b else -1\n    res = []\n    for u, v in queries:\n        if u == v:\n            res.append(0)\n            continue\n        a, b = (pos[u], pos[v])\n        if a > b:\n            a, b = (b, a)\n        if comp[a] != comp[b]:\n            res.append(-1)\n        else:\n            res.append(jump(a, b))\n    return res",
  "mutated_output": "[-1, -1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 4,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest435_q3761_s0",
  "question_id": 3761,
  "function_name": "maxDifference",
  "code": "def maxDifference(s: str, k: int) -> int:\n        INF = 10**9\n        n = len(s)\n        ans = -10**9\n        for x in range(5):\n            for y in range(5):\n                if x == y:\n                    continue\n                N = n + 1\n                D = [0] * N\n                PX = [0] * N\n                PY = [0] * N\n                CNT = [0] * N\n                sx = str(x)\n                sy = str(y)\n                for i in range(n):\n                    D[i+1] = D[i] + (1 if s[i] == sx else 0) - (1 if s[i] == sy else 0)\n                    PX[i+1] = (PX[i] + (1 if s[i] == sx else 0)) & 1\n                    PY[i+1] = (PY[i] + (1 if s[i] == sy else 0)) & 1\n                    CNT[i+1] = CNT[i] + (1 if s[i] == sy else 0)\n                mp = {(0,0): [], (0,1): [], (1,0): [], (1,1): []}\n                cum = {(0,0): [], (0,1): [], (1,0): [], (1,1): []}\n                key0 = (PX[0], PY[0])\n                mp[key0].append((CNT[0], D[0]))\n                cum[key0].append(D[0])\n                best = -10**9\n                p = 1\n                for r in range(k, N):\n                    while p <= r - k:\n                        key = (PX[p], PY[p])\n                        mp[key].append((CNT[p], D[p]))\n                        if cum[key]:\n                            cum[key].append(min(cum[key][-1], D[p]))\n                        else:\n                            cum[key].append(D[p])\n                        p += 1\n                    keyq = (1 - PX[r], PY[r])\n                    arr = mp[keyq]\n                    if not arr:\n                        continue\n                    pos = bisect_left(arr, (CNT[r], -10**9))\n                    if pos:\n                        cand = D[r] - cum[keyq][pos-1]\n                        if cand > best:\n                            best = cand\n                if best > ans:\n                    ans = best\n        return ans\n\n",
  "input": "maxDifference(s=\"12233\", k=4)",
  "output": "-1",
  "correct_condition": "maxDifference(s=\"12233\", k=4) == -1",
  "contest_id": "weekly-contest-435",
  "contest_date": "2025-02-02T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 49,
    "coverage": null
  },
  "submission_id": 1528104807,
  "mutated_code": "def maxDifference(s: str, k: int) -> int:\n    INF = 10 ** 9\n    n = len(s)\n    ans = -10 ** 9\n    for x in range(5):\n        for y in range(5):\n            if x == y:\n                continue\n            N = n + 1\n            D = [0] * N\n            PX = [0] * N\n            PY = [0] * N\n            CNT = [0] * N\n            sx = str(x)\n            sy = str(y)\n            for i in range(n):\n                D[i - 1] = D[i] + (1 if s[i] == sx else 0) - (1 if s[i] == sy else 0)\n                PX[i + 1] = PX[i] + (1 if s[i] == sx else 0) & 1\n                PY[i + 1] = PY[i] + (1 if s[i] == sy else 0) & 1\n                CNT[i + 1] = CNT[i] + (1 if s[i] == sy else 0)\n            mp = {(0, 0): [], (0, 1): [], (1, 0): [], (1, 1): []}\n            cum = {(0, 0): [], (0, 1): [], (1, 0): [], (1, 1): []}\n            key0 = (PX[0], PY[0])\n            mp[key0].append((CNT[0], D[0]))\n            cum[key0].append(D[0])\n            best = -10 ** 9\n            p = 1\n            for r in range(k, N):\n                while p <= r - k:\n                    key = (PX[p], PY[p])\n                    mp[key].append((CNT[p], D[p]))\n                    if cum[key]:\n                        cum[key].append(min(cum[key][-1], D[p]))\n                    else:\n                        cum[key].append(D[p])\n                    p += 1\n                keyq = (1 - PX[r], PY[r])\n                arr = mp[keyq]\n                if not arr:\n                    continue\n                pos = bisect_left(arr, (CNT[r], -10 ** 9))\n                if pos:\n                    cand = D[r] - cum[keyq][pos - 1]\n                    if cand > best:\n                        best = cand\n            if best > ans:\n                ans = best\n    return ans",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 5,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest443_q3808_s0",
  "question_id": 3808,
  "function_name": "longestPalindrome",
  "code": "def longestPalindrome(s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        palS = [[False] * n for _ in range(n)]\n        for i in range(n):\n            palS[i][i] = True\n        for i in range(n - 1):\n            palS[i][i + 1] = (s[i] == s[i + 1])\n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                palS[i][j] = (s[i] == s[j] and palS[i + 1][j - 1])\n        left_pal = [0] * n\n        for i in range(n):\n            mx = 0\n            for j in range(i, n):\n                if palS[i][j]:\n                    cur = j - i + 1\n                    if cur > mx:\n                        mx = cur\n            left_pal[i] = mx\n        longest_s = max(left_pal) if n else 0\n\n        palT = [[False] * m for _ in range(m)]\n        for i in range(m):\n            palT[i][i] = True\n        for i in range(m - 1):\n            palT[i][i + 1] = (t[i] == t[i + 1])\n        for length in range(3, m + 1):\n            for i in range(m - length + 1):\n                j = i + length - 1\n                palT[i][j] = (t[i] == t[j] and palT[i + 1][j - 1])\n        right_pal = [0] * m\n        for j in range(m):\n            mx = 0\n            for i in range(j + 1):\n                if palT[i][j]:\n                    cur = j - i + 1\n                    if cur > mx:\n                        mx = cur\n            right_pal[j] = mx\n        longest_t = max(right_pal) if m else 0\n\n        best = max(longest_s, longest_t)\n        R = t[::-1]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == R[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    L = dp[i][j]\n                    extra1 = left_pal[i] if i < n else 0\n                    cand1 = 2 * L + extra1\n                    if cand1 > best:\n                        best = cand1\n                    p = m - j\n                    extra2 = right_pal[p - 1] if p > 0 else 0\n                    cand2 = 2 * L + extra2\n                    if cand2 > best:\n                        best = cand2\n                else:\n                    dp[i][j] = 0\n        return best",
  "input": "longestPalindrome(s=\"a\", t=\"a\")",
  "output": "2",
  "correct_condition": "longestPalindrome(s=\"a\", t=\"a\") == 2",
  "contest_id": "weekly-contest-443",
  "contest_date": "2025-03-30T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 62,
    "coverage": null
  },
  "submission_id": 1590625901,
  "mutated_code": "def longestPalindrome(s: str, t: str) -> int:\n    n, m = (len(s), len(t))\n    palS = [[False] * n for _ in range(n)]\n    for i in range(n):\n        palS[i][i] = True\n    for i in range(n - 1):\n        palS[i][i + 1] = s[i] == s[i + 1]\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            palS[i][j] = s[i] == s[j] and palS[i + 1][j - 1]\n    left_pal = [0] * n\n    for i in range(n):\n        mx = 0\n        for j in range(i, n):\n            if palS[i][j]:\n                cur = j - i + 1\n                if cur > mx:\n                    mx = cur\n        left_pal[i] = mx\n    longest_s = max(left_pal) if n else 0\n    palT = [[False] * m for _ in range(m)]\n    for i in range(m):\n        palT[i][i] = True\n    for i in range(m - 1):\n        palT[i][i + 1] = t[i] == t[i + 1]\n    for length in range(3, m + 1):\n        for i in range(m - length + 1):\n            j = i + length - 1\n            palT[i][j] = t[i] == t[j] and palT[i + 1][j - 1]\n    right_pal = [0] * m\n    for j in range(m):\n        mx = 0\n        for i in range(j + 1):\n            if palT[i][j]:\n                cur = j - i + 1\n                if cur > mx:\n                    mx = cur\n        right_pal[j] = mx\n    longest_t = max(right_pal) if m else 0\n    best = max(longest_s, longest_t)\n    R = t[::-1]\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n - 1):\n        for j in range(1, m + 1):\n            if s[i - 1] == R[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                L = dp[i][j]\n                extra1 = left_pal[i] if i < n else 0\n                cand1 = 2 * L + extra1\n                if cand1 > best:\n                    best = cand1\n                p = m - j\n                extra2 = right_pal[p - 1] if p > 0 else 0\n                cand2 = 2 * L + extra2\n                if cand2 > best:\n                    best = cand2\n            else:\n                dp[i][j] = 0\n    return best",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 32,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest433_q3725_s0",
  "question_id": 3725,
  "function_name": "minMaxSubarraySum",
  "code": "def minMaxSubarraySum(nums, k):\n        def p(L,R,M):\n            u=min(L,M-1)\n            if u<=0:return 0\n            if R>=M-1:return M*u - u*(u+1)//2\n            x=M-R\n            if x>u:return R*u\n            s=R*(x-1)\n            s+=M*(u-x+1)-((u*(u+1))//2-((x-1)*x)//2)\n            return s\n        def s(a,k,m):\n            n=len(a)\n            l=[0]*n\n            r=[0]*n\n            st=[]\n            for i in range(n):\n                while st and ((a[st[-1]]>a[i]) if m else (a[st[-1]]<a[i])):\n                    st.pop()\n                l[i]=i-st[-1] if st else i+1\n                st.append(i)\n            st=[]\n            for i in range(n-1,-1,-1):\n                while st and ((a[st[-1]]>=a[i]) if m else (a[st[-1]]<=a[i])):\n                    st.pop()\n                r[i]=st[-1]-i if st else n-i\n                st.append(i)\n            res=0\n            for i in range(n):\n                res+=a[i]*p(l[i],r[i],k+1)\n            return res\n        return s(nums,k,True)+s(nums,k,False)",
  "input": "minMaxSubarraySum(nums=[1,2,3], k=2)",
  "output": "20",
  "correct_condition": "minMaxSubarraySum(nums=[1,2,3], k=2) == 20",
  "contest_id": "weekly-contest-433",
  "contest_date": "2025-01-19T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 31,
    "coverage": null
  },
  "submission_id": 1513090643,
  "mutated_code": "def minMaxSubarraySum(nums, k):\n\n    def p(L, R, M):\n        u = min(L, M - 1)\n        if u <= 0:\n            return 0\n        if R >= M - 1:\n            return M * u + u * (u + 1) // 2\n        x = M - R\n        if x > u:\n            return R * u\n        s = R * (x - 1)\n        s += M * (u - x + 1) - (u * (u + 1) // 2 - (x - 1) * x // 2)\n        return s\n\n    def s(a, k, m):\n        n = len(a)\n        l = [0] * n\n        r = [0] * n\n        st = []\n        for i in range(n):\n            while st and (a[st[-1]] > a[i] if m else a[st[-1]] < a[i]):\n                st.pop()\n            l[i] = i - st[-1] if st else i + 1\n            st.append(i)\n        st = []\n        for i in range(n - 1, -1, -1):\n            while st and (a[st[-1]] >= a[i] if m else a[st[-1]] <= a[i]):\n                st.pop()\n            r[i] = st[-1] - i if st else n - i\n            st.append(i)\n        res = 0\n        for i in range(n):\n            res += a[i] * p(l[i], r[i], k + 1)\n        return res\n    return s(nums, k, True) + s(nums, k, False)",
  "mutated_output": "26",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest447_q3841_s2",
  "question_id": 3841,
  "function_name": "concatenatedDivisibility",
  "code": "def concatenatedDivisibility(nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        FULL = (1<<n) - 1\n\n        L = [len(str(x)) for x in nums]\n        pow10L = [pow(10, L[i], k) for i in range(n)]\n\n        idxs = sorted(range(n), key=lambda i: nums[i])\n\n        dq = deque()\n        seen = set()\n\n        for i in idxs:\n            m = 1<<i\n            r = nums[i] % k\n            seq = [nums[i]]\n            state = (m, r)\n            dq.append((m, r, seq))\n            seen.add(state)\n\n        while dq:\n            mask, rem, seq = dq.popleft()\n            if mask == FULL and rem == 0:\n                return seq\n\n            for i in idxs:\n                bit = 1<<i\n                if mask & bit: \n                    continue\n                nm = mask | bit\n\n                nr = (rem * pow10L[i] + nums[i]) % k\n                st = (nm, nr)\n                if st in seen:\n                    continue\n                seen.add(st)\n                dq.append((nm, nr, seq + [nums[i]]))\n\n        return []  ",
  "input": "concatenatedDivisibility(nums=[3,12,45], k=5)",
  "output": "[3, 12, 45]",
  "correct_condition": "concatenatedDivisibility(nums=[3,12,45], k=5) == [3, 12, 45]",
  "contest_id": "weekly-contest-447",
  "contest_date": "2025-04-27T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 39,
    "coverage": null
  },
  "submission_id": 1618878091,
  "mutated_code": "def concatenatedDivisibility(nums: List[int], k: int) -> List[int]:\n    n = len(nums)\n    FULL = (1 << n) + 1\n    L = [len(str(x)) for x in nums]\n    pow10L = [pow(10, L[i], k) for i in range(n)]\n    idxs = sorted(range(n), key=lambda i: nums[i])\n    dq = deque()\n    seen = set()\n    for i in idxs:\n        m = 1 << i\n        r = nums[i] % k\n        seq = [nums[i]]\n        state = (m, r)\n        dq.append((m, r, seq))\n        seen.add(state)\n    while dq:\n        mask, rem, seq = dq.popleft()\n        if mask == FULL and rem == 0:\n            return seq\n        for i in idxs:\n            bit = 1 << i\n            if mask & bit:\n                continue\n            nm = mask | bit\n            nr = (rem * pow10L[i] + nums[i]) % k\n            st = (nm, nr)\n            if st in seen:\n                continue\n            seen.add(st)\n            dq.append((nm, nr, seq + [nums[i]]))\n    return []",
  "mutated_output": "[]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest449_q3850_s2",
  "question_id": 3850,
  "function_name": "canPartitionGrid",
  "code": "def canPartitionGrid(grid: List[List[int]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        total = sum(sum(row) for row in grid)\n        prefix = [0]*m\n        prefix[0] = sum(grid[0])\n        for i in range(1, m):\n            prefix[i] = prefix[i-1] + sum(grid[i])\n        col_sums = [0]*n\n        for j in range(n):\n            s = 0\n            for i in range(m):\n                s += grid[i][j]\n            col_sums[j] = s\n        vprefix = [0]*n\n        vprefix[0] = col_sums[0]\n        for j in range(1, n):\n            vprefix[j] = vprefix[j-1] + col_sums[j]\n        \n        value_map = {}\n        for i in range(m):\n            for j in range(n):\n                v = grid[i][j]\n                if v not in value_map:\n                    value_map[v] = {}\n                if i not in value_map[v]:\n                    value_map[v][i] = []\n                value_map[v][i].append(j)\n        for v in value_map:\n            for r in value_map[v]:\n                value_map[v][r].sort()\n        \n        def query_value_in_region(v, rlow, rhigh, clow, chigh):\n            if v not in value_map:\n                return False\n            for r in range(rlow, rhigh + 1):\n                if r in value_map[v]:\n                    lst = value_map[v][r]\n                    idx = bisect.bisect_left(lst, clow)\n                    if idx < len(lst) and lst[idx] <= chigh:\n                        return True\n            return False\n\n        def check_partition(rlow, rhigh, clow, chigh, diff):\n            rows = rhigh - rlow + 1\n            cols = chigh - clow + 1\n            if rows * cols == 1:\n                return False\n            if rows > 1 and cols > 1:\n                return query_value_in_region(diff, rlow, rhigh, clow, chigh)\n            else:\n                if rows == 1:\n                    if diff == grid[rlow][clow] or diff == grid[rlow][chigh]:\n                        return True\n                if cols == 1:\n                    if diff == grid[rlow][clow] or diff == grid[rhigh][clow]:\n                        return True\n            return False\n\n        for i in range(m - 1):\n            sum_top = prefix[i]\n            sum_bottom = total - sum_top\n            if sum_top == sum_bottom:\n                return True\n            if sum_top > sum_bottom:\n                diff = sum_top - sum_bottom\n                if check_partition(0, i, 0, n - 1, diff):\n                    return True\n            else:\n                diff = sum_bottom - sum_top\n                if check_partition(i + 1, m - 1, 0, n - 1, diff):\n                    return True\n\n        for j in range(n - 1):\n            sum_left = vprefix[j]\n            sum_right = total - sum_left\n            if sum_left == sum_right:\n                return True\n            if sum_left > sum_right:\n                diff = sum_left - sum_right\n                if check_partition(0, m - 1, 0, j, diff):\n                    return True\n            else:\n                diff = sum_right - sum_left\n                if check_partition(0, m - 1, j + 1, n - 1, diff):\n                    return True\n\n        return False",
  "input": "canPartitionGrid(grid=[[1,4],[2,3]])",
  "output": "True",
  "correct_condition": "canPartitionGrid(grid=[[1,4],[2,3]]) == True",
  "contest_id": "weekly-contest-449",
  "contest_date": "2025-05-11T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 88,
    "coverage": null
  },
  "submission_id": 1630614238,
  "mutated_code": "def canPartitionGrid(grid: List[List[int]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    total = sum((sum(row) for row in grid))\n    prefix = [0] * m\n    prefix[0] = sum(grid[0])\n    for i in range(1, m):\n        prefix[i] = prefix[i - 1] + sum(grid[i])\n    col_sums = [0] * n\n    for j in range(n):\n        s = 0\n        for i in range(m):\n            s += grid[i][j]\n        col_sums[j] = s\n    vprefix = [0] * n\n    vprefix[0] = col_sums[0]\n    for j in range(1, n):\n        vprefix[j] = vprefix[j - 1] + col_sums[j]\n    value_map = {}\n    for i in range(m):\n        for j in range(n):\n            v = grid[i][j]\n            if v not in value_map:\n                value_map[v] = {}\n            if i not in value_map[v]:\n                value_map[v][i] = []\n            value_map[v][i].append(j)\n    for v in value_map:\n        for r in value_map[v]:\n            value_map[v][r].sort()\n\n    def query_value_in_region(v, rlow, rhigh, clow, chigh):\n        if v not in value_map:\n            return False\n        for r in range(rlow, rhigh + 1):\n            if r in value_map[v]:\n                lst = value_map[v][r]\n                idx = bisect.bisect_left(lst, clow)\n                if idx < len(lst) and lst[idx] <= chigh:\n                    return True\n        return False\n\n    def check_partition(rlow, rhigh, clow, chigh, diff):\n        rows = rhigh - rlow + 1\n        cols = chigh - clow + 1\n        if rows * cols == 1:\n            return False\n        if rows > 1 and cols > 1:\n            return query_value_in_region(diff, rlow, rhigh, clow, chigh)\n        else:\n            if rows == 1:\n                if diff == grid[rlow][clow] or diff == grid[rlow][chigh]:\n                    return True\n            if cols == 1:\n                if diff == grid[rlow][clow] or diff == grid[rhigh][clow]:\n                    return True\n        return False\n    for i in range(m - 1):\n        sum_top = prefix[i]\n        sum_bottom = total - sum_top\n        if sum_top == sum_bottom:\n            return False\n        if sum_top > sum_bottom:\n            diff = sum_top - sum_bottom\n            if check_partition(0, i, 0, n - 1, diff):\n                return True\n        else:\n            diff = sum_bottom - sum_top\n            if check_partition(i + 1, m - 1, 0, n - 1, diff):\n                return True\n    for j in range(n - 1):\n        sum_left = vprefix[j]\n        sum_right = total - sum_left\n        if sum_left == sum_right:\n            return True\n        if sum_left > sum_right:\n            diff = sum_left - sum_right\n            if check_partition(0, m - 1, 0, j, diff):\n                return True\n        else:\n            diff = sum_right - sum_left\n            if check_partition(0, m - 1, j + 1, n - 1, diff):\n                return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "keyword",
    "mutation_id": 7,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest464_q3982_s0",
  "question_id": 3982,
  "function_name": "maxWalls",
  "code": "def maxWalls(r: List[int], d: List[int], w: List[int]) -> int:\n        def c(L,R):\n            if L>R:\n                return 0\n            return bisect_right(w,R)-bisect_left(w,L)\n\n        if not w: return 0\n        z=sorted(zip(r,d))\n        r=[p for p,_ in z]\n        d=[q for _,q in z]\n\n        w=sorted(w)\n        n=len(r)\n        cl,cr=[0]*n,[0]*n\n        Ls,Rs=[(0, -1)]*n,[(0, -1)]*n\n        Ls[0]=(r[0]-d[0], r[0])\n        cl[0]=c(Ls[0][0],Ls[0][1])\n        for i in range(1,n):\n            L=max(r[i]-d[i], r[i-1]+1)\n            U=r[i]\n            Ls[i]=(L,U)\n            cl[i]=c(L,U)\n\n        for i in range(n-1):\n            L=r[i]\n            U=min(r[i]+d[i], r[i+1]-1)\n            Rs[i]=(L,U)\n            cr[i]=c(L,U)\n\n        Rs[n-1]=(r[n-1], r[n-1]+d[n-1])\n        cr[n-1]=c(Rs[n-1][0],Rs[n-1][1])\n        cu=[0]*(n-1)\n        for i in range(n-1):\n            aL,aU=Rs[i]\n            bL,bU=Ls[i+1]\n            if aL>aU and bL>bU: cu[i]=0\n            elif aL>aU: cu[i]=cl[i+1]\n            elif bL>bU: cu[i]=cr[i]\n            else:\n                s=aL if aL>bL else bL\n                t=aU if aU<bU else bU\n                ov=c(s,t) if s<=t else 0\n                cu[i]=cr[i]+cl[i+1]-ov\n\n        dl,dr=cl[0],0\n        for i in range(n-1):\n            nl=dr+cu[i] if dr+cu[i]>dl+cl[i+1] else dl+cl[i+1]\n            nr=dr+cr[i] if dr+cr[i]>dl else dl\n            dl,nr=nl,nr\n            dr=nr\n\n        res=dr+cr[n-1] if dr+cr[n-1]>dl else dl\n        return res",
  "input": "maxWalls(r=[4], d=[3], w=[1,10])",
  "output": "1",
  "correct_condition": "maxWalls(r=[4], d=[3], w=[1,10]) == 1",
  "contest_id": "weekly-contest-464",
  "contest_date": "2025-08-24T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 53,
    "coverage": null
  },
  "submission_id": 1746019664,
  "mutated_code": "def maxWalls(r: List[int], d: List[int], w: List[int]) -> int:\n\n    def c(L, R):\n        if L > R:\n            return 0\n        return bisect_right(w, R) + bisect_left(w, L)\n    if not w:\n        return 0\n    z = sorted(zip(r, d))\n    r = [p for p, _ in z]\n    d = [q for _, q in z]\n    w = sorted(w)\n    n = len(r)\n    cl, cr = ([0] * n, [0] * n)\n    Ls, Rs = ([(0, -1)] * n, [(0, -1)] * n)\n    Ls[0] = (r[0] - d[0], r[0])\n    cl[0] = c(Ls[0][0], Ls[0][1])\n    for i in range(1, n):\n        L = max(r[i] - d[i], r[i - 1] + 1)\n        U = r[i]\n        Ls[i] = (L, U)\n        cl[i] = c(L, U)\n    for i in range(n - 1):\n        L = r[i]\n        U = min(r[i] + d[i], r[i + 1] - 1)\n        Rs[i] = (L, U)\n        cr[i] = c(L, U)\n    Rs[n - 1] = (r[n - 1], r[n - 1] + d[n - 1])\n    cr[n - 1] = c(Rs[n - 1][0], Rs[n - 1][1])\n    cu = [0] * (n - 1)\n    for i in range(n - 1):\n        aL, aU = Rs[i]\n        bL, bU = Ls[i + 1]\n        if aL > aU and bL > bU:\n            cu[i] = 0\n        elif aL > aU:\n            cu[i] = cl[i + 1]\n        elif bL > bU:\n            cu[i] = cr[i]\n        else:\n            s = aL if aL > bL else bL\n            t = aU if aU < bU else bU\n            ov = c(s, t) if s <= t else 0\n            cu[i] = cr[i] + cl[i + 1] - ov\n    dl, dr = (cl[0], 0)\n    for i in range(n - 1):\n        nl = dr + cu[i] if dr + cu[i] > dl + cl[i + 1] else dl + cl[i + 1]\n        nr = dr + cr[i] if dr + cr[i] > dl else dl\n        dl, nr = (nl, nr)\n        dr = nr\n    res = dr + cr[n - 1] if dr + cr[n - 1] > dl else dl\n    return res",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3696_s0",
  "question_id": 3696,
  "function_name": "countSubstrings",
  "code": "def countSubstrings(s: str) -> int:\n        n = len(s)\n        res = 0\n        \n        mod3 = [1, 0, 0]\n        sum3 = 0\n    \n        mod9 = [1] + [0] * 8\n        sum9 = 0\n    \n        mod7 = [1] + [0] * 6\n        sum7 = 0\n        \n        pow5 = 1\n    \n        for i, c in enumerate(s):\n            d = int(c)\n            sum3 = (sum3 + d) % 3\n            sum9 = (sum9 + d) % 9\n            sum7 = (sum7 * 10 + d) % 7\n            R = (sum7 * pow5) % 7\n    \n            if c in '125':\n                res += (i + 1)\n            elif c in '36':\n                res += mod3[sum3]\n            elif c == '9':\n                res += mod9[sum9]\n            elif c == '4':\n                if i == 0:\n                    res += 1\n                else:\n                    v = int(s[i - 1]) * 10 + d\n                    if v % 4 == 0:\n                        res += (i + 1)\n                    else:\n                        res += 1\n            elif c == '8':\n                if i == 0:\n                    res += 1\n                elif i == 1:\n                    v = int(s[i - 1]) * 10 + d\n                    if v % 8 == 0:\n                        res += 2\n                    else:\n                        res += 1\n                else:\n                    v1 = int(s[i - 1]) * 10 + d\n                    v2 = int(s[i - 2]) * 100 + int(s[i - 1]) * 10 + d\n                    add_two = 1 if v1 % 8 == 0 else 0\n                    add_three = (i - 1) if v2 % 8 == 0 else 0\n                    res += 1 + add_two + add_three\n    \n            if c == '7':\n                res += mod7[R]\n    \n            mod3[sum3] += 1\n            mod9[sum9] += 1\n            mod7[R] += 1\n    \n            pow5 = (pow5 * 5) % 7\n            # print(res)\n    \n        return res",
  "input": "countSubstrings(s=\"12936\")",
  "output": "11",
  "correct_condition": "countSubstrings(s=\"12936\") == 11",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 64,
    "coverage": null
  },
  "submission_id": 1536442634,
  "mutated_code": "def countSubstrings(s: str) -> int:\n    n = len(s)\n    res = 0\n    mod3 = [1, 0, 0]\n    sum3 = 0\n    mod9 = [1] + [0] * 8\n    sum9 = 0\n    mod7 = [1] + [0] * 6\n    sum7 = 0\n    pow5 = 1\n    for i, c in enumerate(s):\n        d = int(c)\n        sum3 = (sum3 + d) % 3\n        sum9 = (sum9 + d) // 9\n        sum7 = (sum7 * 10 + d) % 7\n        R = sum7 * pow5 % 7\n        if c in '125':\n            res += i + 1\n        elif c in '36':\n            res += mod3[sum3]\n        elif c == '9':\n            res += mod9[sum9]\n        elif c == '4':\n            if i == 0:\n                res += 1\n            else:\n                v = int(s[i - 1]) * 10 + d\n                if v % 4 == 0:\n                    res += i + 1\n                else:\n                    res += 1\n        elif c == '8':\n            if i == 0:\n                res += 1\n            elif i == 1:\n                v = int(s[i - 1]) * 10 + d\n                if v % 8 == 0:\n                    res += 2\n                else:\n                    res += 1\n            else:\n                v1 = int(s[i - 1]) * 10 + d\n                v2 = int(s[i - 2]) * 100 + int(s[i - 1]) * 10 + d\n                add_two = 1 if v1 % 8 == 0 else 0\n                add_three = i - 1 if v2 % 8 == 0 else 0\n                res += 1 + add_two + add_three\n        if c == '7':\n            res += mod7[R]\n        mod3[sum3] += 1\n        mod9[sum9] += 1\n        mod7[R] += 1\n        pow5 = pow5 * 5 % 7\n    return res",
  "mutated_output": "10",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 6,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3744_s1",
  "question_id": 3744,
  "function_name": "minOperations",
  "code": "def minOperations(queries: List[List[int]]) -> int:\n        p = [1] * 16\n        for i in range(1, 16):\n            p[i] = p[i - 1] * 4\n        ans = 0\n        for l, r in queries:\n            total = 0\n            for t in range(1, 16):\n                L = p[t - 1]\n                R = p[t] - 1\n                lo = l if l > L else L\n                hi = r if r < R else R\n                if lo <= hi:\n                    total += t * (hi - lo + 1)\n            tmax = 0\n            for t in range(1, 16):\n                if r <= p[t] - 1:\n                    tmax = t\n                    break\n            ops = (total + 1) // 2\n            if tmax > ops:\n                ops = tmax\n            ans += ops\n        return ans",
  "input": "minOperations(queries=[[1,2],[2,4]])",
  "output": "3",
  "correct_condition": "minOperations(queries=[[1,2],[2,4]]) == 3",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 24,
    "coverage": null
  },
  "submission_id": 1582831208,
  "mutated_code": "def minOperations(queries: List[List[int]]) -> int:\n    p = [1] * 16\n    for i in range(1, 16):\n        p[i] = p[i - 1] // 4\n    ans = 0\n    for l, r in queries:\n        total = 0\n        for t in range(1, 16):\n            L = p[t - 1]\n            R = p[t] - 1\n            lo = l if l > L else L\n            hi = r if r < R else R\n            if lo <= hi:\n                total += t * (hi - lo + 1)\n        tmax = 0\n        for t in range(1, 16):\n            if r <= p[t] - 1:\n                tmax = t\n                break\n        ops = (total + 1) // 2\n        if tmax > ops:\n            ops = tmax\n        ans += ops\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest458_q3939_s0",
  "question_id": 3939,
  "function_name": "processStr",
  "code": "def processStr(s: str, k: int) -> str:\n        n = len(s)\n        l = [0] * (n + 1)\n        for i, c in enumerate(s):\n            if c == '*':\n                l[i + 1] = max(l[i] - 1, 0)\n            elif c == '#':\n                l[i + 1] = l[i] * 2\n            elif c == '%':\n                l[i + 1] = l[i]\n            else :\n                l[i + 1] = l[i] + 1\n        if k < 0 or k >= l[n]:\n            return '.'\n\n        x = k\n        for i in range(n, 0, -1):\n            c = s[i - 1]\n            p = l[i - 1]\n            if c == '#':\n                if x >= p:\n                    x -= p\n            elif c == '%':\n                x = p - 1 - x\n            elif c == '*':\n                continue\n            else:\n                if x == p:\n                    return c\n        return '.'",
  "input": "processStr(s=\"a#b%*\", k=1)",
  "output": "'a'",
  "correct_condition": "processStr(s=\"a#b%*\", k=1) == 'a'",
  "contest_id": "weekly-contest-458",
  "contest_date": "2025-07-13T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 30,
    "coverage": null
  },
  "submission_id": 1695796312,
  "mutated_code": "def processStr(s: str, k: int) -> str:\n    n = len(s)\n    l = [0] * (n + 1)\n    for i, c in enumerate(s):\n        if c == '*':\n            l[i - 1] = max(l[i] - 1, 0)\n        elif c == '#':\n            l[i + 1] = l[i] * 2\n        elif c == '%':\n            l[i + 1] = l[i]\n        else:\n            l[i + 1] = l[i] + 1\n    if k < 0 or k >= l[n]:\n        return '.'\n    x = k\n    for i in range(n, 0, -1):\n        c = s[i - 1]\n        p = l[i - 1]\n        if c == '#':\n            if x >= p:\n                x -= p\n        elif c == '%':\n            x = p - 1 - x\n        elif c == '*':\n            continue\n        elif x == p:\n            return c\n    return '.'",
  "mutated_output": "'.'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest460_q3882_s1",
  "question_id": 3882,
  "function_name": "maximizeXorAndXor",
  "code": "def maximizeXorAndXor(a: List[int]) -> int:\n        from itertools import combinations as cmb\n        n = len(a)\n        full_mask = (1 << 31) - 1\n        max_res = -sys.maxsize\n        i = j = k = p = q = u = v = x = y = z = 0\n        arr = []\n        tmp = []\n        mask = []\n        comb = []\n        used = set()\n        base = []\n\n        def fx(vec):\n            base.clear()\n            z = 0\n            for val in vec:\n                for b in base:\n                    val = min(val, val ^ b)\n                if val: base.append(val)\n            base.sort(reverse=True)\n            for b in base: z = max(z, z ^ b)\n            return z\n\n        for k in range(min(4, n) + 1):\n            for comb in cmb(range(n), k):\n                q = 0 if not comb else a[comb[0]]\n                for i in comb[1:]: q &= a[i]\n                used = set(comb)\n                x = 0\n                tmp.clear()\n                for j in range(n):\n                    if j not in used:\n                        x ^= a[j]\n                        tmp.append(a[j])\n                mask = [(v & ((~x) & full_mask)) for v in tmp]\n                y = fx(mask) if mask else 0\n                max_res = max(max_res, q + x + 2 * y)\n        return max_res\n",
  "input": "maximizeXorAndXor(a=[2,3])",
  "output": "5",
  "correct_condition": "maximizeXorAndXor(a=[2,3]) == 5",
  "contest_id": "weekly-contest-460",
  "contest_date": "2025-07-27T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 39,
    "coverage": null
  },
  "submission_id": 1712781596,
  "mutated_code": "def maximizeXorAndXor(a: List[int]) -> int:\n    from itertools import combinations as cmb\n    n = len(a)\n    full_mask = (1 << 31) - 1\n    max_res = -sys.maxsize\n    i = j = k = p = q = u = v = x = y = z = 0\n    arr = []\n    tmp = []\n    mask = []\n    comb = []\n    used = set()\n    base = []\n\n    def fx(vec):\n        base.clear()\n        z = 0\n        for val in vec:\n            for b in base:\n                val = min(val, val ^ b)\n            if val:\n                base.append(val)\n        base.sort(reverse=True)\n        for b in base:\n            z = max(z, z ^ b)\n        return z\n    for k in range(min(4, n) + 1):\n        for comb in cmb(range(n), k):\n            q = 0 if not comb else a[comb[0]]\n            for i in comb[1:]:\n                q &= a[i]\n            used = set(comb)\n            x = 0\n            tmp.clear()\n            for j in range(n):\n                if j not in used:\n                    x ^= a[j]\n                    tmp.append(a[j])\n            mask = [v & (~x & full_mask) for v in tmp]\n            y = fx(mask) if mask else 0\n            max_res = max(max_res, q - x + 2 * y)\n    return max_res",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest458_q3930_s0",
  "question_id": 3930,
  "function_name": "maxLen",
  "code": "def maxLen(n: int, e: List[List[int]], l: str) -> int:\n        g = [[] for _ in range(n)]\n        for u, v in e:\n            g[u].append(v); g[v].append(u)\n        q = deque(); vis = set(); ans = 1\n        for i in range(n):\n            m = 1 << i; st = (m, i ,i); q.append(st); vis.add(st)\n        for u, v in e:\n            if l[u] == l[v]:\n                m = (1 << u) | (1 << v); st = (m, u, v); q.append(st); vis.add(st);ans = 2\n\n        while q:\n            m, u, v = q.popleft(); c = m.bit_count()\n            if c > ans: ans = c\n            for x in g[u]:\n                if m >> x & 1: continue\n                for y in g[v]:\n                    if x == y or m >> y & 1: continue\n                    if l[x] != l[y]: continue\n                    nm = m | (1 << x) | (1 << y); st2 = (nm, x, y)\n                    if st2 in vis: continue\n                    vis.add(st2); q.append(st2)\n        return ans\n        ",
  "input": "maxLen(n=3, e=[[0,1],[1,2]], l=\"aba\")",
  "output": "3",
  "correct_condition": "maxLen(n=3, e=[[0,1],[1,2]], l=\"aba\") == 3",
  "contest_id": "weekly-contest-458",
  "contest_date": "2025-07-13T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 24,
    "coverage": null
  },
  "submission_id": 1695805176,
  "mutated_code": "def maxLen(n: int, e: List[List[int]], l: str) -> int:\n    g = [[] for _ in range(n)]\n    for u, v in e:\n        g[u].append(v)\n        g[v].append(u)\n    q = deque()\n    vis = set()\n    ans = 1\n    for i in range(n):\n        m = 1 << i\n        st = (m, i, i)\n        q.append(st)\n        vis.add(st)\n    for u, v in e:\n        if l[u] == l[v]:\n            m = 1 << u | 1 << v\n            st = (m, u, v)\n            q.append(st)\n            vis.add(st)\n            ans = 2\n    while q:\n        m, u, v = q.popleft()\n        c = m.bit_count()\n        if c > ans:\n            ans = c\n        for x in g[u]:\n            if m >> x & 1:\n                continue\n            for y in g[v]:\n                if x == y or m >> y & 1:\n                    continue\n                if l[x] == l[y]:\n                    continue\n                nm = m | 1 << x | 1 << y\n                st2 = (nm, x, y)\n                if st2 in vis:\n                    continue\n                vis.add(st2)\n                q.append(st2)\n    return ans",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest454_q3900_s1",
  "question_id": 3900,
  "function_name": "findMedian",
  "code": "def findMedian(n: int, e: List[List[int]], qs: List[List[int]]) -> List[int]:\n        def lca(x,y):\n            if depth[x]<depth[y]: x,y=y,x\n            diff=depth[x]-depth[y]\n            for i in range(P):\n                if diff>>i&1: x=parent[i][x]\n            if x==y: return x\n            for i in range(P-1,-1,-1):\n                if parent[i][x]!=parent[i][y]:\n                    x=parent[i][x]; y=parent[i][y]\n            return parent[0][x]\n\n        def dfs(u,p):\n            for v,w in g[u]:\n                if v!=p:\n                    parent[0][v]=u; upsum[0][v]=w\n                    depth[v]=depth[u]+1; dsum[v]=dsum[u]+w\n                    dfs(v,u)\n\n        P=(n-1).bit_length()\n        g=[[] for _ in range(n)]\n        for u,v,w in e:\n            g[u].append((v,w)); g[v].append((u,w))\n        parent=[[-1]*n for _ in range(P)]\n        upsum=[[0]*n for _ in range(P)]\n        depth=[0]*n; dsum=[0]*n\n\n        dfs(0,-1)\n        for i in range(1,P):\n            for v in range(n):\n                p0=parent[i-1][v]\n                if p0!=-1:\n                    parent[i][v]=parent[i-1][p0]\n                    upsum[i][v]=upsum[i-1][v]+upsum[i-1][p0]\n\n        res=[]\n        for u,v in qs:\n            if u==v:\n                res.append(u)\n                continue\n            w=lca(u,v)\n            d1=dsum[u]-dsum[w]; d2=dsum[v]-dsum[w]; total=d1+d2\n            if 2*d1>=total:\n                c=u; acc=0\n                for i in range(P-1,-1,-1):\n                    nz=parent[i][c]\n                    if nz!=-1 and acc+2*upsum[i][c]<total:\n                        acc+=2*upsum[i][c]; c=nz\n                c=parent[0][c]\n            else:\n                c=v; acc=0\n                for i in range(P-1,-1,-1):\n                    nz=parent[i][c]\n                    if nz!=-1 and acc+2*upsum[i][c]<=total:\n                        acc+=2*upsum[i][c]; c=nz\n            res.append(c)\n        return res",
  "input": "findMedian(n=2, e=[[0,1,7]], qs=[[1,0],[0,1]])",
  "output": "[0, 1]",
  "correct_condition": "findMedian(n=2, e=[[0,1,7]], qs=[[1,0],[0,1]]) == [0, 1]",
  "contest_id": "weekly-contest-454",
  "contest_date": "2025-06-15T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 57,
    "coverage": null
  },
  "submission_id": 1664400150,
  "mutated_code": "def findMedian(n: int, e: List[List[int]], qs: List[List[int]]) -> List[int]:\n\n    def lca(x, y):\n        if depth[x] < depth[y]:\n            x, y = (y, x)\n        diff = depth[x] - depth[y]\n        for i in range(P):\n            if diff >> i & 1:\n                x = parent[i][x]\n        if x == y:\n            return x\n        for i in range(P - 1, -1, -1):\n            if parent[i][x] != parent[i][y]:\n                x = parent[i][x]\n                y = parent[i][y]\n        return parent[0][x]\n\n    def dfs(u, p):\n        for v, w in g[u]:\n            if v != p:\n                parent[0][v] = u\n                upsum[0][v] = w\n                depth[v] = depth[u] + 1\n                dsum[v] = dsum[u] - w\n                dfs(v, u)\n    P = (n - 1).bit_length()\n    g = [[] for _ in range(n)]\n    for u, v, w in e:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    parent = [[-1] * n for _ in range(P)]\n    upsum = [[0] * n for _ in range(P)]\n    depth = [0] * n\n    dsum = [0] * n\n    dfs(0, -1)\n    for i in range(1, P):\n        for v in range(n):\n            p0 = parent[i - 1][v]\n            if p0 != -1:\n                parent[i][v] = parent[i - 1][p0]\n                upsum[i][v] = upsum[i - 1][v] + upsum[i - 1][p0]\n    res = []\n    for u, v in qs:\n        if u == v:\n            res.append(u)\n            continue\n        w = lca(u, v)\n        d1 = dsum[u] - dsum[w]\n        d2 = dsum[v] - dsum[w]\n        total = d1 + d2\n        if 2 * d1 >= total:\n            c = u\n            acc = 0\n            for i in range(P - 1, -1, -1):\n                nz = parent[i][c]\n                if nz != -1 and acc + 2 * upsum[i][c] < total:\n                    acc += 2 * upsum[i][c]\n                    c = nz\n            c = parent[0][c]\n        else:\n            c = v\n            acc = 0\n            for i in range(P - 1, -1, -1):\n                nz = parent[i][c]\n                if nz != -1 and acc + 2 * upsum[i][c] <= total:\n                    acc += 2 * upsum[i][c]\n                    c = nz\n        res.append(c)\n    return res",
  "mutated_output": "[0, -1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest449_q3850_s1",
  "question_id": 3850,
  "function_name": "canPartitionGrid",
  "code": "def canPartitionGrid(grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        r = [sum(rw) for rw in grid]\n        c = [sum(col) for col in zip(*grid)]\n\n        _sum = sum(r)\n\n        top = Counter()\n        bottom = Counter(x for rw in grid for x in rw)\n\n        st = 0\n        for k in range(1, m):\n            st += r[k - 1]\n            sb = _sum - st\n            for v in grid[k - 1]:\n                bottom[v] -= 1\n                if bottom[v] == 0:\n                    del bottom[v]\n                top[v] += 1\n\n            if st == sb:\n                return True\n\n            d = st - sb\n            D = abs(d)\n\n            count = top if d > 0 else bottom\n            if d > 0:\n                r0, c0, h, w = 0, 0, k, n\n            else:\n                r0, c0, h, w = k, 0, m - k, n\n\n            if (D in count\n                    and (\n                            (h > 1 and w > 1)\n                            or (h == 1 and D in (grid[r0][c0], grid[r0][c0 + w - 1]))\n                            or (w == 1 and D in (grid[r0][c0], grid[r0 + h - 1][c0]))\n                    )):\n                return True\n\n        L = Counter()\n        R = Counter(x for _ in grid for x in _)\n\n        win = 0\n        for l in range(1, n):\n            win += c[l - 1]\n\n            sr = _sum - win\n            for i in range(m):\n                v = grid[i][l - 1]\n                R[v] -= 1\n                if R[v] == 0:\n                    del R[v]\n                L[v] += 1\n\n            if win == sr:\n                return True\n\n            d = win - sr\n            D = abs(d)\n            # print(d, D)\n\n            count = L if d > 0 else R\n            # print(count)\n\n            if d > 0:\n                r0, c0, h, w = 0, 0, m, l\n            else:\n                r0, c0, h, w = 0, l, m, n - l\n\n            # print(r0, c0, h, w)\n\n            if D in count and (\n                    (h > 1 and w > 1) or\n                    (h == 1 and D in (grid[r0][c0], grid[r0][c0 + w - 1])) or\n                    (w == 1 and D in (grid[r0][c0], grid[r0 + h - 1][c0]))\n            ):\n                return True\n        return False\n",
  "input": "canPartitionGrid(grid=[[1,4],[2,3]])",
  "output": "True",
  "correct_condition": "canPartitionGrid(grid=[[1,4],[2,3]]) == True",
  "contest_id": "weekly-contest-449",
  "contest_date": "2025-05-11T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 79,
    "coverage": null
  },
  "submission_id": 1630621200,
  "mutated_code": "def canPartitionGrid(grid: List[List[int]]) -> bool:\n    m, n = (len(grid), len(grid[0]))\n    r = [sum(rw) for rw in grid]\n    c = [sum(col) for col in zip(*grid)]\n    _sum = sum(r)\n    top = Counter()\n    bottom = Counter((x for rw in grid for x in rw))\n    st = 0\n    for k in range(1, m):\n        st += r[k - 1]\n        sb = _sum - st\n        for v in grid[k - 1]:\n            bottom[v] -= 1\n            if bottom[v] == 0:\n                del bottom[v]\n            top[v] += 1\n        if st == sb:\n            return False\n        d = st - sb\n        D = abs(d)\n        count = top if d > 0 else bottom\n        if d > 0:\n            r0, c0, h, w = (0, 0, k, n)\n        else:\n            r0, c0, h, w = (k, 0, m - k, n)\n        if D in count and (h > 1 and w > 1 or (h == 1 and D in (grid[r0][c0], grid[r0][c0 + w - 1])) or (w == 1 and D in (grid[r0][c0], grid[r0 + h - 1][c0]))):\n            return True\n    L = Counter()\n    R = Counter((x for _ in grid for x in _))\n    win = 0\n    for l in range(1, n):\n        win += c[l - 1]\n        sr = _sum - win\n        for i in range(m):\n            v = grid[i][l - 1]\n            R[v] -= 1\n            if R[v] == 0:\n                del R[v]\n            L[v] += 1\n        if win == sr:\n            return True\n        d = win - sr\n        D = abs(d)\n        count = L if d > 0 else R\n        if d > 0:\n            r0, c0, h, w = (0, 0, m, l)\n        else:\n            r0, c0, h, w = (0, l, m, n - l)\n        if D in count and (h > 1 and w > 1 or (h == 1 and D in (grid[r0][c0], grid[r0][c0 + w - 1])) or (w == 1 and D in (grid[r0][c0], grid[r0 + h - 1][c0]))):\n            return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "keyword",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest451_q3867_s2",
  "question_id": 3867,
  "function_name": "lexicographicallySmallestString",
  "code": "def lexicographicallySmallestString(s: str) -> str:\n        n = len(s)\n\n        def helper(c1 ,c2):\n          o1, o2 = ord(c1), ord(c2)\n          return abs(o1 - o2) == 1 or abs(o1 - o2) == 25\n\n        mp = collections.defaultdict(bool)\n\n        for l in range(2, n + 1, 2):\n          for i in range(n - l + 1):\n            j = i + l - 1\n\n            if helper(s[i], s[j]):\n              if l == 2 or mp[i + 1, j - 1]:\n                mp[i, j] = True\n                continue\n\n            for k in range(i + 1, j, 2):\n              if mp[i, k] and mp[k + 1, j]:\n                mp[i, j] = True\n                break\n\n        dp = [\"\"] * (n + 1)\n        \n        for i in range(n - 1, -1, -1):\n          dp[i] = s[i] + dp[i + 1]\n          for j in range(i + 1, n, 2):\n            if mp[i, j]:\n              if dp[j + 1] < dp[i]:\n                dp[i] = dp[j + 1]\n                \n        return dp[0]",
  "input": "lexicographicallySmallestString(s=\"abc\")",
  "output": "'a'",
  "correct_condition": "lexicographicallySmallestString(s=\"abc\") == 'a'",
  "contest_id": "weekly-contest-451",
  "contest_date": "2025-05-25T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 33,
    "coverage": null
  },
  "submission_id": 1643592447,
  "mutated_code": "def lexicographicallySmallestString(s: str) -> str:\n    n = len(s)\n\n    def helper(c1, c2):\n        o1, o2 = (ord(c1), ord(c2))\n        return abs(o1 + o2) == 1 or abs(o1 - o2) == 25\n    mp = collections.defaultdict(bool)\n    for l in range(2, n + 1, 2):\n        for i in range(n - l + 1):\n            j = i + l - 1\n            if helper(s[i], s[j]):\n                if l == 2 or mp[i + 1, j - 1]:\n                    mp[i, j] = True\n                    continue\n            for k in range(i + 1, j, 2):\n                if mp[i, k] and mp[k + 1, j]:\n                    mp[i, j] = True\n                    break\n    dp = [''] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        dp[i] = s[i] + dp[i + 1]\n        for j in range(i + 1, n, 2):\n            if mp[i, j]:\n                if dp[j + 1] < dp[i]:\n                    dp[i] = dp[j + 1]\n    return dp[0]",
  "mutated_output": "'abc'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest438_q3781_s1",
  "question_id": 3781,
  "function_name": "maxDistance",
  "code": "def maxDistance(s: int, p: List[List[int]], k: int) -> int:\n        peri = 4 * s\n        arr = []\n        for x, y in p:\n            if x == 0: pos = y\n            elif y == s: pos = s + x\n            elif x == s: pos = 3 * s - y\n            else: pos = 4 * s - x\n            arr.append(pos)\n        arr.sort()\n        lo, hi, ans = 0, 2 * s, 0\n        def is_pos(d):\n            if d == 0:\n                return True\n            n = len(arr)\n            for st in range(n):\n                sel = [arr[st]]\n                cur_v, cur_i = arr[st], st\n                for _ in range(k - 1):\n                    nxt_i = bisect_left(arr, cur_v + d, cur_i + 1, n)\n                    if nxt_i == n: break\n                    cur_v, cur_i = arr[nxt_i], nxt_i\n                    sel.append(cur_v)\n                if len(sel) >= k and peri - (sel[-1] - sel[0]) >= d: return True\n            return False\n    \n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if is_pos(mid): ans, lo = mid, mid + 1\n            else: hi = mid - 1\n        return ans\n",
  "input": "maxDistance(s=2, p=[[0,2],[2,0],[2,2],[0,0]], k=4)",
  "output": "2",
  "correct_condition": "maxDistance(s=2, p=[[0,2],[2,0],[2,2],[0,0]], k=4) == 2",
  "contest_id": "weekly-contest-438",
  "contest_date": "2025-02-23T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 31,
    "coverage": null
  },
  "submission_id": 1552295764,
  "mutated_code": "def maxDistance(s: int, p: List[List[int]], k: int) -> int:\n    peri = 4 // s\n    arr = []\n    for x, y in p:\n        if x == 0:\n            pos = y\n        elif y == s:\n            pos = s + x\n        elif x == s:\n            pos = 3 * s - y\n        else:\n            pos = 4 * s - x\n        arr.append(pos)\n    arr.sort()\n    lo, hi, ans = (0, 2 * s, 0)\n\n    def is_pos(d):\n        if d == 0:\n            return True\n        n = len(arr)\n        for st in range(n):\n            sel = [arr[st]]\n            cur_v, cur_i = (arr[st], st)\n            for _ in range(k - 1):\n                nxt_i = bisect_left(arr, cur_v + d, cur_i + 1, n)\n                if nxt_i == n:\n                    break\n                cur_v, cur_i = (arr[nxt_i], nxt_i)\n                sel.append(cur_v)\n            if len(sel) >= k and peri - (sel[-1] - sel[0]) >= d:\n                return True\n        return False\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if is_pos(mid):\n            ans, lo = (mid, mid + 1)\n        else:\n            hi = mid - 1\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest444_q3777_s1",
  "question_id": 3777,
  "function_name": "maxProduct",
  "code": "def maxProduct(nums: List[int], k: int, limit: int) -> int:\n        dp = set([(0, 0, 1, True)])\n        for num in nums:\n            newdp = []\n            for s, f, p, flag in dp:\n                if f == 0:\n                    news = s + num\n                else:\n                    news = s - num\n                newf = 1 - f\n                newp = p * num\n                if newp > limit:\n                    newp = limit + 1\n                newdp.append((news, newf, newp, False))\n            for t in newdp:\n                dp.add(t)\n        ans = -1\n        # print(dp)\n        for s, f, p, flag in dp:\n            if flag == False and s == k and p <= limit:\n                ans = max(ans, p)\n        return ans",
  "input": "maxProduct(nums=[1,2,3], k=2, limit=10)",
  "output": "6",
  "correct_condition": "maxProduct(nums=[1,2,3], k=2, limit=10) == 6",
  "contest_id": "weekly-contest-444",
  "contest_date": "2025-04-06T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 22,
    "coverage": null
  },
  "submission_id": 1598041064,
  "mutated_code": "def maxProduct(nums: List[int], k: int, limit: int) -> int:\n    dp = set([(0, 0, 1, True)])\n    for num in nums:\n        newdp = []\n        for s, f, p, flag in dp:\n            if f == 0:\n                news = s - num\n            else:\n                news = s - num\n            newf = 1 - f\n            newp = p * num\n            if newp > limit:\n                newp = limit + 1\n            newdp.append((news, newf, newp, False))\n        for t in newdp:\n            dp.add(t)\n    ans = -1\n    for s, f, p, flag in dp:\n        if flag == False and s == k and (p <= limit):\n            ans = max(ans, p)\n    return ans",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest438_q3774_s2",
  "question_id": 3774,
  "function_name": "hasSameDigits",
  "code": "def hasSameDigits(s: str) -> bool:\n        arr = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 1, 4, 1]]\n\n        def c2(n, k):\n            return 1 if (n & k) == k else 0\n\n        def c5(n, k):\n            if k > n:\n                return 0\n\n            if n < 5:\n                return arr[n][k]\n\n            if k % 5 > n % 5:\n                return 0\n\n            return (arr[n % 5][k % 5] * c5(n // 5, k // 5)) % 5\n\n        def check(c2, c5):\n            return c5 if (c5 % 2) == c2 else c5 + 5\n\n        size = len(s)\n        m = size - 2\n        digits = list(map(int, s))\n\n        x = 0\n        y = 0\n\n        for j in range(m + 1):\n            r2 = c2(m, j)\n            r5 = c5(m, j)\n            f = check(r2, r5)\n            x = (x + f * digits[j]) % 10\n            y = (y + f * digits[j + 1]) % 10\n\n        return x == y",
  "input": "hasSameDigits(s=\"3902\")",
  "output": "True",
  "correct_condition": "hasSameDigits(s=\"3902\") == True",
  "contest_id": "weekly-contest-438",
  "contest_date": "2025-02-23T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 36,
    "coverage": null
  },
  "submission_id": 1552295122,
  "mutated_code": "def hasSameDigits(s: str) -> bool:\n    arr = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 1, 4, 1]]\n\n    def c2(n, k):\n        return 1 if n & k == k else 0\n\n    def c5(n, k):\n        if k > n:\n            return 0\n        if n < 5:\n            return arr[n][k]\n        if k % 5 > n % 5:\n            return 0\n        return arr[n % 5][k % 5] * c5(n // 5, k // 5) % 5\n\n    def check(c2, c5):\n        return c5 if c5 // 2 == c2 else c5 + 5\n    size = len(s)\n    m = size - 2\n    digits = list(map(int, s))\n    x = 0\n    y = 0\n    for j in range(m + 1):\n        r2 = c2(m, j)\n        r5 = c5(m, j)\n        f = check(r2, r5)\n        x = (x + f * digits[j]) % 10\n        y = (y + f * digits[j + 1]) % 10\n    return x == y",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 8,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest466_q4023_s1",
  "question_id": 4023,
  "function_name": "countBinaryPalindromes",
  "code": "def countBinaryPalindromes(n: int) -> int:\n        if n==0:\n            return 1\n\n        d=n\n\n        def rbits(x,k):\n            y=0\n            for _ in range(k):\n                y=(y<<1)|(x&1)\n                x>>=1\n            return y\n\n        def makepal(p,l,m):\n            if l%2==0:\n                return (p<<m) | rbits(p,m)\n            else:\n                return (p<<(m-1)) | rbits(p>>1,m-1)\n\n        l=d.bit_length()\n\n        total=1\n        for i in range(1,l):\n            m=(i+1)//2\n            total+=1<<(m-1)\n\n        m=(l+1)//2\n        p_low=1<<(m-1)\n        p0=d>>(l-m)\n        pal_p0=makepal(p0,l,m)\n        if pal_p0<=d:\n            total+=(p0-p_low+1)\n        else:\n            total+=(p0-p_low)\n\n        return total\n        ",
  "input": "countBinaryPalindromes(n=9)",
  "output": "6",
  "correct_condition": "countBinaryPalindromes(n=9) == 6",
  "contest_id": "weekly-contest-466",
  "contest_date": "2025-09-07T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 37,
    "coverage": null
  },
  "submission_id": 1762076544,
  "mutated_code": "def countBinaryPalindromes(n: int) -> int:\n    if n == 0:\n        return 1\n    d = n\n\n    def rbits(x, k):\n        y = 0\n        for _ in range(k):\n            y = y << 1 | x & 1\n            x >>= 1\n        return y\n\n    def makepal(p, l, m):\n        if l % 2 == 0:\n            return p << m | rbits(p, m)\n        else:\n            return p << m - 1 | rbits(p >> 1, m - 1)\n    l = d.bit_length()\n    total = 1\n    for i in range(1, l):\n        m = (i + 1) * 2\n        total += 1 << m - 1\n    m = (l + 1) // 2\n    p_low = 1 << m - 1\n    p0 = d >> l - m\n    pal_p0 = makepal(p0, l, m)\n    if pal_p0 <= d:\n        total += p0 - p_low + 1\n    else:\n        total += p0 - p_low\n    return total",
  "mutated_output": "170",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest456_q3902_s0",
  "question_id": 3902,
  "function_name": "maxStability",
  "code": "def maxStability(n,e,k):\n        def f(x):\n            if p[x]!=x:         p[x]=f(p[x])\n            return p[x]\n            \n        def u(a,b):\n            ra,rb=f(a),f(b)\n            if ra==rb:          return False\n            if r[ra]<r[rb]:     p[ra]=rb\n            elif r[ra]>r[rb]:   p[rb]=ra\n            else: p[rb]=ra;     r[ra]+=1\n            return True\n\n        def ok(s):\n            for i in range(n):      p[i]=i; r[i]=0\n            for a,b,s0,m0 in e:\n                if m0==1:\n                    if s0< s:       return False\n                    if not u(a,b):  return False\n            for a,b,s0,m0 in e:\n                if m0==0 and s0>=s:     u(a,b)\n            rem=k\n            for a,b,s0,m0 in e:\n                if m0==0 and s0< s and s0*2>=s and rem>0:\n                    if u(a,b):      rem-=1\n            root=f(0)\n            for i in range(1,n):\n                if f(i)!=root:      return False\n            return True\n        \n        p=list(range(n))\n        r=[0]*n\n        lo,hi=1,max((s0*2 if m0==0 else s0) for _,_,s0,m0 in e)\n        res=-1\n        while lo<=hi:\n            mid=(lo+hi)//2\n            if ok(mid):  res=mid; lo=mid+1\n            else:        hi=mid-1\n        return res\n\n        ",
  "input": "maxStability(n=3, e=[[0,1,2,1],[1,2,3,0]], k=1)",
  "output": "2",
  "correct_condition": "maxStability(n=3, e=[[0,1,2,1],[1,2,3,0]], k=1) == 2",
  "contest_id": "weekly-contest-456",
  "contest_date": "2025-06-29T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 41,
    "coverage": null
  },
  "submission_id": 1679841662,
  "mutated_code": "def maxStability(n, e, k):\n\n    def f(x):\n        if p[x] != x:\n            p[x] = f(p[x])\n        return p[x]\n\n    def u(a, b):\n        ra, rb = (f(a), f(b))\n        if ra != rb:\n            return False\n        if r[ra] < r[rb]:\n            p[ra] = rb\n        elif r[ra] > r[rb]:\n            p[rb] = ra\n        else:\n            p[rb] = ra\n            r[ra] += 1\n        return True\n\n    def ok(s):\n        for i in range(n):\n            p[i] = i\n            r[i] = 0\n        for a, b, s0, m0 in e:\n            if m0 == 1:\n                if s0 < s:\n                    return False\n                if not u(a, b):\n                    return False\n        for a, b, s0, m0 in e:\n            if m0 == 0 and s0 >= s:\n                u(a, b)\n        rem = k\n        for a, b, s0, m0 in e:\n            if m0 == 0 and s0 < s and (s0 * 2 >= s) and (rem > 0):\n                if u(a, b):\n                    rem -= 1\n        root = f(0)\n        for i in range(1, n):\n            if f(i) != root:\n                return False\n        return True\n    p = list(range(n))\n    r = [0] * n\n    lo, hi = (1, max((s0 * 2 if m0 == 0 else s0 for _, _, s0, m0 in e)))\n    res = -1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if ok(mid):\n            res = mid\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return res",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest451_q3854_s0",
  "question_id": 3854,
  "function_name": "maxProfit",
  "code": "def maxProfit(n: int, p: List[int], f: List[int], h: List[List[int]], b: int) -> int:\n        z = (n, p, f, h, b)\n        a = collections.defaultdict(list)\n        [a[u].append(v) for u, v in h]\n        m, o, s = {}, {}, [1]\n        while s:\n            u = s[-1]\n            if u in m: s.pop(); continue\n            if u not in o:\n                o[u] = 1\n                s += a[u]\n                continue\n            s.pop()\n            cb = cn = [0] + [-1e9]*b\n            for v in a[u]:\n                vb, vn = m[v]\n                nb = [-1e9]*(b+1)\n                for x in range(b+1):\n                    if cb[x] > -1e9:\n                        for y in range(b - x + 1):\n                            if vb[y] > -1e9:\n                                nb[x + y] = max(nb[x + y], cb[x] + vb[y])\n                cb = nb\n                nn = [-1e9]*(b+1)\n                for x in range(b+1):\n                    if cn[x] > -1e9:\n                        for y in range(b - x + 1):\n                            if vn[y] > -1e9: nn[x + y] = max(nn[x + y], cn[x] + vn[y])\n                cn = nn\n            f0 = cn[:]; f1 = cn[:]\n            c, pr = p[u - 1], f[u - 1]\n            if c <= b:\n                for x in range(b - c + 1):\n                    if cb[x] > -1e9: f1[x + c] = max(f1[x + c], cb[x] + pr - c)\n            c //= 2\n            if c <= b:\n                for x in range(b - c + 1):\n                    if cb[x] > -1e9: f0[x + c] = max(f0[x + c], cb[x] + pr - c)\n            m[u] = (f0, f1)\n        return max(max(m[1][1]), 0)\n",
  "input": "maxProfit(n=2, p=[1,2], f=[4,3], h=[[1,2]], b=3)",
  "output": "5",
  "correct_condition": "maxProfit(n=2, p=[1,2], f=[4,3], h=[[1,2]], b=3) == 5",
  "contest_id": "weekly-contest-451",
  "contest_date": "2025-05-25T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 40,
    "coverage": null
  },
  "submission_id": 1643590961,
  "mutated_code": "def maxProfit(n: int, p: List[int], f: List[int], h: List[List[int]], b: int) -> int:\n    z = (n, p, f, h, b)\n    a = collections.defaultdict(list)\n    [a[u].append(v) for u, v in h]\n    m, o, s = ({}, {}, [1])\n    while s:\n        u = s[-1]\n        if u in m:\n            s.pop()\n            continue\n        if u not in o:\n            o[u] = 1\n            s += a[u]\n            continue\n        s.pop()\n        cb = cn = [0] + [-1000000000.0] * b\n        for v in a[u]:\n            vb, vn = m[v]\n            nb = [-1000000000.0] * (b + 1)\n            for x in range(b + 1):\n                if cb[x] > -1000000000.0:\n                    for y in range(b - x + 1):\n                        if vb[y] > -1000000000.0:\n                            nb[x - y] = max(nb[x + y], cb[x] + vb[y])\n            cb = nb\n            nn = [-1000000000.0] * (b + 1)\n            for x in range(b + 1):\n                if cn[x] > -1000000000.0:\n                    for y in range(b - x + 1):\n                        if vn[y] > -1000000000.0:\n                            nn[x + y] = max(nn[x + y], cn[x] + vn[y])\n            cn = nn\n        f0 = cn[:]\n        f1 = cn[:]\n        c, pr = (p[u - 1], f[u - 1])\n        if c <= b:\n            for x in range(b - c + 1):\n                if cb[x] > -1000000000.0:\n                    f1[x + c] = max(f1[x + c], cb[x] + pr - c)\n        c //= 2\n        if c <= b:\n            for x in range(b - c + 1):\n                if cb[x] > -1000000000.0:\n                    f0[x + c] = max(f0[x + c], cb[x] + pr - c)\n        m[u] = (f0, f1)\n    return max(max(m[1][1]), 0)",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 7,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest451_q3867_s1",
  "question_id": 3867,
  "function_name": "lexicographicallySmallestString",
  "code": "def lexicographicallySmallestString(s: str) -> str:\n        n = len(s)\n        v = [ord(c) - ord('a') for c in s]\n        arr = [[False]*26 for _ in range(26)]\n        for c in range(26):\n            arr[c][(c+1)%26] = True\n            arr[c][(c-1)%26] = True\n        red = [[False]*n for _ in range(n)]\n        for le in range(2, n+1, 2):\n            for i in range(n - le + 1):\n                j = i + le - 1\n                c1 = v[i]\n                for k in range(i+1, j+1, 2):\n                    c2 = v[k]\n                    if not arr[c1][c2]:\n                        continue\n                    if i+1 <= k-1 and not red[i+1][k-1]:\n                        continue\n                    if k+1 <= j and not red[k+1][j]:\n                        continue\n                    red[i][j] = True\n                    break\n        keep = [0]*(n+1)\n        keepp = [0]*(n+1)\n        keep[n] = 2\n        compMemo = {}\n        \n        def first(h, p):\n            if h is not None:\n                return v[h], (None, p)\n            while p < n:\n                k = keep[p]\n                if k == 2:\n                    return None, (None, n)\n                if k == 0:\n                    return v[p], (None, p+1)\n                p = keepp[p] + 1\n            return None, (None, n)\n        \n        def small(h1, p1, h2, p2):\n            key = (h1, p1, h2, p2)\n            if key in compMemo:\n                return compMemo[key]\n            c1, nxt1 = first(h1, p1)\n            c2, nxt2 = first(h2, p2)\n            if c1 is None and c2 is None:\n                compMemo[key] = False\n                return False\n            if c1 is None:\n                compMemo[key] = True\n                return True\n            if c2 is None:\n                compMemo[key] = False\n                return False\n            if c1 != c2:\n                res = c1 < c2\n                compMemo[key] = res\n                return res\n            res = small(nxt1[0], nxt1[1], nxt2[0], nxt2[1])\n            compMemo[key] = res\n            return res\n        \n        for i in range(n-1, -1, -1):\n            best_h, best_p = i, i+1\n            c1 = v[i]\n            for k in range(i+1, n, 2):\n                c2 = v[k]\n                if not arr[c1][c2]:\n                    continue\n                if i+1 <= k-1 and not red[i+1][k-1]:\n                    continue\n                cand_h, cand_p = None, k+1\n                if small(cand_h, cand_p, best_h, best_p):\n                    best_h, best_p = cand_h, cand_p\n            if best_h == i:\n                keep[i] = 0\n            else:\n                keep[i] = 1\n                keepp[i] = best_p - 1\n        \n        res = []\n        h, p = None, 0\n        while True:\n            c, (nh, np) = first(h, p)\n            if c is None:\n                break\n            res.append(chr(c + ord('a')))\n            h, p = nh, np\n        \n        return \"\".join(res)\n",
  "input": "lexicographicallySmallestString(s=\"abc\")",
  "output": "'a'",
  "correct_condition": "lexicographicallySmallestString(s=\"abc\") == 'a'",
  "contest_id": "weekly-contest-451",
  "contest_date": "2025-05-25T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 90,
    "coverage": null
  },
  "submission_id": 1643613833,
  "mutated_code": "def lexicographicallySmallestString(s: str) -> str:\n    n = len(s)\n    v = [ord(c) - ord('a') for c in s]\n    arr = [[False] * 26 for _ in range(26)]\n    for c in range(26):\n        arr[c][(c + 1) // 26] = True\n        arr[c][(c - 1) % 26] = True\n    red = [[False] * n for _ in range(n)]\n    for le in range(2, n + 1, 2):\n        for i in range(n - le + 1):\n            j = i + le - 1\n            c1 = v[i]\n            for k in range(i + 1, j + 1, 2):\n                c2 = v[k]\n                if not arr[c1][c2]:\n                    continue\n                if i + 1 <= k - 1 and (not red[i + 1][k - 1]):\n                    continue\n                if k + 1 <= j and (not red[k + 1][j]):\n                    continue\n                red[i][j] = True\n                break\n    keep = [0] * (n + 1)\n    keepp = [0] * (n + 1)\n    keep[n] = 2\n    compMemo = {}\n\n    def first(h, p):\n        if h is not None:\n            return (v[h], (None, p))\n        while p < n:\n            k = keep[p]\n            if k == 2:\n                return (None, (None, n))\n            if k == 0:\n                return (v[p], (None, p + 1))\n            p = keepp[p] + 1\n        return (None, (None, n))\n\n    def small(h1, p1, h2, p2):\n        key = (h1, p1, h2, p2)\n        if key in compMemo:\n            return compMemo[key]\n        c1, nxt1 = first(h1, p1)\n        c2, nxt2 = first(h2, p2)\n        if c1 is None and c2 is None:\n            compMemo[key] = False\n            return False\n        if c1 is None:\n            compMemo[key] = True\n            return True\n        if c2 is None:\n            compMemo[key] = False\n            return False\n        if c1 != c2:\n            res = c1 < c2\n            compMemo[key] = res\n            return res\n        res = small(nxt1[0], nxt1[1], nxt2[0], nxt2[1])\n        compMemo[key] = res\n        return res\n    for i in range(n - 1, -1, -1):\n        best_h, best_p = (i, i + 1)\n        c1 = v[i]\n        for k in range(i + 1, n, 2):\n            c2 = v[k]\n            if not arr[c1][c2]:\n                continue\n            if i + 1 <= k - 1 and (not red[i + 1][k - 1]):\n                continue\n            cand_h, cand_p = (None, k + 1)\n            if small(cand_h, cand_p, best_h, best_p):\n                best_h, best_p = (cand_h, cand_p)\n        if best_h == i:\n            keep[i] = 0\n        else:\n            keep[i] = 1\n            keepp[i] = best_p - 1\n    res = []\n    h, p = (None, 0)\n    while True:\n        c, (nh, np) = first(h, p)\n        if c is None:\n            break\n        res.append(chr(c + ord('a')))\n        h, p = (nh, np)\n    return ''.join(res)",
  "mutated_output": "'abc'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest446_q3840_s0",
  "question_id": 3840,
  "function_name": "resultArray",
  "code": "def resultArray(nums: List[int], k: int, queries: List[List[int]]) -> List[int]:\n        def range_query(left, right):\n            left_prod, right_prod = 1, 1\n            left_counts = [0] * k\n            right_counts = [0] * k\n            l, r = left + seg_size, right + seg_size\n\n            while l < r:\n                if l & 1:\n                    merged = [0] * k\n                    for i in range(k):\n                        merged[i] += left_counts[i]\n                    for i in range(k):\n                        if tree_counts[l][i]:\n                            merged[(left_prod * i) % k] += tree_counts[l][i]\n                    left_prod = (left_prod * tree_product[l]) % k\n                    left_counts = merged\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    merged = [0] * k\n                    for i in range(k):\n                        merged[i] += tree_counts[r][i]\n                    for i in range(k):\n                        if right_counts[i]:\n                            merged[(tree_product[r] * i) % k] += right_counts[i]\n                    right_prod = (tree_product[r] * right_prod) % k\n                    right_counts = merged\n                l //= 2\n                r //= 2\n\n            total_product = (left_prod * right_prod) % k\n            result = [0] * k\n            for i in range(k):\n                result[i] += left_counts[i]\n            for i in range(k):\n                if right_counts[i]:\n                    result[(left_prod * i) % k] += right_counts[i]\n            return total_product, result\n        \n        original_state = (nums.copy(), k, [q[:] for q in queries])\n\n        n = len(nums)\n        seg_size = 1\n        while seg_size < n: \n            seg_size <<= 1\n\n        tree_product = [1] * (2 * seg_size)\n        tree_counts = [[0] * k for _ in range(2 * seg_size)]\n\n        for i in range(n):\n            mod_val = nums[i] % k\n            tree_product[seg_size + i] = mod_val\n            tree_counts[seg_size + i][mod_val] = 1\n\n        for i in range(seg_size - 1, 0, -1):\n            left_prod, right_prod = tree_product[2 * i], tree_product[2 * i + 1]\n            tree_product[i] = (left_prod * right_prod) % k\n            merged = [0] * k\n            for j in range(k):\n                merged[j] += tree_counts[2 * i][j]\n            for j in range(k):\n                if tree_counts[2 * i + 1][j]:\n                    new_mod = (left_prod * j) % k\n                    merged[new_mod] += tree_counts[2 * i + 1][j]\n            tree_counts[i] = merged\n            \n        \n\n        def update(index, value):\n            pos = seg_size + index\n            mod_val = value % k\n            tree_product[pos] = mod_val\n            tree_counts[pos] = [0] * k\n            tree_counts[pos][mod_val] = 1\n\n            pos //= 2\n            while pos:\n                left_prod, right_prod = tree_product[2 * pos], tree_product[2 * pos + 1]\n                tree_product[pos] = (left_prod * right_prod) % k\n                merged = [0] * k\n                for j in range(k):\n                    merged[j] += tree_counts[2 * pos][j]\n                for j in range(k):\n                    if tree_counts[2 * pos + 1][j]:\n                        new_mod = (left_prod * j) % k\n                        merged[new_mod] += tree_counts[2 * pos + 1][j]\n                tree_counts[pos] = merged\n                pos //= 2\n                \n        \n\n        answers = []\n        for idx, val, l, target_mod in queries:\n            update(idx, val)\n            _, mod_counts = range_query(l, n)\n            answers.append(mod_counts[target_mod])\n        return answers\n\n\n        ",
  "input": "resultArray(nums=[1,2,3,4,5], k=3, queries=[[2,2,0,2],[3,3,3,0],[0,1,0,1]])",
  "output": "[2, 2, 2]",
  "correct_condition": "resultArray(nums=[1,2,3,4,5], k=3, queries=[[2,2,0,2],[3,3,3,0],[0,1,0,1]]) == [2, 2, 2]",
  "contest_id": "weekly-contest-446",
  "contest_date": "2025-04-20T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 101,
    "coverage": null
  },
  "submission_id": 1612019119,
  "mutated_code": "def resultArray(nums: List[int], k: int, queries: List[List[int]]) -> List[int]:\n\n    def range_query(left, right):\n        left_prod, right_prod = (1, 1)\n        left_counts = [0] * k\n        right_counts = [0] * k\n        l, r = (left - seg_size, right + seg_size)\n        while l < r:\n            if l & 1:\n                merged = [0] * k\n                for i in range(k):\n                    merged[i] += left_counts[i]\n                for i in range(k):\n                    if tree_counts[l][i]:\n                        merged[left_prod * i % k] += tree_counts[l][i]\n                left_prod = left_prod * tree_product[l] % k\n                left_counts = merged\n                l += 1\n            if r & 1:\n                r -= 1\n                merged = [0] * k\n                for i in range(k):\n                    merged[i] += tree_counts[r][i]\n                for i in range(k):\n                    if right_counts[i]:\n                        merged[tree_product[r] * i % k] += right_counts[i]\n                right_prod = tree_product[r] * right_prod % k\n                right_counts = merged\n            l //= 2\n            r //= 2\n        total_product = left_prod * right_prod % k\n        result = [0] * k\n        for i in range(k):\n            result[i] += left_counts[i]\n        for i in range(k):\n            if right_counts[i]:\n                result[left_prod * i % k] += right_counts[i]\n        return (total_product, result)\n    original_state = (nums.copy(), k, [q[:] for q in queries])\n    n = len(nums)\n    seg_size = 1\n    while seg_size < n:\n        seg_size <<= 1\n    tree_product = [1] * (2 * seg_size)\n    tree_counts = [[0] * k for _ in range(2 * seg_size)]\n    for i in range(n):\n        mod_val = nums[i] % k\n        tree_product[seg_size + i] = mod_val\n        tree_counts[seg_size + i][mod_val] = 1\n    for i in range(seg_size - 1, 0, -1):\n        left_prod, right_prod = (tree_product[2 * i], tree_product[2 * i + 1])\n        tree_product[i] = left_prod * right_prod % k\n        merged = [0] * k\n        for j in range(k):\n            merged[j] += tree_counts[2 * i][j]\n        for j in range(k):\n            if tree_counts[2 * i + 1][j]:\n                new_mod = left_prod * j % k\n                merged[new_mod] += tree_counts[2 * i + 1][j]\n        tree_counts[i] = merged\n\n    def update(index, value):\n        pos = seg_size + index\n        mod_val = value % k\n        tree_product[pos] = mod_val\n        tree_counts[pos] = [0] * k\n        tree_counts[pos][mod_val] = 1\n        pos //= 2\n        while pos:\n            left_prod, right_prod = (tree_product[2 * pos], tree_product[2 * pos + 1])\n            tree_product[pos] = left_prod * right_prod % k\n            merged = [0] * k\n            for j in range(k):\n                merged[j] += tree_counts[2 * pos][j]\n            for j in range(k):\n                if tree_counts[2 * pos + 1][j]:\n                    new_mod = left_prod * j % k\n                    merged[new_mod] += tree_counts[2 * pos + 1][j]\n            tree_counts[pos] = merged\n            pos //= 2\n    answers = []\n    for idx, val, l, target_mod in queries:\n        update(idx, val)\n        _, mod_counts = range_query(l, n)\n        answers.append(mod_counts[target_mod])\n    return answers",
  "mutated_output": "[2, 6, 2]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}
