[
  {
    "id": "contest431_q3702_s0",
    "question_id": 3702,
    "function_name": "maxLength",
    "code": "class Solution:\n    def maxLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for l in range(n):\n            a = 1\n            b = 1\n            c = 0\n            for r in range(l, n):\n                a *= nums[r]\n                b = lcm(b, nums[r])\n                c = gcd(c, nums[r])\n                if a == b * c:\n                    ans = max(ans, r - l + 1)\n        return ans\n                \n        ",
    "input": "maxLength(nums=[1,2,1,2,1,1,1])",
    "output": "5",
    "correct_condition": "maxLength(nums=[1,2,1,2,1,1,1]) == 5",
    "contest_id": "weekly-contest-431",
    "contest_date": "2024-01-07T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 17,
      "coverage": null
    },
    "submission_id": 1497983046
  },
  {
    "id": "contest431_q3702_s1",
    "question_id": 3702,
    "function_name": "maxLength",
    "code": "class Solution:\n    def maxLength(self, nums: List[int]) -> int:\n        ans = 1\n        run = 1\n        for l in range(len(nums)):\n            for r in range(l, len(nums)):\n                a = nums[l:r+1]\n                prod = 1\n                g = nums[l]\n                lc = nums[l]\n                for v in a:\n                    g = gcd(g, v)\n                    lc = lcm(lc, v)\n                    prod *= v\n                if g * lc == prod:\n                    ans = max(ans, r - l + 1)\n        return ans",
    "input": "maxLength(nums=[1,2,1,2,1,1,1])",
    "output": "5",
    "correct_condition": "maxLength(nums=[1,2,1,2,1,1,1]) == 5",
    "contest_id": "weekly-contest-431",
    "contest_date": "2024-01-07T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 17,
      "coverage": null
    },
    "submission_id": 1497983616
  },
  {
    "id": "contest431_q3702_s2",
    "question_id": 3702,
    "function_name": "maxLength",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nimport math\nclass Solution:\n    def maxLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        maxi = 1 \n        for i in range(n):\n            cur1 = nums[i]\n            cur2 = nums[i]\n            prod = nums[i]\n            \n            for j in range(i + 1, n):\n                cur1 = math.gcd(cur1, nums[j])\n                cur2 = (cur2 * nums[j]) // math.gcd(cur2, nums[j])\n                prod *= nums[j]\n                if prod == cur1 * cur2:\n                    lens = j - i + 1\n                    if lens > maxi:\n                        maxi = lens\n        return maxi",
    "input": "maxLength(nums=[1,2,1,2,1,1,1])",
    "output": "5",
    "correct_condition": "maxLength(nums=[1,2,1,2,1,1,1]) == 5",
    "contest_id": "weekly-contest-431",
    "contest_date": "2024-01-07T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 219,
      "coverage": null
    },
    "submission_id": 1498014620
  },
  {
    "id": "contest431_q3634_s0",
    "question_id": 3634,
    "function_name": "calculateScore",
    "code": "class Solution:\n    def calculateScore(self, s: str) -> int:\n        g = [[] for _ in range(26)]\n        ans = 0\n        for i, x in enumerate(s):\n            x = ord(x) - 97\n            if g[25 - x]:\n                ans += i - g[25 - x].pop()\n            else:\n                g[x].append(i)\n        return ans\n        ",
    "input": "calculateScore(s=\"aczzx\")",
    "output": "5",
    "correct_condition": "calculateScore(s=\"aczzx\") == 5",
    "contest_id": "weekly-contest-431",
    "contest_date": "2024-01-07T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 12,
      "coverage": null
    },
    "submission_id": 1497985461
  },
  {
    "id": "contest431_q3634_s1",
    "question_id": 3634,
    "function_name": "calculateScore",
    "code": "class Solution:\n    def calculateScore(self, s: str) -> int:\n        def mir(c):\n            return chr(ord('a') + (25 - (ord(c) - ord('a'))))\n        seen = defaultdict(list)\n        ans = 0\n        for i in range(len(s)):\n            c1 = mir(s[i])\n            if seen[c1]:\n                ans += i - seen[c1][-1]\n                seen[c1].pop()\n            else: seen[s[i]].append(i)\n        return ans",
    "input": "calculateScore(s=\"aczzx\")",
    "output": "5",
    "correct_condition": "calculateScore(s=\"aczzx\") == 5",
    "contest_id": "weekly-contest-431",
    "contest_date": "2024-01-07T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 13,
      "coverage": null
    },
    "submission_id": 1497985549
  },
  {
    "id": "contest431_q3634_s2",
    "question_id": 3634,
    "function_name": "calculateScore",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nclass Solution:\n    def calculateScore(self, s: str) -> int:\n        ls = {chr(i): [] for i in range(ord('a'), ord('z') + 1)}\n        score = 0\n        for i, c in enumerate(s):\n            cm = chr(ord('a') + (ord('z') - ord(c)))\n            if ls[cm]:\n                j = ls[cm].pop()\n                score += i - j\n            else:\n                ls[c].append(i)\n        return score",
    "input": "calculateScore(s=\"aczzx\")",
    "output": "5",
    "correct_condition": "calculateScore(s=\"aczzx\") == 5",
    "contest_id": "weekly-contest-431",
    "contest_date": "2024-01-07T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 212,
      "coverage": null
    },
    "submission_id": 1498013955
  },
  {
    "id": "contest431_q3715_s0",
    "question_id": 3715,
    "function_name": "maximumCoins",
    "code": "class Solution:\n    def maximumCoins(self, coins: List[List[int]], k: int) -> int:\n        coins.sort()\n        n = len(coins)\n        def f(p):\n            ret = tot = 0\n            j = 0\n            for i in range(n):\n                while j < n and p[j][1] - p[i][0] + 1 <= k:\n                    tot += (p[j][1] - p[j][0] + 1) * p[j][2]\n                    j += 1\n                cur = tot\n                if j < n and p[j][0] - p[i][0] + 1 <= k:\n                    cur += (p[i][0] + k - p[j][0]) * p[j][2]\n                if cur > ret:\n                    ret = cur\n                if i == j:\n                    j += 1\n                else:\n                    tot -= (p[i][1] - p[i][0] + 1) * p[i][2]\n            return ret\n        ans = f(coins)\n        coins.reverse()\n        m = 10 ** 9 + 1\n        for it in coins:\n            it[0], it[1] = m - it[1], m - it[0]\n        ans = max(ans, f(coins))\n        return ans\n                    \n                ",
    "input": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4)",
    "output": "10",
    "correct_condition": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4) == 10",
    "contest_id": "weekly-contest-431",
    "contest_date": "2024-01-07T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 30,
      "coverage": null
    },
    "submission_id": 1498002559
  },
  {
    "id": "contest431_q3715_s1",
    "question_id": 3715,
    "function_name": "maximumCoins",
    "code": "class Solution:\n    def maximumCoins(self, coins: List[List[int]], k: int) -> int:\n        coins.sort()\n        ans = 0\n        for _ in range(2):\n            cnt = 0\n            r = 0\n            # print(coins)\n            for l in range(len(coins)):\n                while r+1 < len(coins) and coins[r][1]-coins[l][0]+1 <= k:\n                    cnt += (coins[r][1]-coins[r][0]+1 ) * coins[r][2]\n                    r += 1\n                add = min(coins[r][1]+1, coins[l][0] + k) - coins[r][0]\n                add = max(add, 0)\n                add *= coins[r][2]\n                # add = (k - ((0 if r == 0 else coins[r-1][1])-coins[l][0]+1)) * coins[r][2]\n                ans = max(ans, cnt + add)\n                # print(l, r, add / coins[r][2], cnt + add)\n                cnt -= (coins[l][1]-coins[l][0]+1 ) * coins[l][2]\n            for i in range(len(coins)):\n                coins[i][0] *= -1\n                coins[i][1] *= -1\n                coins[i][0], coins[i][1] = coins[i][1], coins[i][0]\n            coins.sort()\n        return ans",
    "input": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4)",
    "output": "10",
    "correct_condition": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4) == 10",
    "contest_id": "weekly-contest-431",
    "contest_date": "2024-01-07T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 25,
      "coverage": null
    },
    "submission_id": 1498001804
  },
  {
    "id": "contest431_q3715_s2",
    "question_id": 3715,
    "function_name": "maximumCoins",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nfrom bisect import bisect_right\nfrom dataclasses import dataclass\n\n@dataclass\nclass Interval:\n    start: int\n    end: int\n    ci: int\n    psum: int = 0\n\nclass Solution:\n    def maximumCoins(self, coins: List[List[int]], k: int) -> int:\n        coins.sort(key=lambda x: x[0])\n        intervals: List[Interval] = []\n        for seg in coins:\n            li, ri, val1 = seg\n            intervals.append(Interval(start=li, end=ri, ci=val1))\n        \n        pref = 0\n        for interval in intervals:\n            lenx = interval.end - interval.start + 1\n            tot = lenx * interval.ci\n            pref += tot\n            interval.psum = pref\n\n        starts = [interval.start for interval in intervals]\n        \n        def getSum(x: int) -> int:\n            if not intervals or x < intervals[0].start:\n                return 0\n            idx = bisect_right(starts, x) - 1\n            if idx < 0:\n                return 0\n            sval = intervals[idx].psum\n            if idx > 0:\n                sval -= intervals[idx - 1].psum\n            overlap = min(x, intervals[idx].end) - intervals[idx].start + 1\n            if overlap > 0:\n                sval = intervals[idx].psum - (intervals[idx -1].psum if idx >0 else 0)\n                sval = (overlap) * intervals[idx].ci\n            else:\n                sval = 0\n            tsum = 0\n            if idx >=0:\n                tsum = intervals[idx].psum - (intervals[idx -1].psum if idx >0 else 0)\n                tsum = (min(x, intervals[idx].end) - intervals[idx].start +1) * intervals[idx].ci\n                if idx >0:\n                    tsum += intervals[idx-1].psum\n            return tsum\n        \n        def get_sum(x):\n            if not intervals or x < intervals[0].start:\n                return 0\n            idx = bisect_right(starts, x) - 1\n            if idx < 0:\n                return 0\n            prevs = intervals[idx -1].psum if idx > 0 else 0\n            overlap = min(x, intervals[idx].end) - intervals[idx].start + 1\n            if overlap < 0:\n                overlap = 0\n            return prevs + overlap * intervals[idx].ci\n        \n        st = set()\n        for seg in coins:\n            li, ri, _ = seg\n            st.add(li)\n            x = ri - k + 1\n            if 1 <= x <= ri:\n                st.add(x)\n        \n        st = sorted(st)\n\n        maxi = 0\n        for x in st:\n            sw = x\n            send = x + k -1\n            sum1 = get_sum(send)\n            sum0 = get_sum(sw -1)\n            tot = sum1 - sum0\n            if tot > maxi:\n                maxi = tot\n        \n        return maxi\n",
    "input": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4)",
    "output": "10",
    "correct_condition": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4) == 10",
    "contest_id": "weekly-contest-431",
    "contest_date": "2024-01-07T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 283,
      "coverage": null
    },
    "submission_id": 1498021486
  },
  {
    "id": "contest431_q3562_s0",
    "question_id": 3562,
    "function_name": "maximumWeight",
    "code": "class Solution:\n    def maximumWeight(self, p: List[List[int]]) -> List[int]:\n        a = []\n        for i, it in enumerate(p):\n            it.append(i)\n            a += [it[0], it[1]]\n        mp = {x: i + 1 for i, x in enumerate(sorted(set(a)))}\n        p.sort(key=lambda it:it[1])\n        for it in p:\n            it[0] = mp[it[0]]\n            it[1] = mp[it[1]]\n        f = [[[0, []] for _ in range(5)]]\n        pr = 0\n        for it in p:\n            l, r, w, i = it\n            while pr < r:\n                f.append(f[pr][:])\n                pr += 1\n            for k in range(4):\n                v, b = f[l - 1][k]\n                b = b[::] + [i]\n                b.sort()\n                v -= w\n                f[r][k + 1] = min(f[r][k + 1], [v, b])\n        return f[-1][4][1]",
    "input": "maximumWeight(p=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]])",
    "output": "[2, 3]",
    "correct_condition": "maximumWeight(p=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]) == [2, 3]",
    "contest_id": "weekly-contest-431",
    "contest_date": "2024-01-07T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 25,
      "coverage": null
    },
    "submission_id": 1498025769
  },
  {
    "id": "contest431_q3562_s1",
    "question_id": 3562,
    "function_name": "maximumWeight",
    "code": "class Solution:\n    def maximumWeight(self, intervals: List[List[int]]) -> List[int]:\n        locations = set()\n        for l, r, w in intervals:\n            locations.add(l)\n            locations.add(r+1)\n        locations = sorted(list(locations))\n        to_idx = dict()\n        for i, x in enumerate(locations):\n            to_idx[x] = i\n        nxt = [[] for i in range(len(locations))]\n        for i, (l, r, w) in enumerate(intervals):\n            nxt[to_idx[l]].append((to_idx[r+1], w, i))\n        @cache\n        def dp(idx, left):\n            res = (10 ** 12, [])\n            if idx >= len(locations) or left == 0: return res\n            \n            res = min(res, dp(idx + 1, left))\n            for r, w, i in nxt[idx]:\n                (a, ls) = dp(r, left-1)\n                a -= w\n                ls1 = ls.copy()\n                ls1.append(i)\n                ls1.sort()\n                res = min(res, (a, ls1))\n            return res\n        w, ls = dp(0, 4)\n        return ls\n            ",
    "input": "maximumWeight(intervals=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]])",
    "output": "[2, 3]",
    "correct_condition": "maximumWeight(intervals=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]) == [2, 3]",
    "contest_id": "weekly-contest-431",
    "contest_date": "2024-01-07T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 30,
      "coverage": null
    },
    "submission_id": 1498015639
  },
  {
    "id": "contest431_q3562_s2",
    "question_id": 3562,
    "function_name": "maximumWeight",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nfrom bisect import bisect_right\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass Interval:\n    start: int\n    end: int\n    weight: int\n    ind: int\n    psum: int = 0\n\nclass Solution:\n    def maximumWeight(self, intervals: List[List[int]]) -> List[int]:\n        n = len(intervals)\n        sit = []\n        for i in range(n):\n            l, r, w = intervals[i]\n            sit.append(Interval(start=l, end=r, weight=w, ind=i))\n        \n        sit.sort(key=lambda x: (x.end, x.start))\n        last = [-1] * n\n        etime = [interval.end for interval in sit]\n        for i in range(n):\n            j = bisect_right(etime, sit[i].start - 1) - 1\n            last[i] = j \n        dp = [ [ (0, []) for _ in range(5) ] for _ in range(n+1) ]\n        \n        for i in range(1, n+1):\n            curr = sit[i-1]\n            for k in range(0, 5):\n                if k == 0:\n                    dp[i][k] = (0, [])\n                else:\n                    wt1, st1 = dp[i-1][k]\n                    if last[i-1] != -1 and k-1 >=0:\n                        wtp, stp = dp[last[i-1]+1][k-1]\n                    elif last[i-1] == -1 and k-1 >=0:\n                        wtp, stp = dp[0][k-1]\n                    else:\n                        wtp, stp = (0, [])\n                    \n                    wto = wtp + curr.weight\n                    sto = stp + [curr.ind]\n                    \n                    if wt1 > wto:\n                        dp[i][k] = (wt1, st1)\n                    elif wt1 < wto:\n                        dp[i][k] = (wto, sto)\n                    else:\n                        sst1 = sorted(st1)\n                        sst2 = sorted(sto)\n                        if sst1 < sst2:\n                            dp[i][k] = (wt1, st1)\n                        else:\n                            dp[i][k] = (wto, sto)\n        bwt = 0\n        bst = []\n        for k in range(1, 5):\n            currwt, currst = dp[n][k]\n            if currwt > bwt:\n                bwt = currwt\n                bst = currst\n            elif currwt == bwt:\n                if not bst:\n                    bst = currst\n                else:\n                    sbest = sorted(bst)\n                    scurr = sorted(currst)\n                    if scurr < sbest:\n                        bst = currst\n        \n        bsrt = sorted(bst)\n        return bsrt\n",
    "input": "maximumWeight(intervals=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]])",
    "output": "[2, 3]",
    "correct_condition": "maximumWeight(intervals=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]) == [2, 3]",
    "contest_id": "weekly-contest-431",
    "contest_date": "2024-01-07T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 273,
      "coverage": null
    },
    "submission_id": 1498028040
  },
  {
    "id": "contest432_q3708_s0",
    "question_id": 3708,
    "function_name": "zigzagTraversal",
    "code": "\nclass Solution:\n    def zigzagTraversal(self, grid: List[List[int]]) -> List[int]:\n        R, C = len(grid), len(grid[0])\n        ans = []\n        i, j = 0, 0\n\n        def connected(i, j, ii, jj):\n            return (i == ii and abs(j - jj) == 1) or (j == jj and abs(i - ii) == 1)\n\n        dir = 1\n        while 0 <= i < R and 0 <= j < C:\n            ans.append(grid[i][j])\n            ii = i\n            jj = j + 2 * dir\n            if 0 <= jj < C:\n                i, j = ii, jj\n            else:\n                ii = i + 1\n                jj = 0 if jj < 0 else C - 1\n                dir = -dir\n                if 0 <= ii < R and 0 <= jj < C:\n                    if connected(i, j, ii, jj):\n                        jj += dir\n                    i, j = ii, jj\n                else:\n                    break\n\n        return ans\n\n",
    "input": "zigzagTraversal(grid=[[1,2],[3,4]])",
    "output": "[1, 4]",
    "correct_condition": "zigzagTraversal(grid=[[1,2],[3,4]]) == [1, 4]",
    "contest_id": "weekly-contest-432",
    "contest_date": "2024-01-14T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 30,
      "coverage": null
    },
    "submission_id": 1505653842
  },
  {
    "id": "contest432_q3708_s1",
    "question_id": 3708,
    "function_name": "zigzagTraversal",
    "code": "class Solution:\n    def zigzagTraversal(self, grid: List[List[int]]) -> List[int]:\n\n        m, n = len(grid), len(grid[0])\n\n        r = 1\n        i, j = 0, 0\n        res = []\n        \n        while i < m:\n            res.append(grid[i][j])\n            if r:\n                j += 2\n                if j >= n:\n                    i += 1\n                    j = n - 1 - (j - n)\n                    r = 1 - r\n            else:\n                j -= 2\n                if j < 0:\n                    i += 1\n                    j = 0 - j - 1\n                    r = 1 - r\n\n        return res",
    "input": "zigzagTraversal(grid=[[1,2],[3,4]])",
    "output": "[1, 4]",
    "correct_condition": "zigzagTraversal(grid=[[1,2],[3,4]]) == [1, 4]",
    "contest_id": "weekly-contest-432",
    "contest_date": "2024-01-14T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 25,
      "coverage": null
    },
    "submission_id": 1505650015
  },
  {
    "id": "contest432_q3708_s2",
    "question_id": 3708,
    "function_name": "zigzagTraversal",
    "code": "class Solution:\n    def zigzagTraversal(self, grid: List[List[int]]) -> List[int]:\n        ans = []\n        for i, row in enumerate(grid):\n            if i % 2:\n                ans += row[::-1]\n            else:\n                ans += row\n        return ans[::2]\n            \n        ",
    "input": "zigzagTraversal(grid=[[1,2],[3,4]])",
    "output": "[1, 4]",
    "correct_condition": "zigzagTraversal(grid=[[1,2],[3,4]]) == [1, 4]",
    "contest_id": "weekly-contest-432",
    "contest_date": "2024-01-14T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 11,
      "coverage": null
    },
    "submission_id": 1505643478
  },
  {
    "id": "contest432_q3677_s0",
    "question_id": 3677,
    "function_name": "maximumAmount",
    "code": "\nclass Solution:\n    def maximumAmount(self, coins: List[List[int]]) -> int:\n        R, C = len(coins), len(coins[0])\n\n        @cache\n        def f(i, j, magic):\n            if (i, j) in ((R, C - 1), (R - 1, C)):\n                return 0\n            if i >= R or j >= C:\n                return -inf\n\n            value = coins[i][j] + max(f(i + 1, j, magic), f(i, j + 1, magic))\n            if magic > 0:\n                value = max(value, max(coins[i][j], 0) + max(f(i, j + 1, magic - 1), f(i + 1, j, magic - 1)))\n            return value\n\n        ans = f(0, 0, 2)\n        return ans\n\n",
    "input": "maximumAmount(coins=[[0,1,-1],[1,-2,3],[2,-3,4]])",
    "output": "8",
    "correct_condition": "maximumAmount(coins=[[0,1,-1],[1,-2,3],[2,-3,4]]) == 8",
    "contest_id": "weekly-contest-432",
    "contest_date": "2024-01-14T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 20,
      "coverage": null
    },
    "submission_id": 1505662274
  },
  {
    "id": "contest432_q3677_s1",
    "question_id": 3677,
    "function_name": "maximumAmount",
    "code": "class Solution:\n    def maximumAmount(self, coins: List[List[int]]) -> int:\n\n        m, n = len(coins), len(coins[0])\n        \n        dp0 = [[float('-inf')] * n for _ in range(m)]\n        dp1 = [[float('-inf')] * n for _ in range(m)]\n        dp2 = [[float('-inf')] * n for _ in range(m)]\n\n        dp0[0][0] = coins[0][0]\n        if coins[0][0] < 0:\n            dp1[0][0] = 0\n\n        for i, r in enumerate(coins):\n            for j, num in enumerate(r):\n                if i > 0:\n                    dp0[i][j] = max(dp0[i][j], dp0[i-1][j] + coins[i][j])\n                    dp1[i][j] = max(dp1[i][j], dp1[i-1][j] + coins[i][j])\n                    dp2[i][j] = max(dp2[i][j], dp2[i-1][j] + coins[i][j])\n                    if coins[i][j] < 0:\n                        dp1[i][j] = max(dp1[i][j], dp0[i-1][j])\n                        dp2[i][j] = max(dp2[i][j], dp1[i-1][j])\n\n                if j > 0:\n                    dp0[i][j] = max(dp0[i][j], dp0[i][j-1] + coins[i][j])\n                    dp1[i][j] = max(dp1[i][j], dp1[i][j-1] + coins[i][j])\n                    dp2[i][j] = max(dp2[i][j], dp2[i][j-1] + coins[i][j])\n                    if coins[i][j] < 0:\n                        dp1[i][j] = max(dp1[i][j], dp0[i][j-1])\n                        dp2[i][j] = max(dp2[i][j], dp1[i][j-1])\n                        \n        return max(dp0[-1][-1], dp1[-1][-1], dp2[-1][-1])",
    "input": "maximumAmount(coins=[[0,1,-1],[1,-2,3],[2,-3,4]])",
    "output": "8",
    "correct_condition": "maximumAmount(coins=[[0,1,-1],[1,-2,3],[2,-3,4]]) == 8",
    "contest_id": "weekly-contest-432",
    "contest_date": "2024-01-14T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 32,
      "coverage": null
    },
    "submission_id": 1505663966
  },
  {
    "id": "contest432_q3677_s2",
    "question_id": 3677,
    "function_name": "maximumAmount",
    "code": "inf = 10 ** 9\nclass Solution:\n    def maximumAmount(self, g: List[List[int]]) -> int:\n        n = len(g)\n        m = len(g[0])\n        f = [[[-inf] * 3 for j in range(m)] for i in range(n)]\n        f[0][0][0] = g[0][0]\n        f[0][0][1] = f[0][0][2] = max(g[0][0], 0)\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    continue\n                x = g[i][j]\n                for k in range(3):\n                    if i > 0 and f[i - 1][j][k] + x > f[i][j][k]:\n                        f[i][j][k] = f[i - 1][j][k] + x\n                    if j > 0 and f[i][j - 1][k] + x > f[i][j][k]:\n                        f[i][j][k] = f[i][j - 1][k] + x\n                    if k and i > 0 and f[i - 1][j][k - 1] > f[i][j][k]:\n                        f[i][j][k] = f[i - 1][j][k - 1]\n                    if k and j > 0 and f[i][j - 1][k - 1] > f[i][j][k]:\n                        f[i][j][k] = f[i][j - 1][k - 1]\n        return max(f[-1][-1])\n        ",
    "input": "maximumAmount(g=[[0,1,-1],[1,-2,3],[2,-3,4]])",
    "output": "8",
    "correct_condition": "maximumAmount(g=[[0,1,-1],[1,-2,3],[2,-3,4]]) == 8",
    "contest_id": "weekly-contest-432",
    "contest_date": "2024-01-14T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 24,
      "coverage": null
    },
    "submission_id": 1505655943
  },
  {
    "id": "contest432_q3720_s0",
    "question_id": 3720,
    "function_name": "minMaxWeight",
    "code": "\nclass Solution:\n    def minMaxWeight(self, n: int, edges: List[List[int]], threshold: int) -> int:\n        G = [[] for _ in range(n)]\n        for u, v, w in edges:\n            G[v].append((u, w))\n\n        def dfs(u, visited, cap):\n            visited[u] = True\n            for v, w in G[u]:\n                if w <= cap and not visited[v]:\n                    dfs(v, visited, cap)\n\n        visited = [False] * n\n        dfs(0, visited, inf)\n        for i in range(n):\n            if not visited[i]:\n                return -1\n\n        L = 0\n        R = 1000000 + 20\n        while L + 1 < R:\n            mid = (L + R) // 2\n            visited = [False] * n\n            dfs(0, visited, mid)\n            ok = True\n            for i in range(n):\n                if not visited[i]:\n                    ok = False\n                    break\n            if ok:\n                R = mid\n            else:\n                L = mid\n\n        return R\n",
    "input": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2)",
    "output": "1",
    "correct_condition": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2) == 1",
    "contest_id": "weekly-contest-432",
    "contest_date": "2024-01-14T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 36,
      "coverage": null
    },
    "submission_id": 1505695158
  },
  {
    "id": "contest432_q3720_s1",
    "question_id": 3720,
    "function_name": "minMaxWeight",
    "code": "class Solution:\n    def minMaxWeight(self, n: int, edges: List[List[int]], threshold: int) -> int:\n\n        ws = set()\n        graph = {}\n        rev = {}\n        for u, v, w in edges:\n            ws.add(w)\n            \n            if u not in graph:\n                graph[u] = defaultdict(lambda: float('inf'))\n            if v not in rev:\n                rev[v] = defaultdict(lambda: float('inf'))\n\n            graph[u][v] = min(graph[u][v], w)\n            rev[v][u] = min(rev[v][u], w)\n\n        q = deque([0])\n        seen = set([0])\n        while q:\n            v = q.popleft()\n            if v in rev:\n                for u in rev[v]:\n                    if u not in seen:\n                        q.append(u)\n                        seen.add(u)\n                        \n        if len(seen) < n:\n            return -1\n\n        def can(x):\n            q = deque([0])\n            seen = set([0])\n            while q:\n                v = q.popleft()\n                if v in rev:\n                    for u in rev[v]:\n                        if rev[v][u] <= x and u not in seen:\n                            q.append(u)\n                            seen.add(u)\n            return len(seen) == n\n\n        l, r = min(ws), max(ws)\n        while l < r:\n            mid = (l + r) // 2\n            if can(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l",
    "input": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2)",
    "output": "1",
    "correct_condition": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2) == 1",
    "contest_id": "weekly-contest-432",
    "contest_date": "2024-01-14T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 50,
      "coverage": null
    },
    "submission_id": 1505688956
  },
  {
    "id": "contest432_q3720_s2",
    "question_id": 3720,
    "function_name": "minMaxWeight",
    "code": "class Solution:\n    def minMaxWeight(self, n: int, edges: List[List[int]], threshold: int) -> int:\n        g = [[] for _ in range(n)]\n        m = 1\n        for u, v, w in edges:\n            g[v].append((u, w))\n            if w > m:\n                m = w\n        def check(mid):\n            vis = [0] * n\n            vis[0] = 1\n            Q = deque([0])\n            while Q:\n                u = Q.popleft()\n                for v, w in g[u]:\n                    if w <= mid and not vis[v]:\n                        Q.append(v)\n                        vis[v] = 1\n            return sum(vis) == n\n                        \n        \n        lo, hi = 1, m + 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if check(mid):\n                hi = mid\n            else:\n                lo = mid + 1\n        return -1 if lo > m else lo",
    "input": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2)",
    "output": "1",
    "correct_condition": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2) == 1",
    "contest_id": "weekly-contest-432",
    "contest_date": "2024-01-14T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 29,
      "coverage": null
    },
    "submission_id": 1505677494
  },
  {
    "id": "contest432_q3674_s0",
    "question_id": 3674,
    "function_name": "countNonDecreasingSubarrays",
    "code": "import bisect\nfrom typing import *\nfrom sortedcontainers import SortedList, SortedDict\nfrom collections import Counter, defaultdict\nfrom math import inf\nfrom math import gcd\nfrom math import factorial\nimport string\nimport random\nimport itertools\nfrom functools import cache, lru_cache\nfrom fractions import Fraction\nfrom itertools import pairwise\n\nclass Solution:\n    def countNonDecreasingSubarrays(self, nums: List[int], k: int) -> int:\n        nums.reverse()\n        n = len(nums)\n        nums.append(10**20)\n        ans = 0\n        remains = k\n        right = 0\n        stack = Deque()\n        for left in range(n):\n            while remains >= 0 and right <= n:\n                if len(stack) == 0 or nums[right] < stack[-1][0]:\n                    stack.append([nums[right], 1])\n                    right += 1\n                else:\n                    combined = 1\n                    while len(stack) > 0 and nums[right] >= stack[-1][0]:\n                        combined += stack[-1][1]\n                        remains -= (nums[right] - stack[-1][0]) * stack[-1][1]\n                        stack.pop()\n                    stack.append([nums[right], combined])\n                    right += 1\n            ans += right - left - 1\n            remains += stack[0][0] - nums[left]\n            stack[0][1] -= 1\n            while len(stack) > 0 and stack[0][1] == 0:\n                stack.popleft()\n\n        return ans\n\n",
    "input": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7)",
    "output": "17",
    "correct_condition": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7) == 17",
    "contest_id": "weekly-contest-432",
    "contest_date": "2024-01-14T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 44,
      "coverage": null
    },
    "submission_id": 1505682945
  },
  {
    "id": "contest432_q3674_s1",
    "question_id": 3674,
    "function_name": "countNonDecreasingSubarrays",
    "code": "class Solution:\n    def countNonDecreasingSubarrays(self, nums: List[int], k: int) -> int:\n\n        n = len(nums)\n\n        j = n\n        total = 0\n        stack = deque()\n        res = 0\n        for i in range(n-1, -1, -1):\n            num = nums[i]\n            \n            inc = 0\n            while stack and nums[stack[-1]] <= nums[i]:\n                cur = stack.pop()\n                prev = stack[-1] if stack else j\n                inc += (nums[i] - nums[cur]) * (prev - cur)\n            total += inc\n\n            stack.append(i)\n\n            while total > k:\n                total -= nums[stack[0]] - nums[j-1]\n                j -= 1\n\n                if j == stack[0]:\n                    stack.popleft()\n\n            res += j - i\n        return res",
    "input": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7)",
    "output": "17",
    "correct_condition": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7) == 17",
    "contest_id": "weekly-contest-432",
    "contest_date": "2024-01-14T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 30,
      "coverage": null
    },
    "submission_id": 1505713317
  },
  {
    "id": "contest432_q3674_s2",
    "question_id": 3674,
    "function_name": "countNonDecreasingSubarrays",
    "code": "class Solution:\n    def countNonDecreasingSubarrays(self, nums: List[int], k: int) -> int:\n        ans = 0\n        n = len(nums)\n        nextlargestidx = [None] * n # strictly larger\n\n        st = []\n        for i in range(len(nums)):\n            while len(st) != 0 and nums[st[-1]] < nums[i]:\n                nextlargestidx[st[-1]] = i\n                st.pop()\n            st.append(i)\n\n        # print(nextlargestidx)\n        \n        start = 0 # inclusive\n        used = 0\n        waterline = 0\n        for i in range(len(nums)):\n            if waterline > nums[i]:\n                used += waterline - nums[i]\n            else:\n                waterline = nums[i]\n\n            while used > k:\n                # attempt to move start forward one\n                oldnext = nextlargestidx[start]\n                oldwaterline = nums[start]\n                \n                temp = start+1\n                while temp is not None and (oldnext is None or temp < oldnext) and (temp <= i):\n                    if oldnext is None or oldnext > i:\n                        waterline = nums[temp]\n                    basinend = n if nextlargestidx[temp] is None else nextlargestidx[temp]\n                    reducecount = min(i+1,basinend) - temp\n                    used -= reducecount * (oldwaterline - nums[temp])\n                    temp = nextlargestidx[temp]\n                \n                    \n                start += 1\n            # print(start, \"to\", i, \"using\", used, \"waterline\", waterline)\n            ans += (i-start+1)\n\n        return ans",
    "input": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7)",
    "output": "17",
    "correct_condition": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7) == 17",
    "contest_id": "weekly-contest-432",
    "contest_date": "2024-01-14T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 44,
      "coverage": null
    },
    "submission_id": 1505705811
  },
  {
    "id": "contest433_q3731_s0",
    "question_id": 3731,
    "function_name": "subarraySum",
    "code": "class Solution:\n    def subarraySum(self, nums):\n        n=len(nums)\n        p=[0]*(n+1)\n        for i in range(n):\n            p[i+1]=p[i]+nums[i]\n        s1=0\n        s2=0\n        for i in range(n):\n            st=i-nums[i]\n            if st<0: st=0\n            s1+=p[i+1]\n            s2+=p[st]\n        return s1-s2",
    "input": "subarraySum(nums=[2,3,1])",
    "output": "11",
    "correct_condition": "subarraySum(nums=[2,3,1]) == 11",
    "contest_id": "weekly-contest-433",
    "contest_date": "2024-01-21T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 14,
      "coverage": null
    },
    "submission_id": 1513087537
  },
  {
    "id": "contest433_q3731_s1",
    "question_id": 3731,
    "function_name": "subarraySum",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nclass Solution:\n    def subarraySum(self, nums: List[int]) -> int:\n        n = len(nums)\n        pref = [0] * (n + 1)\n        for i in range(n):\n            pref[i + 1] = pref[i] + nums[i]\n        \n        ans = 0\n        \n        for i in range(n):\n            start = max(0, i - nums[i])\n            ans += pref[i + 1] - pref[start]\n        return int(ans)\n",
    "input": "subarraySum(nums=[2,3,1])",
    "output": "11",
    "correct_condition": "subarraySum(nums=[2,3,1]) == 11",
    "contest_id": "weekly-contest-433",
    "contest_date": "2024-01-21T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 213,
      "coverage": null
    },
    "submission_id": 1513087481
  },
  {
    "id": "contest433_q3731_s2",
    "question_id": 3731,
    "function_name": "subarraySum",
    "code": "class Solution:\n    def subarraySum(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            start = max(0, i - nums[i])\n            s = 0\n            for j in range(start, i + 1):\n                s += nums[j]\n            ans += s\n        return ans",
    "input": "subarraySum(nums=[2,3,1])",
    "output": "11",
    "correct_condition": "subarraySum(nums=[2,3,1]) == 11",
    "contest_id": "weekly-contest-433",
    "contest_date": "2024-01-21T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 11,
      "coverage": null
    },
    "submission_id": 1513080952
  },
  {
    "id": "contest433_q3714_s0",
    "question_id": 3714,
    "function_name": "minMaxSums",
    "code": "class Solution:\n    def minMaxSums(self, nums: List[int], k: int) -> int:\n        import sys\n        sys.setrecursionlimit(10**7)\n        M=10**9+7\n        n=len(nums)\n        f=[1]*(n+1)\n        invf=[1]*(n+1)\n        for i in range(1,n+1):\n            f[i]=(f[i-1]*i)%M\n        def p(b,e):\n            r=1\n            while e>0:\n                if e&1:\n                    r=(r*b)%M\n                b=(b*b)%M\n                e>>=1\n            return r\n        invf[n]=p(f[n],M-2)\n        for i in range(n-1,-1,-1):\n            invf[i]=(invf[i+1]*(i+1))%M\n        def C(a,b):\n            if b<0 or b>a:\n                return 0\n            return (f[a]*((invf[b]*invf[a-b])%M))%M\n        nums.sort()\n        ans=0\n        for i in range(n):\n            for s in range(1,k+1):\n                if s-1<=i:\n                    ans=(ans+nums[i]*C(i,s-1))%M\n        for i in range(n):\n            for s in range(1,k+1):\n                if s-1<=n-1-i:\n                    ans=(ans+nums[i]*C(n-1-i,s-1))%M\n        return ans%M\n",
    "input": "minMaxSums(nums=[1,2,3], k=2)",
    "output": "24",
    "correct_condition": "minMaxSums(nums=[1,2,3], k=2) == 24",
    "contest_id": "weekly-contest-433",
    "contest_date": "2024-01-21T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 36,
      "coverage": null
    },
    "submission_id": 1513088015
  },
  {
    "id": "contest433_q3714_s1",
    "question_id": 3714,
    "function_name": "minMaxSums",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nclass Solution:\n    def minMaxSums(self, arr: List[int], k: int) -> int:\n        mod = 10**9+7\n        n = len(arr)\n        arr.sort()\n        \n        combi = [[0] * (k + 1) for i in range(n + 1)]\n        for i in range(n + 1):\n            combi[i][0] = 1\n            for j in range(1, min(i, k) + 1):\n                combi[i][j] = (combi[i - 1][j - 1] + combi[i - 1][j]) % mod\n        \n        ans = 0\n        \n        for j in range(n):\n            ways = 0\n            maxl = min(k, j + 1)\n            for l in range(1, maxl + 1):\n                ways += combi[j][l - 1]\n                if ways >= mod:\n                    ways -= mod\n            ans += arr[j] * ways % mod\n            ans %= mod\n        \n        for i in range(n):\n            ways = 0\n            maxl = min(k, n - i)\n            rem = n - 1 - i\n            for l in range(1, maxl + 1):\n                ways += combi[rem][l - 1]\n                if ways >= mod:\n                    ways -= mod\n            ans += arr[i] * ways % mod\n            ans %= mod\n        \n        return int(ans)\n\n",
    "input": "minMaxSums(arr=[1,2,3], k=2)",
    "output": "24",
    "correct_condition": "minMaxSums(arr=[1,2,3], k=2) == 24",
    "contest_id": "weekly-contest-433",
    "contest_date": "2024-01-21T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 237,
      "coverage": null
    },
    "submission_id": 1513090108
  },
  {
    "id": "contest433_q3714_s2",
    "question_id": 3714,
    "function_name": "minMaxSums",
    "code": "class Solution:\n    def minMaxSums(self, nums: List[int], k: int) -> int:\n        MOD = 10**9+7\n        n = len(nums)\n        nums.sort()\n        fact = [1] * (n+1)\n        inv_fact = [1] * (n+1)\n        \n        for i in range(1,n+1):\n            fact[i] = fact[i-1] * i % MOD\n        inv_fact[n] = pow(fact[n], MOD-2, MOD)\n        \n        for i in range(n-1,-1,-1):\n            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n        \n        def comb(a,b):\n            if b < 0 or b > a: return 0\n            return fact[a] * inv_fact[b] % MOD * inv_fact[a-b] % MOD\n        partialC = [0] * n\n        for i in range(n):\n            m = min(i,k-1)\n            s = 0\n            for j in range(m+1):\n                s = (s + comb(i,j)) % MOD\n            partialC[i] = s\n        ans1 = 0\n        ans2 = 0\n        for i in range(n):\n            ans1 = (ans1 + nums[i] * partialC[i]) % MOD\n            ans2 = (ans2 + nums[i] * partialC[n-1-i]) % MOD\n        return (ans1 + ans2) % MOD",
    "input": "minMaxSums(nums=[1,2,3], k=2)",
    "output": "24",
    "correct_condition": "minMaxSums(nums=[1,2,3], k=2) == 24",
    "contest_id": "weekly-contest-433",
    "contest_date": "2024-01-21T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 31,
      "coverage": null
    },
    "submission_id": 1513086962
  },
  {
    "id": "contest433_q3737_s0",
    "question_id": 3737,
    "function_name": "minCost",
    "code": "class Solution:\n    def minCost(self, n: int, cost: List[List[int]]) -> int:\n        s=[(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]\n        dp1=[cost[0][x[0]]+cost[n-1][x[1]] for x in s]\n        v=[[False]*6 for _ in range(6)]\n        for i in range(6):\n            for j in range(6):\n                v[i][j]=(s[i][0]!=s[j][0] and s[i][1]!=s[j][1])\n        for i in range(1,n//2):\n            dp2=[0]*6\n            for j in range(6):\n                mn=min(dp1[k] for k in range(6) if v[k][j])\n                dp2[j]=mn + cost[i][s[j][0]] + cost[n-1-i][s[j][1]]\n            dp1=dp2\n        return min(dp1)\n",
    "input": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]])",
    "output": "9",
    "correct_condition": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]]) == 9",
    "contest_id": "weekly-contest-433",
    "contest_date": "2024-01-21T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 15,
      "coverage": null
    },
    "submission_id": 1513082546
  },
  {
    "id": "contest433_q3737_s1",
    "question_id": 3737,
    "function_name": "minCost",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nclass Solution:\n    def minCost(self, n: int, cost: list[list[int]]) -> int:\n        cpy=cost.copy()\n        half = n // 2\n        vst = [(a, b) for a in range(3) for b in range(3) if a != b]\n        sidx = {state: idx for idx, state in enumerate(vst)}\n        nst = len(vst) \n        INF = float('inf')\n        \n        dp = [INF] * nst\n        ndp = [INF] * nst\n        \n        for (a, b) in vst:\n            idx = sidx[(a, b)]\n            dp[idx] = cpy[0][a] + cpy[n-1][b]\n        \n        for i in range(1, half):\n            for s in range(nst):\n                ndp[s] = INF\n            \n            for (a, b) in vst:\n                cidx = sidx[(a, b)]\n                ccost = cpy[i][a] + cpy[n-1-i][b]\n                \n                for (pa, pb) in vst:\n                    if a == pa or b == pb:\n                        continue\n                    prevs = sidx[(pa, pb)]\n                    if dp[prevs] == INF:\n                        continue\n                    ndp[cidx] = min(ndp[cidx], dp[prevs] + ccost)\n            \n            dp, ndp = ndp, dp \n        return min(dp)\n",
    "input": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]])",
    "output": "9",
    "correct_condition": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]]) == 9",
    "contest_id": "weekly-contest-433",
    "contest_date": "2024-01-21T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 234,
      "coverage": null
    },
    "submission_id": 1513098787
  },
  {
    "id": "contest433_q3737_s2",
    "question_id": 3737,
    "function_name": "minCost",
    "code": "class Solution:\n    def minCost(self, n: int, cost: List[List[int]]) -> int:\n        dp = [[[float('inf')] * 3 for _ in range(3)] for __ in range(n//2+1)]\n        for cl in range(3):\n            for cr in range(3):\n                dp[0][cl][cr] = 0\n                \n        for nl in range(3):\n            for nr in range(3):\n                if nl != nr:\n                    for cl in range(3):\n                        for cr in range(3):\n                            v = dp[0][cl][cr] + cost[0][nl] + cost[n-1][nr]\n                            if v < dp[1][nl][nr]:\n                                dp[1][nl][nr] = v\n                                \n        for i in range(1, n//2):\n            for cl in range(3):\n                for cr in range(3):\n                    p = dp[i][cl][cr]\n                    if p == inf:\n                        continue\n                    for nl in range(3):\n                        for nr in range(3):\n                            if nl != nr and nl != cl and nr != cr:\n                                v = p + cost[i][nl] + cost[n-1-i][nr]\n                                if v < dp[i+1][nl][nr]:\n                                    dp[i+1][nl][nr] = v\n                                    \n        r = float('inf')\n        \n        for cl in range(3):\n            for cr in range(3):\n                if dp[n//2][cl][cr] < r:\n                    r = dp[n//2][cl][cr]\n        return r",
    "input": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]])",
    "output": "9",
    "correct_condition": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]]) == 9",
    "contest_id": "weekly-contest-433",
    "contest_date": "2024-01-21T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 36,
      "coverage": null
    },
    "submission_id": 1513091870
  },
  {
    "id": "contest433_q3725_s0",
    "question_id": 3725,
    "function_name": "minMaxSubarraySum",
    "code": "class Solution:\n    def minMaxSubarraySum(self, nums, k):\n        def p(L,R,M):\n            u=min(L,M-1)\n            if u<=0:return 0\n            if R>=M-1:return M*u - u*(u+1)//2\n            x=M-R\n            if x>u:return R*u\n            s=R*(x-1)\n            s+=M*(u-x+1)-((u*(u+1))//2-((x-1)*x)//2)\n            return s\n        def s(a,k,m):\n            n=len(a)\n            l=[0]*n\n            r=[0]*n\n            st=[]\n            for i in range(n):\n                while st and ((a[st[-1]]>a[i]) if m else (a[st[-1]]<a[i])):\n                    st.pop()\n                l[i]=i-st[-1] if st else i+1\n                st.append(i)\n            st=[]\n            for i in range(n-1,-1,-1):\n                while st and ((a[st[-1]]>=a[i]) if m else (a[st[-1]]<=a[i])):\n                    st.pop()\n                r[i]=st[-1]-i if st else n-i\n                st.append(i)\n            res=0\n            for i in range(n):\n                res+=a[i]*p(l[i],r[i],k+1)\n            return res\n        return s(nums,k,True)+s(nums,k,False)",
    "input": "minMaxSubarraySum(nums=[1,2,3], k=2)",
    "output": "20",
    "correct_condition": "minMaxSubarraySum(nums=[1,2,3], k=2) == 20",
    "contest_id": "weekly-contest-433",
    "contest_date": "2024-01-21T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 32,
      "coverage": null
    },
    "submission_id": 1513090643
  },
  {
    "id": "contest433_q3725_s1",
    "question_id": 3725,
    "function_name": "minMaxSubarraySum",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nclass Solution:\n    def minMaxSubarraySum(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        \n        prev1 = [-1] * n\n        nx1 = [n] * n\n        prev2 = [-1] * n\n        nx2 = [n] * n\n        \n        stk = []\n        for i in range(n):\n            while stk and arr[stk[-1]] >= arr[i]:\n                stk.pop()\n            prev1[i] = stk[-1] if stk else -1\n            stk.append(i)\n        \n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and arr[stk[-1]] > arr[i]:\n                stk.pop()\n            nx1[i] = stk[-1] if stk else n\n            stk.append(i)\n        \n        stk = []\n        for i in range(n):\n            while stk and arr[stk[-1]] <= arr[i]:\n                stk.pop()\n            prev2[i] = stk[-1] if stk else -1\n            stk.append(i)\n        \n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and arr[stk[-1]] < arr[i]:\n                stk.pop()\n            nx2[i] = stk[-1] if stk else n\n            stk.append(i)\n        \n        tot = 0\n\n        def calc(i, left, right, val):\n            L = left\n            R = right\n            lim = min(L, k)\n            if lim <= 0:\n                return 0\n            sumc = 0\n            cng = max(1, k - R + 1)\n            if cng > lim:\n                sumc = lim * R\n            else:\n                fp = cng - 1\n                if fp > 0:\n                    sumc += fp * R\n                for x in range(max(1, cng), lim + 1):\n                    sumc += (k - x + 1)\n            return val * sumc\n        \n        for i in range(n):\n            lmin = i - prev1[i]\n            rmin = nx1[i] - i\n            tot += calc(i, lmin, rmin, arr[i])\n            \n            lmax = i - prev2[i]\n            rmax = nx2[i] - i\n            tot += calc(i, lmax, rmax, arr[i])\n        \n        return tot\n",
    "input": "minMaxSubarraySum(arr=[1,2,3], k=2)",
    "output": "20",
    "correct_condition": "minMaxSubarraySum(arr=[1,2,3], k=2) == 20",
    "contest_id": "weekly-contest-433",
    "contest_date": "2024-01-21T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 267,
      "coverage": null
    },
    "submission_id": 1513094898
  },
  {
    "id": "contest433_q3725_s2",
    "question_id": 3725,
    "function_name": "minMaxSubarraySum",
    "code": "class Solution:\n    def minMaxSubarraySum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        lSmall = [-1]*n\n        rSmall = [n]*n\n        stack = []\n        for i in range(n):\n            while stack and nums[stack[-1]]>nums[i]:\n                stack.pop()\n            lSmall[i] = stack[-1] if stack else -1\n            stack.append(i)\n        stack.clear()\n        for i in range(n-1,-1,-1):\n            while stack and nums[stack[-1]]>=nums[i]:\n                stack.pop()\n            rSmall[i] = stack[-1] if stack else n\n            stack.append(i)\n        def countSub(L,R,k):\n            if L==0 or R==0:\n                return 0\n            m = k - 1\n            if (L - 1)+(R - 1) <= m:\n                return L*R\n            X = min(L,m+1)\n            x0 = max(0,m - (R-1))\n            s = 0\n            if x0>0:\n                t = min(x0,X)\n                s += t*R\n            if x0< X:\n                start = max(x0,0)\n                end = X\n                c = (end - start)\n                s += c*(m+1) - (start+end-1)*c//2\n            return s\n        totalMin = 0\n        for i in range(n):\n            L = i - lSmall[i]\n            R = rSmall[i] - i\n            totalMin += nums[i]*countSub(L,R,k)\n        lBig = [-1]*n\n        rBig = [n]*n\n        stack.clear()\n        for i in range(n):\n            while stack and nums[stack[-1]]<nums[i]:\n                stack.pop()\n            lBig[i] = stack[-1] if stack else -1\n            stack.append(i)\n        stack.clear()\n        for i in range(n-1,-1,-1):\n            while stack and nums[stack[-1]]<=nums[i]:\n                stack.pop()\n            rBig[i] = stack[-1] if stack else n\n            stack.append(i)\n        totalMax = 0\n        for i in range(n):\n            L = i - lBig[i]\n            R = rBig[i] - i\n            totalMax += nums[i]*countSub(L,R,k)\n        return totalMin + totalMax",
    "input": "minMaxSubarraySum(nums=[1,2,3], k=2)",
    "output": "20",
    "correct_condition": "minMaxSubarraySum(nums=[1,2,3], k=2) == 20",
    "contest_id": "weekly-contest-433",
    "contest_date": "2024-01-21T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 60,
      "coverage": null
    },
    "submission_id": 1513104348
  },
  {
    "id": "contest434_q3704_s0",
    "question_id": 3704,
    "function_name": "countPartitions",
    "code": "class Solution:\n    def countPartitions(self, nums: List[int]) -> int:\n        S = sum(nums)\n        n = len(nums)\n        answer = 0 \n        S1 = 0 \n        for i in range(n-1):\n            S1+=nums[i]\n            S-=nums[i]\n            if (S-S1) % 2==0:\n                answer+=1\n        return answer\n        ",
    "input": "countPartitions(nums=[10,10,3,7,6])",
    "output": "4",
    "correct_condition": "countPartitions(nums=[10,10,3,7,6]) == 4",
    "contest_id": "weekly-contest-434",
    "contest_date": "2024-01-28T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 13,
      "coverage": null
    },
    "submission_id": 1520578515
  },
  {
    "id": "contest434_q3704_s1",
    "question_id": 3704,
    "function_name": "countPartitions",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def countPartitions(self, nums: List[int]) -> int:\n        ans = sum(nums)\n        if ans % 2 == 0:\n            return len(nums) - 1\n        else:\n            return 0",
    "input": "countPartitions(nums=[10,10,3,7,6])",
    "output": "4",
    "correct_condition": "countPartitions(nums=[10,10,3,7,6]) == 4",
    "contest_id": "weekly-contest-434",
    "contest_date": "2024-01-28T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 207,
      "coverage": null
    },
    "submission_id": 1520622334
  },
  {
    "id": "contest434_q3704_s2",
    "question_id": 3704,
    "function_name": "countPartitions",
    "code": "class Solution:\n    def countPartitions(self, nums: List[int]) -> int:\n        total = sum(nums)\n        if total % 2 != 0:\n            return 0\n        return len(nums) - 1",
    "input": "countPartitions(nums=[10,10,3,7,6])",
    "output": "4",
    "correct_condition": "countPartitions(nums=[10,10,3,7,6]) == 4",
    "contest_id": "weekly-contest-434",
    "contest_date": "2024-01-28T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 6,
      "coverage": null
    },
    "submission_id": 1520580436
  },
  {
    "id": "contest434_q3721_s0",
    "question_id": 3721,
    "function_name": "countMentions",
    "code": "class Solution:\n    def countMentions(self, numberOfUsers: int, events: List[List[str]]) -> List[int]:\n        m = numberOfUsers\n        n = len(events)\n        L = []\n        for event in events:\n            if event[0]=='MESSAGE':\n                t = int(event[1])\n                L.append([t, 2, event[2]])\n            else:\n                t = int(event[1])\n                L.append([t, 0, event[2]])\n                L.append([t+60, 1, event[2]])\n        d = {}\n        for t, x, R in L:\n            if t not in d:\n                d[t] = [[], [], []]\n            d[t][x].append(R)\n        users = set(range(m))\n        answer = [0 for i in range(m)]\n        for t in sorted(d):\n            for user in d[t][1]:\n                users.add(int(user))\n            for user in d[t][0]:\n                user = int(user)\n                if user in users:\n                    users.remove(user)\n            for x in d[t][2]:\n                if x=='ALL':\n                    for i in range(m):\n                        answer[i]+=1\n                elif x=='HERE':\n                    for i in users:\n                        answer[i]+=1\n                else:\n                    x = x.split()\n                    for i in x:\n                        answer[int(i[2:])]+=1\n        return answer",
    "input": "countMentions(numberOfUsers=2, events=[[\"MESSAGE\",\"10\",\"id1 id0\"],[\"OFFLINE\",\"11\",\"0\"],[\"MESSAGE\",\"71\",\"HERE\"]])",
    "output": "[2, 2]",
    "correct_condition": "countMentions(numberOfUsers=2, events=[[\"MESSAGE\",\"10\",\"id1 id0\"],[\"OFFLINE\",\"11\",\"0\"],[\"MESSAGE\",\"71\",\"HERE\"]]) == [2, 2]",
    "contest_id": "weekly-contest-434",
    "contest_date": "2024-01-28T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 39,
      "coverage": null
    },
    "submission_id": 1520610644
  },
  {
    "id": "contest434_q3721_s2",
    "question_id": 3721,
    "function_name": "countMentions",
    "code": "from typing import List\n\nclass Solution:\n    def countMentions(self, numberOfUsers: int, events: List[List[str]]) -> List[int]:\n        mentions = [0] * numberOfUsers\n        offline_until = [0] * numberOfUsers\n\n        def sort_events(events: List[List[str]]) -> List[List[str]]:\n          \n            def sort_key(event):\n                ts = int(event[1])\n                event_type_priority = 0 if event[0] == 'OFFLINE' else 1\n                return (ts, event_type_priority)\n\n            return sorted(events, key=sort_key)\n\n        def handle_offline_event(user_id: int, ts: int):\n          \n            offline_until[user_id] = ts + 60\n\n        def handle_message_event(ts: int, payload: str):\n          \n            tokens = payload.split()\n            for token in tokens:\n                if token == 'ALL':\n                    # Mention all users (including offline)\n                    for user in range(numberOfUsers):\n                        mentions[user] += 1\n                elif token == 'HERE':\n                   \n                    for user in range(numberOfUsers):\n                        if offline_until[user] <= ts:\n                            mentions[user] += 1\n                else:  \n                    user = int(token[2:])\n                    mentions[user] += 1\n\n        def process_events(events: List[List[str]]):\n          \n            for event in events:\n                event_type, ts_str, payload = event\n                ts = int(ts_str)\n\n                if event_type == 'OFFLINE':\n                    handle_offline_event(int(payload), ts)\n                elif event_type == 'MESSAGE':\n                    handle_message_event(ts, payload)\n\n        # Sort events and process them\n        sorted_events = sort_events(events)\n        process_events(sorted_events)\n\n        return mentions\n",
    "input": "countMentions(numberOfUsers=2, events=[[\"MESSAGE\",\"10\",\"id1 id0\"],[\"OFFLINE\",\"11\",\"0\"],[\"MESSAGE\",\"71\",\"HERE\"]])",
    "output": "[2, 2]",
    "correct_condition": "countMentions(numberOfUsers=2, events=[[\"MESSAGE\",\"10\",\"id1 id0\"],[\"OFFLINE\",\"11\",\"0\"],[\"MESSAGE\",\"71\",\"HERE\"]]) == [2, 2]",
    "contest_id": "weekly-contest-434",
    "contest_date": "2024-01-28T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 53,
      "coverage": null
    },
    "submission_id": 1520595169
  },
  {
    "id": "contest434_q3751_s0",
    "question_id": 3751,
    "function_name": "maxFrequency",
    "code": "class Solution:\n    def maxFrequency(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        k_count = 0 \n        for x in nums:\n            if x==k:\n                k_count+=1\n        answer = k_count\n        for x in range(1, 51):\n            curr_k = 0 \n            my_min = 0\n            x_count = 0 \n            for i in range(n):\n                if nums[i]==x:\n                    x_count+=1 \n                if nums[i]==k:\n                    curr_k+=1\n                my_min = min(my_min, x_count-curr_k)\n                answer = max(answer, x_count-my_min+k_count-curr_k)\n                #best you can do \n                #is [k-count best-freq]+rema\n                #x-freq - \n        return answer\n        \n        ",
    "input": "maxFrequency(nums=[1,2,3,4,5,6], k=1)",
    "output": "2",
    "correct_condition": "maxFrequency(nums=[1,2,3,4,5,6], k=1) == 2",
    "contest_id": "weekly-contest-434",
    "contest_date": "2024-01-28T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 25,
      "coverage": null
    },
    "submission_id": 1520594425
  },
  {
    "id": "contest434_q3751_s1",
    "question_id": 3751,
    "function_name": "maxFrequency",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def maxFrequency(self, nums: List[int], k: int) -> int:\n        totk = sum(1 for num in nums if num == k)\n        maxf = totk\n        for t in range(1, 51):\n            if t == k:\n                continue\n            csum = 0\n            msum = 0\n            for num in nums:\n                if num == t:\n                    csum += 1\n                elif num == k:\n                    csum -= 1\n                if csum < 0:\n                    csum = 0\n                msum = max(msum, csum)\n            maxf = max(maxf, totk + msum)\n        return maxf\n",
    "input": "maxFrequency(nums=[1,2,3,4,5,6], k=1)",
    "output": "2",
    "correct_condition": "maxFrequency(nums=[1,2,3,4,5,6], k=1) == 2",
    "contest_id": "weekly-contest-434",
    "contest_date": "2024-01-28T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 219,
      "coverage": null
    },
    "submission_id": 1520625578
  },
  {
    "id": "contest434_q3751_s2",
    "question_id": 3751,
    "function_name": "maxFrequency",
    "code": "from typing import List\n\nclass Solution:\n    def maxFrequency(self, nums: List[int], k: int) -> int:\n        import sys\n\n        def count_k_occurrences(nums: List[int], k: int) -> int:\n          \n            return sum(1 for x in nums if x == k)\n\n        def build_array(nums: List[int], k: int, v: int) -> List[int]:\n        \n            return [1 if x == v else -1 if x == k else 0 for x in nums]\n\n        def find_max_subarray_sum(arr: List[int]) -> int:\n          \n            current_sum = 0\n            max_sum = -sys.maxsize\n            for val in arr:\n                current_sum = max(val, current_sum + val)\n                max_sum = max(max_sum, current_sum)\n            return max_sum\n\n        def calculate_best_gain(nums: List[int], k: int, n: int) -> int:\n         \n            best_gain = 0\n            for v in range(1, 51):\n                if v == k:\n                    continue\n                arr = build_array(nums, k, v)\n                max_sum = find_max_subarray_sum(arr)\n                if max_sum > best_gain:\n                    best_gain = max_sum\n            return best_gain\n\n        n = len(nums)\n        base_k = count_k_occurrences(nums, k)\n\n        if base_k == n:\n            return n\n\n        best_gain = calculate_best_gain(nums, k, n)\n        return base_k + max(0, best_gain)\n",
    "input": "maxFrequency(nums=[1,2,3,4,5,6], k=1)",
    "output": "2",
    "correct_condition": "maxFrequency(nums=[1,2,3,4,5,6], k=1) == 2",
    "contest_id": "weekly-contest-434",
    "contest_date": "2024-01-28T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 43,
      "coverage": null
    },
    "submission_id": 1520602804
  },
  {
    "id": "contest434_q3713_s0",
    "question_id": 3713,
    "function_name": "supersequences",
    "code": "# from heapq import heappop, heappush\n\n\ndef toposort(graph):\n    res, found = [], [0] * len(graph)\n    stack = list(range(len(graph)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            res.append(~node)\n        elif not found[node]:\n            found[node] = 1\n            stack.append(~node)\n            stack += graph[node]\n\n    # cycle check\n    for node in res:\n        if any(found[nei] for nei in graph[node]):\n            return None\n        found[node] = 0\n\n    return res[::-1]\n\n\ndef kahn(graph):\n    n = len(graph)\n\n    indeg, idx = [0] * n, [0] * n\n    for i in range(n):\n        for e in graph[i]:\n            indeg[e] += 1\n\n    q, res = [], []\n    for i in range(n):\n        if indeg[i] == 0:\n            q.append(i)  # heappush(q, -i)\n\n    nr = 0\n    while q:\n        res.append(q.pop())  # res.append(-heappop(q))\n        idx[res[-1]], nr = nr, nr + 1\n        for e in graph[res[-1]]:\n            indeg[e] -= 1\n            if indeg[e] == 0:\n                q.append(e)  # heappush(q, -e)\n\n    return res, idx, nr == n\n    \nclass Solution:\n    def supersequences(self, words: List[str]) -> List[List[int]]:\n        \"\"\"\n        certainly every-letter-twice works\n        so, SOME letters twice \n\n        a     a \n        \"\"\"\n        g = [[] for i in range(26)]\n        g2 = [[] for i in range(26)]\n        for xy in words:\n            x = xy[0]\n            y = xy[1]\n            x = ord(x)-ord('a')\n            y = ord(y)-ord('a')\n            g[x].append(y)\n            g2[y].append(x)\n        L = []\n        for i in range(26):\n            if len(g[i]) > 0 or len(g2[i]) > 0:\n                L.append(i)\n        from itertools import combinations\n        m = len(L)\n        for k in range(m+1):\n            works = []\n            for doubled in combinations(L, k):\n                D = set(doubled)\n                g2 = [[] for i in range(26)]\n                for i in L:\n                    if i not in D:\n                        for j in g[i]:\n                            if j not in D:\n                                g2[i].append(j)\n                if toposort(g2) is not None:\n                    works.append(D)\n            if len(works) > 0:\n                answer = []\n                for D in works:\n                    entry = [0 for i in range(26)]\n                    for i in L:\n                        entry[i] = 1 \n                    for i in D:\n                        entry[i]+=1\n                    answer.append(entry)\n                return answer\n        ",
    "input": "supersequences(words=[\"ab\",\"ba\"])",
    "output": "[[2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]",
    "correct_condition": "supersequences(words=[\"ab\",\"ba\"]) == [[2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]",
    "contest_id": "weekly-contest-434",
    "contest_date": "2024-01-28T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 94,
      "coverage": null
    },
    "submission_id": 1520629198
  },
  {
    "id": "contest434_q3713_s1",
    "question_id": 3713,
    "function_name": "supersequences",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def supersequences(self, words: List[str]) -> List[List[int]]:\n        lset = set()\n        for w in words:\n            if len(w) >= 1:\n                lset.add(w[0])\n            if len(w) >= 2:\n                lset.add(w[1])\n        letters = sorted(lset)\n        k = len(letters)\n        ind1 = {letter: i for i, letter in enumerate(letters)}\n        adj = [[] for i in range(k)]\n        ls1 = [False] * k\n        for w in words:\n            if len(w) < 2:\n                continue\n            a = ind1[w[0]]\n            b = ind1[w[1]]\n            if a == b:\n                ls1[a] = True\n            else:\n                adj[a].append(b)\n        disc = [-1] * k\n        low = [0] * k\n        sid = [-1] * k\n        stks = [False] * k\n        st = []\n        dfst = 0\n        scnt = 0\n\n        def solve(u):\n            nonlocal dfst, scnt\n            disc[u] = low[u] = dfst\n            dfst += 1\n            st.append(u)\n            stks[u] = True\n            for v in adj[u]:\n                if disc[v] == -1:\n                    solve(v)\n                    low[u] = min(low[u], low[v])\n                elif stks[v]:\n                    low[u] = min(low[u], disc[v])\n            if low[u] == disc[u]:\n                while True:\n                    topv = st.pop()\n                    stks[topv] = False\n                    sid[topv] = scnt\n                    if topv == u:\n                        break\n                scnt += 1\n\n        for i in range(k):\n            if disc[i] == -1:\n                solve(i)\n\n        mem1 = [[] for i in range(scnt)]\n        for i in range(k):\n            mem1[sid[i]].append(i)\n\n        freq1 = [[] for i in range(scnt)]\n\n        def solve2(cmpx, rept):\n            act = set(x for x in cmpx if not rept[x])\n            if not act:\n                return True\n            adjs = defaultdict(list)\n            for x in cmpx:\n                if not rept[x]:\n                    for v in adj[x]:\n                        if v in act:\n                            adjs[x].append(v)\n            vis = {x: 0 for x in act}\n\n            def dfs(u):\n                vis[u] = 1\n                for v in adjs[u]:\n                    if vis[v] == 0:\n                        if dfs(v):\n                            return True\n                    elif vis[v] == 1:\n                        return True\n                vis[u] = 2\n                return False\n\n            for x in act:\n                if vis[x] == 0:\n                    if dfs(x):\n                        return False\n            return True\n\n        for s in range(scnt):\n            cmpx = mem1[s]\n            sz = len(cmpx)\n            if sz == 1:\n                x = cmpx[0]\n                if ls1[x]:\n                    freq1[s].append([2])\n                else:\n                    freq1[s].append([1])\n                continue\n            fnx = [x for x in cmpx if ls1[x]]\n            lcn = {x: i for i, x in enumerate(cmpx)}\n            mskf = 0\n            for x in fnx:\n                mskf |= (1 << lcn[x])\n            bcar = float('inf')\n            gsubs = []\n            for mask in range(1 << sz):\n                if (mask & mskf) != mskf:\n                    continue\n                c = bin(mask).count('1')\n                if c > bcar:\n                    continue\n                rept = [False] * k\n                for i in range(sz):\n                    if (mask & (1 << i)):\n                        ltx = cmpx[i]\n                        rept[ltx] = True\n                if solve2(cmpx, rept):\n                    if c < bcar:\n                        bcar = c\n                        gsubs = [rept.copy()]\n                    elif c == bcar:\n                        gsubs.append(rept.copy())\n            for zx in gsubs:\n                freqp = [1] * sz\n                for i in range(sz):\n                    if zx[cmpx[i]]:\n                        freqp[i] = 2\n                freq1[s].append(freqp)\n\n        pres = []\n        sfreqs = [0] * k\n\n        def dfs2(s, curr):\n            if s == scnt:\n                pres.append(curr.copy())\n                return\n            for freqv in freq1[s]:\n                ncurr = curr.copy()\n                for i, ltx in enumerate(mem1[s]):\n                    ncurr[ltx] = freqv[i]\n                dfs2(s + 1, ncurr)\n\n        dfs2(0, sfreqs)\n\n        msums = float('inf')\n        for fv in pres:\n            s = sum(fv)\n            if s < msums:\n                msums = s\n        minfreq = [fv for fv in pres if sum(fv) == msums]\n\n        fst = set()\n        for fv in minfreq:\n            fre26 = [0] * 26\n            for i, freq in enumerate(fv):\n                letter = letters[i]\n                fre26[ord(letter) - ord('a')] = freq\n            fst.add(tuple(fre26))\n\n        return [list(t) for t in fst]\n",
    "input": "supersequences(words=[\"ab\",\"ba\"])",
    "output": "[[1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]",
    "correct_condition": "supersequences(words=[\"ab\",\"ba\"]) == [[1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]",
    "contest_id": "weekly-contest-434",
    "contest_date": "2024-01-28T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 362,
      "coverage": null
    },
    "submission_id": 1520639348
  },
  {
    "id": "contest434_q3713_s2",
    "question_id": 3713,
    "function_name": "supersequences",
    "code": "from collections import deque\n\nclass Solution:\n    def supersequences(self, words):\n        if not words:\n            return []\n        \n        # Step 1: Collect unique letters and map to indices\n        unique_chars = set()\n        for word in words:\n            unique_chars.add(word[0])\n            unique_chars.add(word[1])\n        sorted_chars = sorted(unique_chars)\n        u = len(sorted_chars)\n        char_to_idx = {c: i for i, c in enumerate(sorted_chars)}\n        \n        # Step 2: Build adjacency matrix and self_loop array\n        adjacency = [[False] * u for _ in range(u)]\n        self_loop = [False] * u\n        for word in words:\n            c1, c2 = word[0], word[1]\n            x = char_to_idx[c1]\n            y = char_to_idx[c2]\n            if x == y:\n                self_loop[x] = True\n            else:\n                adjacency[x][y] = True\n        \n        # Build graph for Tarjan's algorithm\n        graph = [[] for _ in range(u)]\n        for i in range(u):\n            for j in range(u):\n                if adjacency[i][j]:\n                    graph[i].append(j)\n        \n        # Step 3: Find SCCs using Tarjan's algorithm\n        scc_id, scc_count = self.tarjans_algorithm(u, graph)\n        \n        # Step 4: Build SCC vertices and condensed graph\n        scc_vertices = [[] for _ in range(scc_count)]\n        for node in range(u):\n            scc_vertices[scc_id[node]].append(node)\n        \n        condensed_graph, in_degree = self.build_condensed_graph(scc_id, scc_count, graph)\n        \n        # Step 5: Topological sort of condensed graph\n        topo_order = self.topological_sort(condensed_graph, in_degree, scc_count)\n        \n        # Step 6: Compute frequency options for each SCC\n        freq_options_per_scc = []\n        for scc_idx in topo_order:\n            scc_nodes = scc_vertices[scc_idx]\n            options = self.compute_freq_options_for_scc(scc_nodes, self_loop, adjacency, u)\n            freq_options_per_scc.append(options)\n        \n        # Step 7: Combine options via Cartesian product\n        all_global = self.combine_freq_options(freq_options_per_scc, u)\n        \n        # Step 8: Convert to 26-letter frequencies and deduplicate\n        result = self.convert_and_deduplicate(all_global, sorted_chars)\n        \n        return result\n    \n    def tarjans_algorithm(self, u, graph):\n        index = [-1] * u\n        low_link = [0] * u\n        on_stack = [False] * u\n        stack = []\n        scc_id = [-1] * u\n        current_index = 0\n        scc_count = 0\n        \n        def strongconnect(v):\n            nonlocal current_index, scc_count\n            index[v] = current_index\n            low_link[v] = current_index\n            current_index += 1\n            stack.append(v)\n            on_stack[v] = True\n            for w in graph[v]:\n                if index[w] == -1:\n                    strongconnect(w)\n                    low_link[v] = min(low_link[v], low_link[w])\n                elif on_stack[w]:\n                    low_link[v] = min(low_link[v], index[w])\n            if low_link[v] == index[v]:\n                while True:\n                    node = stack.pop()\n                    on_stack[node] = False\n                    scc_id[node] = scc_count\n                    if node == v:\n                        break\n                scc_count += 1\n        \n        for v in range(u):\n            if index[v] == -1:\n                strongconnect(v)\n        return scc_id, scc_count\n    \n    def build_condensed_graph(self, scc_id, scc_count, graph):\n        condensed = [set() for _ in range(scc_count)]\n        for v in range(len(graph)):\n            current_scc = scc_id[v]\n            for w in graph[v]:\n                target_scc = scc_id[w]\n                if current_scc != target_scc:\n                    condensed[current_scc].add(target_scc)\n        condensed_graph = [list(s) for s in condensed]\n        in_degree = [0] * scc_count\n        for c1 in range(scc_count):\n            for c2 in condensed_graph[c1]:\n                in_degree[c2] += 1\n        return condensed_graph, in_degree\n    \n    def topological_sort(self, condensed_graph, in_degree, scc_count):\n        q = deque()\n        for c in range(scc_count):\n            if in_degree[c] == 0:\n                q.append(c)\n        topo_order = []\n        while q:\n            c = q.popleft()\n            topo_order.append(c)\n            for neighbor in condensed_graph[c]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    q.append(neighbor)\n        return topo_order\n    \n    def compute_freq_options_for_scc(self, scc_nodes, self_loop, adjacency, u):\n        k = len(scc_nodes)\n        if k == 1:\n            only = scc_nodes[0]\n            freq = [0] * u\n            freq[only] = 2 if self_loop[only] else 1\n            return [freq]\n        local_to_global = {i: node for i, node in enumerate(scc_nodes)}\n        forced_mask = 0\n        sub_graph = [[] for _ in range(k)]\n        for i in range(k):\n            global_i = scc_nodes[i]\n            if self_loop[global_i]:\n                forced_mask |= (1 << i)\n            for j in range(k):\n                global_j = scc_nodes[j]\n                if adjacency[global_i][global_j]:\n                    sub_graph[i].append(j)\n        min_sets = self.find_minimal_fvs(k, sub_graph, forced_mask)\n        freq_options = []\n        for mask in min_sets:\n            freq = [0] * u\n            for i in range(k):\n                node = scc_nodes[i]\n                if (mask >> i) & 1:\n                    freq[node] = 2\n                else:\n                    freq[node] = 1\n            freq_options.append(freq)\n        return freq_options\n    \n    def find_minimal_fvs(self, k, sub_graph, forced_mask):\n        optional_mask = ((1 << k) - 1) & ~forced_mask\n        forced_count = bin(forced_mask).count('1')\n        min_size = float('inf')\n        solutions = []\n        for sub in range(0, optional_mask + 1):\n            if (sub & optional_mask) != sub:\n                continue\n            s = forced_mask | sub\n            current_size = forced_count + bin(sub).count('1')\n            if current_size > min_size:\n                continue\n            if self.is_acyclic_after_removal(k, sub_graph, s):\n                if current_size < min_size:\n                    min_size = current_size\n                    solutions = [s]\n                elif current_size == min_size:\n                    solutions.append(s)\n        return solutions\n    \n    def is_acyclic_after_removal(self, k, sub_graph, remove_mask):\n        in_degree = [0] * k\n        remaining = 0\n        for v in range(k):\n            if (remove_mask >> v) & 1:\n                continue\n            remaining += 1\n            for w in sub_graph[v]:\n                if not ((remove_mask >> w) & 1):\n                    in_degree[w] += 1\n        q = deque()\n        for v in range(k):\n            if not ((remove_mask >> v) & 1) and in_degree[v] == 0:\n                q.append(v)\n        visited = 0\n        while q:\n            v = q.popleft()\n            visited += 1\n            for w in sub_graph[v]:\n                if not ((remove_mask >> w) & 1):\n                    in_degree[w] -= 1\n                    if in_degree[w] == 0:\n                        q.append(w)\n        return visited == remaining\n    \n    def combine_freq_options(self, freq_options_per_scc, u):\n        all_global = [[0] * u]\n        for options in freq_options_per_scc:\n            new_all = []\n            for base in all_global:\n                for freq in options:\n                    combined = [base[i] + freq[i] for i in range(u)]\n                    new_all.append(combined)\n            all_global = new_all\n        return all_global\n    \n    def convert_and_deduplicate(self, all_global, sorted_chars):\n        seen = set()\n        result = []\n        for freq_u in all_global:\n            freq_26 = [0] * 26\n            for i, c in enumerate(sorted_chars):\n                idx = ord(c) - ord('a')\n                freq_26[idx] = freq_u[i]\n            key = tuple(freq_26)\n            if key not in seen:\n                seen.add(key)\n                result.append(freq_26)\n        return result",
    "input": "supersequences(words=[\"ab\",\"ba\"])",
    "output": "[[2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]",
    "correct_condition": "supersequences(words=[\"ab\",\"ba\"]) == [[2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]",
    "contest_id": "weekly-contest-434",
    "contest_date": "2024-01-28T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 229,
      "coverage": null
    },
    "submission_id": 1520642624
  },
  {
    "id": "contest435_q3753_s0",
    "question_id": 3753,
    "function_name": "maxDifference",
    "code": "class Solution:\n    def maxDifference(self, s: str) -> int:\n        freq = Counter(s)\n        odd = [c for c in freq.values() if c % 2]\n        even = [c for c in freq.values() if c % 2 == 0]\n        return max(odd) - min(even) if odd and even else -1",
    "input": "maxDifference(s=\"aaaaabbc\")",
    "output": "3",
    "correct_condition": "maxDifference(s=\"aaaaabbc\") == 3",
    "contest_id": "weekly-contest-435",
    "contest_date": "2024-02-04T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 6,
      "coverage": null
    },
    "submission_id": 1528081228
  },
  {
    "id": "contest435_q3753_s1",
    "question_id": 3753,
    "function_name": "maxDifference",
    "code": "class Solution:\n    def maxDifference(self, s: str) -> int:\n        count = [0] * 26\n        for c in s:\n            count[ord(c) - ord('a')] += 1\n        odd = -1\n        even = float('inf')\n        for x in count:\n            if x:\n                if x % 2 == 0:\n                    even = min(even, x)\n                else:\n                    odd = max(odd, x)\n        return odd - even\n\n",
    "input": "maxDifference(s=\"aaaaabbc\")",
    "output": "3",
    "correct_condition": "maxDifference(s=\"aaaaabbc\") == 3",
    "contest_id": "weekly-contest-435",
    "contest_date": "2024-02-04T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 15,
      "coverage": null
    },
    "submission_id": 1528102981
  },
  {
    "id": "contest435_q3753_s2",
    "question_id": 3753,
    "function_name": "maxDifference",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def maxDifference(self, s: str) -> int:\n        freq = [0] * 26\n        for k in s:\n            freq[ord(k) - ord('a')] += 1\n        odd = -1  \n        even = float('inf') \n        for p in freq:\n            if p == 0:\n                continue  \n            if p % 2 == 1: \n                odd = max(odd, p)\n            else: \n                even = min(even, p)\n        return odd - even",
    "input": "maxDifference(s=\"aaaaabbc\")",
    "output": "3",
    "correct_condition": "maxDifference(s=\"aaaaabbc\") == 3",
    "contest_id": "weekly-contest-435",
    "contest_date": "2024-02-04T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 215,
      "coverage": null
    },
    "submission_id": 1528109134
  },
  {
    "id": "contest435_q3754_s0",
    "question_id": 3754,
    "function_name": "maxDistance",
    "code": "class Solution:\n    def maxDistance(self, s: str, k: int) -> int:\n\n        res = 0\n        e = w = n = s_count = 0\n        for i, ch in enumerate(s, 1):\n            if ch == 'E': e += 1\n            elif ch == 'W': w += 1\n            elif ch == 'N': n += 1\n            else: s_count += 1\n            bx = abs(e - w)\n            hx = min(e, w)\n            by = abs(n - s_count)\n            hy = min(n, s_count)\n            cur = bx + by + 2 * min(k, hx + hy)\n            if cur > i: cur = i\n            if cur > res: res = cur\n        return res",
    "input": "maxDistance(s=\"NWSE\", k=1)",
    "output": "3",
    "correct_condition": "maxDistance(s=\"NWSE\", k=1) == 3",
    "contest_id": "weekly-contest-435",
    "contest_date": "2024-02-04T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 18,
      "coverage": null
    },
    "submission_id": 1528089568
  },
  {
    "id": "contest435_q3754_s1",
    "question_id": 3754,
    "function_name": "maxDistance",
    "code": "from collections import Counter\n\nclass Solution:\n    def maxDistance(self, s: str, k: int) -> int:\n        n, a, c = len(s), 0, Counter()\n        \n        u = lambda x: c.update(x)\n        d = lambda x, y: abs(c[x] - c[y])\n        f = lambda x, y: min(c[x], c[y])\n        \n        for i, x in enumerate(s):\n            u(x)\n            dx, dy = d('E', 'W'), d('N', 'S')\n            fc = f('E', 'W') + f('N', 'S')\n            cand = min(dx + dy + 2 * min(k, fc), i + 1)\n            a = max(a, cand)\n        \n        return a\n",
    "input": "maxDistance(s=\"NWSE\", k=1)",
    "output": "3",
    "correct_condition": "maxDistance(s=\"NWSE\", k=1) == 3",
    "contest_id": "weekly-contest-435",
    "contest_date": "2024-02-04T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 18,
      "coverage": null
    },
    "submission_id": 1528113622
  },
  {
    "id": "contest435_q3754_s2",
    "question_id": 3754,
    "function_name": "maxDistance",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def maxDistance(self, s: str, k: int) -> int:\n        n = len(s)\n        pre1 = [0] * (n + 1)\n        pre2 = [0] * (n + 1)\n        pre3 = [0] * (n + 1)\n        pre4 = [0] * (n + 1)\n        \n        for i in range(n):\n            pre1[i+1] = pre1[i] + (s[i] == 'N')\n            pre2[i+1] = pre2[i] + (s[i] == 'S')\n            pre3[i+1] = pre3[i] + (s[i] == 'E')\n            pre4[i+1] = pre4[i] + (s[i] == 'W')\n        \n        ans = 0\n        \n        for m in range(1, n + 1):\n            for z in [(pre1[m] + pre3[m]), (pre1[m] + pre4[m]), (pre2[m] + pre3[m]), (pre2[m] + pre4[m])]:\n                p = m - z\n                cur = m if p <= k else (2 * z + 2 * k - m)\n                ans = max(ans, cur)\n        \n        return ans\n",
    "input": "maxDistance(s=\"NWSE\", k=1)",
    "output": "3",
    "correct_condition": "maxDistance(s=\"NWSE\", k=1) == 3",
    "contest_id": "weekly-contest-435",
    "contest_date": "2024-02-04T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 223,
      "coverage": null
    },
    "submission_id": 1528113125
  },
  {
    "id": "contest435_q3697_s0",
    "question_id": 3697,
    "function_name": "minimumIncrements",
    "code": "from math import gcd\n\n\nclass Solution:\n    def minimumIncrements(self, nums: List[int], target: List[int]) -> int:\n        m = len(target)\n        full = (1 << m) - 1\n        subs = []\n        for s in range(1, 1 << m):\n            lcm_val = 1\n            for i in range(m):\n                if s >> i & 1:\n                    lcm_val = lcm_val * target[i] // gcd(lcm_val, target[i])\n            subs.append((s, lcm_val))\n        INF = 10**19\n        dp = [INF] * (1 << m)\n        dp[0] = 0\n        for a in nums:\n            ndp = dp[:]\n            for mask in range(1 << m):\n                if dp[mask] == INF:\n                    continue\n                for s, l in subs:\n                    nm = mask | s\n                    cost = (l - (a % l)) % l\n                    ndp[nm] = min(ndp[nm], dp[mask] + cost)\n            dp = ndp\n        return dp[full]",
    "input": "minimumIncrements(nums=[1,2,3], target=[4])",
    "output": "1",
    "correct_condition": "minimumIncrements(nums=[1,2,3], target=[4]) == 1",
    "contest_id": "weekly-contest-435",
    "contest_date": "2024-02-04T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 28,
      "coverage": null
    },
    "submission_id": 1528091022
  },
  {
    "id": "contest435_q3697_s1",
    "question_id": 3697,
    "function_name": "minimumIncrements",
    "code": "from math import gcd\nfrom functools import reduce\n\nclass Candidate:\n    def __init__(self, L, mask):\n        self.L = L\n        self.mask = mask\n\nclass MinIncrementsSolver:\n    def lcm(self, a, b):\n        return a // gcd(a, b) * b\n\n    def unique_targets(self, target):\n        return list(set(sorted(target)))\n\n    def generate_candidates(self, target):\n        m = len(target)\n        candidates = []\n        seen = set()\n        total = 1 << m\n        for s in range(1, total):\n            curL = 1\n            for j in range(m):\n                if s & (1 << j):\n                    curL = self.lcm(curL, target[j])\n            cover_mask = 0\n            for j in range(m):\n                if curL % target[j] == 0:\n                    cover_mask |= (1 << j)\n            if curL not in seen:\n                seen.add(curL)\n                candidates.append(Candidate(curL, cover_mask))\n        return candidates\n\n    def compute_cost(self, n, L):\n        rem = n % L\n        return 0 if rem == 0 else (L - rem)\n\n    def solve_dp(self, nums, candidates, full_mask, m):\n        INF = 10**18\n        dp = [INF] * (1 << m)\n        dp[0] = 0\n        for num in nums:\n            new_dp = dp[:]\n            for cand in candidates:\n                cost = self.compute_cost(num, cand.L)\n                for mask in range(1 << m):\n                    if dp[mask] == INF:\n                        continue\n                    nmask = mask | cand.mask\n                    new_dp[nmask] = min(new_dp[nmask], dp[mask] + cost)\n            dp = new_dp\n        return dp[full_mask]\n\n    def minimum_increments(self, nums, target):\n        uniq = self.unique_targets(target)\n        m = len(uniq)\n        full_mask = (1 << m) - 1\n        candidates = self.generate_candidates(uniq)\n        ans = self.solve_dp(nums, candidates, full_mask, m)\n        return ans\n\nclass Solution:\n    def minimumIncrements(self, nums, target):\n        solver = MinIncrementsSolver()\n        result = solver.minimum_increments(nums, target)\n        return int(result)\n\n",
    "input": "minimumIncrements(nums=[1,2,3], target=[4])",
    "output": "1",
    "correct_condition": "minimumIncrements(nums=[1,2,3], target=[4]) == 1",
    "contest_id": "weekly-contest-435",
    "contest_date": "2024-02-04T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 68,
      "coverage": null
    },
    "submission_id": 1528095476
  },
  {
    "id": "contest435_q3697_s2",
    "question_id": 3697,
    "function_name": "minimumIncrements",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nimport math\nfrom itertools import product\n\nclass Solution:\n    def minimumIncrements(self, nums: List[int], target: List[int]) -> int:\n        cpy = nums[:]\n        n = len(cpy)\n        m = len(target)\n        fmsk = (1 << m) - 1\n        mlcm = [1] * (1 << m)\n        for msks in range(1, 1 << m):\n            clcm = 1\n            for j in range(m):\n                if msks & (1 << j):\n                    clcm = (clcm * target[j]) // math.gcd(clcm, target[j])\n            mlcm[msks] = clcm\n        \n        INF = float('inf')\n        dp = [[INF] * (1 << m) for i in range(n + 1)]\n        dp[0][0] = 0\n        \n        for i in range(n):\n            x = cpy[i]\n            ls = []\n            for msks in range(1, 1 << m):\n                z = mlcm[msks]\n                mulx = (x + z - 1) // z \n                nval = mulx * z\n                cstx = nval - x\n                ls.append((msks, cstx))\n            \n            for msks in range(1 << m):\n                dp[i + 1][msks] = min(dp[i + 1][msks], dp[i][msks])\n                for smsk, cstx in ls:\n                    mskn = msks | smsk\n                    dp[i + 1][mskn] = min(dp[i + 1][mskn], dp[i][msks] + cstx)\n        \n        return dp[n][fmsk]",
    "input": "minimumIncrements(nums=[1,2,3], target=[4])",
    "output": "1",
    "correct_condition": "minimumIncrements(nums=[1,2,3], target=[4]) == 1",
    "contest_id": "weekly-contest-435",
    "contest_date": "2024-02-04T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 238,
      "coverage": null
    },
    "submission_id": 1528107386
  },
  {
    "id": "contest435_q3761_s0",
    "question_id": 3761,
    "function_name": "maxDifference",
    "code": "from bisect import bisect_left\nclass Solution:\n    def maxDifference(self, s: str, k: int) -> int:\n        INF = 10**9\n        n = len(s)\n        ans = -10**9\n        for x in range(5):\n            for y in range(5):\n                if x == y:\n                    continue\n                N = n + 1\n                D = [0] * N\n                PX = [0] * N\n                PY = [0] * N\n                CNT = [0] * N\n                sx = str(x)\n                sy = str(y)\n                for i in range(n):\n                    D[i+1] = D[i] + (1 if s[i] == sx else 0) - (1 if s[i] == sy else 0)\n                    PX[i+1] = (PX[i] + (1 if s[i] == sx else 0)) & 1\n                    PY[i+1] = (PY[i] + (1 if s[i] == sy else 0)) & 1\n                    CNT[i+1] = CNT[i] + (1 if s[i] == sy else 0)\n                mp = {(0,0): [], (0,1): [], (1,0): [], (1,1): []}\n                cum = {(0,0): [], (0,1): [], (1,0): [], (1,1): []}\n                key0 = (PX[0], PY[0])\n                mp[key0].append((CNT[0], D[0]))\n                cum[key0].append(D[0])\n                best = -10**9\n                p = 1\n                for r in range(k, N):\n                    while p <= r - k:\n                        key = (PX[p], PY[p])\n                        mp[key].append((CNT[p], D[p]))\n                        if cum[key]:\n                            cum[key].append(min(cum[key][-1], D[p]))\n                        else:\n                            cum[key].append(D[p])\n                        p += 1\n                    keyq = (1 - PX[r], PY[r])\n                    arr = mp[keyq]\n                    if not arr:\n                        continue\n                    pos = bisect_left(arr, (CNT[r], -10**9))\n                    if pos:\n                        cand = D[r] - cum[keyq][pos-1]\n                        if cand > best:\n                            best = cand\n                if best > ans:\n                    ans = best\n        return ans\n\n",
    "input": "maxDifference(s=\"12233\", k=4)",
    "output": "-1",
    "correct_condition": "maxDifference(s=\"12233\", k=4) == -1",
    "contest_id": "weekly-contest-435",
    "contest_date": "2024-02-04T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 51,
      "coverage": null
    },
    "submission_id": 1528104807
  },
  {
    "id": "contest435_q3761_s2",
    "question_id": 3761,
    "function_name": "maxDifference",
    "code": "def build_prefix_arrays(s: str, a: int, b: int, n: int) -> tuple:\n    F = [0] * (n + 1)\n    Ca = [0] * (n + 1)\n    Cb = [0] * (n + 1)\n    for i in range(n):\n        dig = int(s[i])\n        delta = 1 if dig == a else (-1 if dig == b else 0)\n        F[i + 1] = F[i] + delta\n        Ca[i + 1] = Ca[i] + (1 if dig == a else 0)\n        Cb[i + 1] = Cb[i] + (1 if dig == b else 0)\n    return F, Ca, Cb\n\ndef build_best_arr(F: list, Ca: list, Cb: list, n: int, INF: float) -> list:\n    best_arr = [[[INF] * (n + 1) for _ in range(2)] for _ in range(2)]\n    pb0 = Cb[0] & 1\n    pa0 = Ca[0] & 1\n    best_arr[pa0][pb0][0] = F[0]\n    for i in range(1, n + 1):\n        pb = Cb[i] & 1\n        pa = Ca[i] & 1\n        for u in range(2):\n            for t in range(2):\n                best_arr[t][u][i] = best_arr[t][u][i - 1]\n        best_arr[pa][pb][i] = min(best_arr[pa][pb][i], F[i])\n    return best_arr\n\ndef find_largest_index(prefix: list, target: int, j: int) -> int:\n    index = -1\n    lo, hi = 0, j\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if prefix[mid] <= target:\n            index = mid\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return index\n\nclass Solution:\n    def maxDifference(self, s: str, k: int) -> int:\n        INF = float('inf')\n        n = len(s)\n        ans = -INF\n        fnd = False\n        for a in range(5):\n            for b in range(5):\n                if a == b:\n                    continue\n                F, Ca, Cb = build_prefix_arrays(s, a, b, n)\n                best_arr = build_best_arr(F, Ca, Cb, n, INF)\n                for j in range(k, n + 1):\n                    if Ca[j] == 0 or Cb[j] == 0:\n                        continue\n                    X3 = find_largest_index(Cb, Cb[j] - 1, j)\n                    X2 = find_largest_index(Ca, Ca[j] - 1, j)\n                    X1 = j - k\n                    X = min(X1, X2, X3)\n                    if X < 0:\n                        continue\n                    reqB = (Cb[j] & 1)\n                    reqA = (1 - (Ca[j] & 1)) & 1\n                    candidate = best_arr[reqA][reqB][X]\n                    if candidate == INF:\n                        continue\n                    diff = F[j] - candidate\n                    fnd = True\n                    ans = max(ans, diff)\n        if not fnd:\n            return -1\n        return ans",
    "input": "maxDifference(s=\"12233\", k=4)",
    "output": "-1",
    "correct_condition": "maxDifference(s=\"12233\", k=4) == -1",
    "contest_id": "weekly-contest-435",
    "contest_date": "2024-02-04T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 70,
      "coverage": null
    },
    "submission_id": 1528137393
  }
]