[
  {
    "id": "contest431_q3702_s0",
    "question_id": 3702,
    "function_name": "maxLength",
    "code": "class Solution:\n    def maxLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for l in range(n):\n            a = 1\n            b = 1\n            c = 0\n            for r in range(l, n):\n                a *= nums[r]\n                b = lcm(b, nums[r])\n                c = gcd(c, nums[r])\n                if a == b * c:\n                    ans = max(ans, r - l + 1)\n        return ans\n                \n        ",
    "input": "maxLength(nums=[1,2,1,2,1,1,1])",
    "output": "5",
    "correct_condition": "maxLength(nums=[1,2,1,2,1,1,1]) == 5",
    "contest_id": "weekly-contest-431",
    "contest_date": "2025-01-05T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 17,
      "coverage": null
    },
    "submission_id": 1497983046
  },
  {
    "id": "contest431_q3702_s1",
    "question_id": 3702,
    "function_name": "maxLength",
    "code": "class Solution:\n    def maxLength(self, nums: List[int]) -> int:\n        ans = 1\n        run = 1\n        for l in range(len(nums)):\n            for r in range(l, len(nums)):\n                a = nums[l:r+1]\n                prod = 1\n                g = nums[l]\n                lc = nums[l]\n                for v in a:\n                    g = gcd(g, v)\n                    lc = lcm(lc, v)\n                    prod *= v\n                if g * lc == prod:\n                    ans = max(ans, r - l + 1)\n        return ans",
    "input": "maxLength(nums=[1,2,1,2,1,1,1])",
    "output": "5",
    "correct_condition": "maxLength(nums=[1,2,1,2,1,1,1]) == 5",
    "contest_id": "weekly-contest-431",
    "contest_date": "2025-01-05T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 17,
      "coverage": null
    },
    "submission_id": 1497983616
  },
  {
    "id": "contest431_q3702_s2",
    "question_id": 3702,
    "function_name": "maxLength",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nimport math\nclass Solution:\n    def maxLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        maxi = 1 \n        for i in range(n):\n            cur1 = nums[i]\n            cur2 = nums[i]\n            prod = nums[i]\n            \n            for j in range(i + 1, n):\n                cur1 = math.gcd(cur1, nums[j])\n                cur2 = (cur2 * nums[j]) // math.gcd(cur2, nums[j])\n                prod *= nums[j]\n                if prod == cur1 * cur2:\n                    lens = j - i + 1\n                    if lens > maxi:\n                        maxi = lens\n        return maxi",
    "input": "maxLength(nums=[1,2,1,2,1,1,1])",
    "output": "5",
    "correct_condition": "maxLength(nums=[1,2,1,2,1,1,1]) == 5",
    "contest_id": "weekly-contest-431",
    "contest_date": "2025-01-05T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 219,
      "coverage": null
    },
    "submission_id": 1498014620
  },
  {
    "id": "contest431_q3634_s0",
    "question_id": 3634,
    "function_name": "calculateScore",
    "code": "class Solution:\n    def calculateScore(self, s: str) -> int:\n        g = [[] for _ in range(26)]\n        ans = 0\n        for i, x in enumerate(s):\n            x = ord(x) - 97\n            if g[25 - x]:\n                ans += i - g[25 - x].pop()\n            else:\n                g[x].append(i)\n        return ans\n        ",
    "input": "calculateScore(s=\"aczzx\")",
    "output": "5",
    "correct_condition": "calculateScore(s=\"aczzx\") == 5",
    "contest_id": "weekly-contest-431",
    "contest_date": "2025-01-05T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 12,
      "coverage": null
    },
    "submission_id": 1497985461
  },
  {
    "id": "contest431_q3634_s1",
    "question_id": 3634,
    "function_name": "calculateScore",
    "code": "class Solution:\n    def calculateScore(self, s: str) -> int:\n        def mir(c):\n            return chr(ord('a') + (25 - (ord(c) - ord('a'))))\n        seen = defaultdict(list)\n        ans = 0\n        for i in range(len(s)):\n            c1 = mir(s[i])\n            if seen[c1]:\n                ans += i - seen[c1][-1]\n                seen[c1].pop()\n            else: seen[s[i]].append(i)\n        return ans",
    "input": "calculateScore(s=\"aczzx\")",
    "output": "5",
    "correct_condition": "calculateScore(s=\"aczzx\") == 5",
    "contest_id": "weekly-contest-431",
    "contest_date": "2025-01-05T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 13,
      "coverage": null
    },
    "submission_id": 1497985549
  },
  {
    "id": "contest431_q3634_s2",
    "question_id": 3634,
    "function_name": "calculateScore",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nclass Solution:\n    def calculateScore(self, s: str) -> int:\n        ls = {chr(i): [] for i in range(ord('a'), ord('z') + 1)}\n        score = 0\n        for i, c in enumerate(s):\n            cm = chr(ord('a') + (ord('z') - ord(c)))\n            if ls[cm]:\n                j = ls[cm].pop()\n                score += i - j\n            else:\n                ls[c].append(i)\n        return score",
    "input": "calculateScore(s=\"aczzx\")",
    "output": "5",
    "correct_condition": "calculateScore(s=\"aczzx\") == 5",
    "contest_id": "weekly-contest-431",
    "contest_date": "2025-01-05T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 212,
      "coverage": null
    },
    "submission_id": 1498013955
  },
  {
    "id": "contest431_q3715_s0",
    "question_id": 3715,
    "function_name": "maximumCoins",
    "code": "class Solution:\n    def maximumCoins(self, coins: List[List[int]], k: int) -> int:\n        coins.sort()\n        n = len(coins)\n        def f(p):\n            ret = tot = 0\n            j = 0\n            for i in range(n):\n                while j < n and p[j][1] - p[i][0] + 1 <= k:\n                    tot += (p[j][1] - p[j][0] + 1) * p[j][2]\n                    j += 1\n                cur = tot\n                if j < n and p[j][0] - p[i][0] + 1 <= k:\n                    cur += (p[i][0] + k - p[j][0]) * p[j][2]\n                if cur > ret:\n                    ret = cur\n                if i == j:\n                    j += 1\n                else:\n                    tot -= (p[i][1] - p[i][0] + 1) * p[i][2]\n            return ret\n        ans = f(coins)\n        coins.reverse()\n        m = 10 ** 9 + 1\n        for it in coins:\n            it[0], it[1] = m - it[1], m - it[0]\n        ans = max(ans, f(coins))\n        return ans\n                    \n                ",
    "input": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4)",
    "output": "10",
    "correct_condition": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4) == 10",
    "contest_id": "weekly-contest-431",
    "contest_date": "2025-01-05T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 30,
      "coverage": null
    },
    "submission_id": 1498002559
  },
  {
    "id": "contest431_q3715_s1",
    "question_id": 3715,
    "function_name": "maximumCoins",
    "code": "class Solution:\n    def maximumCoins(self, coins: List[List[int]], k: int) -> int:\n        coins.sort()\n        ans = 0\n        for _ in range(2):\n            cnt = 0\n            r = 0\n            # print(coins)\n            for l in range(len(coins)):\n                while r+1 < len(coins) and coins[r][1]-coins[l][0]+1 <= k:\n                    cnt += (coins[r][1]-coins[r][0]+1 ) * coins[r][2]\n                    r += 1\n                add = min(coins[r][1]+1, coins[l][0] + k) - coins[r][0]\n                add = max(add, 0)\n                add *= coins[r][2]\n                # add = (k - ((0 if r == 0 else coins[r-1][1])-coins[l][0]+1)) * coins[r][2]\n                ans = max(ans, cnt + add)\n                # print(l, r, add / coins[r][2], cnt + add)\n                cnt -= (coins[l][1]-coins[l][0]+1 ) * coins[l][2]\n            for i in range(len(coins)):\n                coins[i][0] *= -1\n                coins[i][1] *= -1\n                coins[i][0], coins[i][1] = coins[i][1], coins[i][0]\n            coins.sort()\n        return ans",
    "input": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4)",
    "output": "10",
    "correct_condition": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4) == 10",
    "contest_id": "weekly-contest-431",
    "contest_date": "2025-01-05T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 25,
      "coverage": null
    },
    "submission_id": 1498001804
  },
  {
    "id": "contest431_q3715_s2",
    "question_id": 3715,
    "function_name": "maximumCoins",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nfrom bisect import bisect_right\nfrom dataclasses import dataclass\n\n@dataclass\nclass Interval:\n    start: int\n    end: int\n    ci: int\n    psum: int = 0\n\nclass Solution:\n    def maximumCoins(self, coins: List[List[int]], k: int) -> int:\n        coins.sort(key=lambda x: x[0])\n        intervals: List[Interval] = []\n        for seg in coins:\n            li, ri, val1 = seg\n            intervals.append(Interval(start=li, end=ri, ci=val1))\n        \n        pref = 0\n        for interval in intervals:\n            lenx = interval.end - interval.start + 1\n            tot = lenx * interval.ci\n            pref += tot\n            interval.psum = pref\n\n        starts = [interval.start for interval in intervals]\n        \n        def getSum(x: int) -> int:\n            if not intervals or x < intervals[0].start:\n                return 0\n            idx = bisect_right(starts, x) - 1\n            if idx < 0:\n                return 0\n            sval = intervals[idx].psum\n            if idx > 0:\n                sval -= intervals[idx - 1].psum\n            overlap = min(x, intervals[idx].end) - intervals[idx].start + 1\n            if overlap > 0:\n                sval = intervals[idx].psum - (intervals[idx -1].psum if idx >0 else 0)\n                sval = (overlap) * intervals[idx].ci\n            else:\n                sval = 0\n            tsum = 0\n            if idx >=0:\n                tsum = intervals[idx].psum - (intervals[idx -1].psum if idx >0 else 0)\n                tsum = (min(x, intervals[idx].end) - intervals[idx].start +1) * intervals[idx].ci\n                if idx >0:\n                    tsum += intervals[idx-1].psum\n            return tsum\n        \n        def get_sum(x):\n            if not intervals or x < intervals[0].start:\n                return 0\n            idx = bisect_right(starts, x) - 1\n            if idx < 0:\n                return 0\n            prevs = intervals[idx -1].psum if idx > 0 else 0\n            overlap = min(x, intervals[idx].end) - intervals[idx].start + 1\n            if overlap < 0:\n                overlap = 0\n            return prevs + overlap * intervals[idx].ci\n        \n        st = set()\n        for seg in coins:\n            li, ri, _ = seg\n            st.add(li)\n            x = ri - k + 1\n            if 1 <= x <= ri:\n                st.add(x)\n        \n        st = sorted(st)\n\n        maxi = 0\n        for x in st:\n            sw = x\n            send = x + k -1\n            sum1 = get_sum(send)\n            sum0 = get_sum(sw -1)\n            tot = sum1 - sum0\n            if tot > maxi:\n                maxi = tot\n        \n        return maxi\n",
    "input": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4)",
    "output": "10",
    "correct_condition": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4) == 10",
    "contest_id": "weekly-contest-431",
    "contest_date": "2025-01-05T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 283,
      "coverage": null
    },
    "submission_id": 1498021486
  },
  {
    "id": "contest431_q3562_s0",
    "question_id": 3562,
    "function_name": "maximumWeight",
    "code": "class Solution:\n    def maximumWeight(self, p: List[List[int]]) -> List[int]:\n        a = []\n        for i, it in enumerate(p):\n            it.append(i)\n            a += [it[0], it[1]]\n        mp = {x: i + 1 for i, x in enumerate(sorted(set(a)))}\n        p.sort(key=lambda it:it[1])\n        for it in p:\n            it[0] = mp[it[0]]\n            it[1] = mp[it[1]]\n        f = [[[0, []] for _ in range(5)]]\n        pr = 0\n        for it in p:\n            l, r, w, i = it\n            while pr < r:\n                f.append(f[pr][:])\n                pr += 1\n            for k in range(4):\n                v, b = f[l - 1][k]\n                b = b[::] + [i]\n                b.sort()\n                v -= w\n                f[r][k + 1] = min(f[r][k + 1], [v, b])\n        return f[-1][4][1]",
    "input": "maximumWeight(p=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]])",
    "output": "[2, 3]",
    "correct_condition": "maximumWeight(p=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]) == [2, 3]",
    "contest_id": "weekly-contest-431",
    "contest_date": "2025-01-05T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 25,
      "coverage": null
    },
    "submission_id": 1498025769
  },
  {
    "id": "contest431_q3562_s1",
    "question_id": 3562,
    "function_name": "maximumWeight",
    "code": "class Solution:\n    def maximumWeight(self, intervals: List[List[int]]) -> List[int]:\n        locations = set()\n        for l, r, w in intervals:\n            locations.add(l)\n            locations.add(r+1)\n        locations = sorted(list(locations))\n        to_idx = dict()\n        for i, x in enumerate(locations):\n            to_idx[x] = i\n        nxt = [[] for i in range(len(locations))]\n        for i, (l, r, w) in enumerate(intervals):\n            nxt[to_idx[l]].append((to_idx[r+1], w, i))\n        @cache\n        def dp(idx, left):\n            res = (10 ** 12, [])\n            if idx >= len(locations) or left == 0: return res\n            \n            res = min(res, dp(idx + 1, left))\n            for r, w, i in nxt[idx]:\n                (a, ls) = dp(r, left-1)\n                a -= w\n                ls1 = ls.copy()\n                ls1.append(i)\n                ls1.sort()\n                res = min(res, (a, ls1))\n            return res\n        w, ls = dp(0, 4)\n        return ls\n            ",
    "input": "maximumWeight(intervals=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]])",
    "output": "[2, 3]",
    "correct_condition": "maximumWeight(intervals=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]) == [2, 3]",
    "contest_id": "weekly-contest-431",
    "contest_date": "2025-01-05T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 30,
      "coverage": null
    },
    "submission_id": 1498015639
  },
  {
    "id": "contest431_q3562_s2",
    "question_id": 3562,
    "function_name": "maximumWeight",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nfrom bisect import bisect_right\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass Interval:\n    start: int\n    end: int\n    weight: int\n    ind: int\n    psum: int = 0\n\nclass Solution:\n    def maximumWeight(self, intervals: List[List[int]]) -> List[int]:\n        n = len(intervals)\n        sit = []\n        for i in range(n):\n            l, r, w = intervals[i]\n            sit.append(Interval(start=l, end=r, weight=w, ind=i))\n        \n        sit.sort(key=lambda x: (x.end, x.start))\n        last = [-1] * n\n        etime = [interval.end for interval in sit]\n        for i in range(n):\n            j = bisect_right(etime, sit[i].start - 1) - 1\n            last[i] = j \n        dp = [ [ (0, []) for _ in range(5) ] for _ in range(n+1) ]\n        \n        for i in range(1, n+1):\n            curr = sit[i-1]\n            for k in range(0, 5):\n                if k == 0:\n                    dp[i][k] = (0, [])\n                else:\n                    wt1, st1 = dp[i-1][k]\n                    if last[i-1] != -1 and k-1 >=0:\n                        wtp, stp = dp[last[i-1]+1][k-1]\n                    elif last[i-1] == -1 and k-1 >=0:\n                        wtp, stp = dp[0][k-1]\n                    else:\n                        wtp, stp = (0, [])\n                    \n                    wto = wtp + curr.weight\n                    sto = stp + [curr.ind]\n                    \n                    if wt1 > wto:\n                        dp[i][k] = (wt1, st1)\n                    elif wt1 < wto:\n                        dp[i][k] = (wto, sto)\n                    else:\n                        sst1 = sorted(st1)\n                        sst2 = sorted(sto)\n                        if sst1 < sst2:\n                            dp[i][k] = (wt1, st1)\n                        else:\n                            dp[i][k] = (wto, sto)\n        bwt = 0\n        bst = []\n        for k in range(1, 5):\n            currwt, currst = dp[n][k]\n            if currwt > bwt:\n                bwt = currwt\n                bst = currst\n            elif currwt == bwt:\n                if not bst:\n                    bst = currst\n                else:\n                    sbest = sorted(bst)\n                    scurr = sorted(currst)\n                    if scurr < sbest:\n                        bst = currst\n        \n        bsrt = sorted(bst)\n        return bsrt\n",
    "input": "maximumWeight(intervals=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]])",
    "output": "[2, 3]",
    "correct_condition": "maximumWeight(intervals=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]) == [2, 3]",
    "contest_id": "weekly-contest-431",
    "contest_date": "2025-01-05T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 273,
      "coverage": null
    },
    "submission_id": 1498028040
  },
  {
    "id": "contest432_q3708_s0",
    "question_id": 3708,
    "function_name": "zigzagTraversal",
    "code": "\nclass Solution:\n    def zigzagTraversal(self, grid: List[List[int]]) -> List[int]:\n        R, C = len(grid), len(grid[0])\n        ans = []\n        i, j = 0, 0\n\n        def connected(i, j, ii, jj):\n            return (i == ii and abs(j - jj) == 1) or (j == jj and abs(i - ii) == 1)\n\n        dir = 1\n        while 0 <= i < R and 0 <= j < C:\n            ans.append(grid[i][j])\n            ii = i\n            jj = j + 2 * dir\n            if 0 <= jj < C:\n                i, j = ii, jj\n            else:\n                ii = i + 1\n                jj = 0 if jj < 0 else C - 1\n                dir = -dir\n                if 0 <= ii < R and 0 <= jj < C:\n                    if connected(i, j, ii, jj):\n                        jj += dir\n                    i, j = ii, jj\n                else:\n                    break\n\n        return ans\n\n",
    "input": "zigzagTraversal(grid=[[1,2],[3,4]])",
    "output": "[1, 4]",
    "correct_condition": "zigzagTraversal(grid=[[1,2],[3,4]]) == [1, 4]",
    "contest_id": "weekly-contest-432",
    "contest_date": "2025-01-12T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 30,
      "coverage": null
    },
    "submission_id": 1505653842
  },
  {
    "id": "contest432_q3708_s1",
    "question_id": 3708,
    "function_name": "zigzagTraversal",
    "code": "class Solution:\n    def zigzagTraversal(self, grid: List[List[int]]) -> List[int]:\n\n        m, n = len(grid), len(grid[0])\n\n        r = 1\n        i, j = 0, 0\n        res = []\n        \n        while i < m:\n            res.append(grid[i][j])\n            if r:\n                j += 2\n                if j >= n:\n                    i += 1\n                    j = n - 1 - (j - n)\n                    r = 1 - r\n            else:\n                j -= 2\n                if j < 0:\n                    i += 1\n                    j = 0 - j - 1\n                    r = 1 - r\n\n        return res",
    "input": "zigzagTraversal(grid=[[1,2],[3,4]])",
    "output": "[1, 4]",
    "correct_condition": "zigzagTraversal(grid=[[1,2],[3,4]]) == [1, 4]",
    "contest_id": "weekly-contest-432",
    "contest_date": "2025-01-12T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 25,
      "coverage": null
    },
    "submission_id": 1505650015
  },
  {
    "id": "contest432_q3708_s2",
    "question_id": 3708,
    "function_name": "zigzagTraversal",
    "code": "class Solution:\n    def zigzagTraversal(self, grid: List[List[int]]) -> List[int]:\n        ans = []\n        for i, row in enumerate(grid):\n            if i % 2:\n                ans += row[::-1]\n            else:\n                ans += row\n        return ans[::2]\n            \n        ",
    "input": "zigzagTraversal(grid=[[1,2],[3,4]])",
    "output": "[1, 4]",
    "correct_condition": "zigzagTraversal(grid=[[1,2],[3,4]]) == [1, 4]",
    "contest_id": "weekly-contest-432",
    "contest_date": "2025-01-12T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 11,
      "coverage": null
    },
    "submission_id": 1505643478
  },
  {
    "id": "contest432_q3677_s0",
    "question_id": 3677,
    "function_name": "maximumAmount",
    "code": "\nclass Solution:\n    def maximumAmount(self, coins: List[List[int]]) -> int:\n        R, C = len(coins), len(coins[0])\n\n        @cache\n        def f(i, j, magic):\n            if (i, j) in ((R, C - 1), (R - 1, C)):\n                return 0\n            if i >= R or j >= C:\n                return -inf\n\n            value = coins[i][j] + max(f(i + 1, j, magic), f(i, j + 1, magic))\n            if magic > 0:\n                value = max(value, max(coins[i][j], 0) + max(f(i, j + 1, magic - 1), f(i + 1, j, magic - 1)))\n            return value\n\n        ans = f(0, 0, 2)\n        return ans\n\n",
    "input": "maximumAmount(coins=[[0,1,-1],[1,-2,3],[2,-3,4]])",
    "output": "8",
    "correct_condition": "maximumAmount(coins=[[0,1,-1],[1,-2,3],[2,-3,4]]) == 8",
    "contest_id": "weekly-contest-432",
    "contest_date": "2025-01-12T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 20,
      "coverage": null
    },
    "submission_id": 1505662274
  },
  {
    "id": "contest432_q3677_s1",
    "question_id": 3677,
    "function_name": "maximumAmount",
    "code": "class Solution:\n    def maximumAmount(self, coins: List[List[int]]) -> int:\n\n        m, n = len(coins), len(coins[0])\n        \n        dp0 = [[float('-inf')] * n for _ in range(m)]\n        dp1 = [[float('-inf')] * n for _ in range(m)]\n        dp2 = [[float('-inf')] * n for _ in range(m)]\n\n        dp0[0][0] = coins[0][0]\n        if coins[0][0] < 0:\n            dp1[0][0] = 0\n\n        for i, r in enumerate(coins):\n            for j, num in enumerate(r):\n                if i > 0:\n                    dp0[i][j] = max(dp0[i][j], dp0[i-1][j] + coins[i][j])\n                    dp1[i][j] = max(dp1[i][j], dp1[i-1][j] + coins[i][j])\n                    dp2[i][j] = max(dp2[i][j], dp2[i-1][j] + coins[i][j])\n                    if coins[i][j] < 0:\n                        dp1[i][j] = max(dp1[i][j], dp0[i-1][j])\n                        dp2[i][j] = max(dp2[i][j], dp1[i-1][j])\n\n                if j > 0:\n                    dp0[i][j] = max(dp0[i][j], dp0[i][j-1] + coins[i][j])\n                    dp1[i][j] = max(dp1[i][j], dp1[i][j-1] + coins[i][j])\n                    dp2[i][j] = max(dp2[i][j], dp2[i][j-1] + coins[i][j])\n                    if coins[i][j] < 0:\n                        dp1[i][j] = max(dp1[i][j], dp0[i][j-1])\n                        dp2[i][j] = max(dp2[i][j], dp1[i][j-1])\n                        \n        return max(dp0[-1][-1], dp1[-1][-1], dp2[-1][-1])",
    "input": "maximumAmount(coins=[[0,1,-1],[1,-2,3],[2,-3,4]])",
    "output": "8",
    "correct_condition": "maximumAmount(coins=[[0,1,-1],[1,-2,3],[2,-3,4]]) == 8",
    "contest_id": "weekly-contest-432",
    "contest_date": "2025-01-12T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 32,
      "coverage": null
    },
    "submission_id": 1505663966
  },
  {
    "id": "contest432_q3677_s2",
    "question_id": 3677,
    "function_name": "maximumAmount",
    "code": "inf = 10 ** 9\nclass Solution:\n    def maximumAmount(self, g: List[List[int]]) -> int:\n        n = len(g)\n        m = len(g[0])\n        f = [[[-inf] * 3 for j in range(m)] for i in range(n)]\n        f[0][0][0] = g[0][0]\n        f[0][0][1] = f[0][0][2] = max(g[0][0], 0)\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    continue\n                x = g[i][j]\n                for k in range(3):\n                    if i > 0 and f[i - 1][j][k] + x > f[i][j][k]:\n                        f[i][j][k] = f[i - 1][j][k] + x\n                    if j > 0 and f[i][j - 1][k] + x > f[i][j][k]:\n                        f[i][j][k] = f[i][j - 1][k] + x\n                    if k and i > 0 and f[i - 1][j][k - 1] > f[i][j][k]:\n                        f[i][j][k] = f[i - 1][j][k - 1]\n                    if k and j > 0 and f[i][j - 1][k - 1] > f[i][j][k]:\n                        f[i][j][k] = f[i][j - 1][k - 1]\n        return max(f[-1][-1])\n        ",
    "input": "maximumAmount(g=[[0,1,-1],[1,-2,3],[2,-3,4]])",
    "output": "8",
    "correct_condition": "maximumAmount(g=[[0,1,-1],[1,-2,3],[2,-3,4]]) == 8",
    "contest_id": "weekly-contest-432",
    "contest_date": "2025-01-12T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 24,
      "coverage": null
    },
    "submission_id": 1505655943
  },
  {
    "id": "contest432_q3720_s0",
    "question_id": 3720,
    "function_name": "minMaxWeight",
    "code": "\nclass Solution:\n    def minMaxWeight(self, n: int, edges: List[List[int]], threshold: int) -> int:\n        G = [[] for _ in range(n)]\n        for u, v, w in edges:\n            G[v].append((u, w))\n\n        def dfs(u, visited, cap):\n            visited[u] = True\n            for v, w in G[u]:\n                if w <= cap and not visited[v]:\n                    dfs(v, visited, cap)\n\n        visited = [False] * n\n        dfs(0, visited, inf)\n        for i in range(n):\n            if not visited[i]:\n                return -1\n\n        L = 0\n        R = 1000000 + 20\n        while L + 1 < R:\n            mid = (L + R) // 2\n            visited = [False] * n\n            dfs(0, visited, mid)\n            ok = True\n            for i in range(n):\n                if not visited[i]:\n                    ok = False\n                    break\n            if ok:\n                R = mid\n            else:\n                L = mid\n\n        return R\n",
    "input": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2)",
    "output": "1",
    "correct_condition": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2) == 1",
    "contest_id": "weekly-contest-432",
    "contest_date": "2025-01-12T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 36,
      "coverage": null
    },
    "submission_id": 1505695158
  },
  {
    "id": "contest432_q3720_s1",
    "question_id": 3720,
    "function_name": "minMaxWeight",
    "code": "class Solution:\n    def minMaxWeight(self, n: int, edges: List[List[int]], threshold: int) -> int:\n\n        ws = set()\n        graph = {}\n        rev = {}\n        for u, v, w in edges:\n            ws.add(w)\n            \n            if u not in graph:\n                graph[u] = defaultdict(lambda: float('inf'))\n            if v not in rev:\n                rev[v] = defaultdict(lambda: float('inf'))\n\n            graph[u][v] = min(graph[u][v], w)\n            rev[v][u] = min(rev[v][u], w)\n\n        q = deque([0])\n        seen = set([0])\n        while q:\n            v = q.popleft()\n            if v in rev:\n                for u in rev[v]:\n                    if u not in seen:\n                        q.append(u)\n                        seen.add(u)\n                        \n        if len(seen) < n:\n            return -1\n\n        def can(x):\n            q = deque([0])\n            seen = set([0])\n            while q:\n                v = q.popleft()\n                if v in rev:\n                    for u in rev[v]:\n                        if rev[v][u] <= x and u not in seen:\n                            q.append(u)\n                            seen.add(u)\n            return len(seen) == n\n\n        l, r = min(ws), max(ws)\n        while l < r:\n            mid = (l + r) // 2\n            if can(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l",
    "input": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2)",
    "output": "1",
    "correct_condition": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2) == 1",
    "contest_id": "weekly-contest-432",
    "contest_date": "2025-01-12T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 50,
      "coverage": null
    },
    "submission_id": 1505688956
  },
  {
    "id": "contest432_q3720_s2",
    "question_id": 3720,
    "function_name": "minMaxWeight",
    "code": "class Solution:\n    def minMaxWeight(self, n: int, edges: List[List[int]], threshold: int) -> int:\n        g = [[] for _ in range(n)]\n        m = 1\n        for u, v, w in edges:\n            g[v].append((u, w))\n            if w > m:\n                m = w\n        def check(mid):\n            vis = [0] * n\n            vis[0] = 1\n            Q = deque([0])\n            while Q:\n                u = Q.popleft()\n                for v, w in g[u]:\n                    if w <= mid and not vis[v]:\n                        Q.append(v)\n                        vis[v] = 1\n            return sum(vis) == n\n                        \n        \n        lo, hi = 1, m + 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if check(mid):\n                hi = mid\n            else:\n                lo = mid + 1\n        return -1 if lo > m else lo",
    "input": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2)",
    "output": "1",
    "correct_condition": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2) == 1",
    "contest_id": "weekly-contest-432",
    "contest_date": "2025-01-12T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 29,
      "coverage": null
    },
    "submission_id": 1505677494
  },
  {
    "id": "contest432_q3674_s0",
    "question_id": 3674,
    "function_name": "countNonDecreasingSubarrays",
    "code": "import bisect\nfrom typing import *\nfrom sortedcontainers import SortedList, SortedDict\nfrom collections import Counter, defaultdict\nfrom math import inf\nfrom math import gcd\nfrom math import factorial\nimport string\nimport random\nimport itertools\nfrom functools import cache, lru_cache\nfrom fractions import Fraction\nfrom itertools import pairwise\n\nclass Solution:\n    def countNonDecreasingSubarrays(self, nums: List[int], k: int) -> int:\n        nums.reverse()\n        n = len(nums)\n        nums.append(10**20)\n        ans = 0\n        remains = k\n        right = 0\n        stack = Deque()\n        for left in range(n):\n            while remains >= 0 and right <= n:\n                if len(stack) == 0 or nums[right] < stack[-1][0]:\n                    stack.append([nums[right], 1])\n                    right += 1\n                else:\n                    combined = 1\n                    while len(stack) > 0 and nums[right] >= stack[-1][0]:\n                        combined += stack[-1][1]\n                        remains -= (nums[right] - stack[-1][0]) * stack[-1][1]\n                        stack.pop()\n                    stack.append([nums[right], combined])\n                    right += 1\n            ans += right - left - 1\n            remains += stack[0][0] - nums[left]\n            stack[0][1] -= 1\n            while len(stack) > 0 and stack[0][1] == 0:\n                stack.popleft()\n\n        return ans\n\n",
    "input": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7)",
    "output": "17",
    "correct_condition": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7) == 17",
    "contest_id": "weekly-contest-432",
    "contest_date": "2025-01-12T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 44,
      "coverage": null
    },
    "submission_id": 1505682945
  },
  {
    "id": "contest432_q3674_s1",
    "question_id": 3674,
    "function_name": "countNonDecreasingSubarrays",
    "code": "class Solution:\n    def countNonDecreasingSubarrays(self, nums: List[int], k: int) -> int:\n\n        n = len(nums)\n\n        j = n\n        total = 0\n        stack = deque()\n        res = 0\n        for i in range(n-1, -1, -1):\n            num = nums[i]\n            \n            inc = 0\n            while stack and nums[stack[-1]] <= nums[i]:\n                cur = stack.pop()\n                prev = stack[-1] if stack else j\n                inc += (nums[i] - nums[cur]) * (prev - cur)\n            total += inc\n\n            stack.append(i)\n\n            while total > k:\n                total -= nums[stack[0]] - nums[j-1]\n                j -= 1\n\n                if j == stack[0]:\n                    stack.popleft()\n\n            res += j - i\n        return res",
    "input": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7)",
    "output": "17",
    "correct_condition": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7) == 17",
    "contest_id": "weekly-contest-432",
    "contest_date": "2025-01-12T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 30,
      "coverage": null
    },
    "submission_id": 1505713317
  },
  {
    "id": "contest432_q3674_s2",
    "question_id": 3674,
    "function_name": "countNonDecreasingSubarrays",
    "code": "class Solution:\n    def countNonDecreasingSubarrays(self, nums: List[int], k: int) -> int:\n        ans = 0\n        n = len(nums)\n        nextlargestidx = [None] * n # strictly larger\n\n        st = []\n        for i in range(len(nums)):\n            while len(st) != 0 and nums[st[-1]] < nums[i]:\n                nextlargestidx[st[-1]] = i\n                st.pop()\n            st.append(i)\n\n        # print(nextlargestidx)\n        \n        start = 0 # inclusive\n        used = 0\n        waterline = 0\n        for i in range(len(nums)):\n            if waterline > nums[i]:\n                used += waterline - nums[i]\n            else:\n                waterline = nums[i]\n\n            while used > k:\n                # attempt to move start forward one\n                oldnext = nextlargestidx[start]\n                oldwaterline = nums[start]\n                \n                temp = start+1\n                while temp is not None and (oldnext is None or temp < oldnext) and (temp <= i):\n                    if oldnext is None or oldnext > i:\n                        waterline = nums[temp]\n                    basinend = n if nextlargestidx[temp] is None else nextlargestidx[temp]\n                    reducecount = min(i+1,basinend) - temp\n                    used -= reducecount * (oldwaterline - nums[temp])\n                    temp = nextlargestidx[temp]\n                \n                    \n                start += 1\n            # print(start, \"to\", i, \"using\", used, \"waterline\", waterline)\n            ans += (i-start+1)\n\n        return ans",
    "input": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7)",
    "output": "17",
    "correct_condition": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7) == 17",
    "contest_id": "weekly-contest-432",
    "contest_date": "2025-01-12T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 44,
      "coverage": null
    },
    "submission_id": 1505705811
  },
  {
    "id": "contest433_q3731_s0",
    "question_id": 3731,
    "function_name": "subarraySum",
    "code": "class Solution:\n    def subarraySum(self, nums):\n        n=len(nums)\n        p=[0]*(n+1)\n        for i in range(n):\n            p[i+1]=p[i]+nums[i]\n        s1=0\n        s2=0\n        for i in range(n):\n            st=i-nums[i]\n            if st<0: st=0\n            s1+=p[i+1]\n            s2+=p[st]\n        return s1-s2",
    "input": "subarraySum(nums=[2,3,1])",
    "output": "11",
    "correct_condition": "subarraySum(nums=[2,3,1]) == 11",
    "contest_id": "weekly-contest-433",
    "contest_date": "2025-01-19T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 14,
      "coverage": null
    },
    "submission_id": 1513087537
  },
  {
    "id": "contest433_q3731_s1",
    "question_id": 3731,
    "function_name": "subarraySum",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nclass Solution:\n    def subarraySum(self, nums: List[int]) -> int:\n        n = len(nums)\n        pref = [0] * (n + 1)\n        for i in range(n):\n            pref[i + 1] = pref[i] + nums[i]\n        \n        ans = 0\n        \n        for i in range(n):\n            start = max(0, i - nums[i])\n            ans += pref[i + 1] - pref[start]\n        return int(ans)\n",
    "input": "subarraySum(nums=[2,3,1])",
    "output": "11",
    "correct_condition": "subarraySum(nums=[2,3,1]) == 11",
    "contest_id": "weekly-contest-433",
    "contest_date": "2025-01-19T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 213,
      "coverage": null
    },
    "submission_id": 1513087481
  },
  {
    "id": "contest433_q3731_s2",
    "question_id": 3731,
    "function_name": "subarraySum",
    "code": "class Solution:\n    def subarraySum(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            start = max(0, i - nums[i])\n            s = 0\n            for j in range(start, i + 1):\n                s += nums[j]\n            ans += s\n        return ans",
    "input": "subarraySum(nums=[2,3,1])",
    "output": "11",
    "correct_condition": "subarraySum(nums=[2,3,1]) == 11",
    "contest_id": "weekly-contest-433",
    "contest_date": "2025-01-19T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 11,
      "coverage": null
    },
    "submission_id": 1513080952
  },
  {
    "id": "contest433_q3714_s0",
    "question_id": 3714,
    "function_name": "minMaxSums",
    "code": "class Solution:\n    def minMaxSums(self, nums: List[int], k: int) -> int:\n        import sys\n        sys.setrecursionlimit(10**7)\n        M=10**9+7\n        n=len(nums)\n        f=[1]*(n+1)\n        invf=[1]*(n+1)\n        for i in range(1,n+1):\n            f[i]=(f[i-1]*i)%M\n        def p(b,e):\n            r=1\n            while e>0:\n                if e&1:\n                    r=(r*b)%M\n                b=(b*b)%M\n                e>>=1\n            return r\n        invf[n]=p(f[n],M-2)\n        for i in range(n-1,-1,-1):\n            invf[i]=(invf[i+1]*(i+1))%M\n        def C(a,b):\n            if b<0 or b>a:\n                return 0\n            return (f[a]*((invf[b]*invf[a-b])%M))%M\n        nums.sort()\n        ans=0\n        for i in range(n):\n            for s in range(1,k+1):\n                if s-1<=i:\n                    ans=(ans+nums[i]*C(i,s-1))%M\n        for i in range(n):\n            for s in range(1,k+1):\n                if s-1<=n-1-i:\n                    ans=(ans+nums[i]*C(n-1-i,s-1))%M\n        return ans%M\n",
    "input": "minMaxSums(nums=[1,2,3], k=2)",
    "output": "24",
    "correct_condition": "minMaxSums(nums=[1,2,3], k=2) == 24",
    "contest_id": "weekly-contest-433",
    "contest_date": "2025-01-19T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 36,
      "coverage": null
    },
    "submission_id": 1513088015
  },
  {
    "id": "contest433_q3714_s1",
    "question_id": 3714,
    "function_name": "minMaxSums",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nclass Solution:\n    def minMaxSums(self, arr: List[int], k: int) -> int:\n        mod = 10**9+7\n        n = len(arr)\n        arr.sort()\n        \n        combi = [[0] * (k + 1) for i in range(n + 1)]\n        for i in range(n + 1):\n            combi[i][0] = 1\n            for j in range(1, min(i, k) + 1):\n                combi[i][j] = (combi[i - 1][j - 1] + combi[i - 1][j]) % mod\n        \n        ans = 0\n        \n        for j in range(n):\n            ways = 0\n            maxl = min(k, j + 1)\n            for l in range(1, maxl + 1):\n                ways += combi[j][l - 1]\n                if ways >= mod:\n                    ways -= mod\n            ans += arr[j] * ways % mod\n            ans %= mod\n        \n        for i in range(n):\n            ways = 0\n            maxl = min(k, n - i)\n            rem = n - 1 - i\n            for l in range(1, maxl + 1):\n                ways += combi[rem][l - 1]\n                if ways >= mod:\n                    ways -= mod\n            ans += arr[i] * ways % mod\n            ans %= mod\n        \n        return int(ans)\n\n",
    "input": "minMaxSums(arr=[1,2,3], k=2)",
    "output": "24",
    "correct_condition": "minMaxSums(arr=[1,2,3], k=2) == 24",
    "contest_id": "weekly-contest-433",
    "contest_date": "2025-01-19T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 237,
      "coverage": null
    },
    "submission_id": 1513090108
  },
  {
    "id": "contest433_q3714_s2",
    "question_id": 3714,
    "function_name": "minMaxSums",
    "code": "class Solution:\n    def minMaxSums(self, nums: List[int], k: int) -> int:\n        MOD = 10**9+7\n        n = len(nums)\n        nums.sort()\n        fact = [1] * (n+1)\n        inv_fact = [1] * (n+1)\n        \n        for i in range(1,n+1):\n            fact[i] = fact[i-1] * i % MOD\n        inv_fact[n] = pow(fact[n], MOD-2, MOD)\n        \n        for i in range(n-1,-1,-1):\n            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n        \n        def comb(a,b):\n            if b < 0 or b > a: return 0\n            return fact[a] * inv_fact[b] % MOD * inv_fact[a-b] % MOD\n        partialC = [0] * n\n        for i in range(n):\n            m = min(i,k-1)\n            s = 0\n            for j in range(m+1):\n                s = (s + comb(i,j)) % MOD\n            partialC[i] = s\n        ans1 = 0\n        ans2 = 0\n        for i in range(n):\n            ans1 = (ans1 + nums[i] * partialC[i]) % MOD\n            ans2 = (ans2 + nums[i] * partialC[n-1-i]) % MOD\n        return (ans1 + ans2) % MOD",
    "input": "minMaxSums(nums=[1,2,3], k=2)",
    "output": "24",
    "correct_condition": "minMaxSums(nums=[1,2,3], k=2) == 24",
    "contest_id": "weekly-contest-433",
    "contest_date": "2025-01-19T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 31,
      "coverage": null
    },
    "submission_id": 1513086962
  },
  {
    "id": "contest433_q3737_s0",
    "question_id": 3737,
    "function_name": "minCost",
    "code": "class Solution:\n    def minCost(self, n: int, cost: List[List[int]]) -> int:\n        s=[(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]\n        dp1=[cost[0][x[0]]+cost[n-1][x[1]] for x in s]\n        v=[[False]*6 for _ in range(6)]\n        for i in range(6):\n            for j in range(6):\n                v[i][j]=(s[i][0]!=s[j][0] and s[i][1]!=s[j][1])\n        for i in range(1,n//2):\n            dp2=[0]*6\n            for j in range(6):\n                mn=min(dp1[k] for k in range(6) if v[k][j])\n                dp2[j]=mn + cost[i][s[j][0]] + cost[n-1-i][s[j][1]]\n            dp1=dp2\n        return min(dp1)\n",
    "input": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]])",
    "output": "9",
    "correct_condition": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]]) == 9",
    "contest_id": "weekly-contest-433",
    "contest_date": "2025-01-19T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 15,
      "coverage": null
    },
    "submission_id": 1513082546
  },
  {
    "id": "contest433_q3737_s1",
    "question_id": 3737,
    "function_name": "minCost",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nclass Solution:\n    def minCost(self, n: int, cost: list[list[int]]) -> int:\n        cpy=cost.copy()\n        half = n // 2\n        vst = [(a, b) for a in range(3) for b in range(3) if a != b]\n        sidx = {state: idx for idx, state in enumerate(vst)}\n        nst = len(vst) \n        INF = float('inf')\n        \n        dp = [INF] * nst\n        ndp = [INF] * nst\n        \n        for (a, b) in vst:\n            idx = sidx[(a, b)]\n            dp[idx] = cpy[0][a] + cpy[n-1][b]\n        \n        for i in range(1, half):\n            for s in range(nst):\n                ndp[s] = INF\n            \n            for (a, b) in vst:\n                cidx = sidx[(a, b)]\n                ccost = cpy[i][a] + cpy[n-1-i][b]\n                \n                for (pa, pb) in vst:\n                    if a == pa or b == pb:\n                        continue\n                    prevs = sidx[(pa, pb)]\n                    if dp[prevs] == INF:\n                        continue\n                    ndp[cidx] = min(ndp[cidx], dp[prevs] + ccost)\n            \n            dp, ndp = ndp, dp \n        return min(dp)\n",
    "input": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]])",
    "output": "9",
    "correct_condition": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]]) == 9",
    "contest_id": "weekly-contest-433",
    "contest_date": "2025-01-19T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 234,
      "coverage": null
    },
    "submission_id": 1513098787
  },
  {
    "id": "contest433_q3737_s2",
    "question_id": 3737,
    "function_name": "minCost",
    "code": "class Solution:\n    def minCost(self, n: int, cost: List[List[int]]) -> int:\n        dp = [[[float('inf')] * 3 for _ in range(3)] for __ in range(n//2+1)]\n        for cl in range(3):\n            for cr in range(3):\n                dp[0][cl][cr] = 0\n                \n        for nl in range(3):\n            for nr in range(3):\n                if nl != nr:\n                    for cl in range(3):\n                        for cr in range(3):\n                            v = dp[0][cl][cr] + cost[0][nl] + cost[n-1][nr]\n                            if v < dp[1][nl][nr]:\n                                dp[1][nl][nr] = v\n                                \n        for i in range(1, n//2):\n            for cl in range(3):\n                for cr in range(3):\n                    p = dp[i][cl][cr]\n                    if p == inf:\n                        continue\n                    for nl in range(3):\n                        for nr in range(3):\n                            if nl != nr and nl != cl and nr != cr:\n                                v = p + cost[i][nl] + cost[n-1-i][nr]\n                                if v < dp[i+1][nl][nr]:\n                                    dp[i+1][nl][nr] = v\n                                    \n        r = float('inf')\n        \n        for cl in range(3):\n            for cr in range(3):\n                if dp[n//2][cl][cr] < r:\n                    r = dp[n//2][cl][cr]\n        return r",
    "input": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]])",
    "output": "9",
    "correct_condition": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]]) == 9",
    "contest_id": "weekly-contest-433",
    "contest_date": "2025-01-19T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 36,
      "coverage": null
    },
    "submission_id": 1513091870
  },
  {
    "id": "contest433_q3725_s0",
    "question_id": 3725,
    "function_name": "minMaxSubarraySum",
    "code": "class Solution:\n    def minMaxSubarraySum(self, nums, k):\n        def p(L,R,M):\n            u=min(L,M-1)\n            if u<=0:return 0\n            if R>=M-1:return M*u - u*(u+1)//2\n            x=M-R\n            if x>u:return R*u\n            s=R*(x-1)\n            s+=M*(u-x+1)-((u*(u+1))//2-((x-1)*x)//2)\n            return s\n        def s(a,k,m):\n            n=len(a)\n            l=[0]*n\n            r=[0]*n\n            st=[]\n            for i in range(n):\n                while st and ((a[st[-1]]>a[i]) if m else (a[st[-1]]<a[i])):\n                    st.pop()\n                l[i]=i-st[-1] if st else i+1\n                st.append(i)\n            st=[]\n            for i in range(n-1,-1,-1):\n                while st and ((a[st[-1]]>=a[i]) if m else (a[st[-1]]<=a[i])):\n                    st.pop()\n                r[i]=st[-1]-i if st else n-i\n                st.append(i)\n            res=0\n            for i in range(n):\n                res+=a[i]*p(l[i],r[i],k+1)\n            return res\n        return s(nums,k,True)+s(nums,k,False)",
    "input": "minMaxSubarraySum(nums=[1,2,3], k=2)",
    "output": "20",
    "correct_condition": "minMaxSubarraySum(nums=[1,2,3], k=2) == 20",
    "contest_id": "weekly-contest-433",
    "contest_date": "2025-01-19T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 32,
      "coverage": null
    },
    "submission_id": 1513090643
  },
  {
    "id": "contest433_q3725_s1",
    "question_id": 3725,
    "function_name": "minMaxSubarraySum",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nclass Solution:\n    def minMaxSubarraySum(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        \n        prev1 = [-1] * n\n        nx1 = [n] * n\n        prev2 = [-1] * n\n        nx2 = [n] * n\n        \n        stk = []\n        for i in range(n):\n            while stk and arr[stk[-1]] >= arr[i]:\n                stk.pop()\n            prev1[i] = stk[-1] if stk else -1\n            stk.append(i)\n        \n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and arr[stk[-1]] > arr[i]:\n                stk.pop()\n            nx1[i] = stk[-1] if stk else n\n            stk.append(i)\n        \n        stk = []\n        for i in range(n):\n            while stk and arr[stk[-1]] <= arr[i]:\n                stk.pop()\n            prev2[i] = stk[-1] if stk else -1\n            stk.append(i)\n        \n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and arr[stk[-1]] < arr[i]:\n                stk.pop()\n            nx2[i] = stk[-1] if stk else n\n            stk.append(i)\n        \n        tot = 0\n\n        def calc(i, left, right, val):\n            L = left\n            R = right\n            lim = min(L, k)\n            if lim <= 0:\n                return 0\n            sumc = 0\n            cng = max(1, k - R + 1)\n            if cng > lim:\n                sumc = lim * R\n            else:\n                fp = cng - 1\n                if fp > 0:\n                    sumc += fp * R\n                for x in range(max(1, cng), lim + 1):\n                    sumc += (k - x + 1)\n            return val * sumc\n        \n        for i in range(n):\n            lmin = i - prev1[i]\n            rmin = nx1[i] - i\n            tot += calc(i, lmin, rmin, arr[i])\n            \n            lmax = i - prev2[i]\n            rmax = nx2[i] - i\n            tot += calc(i, lmax, rmax, arr[i])\n        \n        return tot\n",
    "input": "minMaxSubarraySum(arr=[1,2,3], k=2)",
    "output": "20",
    "correct_condition": "minMaxSubarraySum(arr=[1,2,3], k=2) == 20",
    "contest_id": "weekly-contest-433",
    "contest_date": "2025-01-19T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 267,
      "coverage": null
    },
    "submission_id": 1513094898
  },
  {
    "id": "contest433_q3725_s2",
    "question_id": 3725,
    "function_name": "minMaxSubarraySum",
    "code": "class Solution:\n    def minMaxSubarraySum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        lSmall = [-1]*n\n        rSmall = [n]*n\n        stack = []\n        for i in range(n):\n            while stack and nums[stack[-1]]>nums[i]:\n                stack.pop()\n            lSmall[i] = stack[-1] if stack else -1\n            stack.append(i)\n        stack.clear()\n        for i in range(n-1,-1,-1):\n            while stack and nums[stack[-1]]>=nums[i]:\n                stack.pop()\n            rSmall[i] = stack[-1] if stack else n\n            stack.append(i)\n        def countSub(L,R,k):\n            if L==0 or R==0:\n                return 0\n            m = k - 1\n            if (L - 1)+(R - 1) <= m:\n                return L*R\n            X = min(L,m+1)\n            x0 = max(0,m - (R-1))\n            s = 0\n            if x0>0:\n                t = min(x0,X)\n                s += t*R\n            if x0< X:\n                start = max(x0,0)\n                end = X\n                c = (end - start)\n                s += c*(m+1) - (start+end-1)*c//2\n            return s\n        totalMin = 0\n        for i in range(n):\n            L = i - lSmall[i]\n            R = rSmall[i] - i\n            totalMin += nums[i]*countSub(L,R,k)\n        lBig = [-1]*n\n        rBig = [n]*n\n        stack.clear()\n        for i in range(n):\n            while stack and nums[stack[-1]]<nums[i]:\n                stack.pop()\n            lBig[i] = stack[-1] if stack else -1\n            stack.append(i)\n        stack.clear()\n        for i in range(n-1,-1,-1):\n            while stack and nums[stack[-1]]<=nums[i]:\n                stack.pop()\n            rBig[i] = stack[-1] if stack else n\n            stack.append(i)\n        totalMax = 0\n        for i in range(n):\n            L = i - lBig[i]\n            R = rBig[i] - i\n            totalMax += nums[i]*countSub(L,R,k)\n        return totalMin + totalMax",
    "input": "minMaxSubarraySum(nums=[1,2,3], k=2)",
    "output": "20",
    "correct_condition": "minMaxSubarraySum(nums=[1,2,3], k=2) == 20",
    "contest_id": "weekly-contest-433",
    "contest_date": "2025-01-19T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 60,
      "coverage": null
    },
    "submission_id": 1513104348
  },
  {
    "id": "contest434_q3704_s0",
    "question_id": 3704,
    "function_name": "countPartitions",
    "code": "class Solution:\n    def countPartitions(self, nums: List[int]) -> int:\n        S = sum(nums)\n        n = len(nums)\n        answer = 0 \n        S1 = 0 \n        for i in range(n-1):\n            S1+=nums[i]\n            S-=nums[i]\n            if (S-S1) % 2==0:\n                answer+=1\n        return answer\n        ",
    "input": "countPartitions(nums=[10,10,3,7,6])",
    "output": "4",
    "correct_condition": "countPartitions(nums=[10,10,3,7,6]) == 4",
    "contest_id": "weekly-contest-434",
    "contest_date": "2025-01-26T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 13,
      "coverage": null
    },
    "submission_id": 1520578515
  },
  {
    "id": "contest434_q3704_s1",
    "question_id": 3704,
    "function_name": "countPartitions",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def countPartitions(self, nums: List[int]) -> int:\n        ans = sum(nums)\n        if ans % 2 == 0:\n            return len(nums) - 1\n        else:\n            return 0",
    "input": "countPartitions(nums=[10,10,3,7,6])",
    "output": "4",
    "correct_condition": "countPartitions(nums=[10,10,3,7,6]) == 4",
    "contest_id": "weekly-contest-434",
    "contest_date": "2025-01-26T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 207,
      "coverage": null
    },
    "submission_id": 1520622334
  },
  {
    "id": "contest434_q3704_s2",
    "question_id": 3704,
    "function_name": "countPartitions",
    "code": "class Solution:\n    def countPartitions(self, nums: List[int]) -> int:\n        total = sum(nums)\n        if total % 2 != 0:\n            return 0\n        return len(nums) - 1",
    "input": "countPartitions(nums=[10,10,3,7,6])",
    "output": "4",
    "correct_condition": "countPartitions(nums=[10,10,3,7,6]) == 4",
    "contest_id": "weekly-contest-434",
    "contest_date": "2025-01-26T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 6,
      "coverage": null
    },
    "submission_id": 1520580436
  },
  {
    "id": "contest434_q3721_s0",
    "question_id": 3721,
    "function_name": "countMentions",
    "code": "class Solution:\n    def countMentions(self, numberOfUsers: int, events: List[List[str]]) -> List[int]:\n        m = numberOfUsers\n        n = len(events)\n        L = []\n        for event in events:\n            if event[0]=='MESSAGE':\n                t = int(event[1])\n                L.append([t, 2, event[2]])\n            else:\n                t = int(event[1])\n                L.append([t, 0, event[2]])\n                L.append([t+60, 1, event[2]])\n        d = {}\n        for t, x, R in L:\n            if t not in d:\n                d[t] = [[], [], []]\n            d[t][x].append(R)\n        users = set(range(m))\n        answer = [0 for i in range(m)]\n        for t in sorted(d):\n            for user in d[t][1]:\n                users.add(int(user))\n            for user in d[t][0]:\n                user = int(user)\n                if user in users:\n                    users.remove(user)\n            for x in d[t][2]:\n                if x=='ALL':\n                    for i in range(m):\n                        answer[i]+=1\n                elif x=='HERE':\n                    for i in users:\n                        answer[i]+=1\n                else:\n                    x = x.split()\n                    for i in x:\n                        answer[int(i[2:])]+=1\n        return answer",
    "input": "countMentions(numberOfUsers=2, events=[[\"MESSAGE\",\"10\",\"id1 id0\"],[\"OFFLINE\",\"11\",\"0\"],[\"MESSAGE\",\"71\",\"HERE\"]])",
    "output": "[2, 2]",
    "correct_condition": "countMentions(numberOfUsers=2, events=[[\"MESSAGE\",\"10\",\"id1 id0\"],[\"OFFLINE\",\"11\",\"0\"],[\"MESSAGE\",\"71\",\"HERE\"]]) == [2, 2]",
    "contest_id": "weekly-contest-434",
    "contest_date": "2025-01-26T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 39,
      "coverage": null
    },
    "submission_id": 1520610644
  },
  {
    "id": "contest434_q3721_s2",
    "question_id": 3721,
    "function_name": "countMentions",
    "code": "from typing import List\n\nclass Solution:\n    def countMentions(self, numberOfUsers: int, events: List[List[str]]) -> List[int]:\n        mentions = [0] * numberOfUsers\n        offline_until = [0] * numberOfUsers\n\n        def sort_events(events: List[List[str]]) -> List[List[str]]:\n          \n            def sort_key(event):\n                ts = int(event[1])\n                event_type_priority = 0 if event[0] == 'OFFLINE' else 1\n                return (ts, event_type_priority)\n\n            return sorted(events, key=sort_key)\n\n        def handle_offline_event(user_id: int, ts: int):\n          \n            offline_until[user_id] = ts + 60\n\n        def handle_message_event(ts: int, payload: str):\n          \n            tokens = payload.split()\n            for token in tokens:\n                if token == 'ALL':\n                    # Mention all users (including offline)\n                    for user in range(numberOfUsers):\n                        mentions[user] += 1\n                elif token == 'HERE':\n                   \n                    for user in range(numberOfUsers):\n                        if offline_until[user] <= ts:\n                            mentions[user] += 1\n                else:  \n                    user = int(token[2:])\n                    mentions[user] += 1\n\n        def process_events(events: List[List[str]]):\n          \n            for event in events:\n                event_type, ts_str, payload = event\n                ts = int(ts_str)\n\n                if event_type == 'OFFLINE':\n                    handle_offline_event(int(payload), ts)\n                elif event_type == 'MESSAGE':\n                    handle_message_event(ts, payload)\n\n        # Sort events and process them\n        sorted_events = sort_events(events)\n        process_events(sorted_events)\n\n        return mentions\n",
    "input": "countMentions(numberOfUsers=2, events=[[\"MESSAGE\",\"10\",\"id1 id0\"],[\"OFFLINE\",\"11\",\"0\"],[\"MESSAGE\",\"71\",\"HERE\"]])",
    "output": "[2, 2]",
    "correct_condition": "countMentions(numberOfUsers=2, events=[[\"MESSAGE\",\"10\",\"id1 id0\"],[\"OFFLINE\",\"11\",\"0\"],[\"MESSAGE\",\"71\",\"HERE\"]]) == [2, 2]",
    "contest_id": "weekly-contest-434",
    "contest_date": "2025-01-26T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 53,
      "coverage": null
    },
    "submission_id": 1520595169
  },
  {
    "id": "contest434_q3751_s0",
    "question_id": 3751,
    "function_name": "maxFrequency",
    "code": "class Solution:\n    def maxFrequency(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        k_count = 0 \n        for x in nums:\n            if x==k:\n                k_count+=1\n        answer = k_count\n        for x in range(1, 51):\n            curr_k = 0 \n            my_min = 0\n            x_count = 0 \n            for i in range(n):\n                if nums[i]==x:\n                    x_count+=1 \n                if nums[i]==k:\n                    curr_k+=1\n                my_min = min(my_min, x_count-curr_k)\n                answer = max(answer, x_count-my_min+k_count-curr_k)\n                #best you can do \n                #is [k-count best-freq]+rema\n                #x-freq - \n        return answer\n        \n        ",
    "input": "maxFrequency(nums=[1,2,3,4,5,6], k=1)",
    "output": "2",
    "correct_condition": "maxFrequency(nums=[1,2,3,4,5,6], k=1) == 2",
    "contest_id": "weekly-contest-434",
    "contest_date": "2025-01-26T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 25,
      "coverage": null
    },
    "submission_id": 1520594425
  },
  {
    "id": "contest434_q3751_s1",
    "question_id": 3751,
    "function_name": "maxFrequency",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def maxFrequency(self, nums: List[int], k: int) -> int:\n        totk = sum(1 for num in nums if num == k)\n        maxf = totk\n        for t in range(1, 51):\n            if t == k:\n                continue\n            csum = 0\n            msum = 0\n            for num in nums:\n                if num == t:\n                    csum += 1\n                elif num == k:\n                    csum -= 1\n                if csum < 0:\n                    csum = 0\n                msum = max(msum, csum)\n            maxf = max(maxf, totk + msum)\n        return maxf\n",
    "input": "maxFrequency(nums=[1,2,3,4,5,6], k=1)",
    "output": "2",
    "correct_condition": "maxFrequency(nums=[1,2,3,4,5,6], k=1) == 2",
    "contest_id": "weekly-contest-434",
    "contest_date": "2025-01-26T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 219,
      "coverage": null
    },
    "submission_id": 1520625578
  },
  {
    "id": "contest434_q3751_s2",
    "question_id": 3751,
    "function_name": "maxFrequency",
    "code": "from typing import List\n\nclass Solution:\n    def maxFrequency(self, nums: List[int], k: int) -> int:\n        import sys\n\n        def count_k_occurrences(nums: List[int], k: int) -> int:\n          \n            return sum(1 for x in nums if x == k)\n\n        def build_array(nums: List[int], k: int, v: int) -> List[int]:\n        \n            return [1 if x == v else -1 if x == k else 0 for x in nums]\n\n        def find_max_subarray_sum(arr: List[int]) -> int:\n          \n            current_sum = 0\n            max_sum = -sys.maxsize\n            for val in arr:\n                current_sum = max(val, current_sum + val)\n                max_sum = max(max_sum, current_sum)\n            return max_sum\n\n        def calculate_best_gain(nums: List[int], k: int, n: int) -> int:\n         \n            best_gain = 0\n            for v in range(1, 51):\n                if v == k:\n                    continue\n                arr = build_array(nums, k, v)\n                max_sum = find_max_subarray_sum(arr)\n                if max_sum > best_gain:\n                    best_gain = max_sum\n            return best_gain\n\n        n = len(nums)\n        base_k = count_k_occurrences(nums, k)\n\n        if base_k == n:\n            return n\n\n        best_gain = calculate_best_gain(nums, k, n)\n        return base_k + max(0, best_gain)\n",
    "input": "maxFrequency(nums=[1,2,3,4,5,6], k=1)",
    "output": "2",
    "correct_condition": "maxFrequency(nums=[1,2,3,4,5,6], k=1) == 2",
    "contest_id": "weekly-contest-434",
    "contest_date": "2025-01-26T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 43,
      "coverage": null
    },
    "submission_id": 1520602804
  },
  {
    "id": "contest434_q3713_s0",
    "question_id": 3713,
    "function_name": "supersequences",
    "code": "# from heapq import heappop, heappush\n\n\ndef toposort(graph):\n    res, found = [], [0] * len(graph)\n    stack = list(range(len(graph)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            res.append(~node)\n        elif not found[node]:\n            found[node] = 1\n            stack.append(~node)\n            stack += graph[node]\n\n    # cycle check\n    for node in res:\n        if any(found[nei] for nei in graph[node]):\n            return None\n        found[node] = 0\n\n    return res[::-1]\n\n\ndef kahn(graph):\n    n = len(graph)\n\n    indeg, idx = [0] * n, [0] * n\n    for i in range(n):\n        for e in graph[i]:\n            indeg[e] += 1\n\n    q, res = [], []\n    for i in range(n):\n        if indeg[i] == 0:\n            q.append(i)  # heappush(q, -i)\n\n    nr = 0\n    while q:\n        res.append(q.pop())  # res.append(-heappop(q))\n        idx[res[-1]], nr = nr, nr + 1\n        for e in graph[res[-1]]:\n            indeg[e] -= 1\n            if indeg[e] == 0:\n                q.append(e)  # heappush(q, -e)\n\n    return res, idx, nr == n\n    \nclass Solution:\n    def supersequences(self, words: List[str]) -> List[List[int]]:\n        \"\"\"\n        certainly every-letter-twice works\n        so, SOME letters twice \n\n        a     a \n        \"\"\"\n        g = [[] for i in range(26)]\n        g2 = [[] for i in range(26)]\n        for xy in words:\n            x = xy[0]\n            y = xy[1]\n            x = ord(x)-ord('a')\n            y = ord(y)-ord('a')\n            g[x].append(y)\n            g2[y].append(x)\n        L = []\n        for i in range(26):\n            if len(g[i]) > 0 or len(g2[i]) > 0:\n                L.append(i)\n        from itertools import combinations\n        m = len(L)\n        for k in range(m+1):\n            works = []\n            for doubled in combinations(L, k):\n                D = set(doubled)\n                g2 = [[] for i in range(26)]\n                for i in L:\n                    if i not in D:\n                        for j in g[i]:\n                            if j not in D:\n                                g2[i].append(j)\n                if toposort(g2) is not None:\n                    works.append(D)\n            if len(works) > 0:\n                answer = []\n                for D in works:\n                    entry = [0 for i in range(26)]\n                    for i in L:\n                        entry[i] = 1 \n                    for i in D:\n                        entry[i]+=1\n                    answer.append(entry)\n                return answer\n        ",
    "input": "supersequences(words=[\"ab\",\"ba\"])",
    "output": "[[2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]",
    "correct_condition": "supersequences(words=[\"ab\",\"ba\"]) == [[2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]",
    "contest_id": "weekly-contest-434",
    "contest_date": "2025-01-26T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 94,
      "coverage": null
    },
    "submission_id": 1520629198
  },
  {
    "id": "contest434_q3713_s1",
    "question_id": 3713,
    "function_name": "supersequences",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def supersequences(self, words: List[str]) -> List[List[int]]:\n        lset = set()\n        for w in words:\n            if len(w) >= 1:\n                lset.add(w[0])\n            if len(w) >= 2:\n                lset.add(w[1])\n        letters = sorted(lset)\n        k = len(letters)\n        ind1 = {letter: i for i, letter in enumerate(letters)}\n        adj = [[] for i in range(k)]\n        ls1 = [False] * k\n        for w in words:\n            if len(w) < 2:\n                continue\n            a = ind1[w[0]]\n            b = ind1[w[1]]\n            if a == b:\n                ls1[a] = True\n            else:\n                adj[a].append(b)\n        disc = [-1] * k\n        low = [0] * k\n        sid = [-1] * k\n        stks = [False] * k\n        st = []\n        dfst = 0\n        scnt = 0\n\n        def solve(u):\n            nonlocal dfst, scnt\n            disc[u] = low[u] = dfst\n            dfst += 1\n            st.append(u)\n            stks[u] = True\n            for v in adj[u]:\n                if disc[v] == -1:\n                    solve(v)\n                    low[u] = min(low[u], low[v])\n                elif stks[v]:\n                    low[u] = min(low[u], disc[v])\n            if low[u] == disc[u]:\n                while True:\n                    topv = st.pop()\n                    stks[topv] = False\n                    sid[topv] = scnt\n                    if topv == u:\n                        break\n                scnt += 1\n\n        for i in range(k):\n            if disc[i] == -1:\n                solve(i)\n\n        mem1 = [[] for i in range(scnt)]\n        for i in range(k):\n            mem1[sid[i]].append(i)\n\n        freq1 = [[] for i in range(scnt)]\n\n        def solve2(cmpx, rept):\n            act = set(x for x in cmpx if not rept[x])\n            if not act:\n                return True\n            adjs = defaultdict(list)\n            for x in cmpx:\n                if not rept[x]:\n                    for v in adj[x]:\n                        if v in act:\n                            adjs[x].append(v)\n            vis = {x: 0 for x in act}\n\n            def dfs(u):\n                vis[u] = 1\n                for v in adjs[u]:\n                    if vis[v] == 0:\n                        if dfs(v):\n                            return True\n                    elif vis[v] == 1:\n                        return True\n                vis[u] = 2\n                return False\n\n            for x in act:\n                if vis[x] == 0:\n                    if dfs(x):\n                        return False\n            return True\n\n        for s in range(scnt):\n            cmpx = mem1[s]\n            sz = len(cmpx)\n            if sz == 1:\n                x = cmpx[0]\n                if ls1[x]:\n                    freq1[s].append([2])\n                else:\n                    freq1[s].append([1])\n                continue\n            fnx = [x for x in cmpx if ls1[x]]\n            lcn = {x: i for i, x in enumerate(cmpx)}\n            mskf = 0\n            for x in fnx:\n                mskf |= (1 << lcn[x])\n            bcar = float('inf')\n            gsubs = []\n            for mask in range(1 << sz):\n                if (mask & mskf) != mskf:\n                    continue\n                c = bin(mask).count('1')\n                if c > bcar:\n                    continue\n                rept = [False] * k\n                for i in range(sz):\n                    if (mask & (1 << i)):\n                        ltx = cmpx[i]\n                        rept[ltx] = True\n                if solve2(cmpx, rept):\n                    if c < bcar:\n                        bcar = c\n                        gsubs = [rept.copy()]\n                    elif c == bcar:\n                        gsubs.append(rept.copy())\n            for zx in gsubs:\n                freqp = [1] * sz\n                for i in range(sz):\n                    if zx[cmpx[i]]:\n                        freqp[i] = 2\n                freq1[s].append(freqp)\n\n        pres = []\n        sfreqs = [0] * k\n\n        def dfs2(s, curr):\n            if s == scnt:\n                pres.append(curr.copy())\n                return\n            for freqv in freq1[s]:\n                ncurr = curr.copy()\n                for i, ltx in enumerate(mem1[s]):\n                    ncurr[ltx] = freqv[i]\n                dfs2(s + 1, ncurr)\n\n        dfs2(0, sfreqs)\n\n        msums = float('inf')\n        for fv in pres:\n            s = sum(fv)\n            if s < msums:\n                msums = s\n        minfreq = [fv for fv in pres if sum(fv) == msums]\n\n        fst = set()\n        for fv in minfreq:\n            fre26 = [0] * 26\n            for i, freq in enumerate(fv):\n                letter = letters[i]\n                fre26[ord(letter) - ord('a')] = freq\n            fst.add(tuple(fre26))\n\n        return [list(t) for t in fst]\n",
    "input": "supersequences(words=[\"ab\",\"ba\"])",
    "output": "[[1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]",
    "correct_condition": "supersequences(words=[\"ab\",\"ba\"]) == [[1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]",
    "contest_id": "weekly-contest-434",
    "contest_date": "2025-01-26T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 362,
      "coverage": null
    },
    "submission_id": 1520639348
  },
  {
    "id": "contest434_q3713_s2",
    "question_id": 3713,
    "function_name": "supersequences",
    "code": "from collections import deque\n\nclass Solution:\n    def supersequences(self, words):\n        if not words:\n            return []\n        \n        # Step 1: Collect unique letters and map to indices\n        unique_chars = set()\n        for word in words:\n            unique_chars.add(word[0])\n            unique_chars.add(word[1])\n        sorted_chars = sorted(unique_chars)\n        u = len(sorted_chars)\n        char_to_idx = {c: i for i, c in enumerate(sorted_chars)}\n        \n        # Step 2: Build adjacency matrix and self_loop array\n        adjacency = [[False] * u for _ in range(u)]\n        self_loop = [False] * u\n        for word in words:\n            c1, c2 = word[0], word[1]\n            x = char_to_idx[c1]\n            y = char_to_idx[c2]\n            if x == y:\n                self_loop[x] = True\n            else:\n                adjacency[x][y] = True\n        \n        # Build graph for Tarjan's algorithm\n        graph = [[] for _ in range(u)]\n        for i in range(u):\n            for j in range(u):\n                if adjacency[i][j]:\n                    graph[i].append(j)\n        \n        # Step 3: Find SCCs using Tarjan's algorithm\n        scc_id, scc_count = self.tarjans_algorithm(u, graph)\n        \n        # Step 4: Build SCC vertices and condensed graph\n        scc_vertices = [[] for _ in range(scc_count)]\n        for node in range(u):\n            scc_vertices[scc_id[node]].append(node)\n        \n        condensed_graph, in_degree = self.build_condensed_graph(scc_id, scc_count, graph)\n        \n        # Step 5: Topological sort of condensed graph\n        topo_order = self.topological_sort(condensed_graph, in_degree, scc_count)\n        \n        # Step 6: Compute frequency options for each SCC\n        freq_options_per_scc = []\n        for scc_idx in topo_order:\n            scc_nodes = scc_vertices[scc_idx]\n            options = self.compute_freq_options_for_scc(scc_nodes, self_loop, adjacency, u)\n            freq_options_per_scc.append(options)\n        \n        # Step 7: Combine options via Cartesian product\n        all_global = self.combine_freq_options(freq_options_per_scc, u)\n        \n        # Step 8: Convert to 26-letter frequencies and deduplicate\n        result = self.convert_and_deduplicate(all_global, sorted_chars)\n        \n        return result\n    \n    def tarjans_algorithm(self, u, graph):\n        index = [-1] * u\n        low_link = [0] * u\n        on_stack = [False] * u\n        stack = []\n        scc_id = [-1] * u\n        current_index = 0\n        scc_count = 0\n        \n        def strongconnect(v):\n            nonlocal current_index, scc_count\n            index[v] = current_index\n            low_link[v] = current_index\n            current_index += 1\n            stack.append(v)\n            on_stack[v] = True\n            for w in graph[v]:\n                if index[w] == -1:\n                    strongconnect(w)\n                    low_link[v] = min(low_link[v], low_link[w])\n                elif on_stack[w]:\n                    low_link[v] = min(low_link[v], index[w])\n            if low_link[v] == index[v]:\n                while True:\n                    node = stack.pop()\n                    on_stack[node] = False\n                    scc_id[node] = scc_count\n                    if node == v:\n                        break\n                scc_count += 1\n        \n        for v in range(u):\n            if index[v] == -1:\n                strongconnect(v)\n        return scc_id, scc_count\n    \n    def build_condensed_graph(self, scc_id, scc_count, graph):\n        condensed = [set() for _ in range(scc_count)]\n        for v in range(len(graph)):\n            current_scc = scc_id[v]\n            for w in graph[v]:\n                target_scc = scc_id[w]\n                if current_scc != target_scc:\n                    condensed[current_scc].add(target_scc)\n        condensed_graph = [list(s) for s in condensed]\n        in_degree = [0] * scc_count\n        for c1 in range(scc_count):\n            for c2 in condensed_graph[c1]:\n                in_degree[c2] += 1\n        return condensed_graph, in_degree\n    \n    def topological_sort(self, condensed_graph, in_degree, scc_count):\n        q = deque()\n        for c in range(scc_count):\n            if in_degree[c] == 0:\n                q.append(c)\n        topo_order = []\n        while q:\n            c = q.popleft()\n            topo_order.append(c)\n            for neighbor in condensed_graph[c]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    q.append(neighbor)\n        return topo_order\n    \n    def compute_freq_options_for_scc(self, scc_nodes, self_loop, adjacency, u):\n        k = len(scc_nodes)\n        if k == 1:\n            only = scc_nodes[0]\n            freq = [0] * u\n            freq[only] = 2 if self_loop[only] else 1\n            return [freq]\n        local_to_global = {i: node for i, node in enumerate(scc_nodes)}\n        forced_mask = 0\n        sub_graph = [[] for _ in range(k)]\n        for i in range(k):\n            global_i = scc_nodes[i]\n            if self_loop[global_i]:\n                forced_mask |= (1 << i)\n            for j in range(k):\n                global_j = scc_nodes[j]\n                if adjacency[global_i][global_j]:\n                    sub_graph[i].append(j)\n        min_sets = self.find_minimal_fvs(k, sub_graph, forced_mask)\n        freq_options = []\n        for mask in min_sets:\n            freq = [0] * u\n            for i in range(k):\n                node = scc_nodes[i]\n                if (mask >> i) & 1:\n                    freq[node] = 2\n                else:\n                    freq[node] = 1\n            freq_options.append(freq)\n        return freq_options\n    \n    def find_minimal_fvs(self, k, sub_graph, forced_mask):\n        optional_mask = ((1 << k) - 1) & ~forced_mask\n        forced_count = bin(forced_mask).count('1')\n        min_size = float('inf')\n        solutions = []\n        for sub in range(0, optional_mask + 1):\n            if (sub & optional_mask) != sub:\n                continue\n            s = forced_mask | sub\n            current_size = forced_count + bin(sub).count('1')\n            if current_size > min_size:\n                continue\n            if self.is_acyclic_after_removal(k, sub_graph, s):\n                if current_size < min_size:\n                    min_size = current_size\n                    solutions = [s]\n                elif current_size == min_size:\n                    solutions.append(s)\n        return solutions\n    \n    def is_acyclic_after_removal(self, k, sub_graph, remove_mask):\n        in_degree = [0] * k\n        remaining = 0\n        for v in range(k):\n            if (remove_mask >> v) & 1:\n                continue\n            remaining += 1\n            for w in sub_graph[v]:\n                if not ((remove_mask >> w) & 1):\n                    in_degree[w] += 1\n        q = deque()\n        for v in range(k):\n            if not ((remove_mask >> v) & 1) and in_degree[v] == 0:\n                q.append(v)\n        visited = 0\n        while q:\n            v = q.popleft()\n            visited += 1\n            for w in sub_graph[v]:\n                if not ((remove_mask >> w) & 1):\n                    in_degree[w] -= 1\n                    if in_degree[w] == 0:\n                        q.append(w)\n        return visited == remaining\n    \n    def combine_freq_options(self, freq_options_per_scc, u):\n        all_global = [[0] * u]\n        for options in freq_options_per_scc:\n            new_all = []\n            for base in all_global:\n                for freq in options:\n                    combined = [base[i] + freq[i] for i in range(u)]\n                    new_all.append(combined)\n            all_global = new_all\n        return all_global\n    \n    def convert_and_deduplicate(self, all_global, sorted_chars):\n        seen = set()\n        result = []\n        for freq_u in all_global:\n            freq_26 = [0] * 26\n            for i, c in enumerate(sorted_chars):\n                idx = ord(c) - ord('a')\n                freq_26[idx] = freq_u[i]\n            key = tuple(freq_26)\n            if key not in seen:\n                seen.add(key)\n                result.append(freq_26)\n        return result",
    "input": "supersequences(words=[\"ab\",\"ba\"])",
    "output": "[[2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]",
    "correct_condition": "supersequences(words=[\"ab\",\"ba\"]) == [[2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]",
    "contest_id": "weekly-contest-434",
    "contest_date": "2025-01-26T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 229,
      "coverage": null
    },
    "submission_id": 1520642624
  },
  {
    "id": "contest435_q3753_s0",
    "question_id": 3753,
    "function_name": "maxDifference",
    "code": "class Solution:\n    def maxDifference(self, s: str) -> int:\n        freq = Counter(s)\n        odd = [c for c in freq.values() if c % 2]\n        even = [c for c in freq.values() if c % 2 == 0]\n        return max(odd) - min(even) if odd and even else -1",
    "input": "maxDifference(s=\"aaaaabbc\")",
    "output": "3",
    "correct_condition": "maxDifference(s=\"aaaaabbc\") == 3",
    "contest_id": "weekly-contest-435",
    "contest_date": "2025-02-02T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 6,
      "coverage": null
    },
    "submission_id": 1528081228
  },
  {
    "id": "contest435_q3753_s1",
    "question_id": 3753,
    "function_name": "maxDifference",
    "code": "class Solution:\n    def maxDifference(self, s: str) -> int:\n        count = [0] * 26\n        for c in s:\n            count[ord(c) - ord('a')] += 1\n        odd = -1\n        even = float('inf')\n        for x in count:\n            if x:\n                if x % 2 == 0:\n                    even = min(even, x)\n                else:\n                    odd = max(odd, x)\n        return odd - even\n\n",
    "input": "maxDifference(s=\"aaaaabbc\")",
    "output": "3",
    "correct_condition": "maxDifference(s=\"aaaaabbc\") == 3",
    "contest_id": "weekly-contest-435",
    "contest_date": "2025-02-02T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 15,
      "coverage": null
    },
    "submission_id": 1528102981
  },
  {
    "id": "contest435_q3753_s2",
    "question_id": 3753,
    "function_name": "maxDifference",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def maxDifference(self, s: str) -> int:\n        freq = [0] * 26\n        for k in s:\n            freq[ord(k) - ord('a')] += 1\n        odd = -1  \n        even = float('inf') \n        for p in freq:\n            if p == 0:\n                continue  \n            if p % 2 == 1: \n                odd = max(odd, p)\n            else: \n                even = min(even, p)\n        return odd - even",
    "input": "maxDifference(s=\"aaaaabbc\")",
    "output": "3",
    "correct_condition": "maxDifference(s=\"aaaaabbc\") == 3",
    "contest_id": "weekly-contest-435",
    "contest_date": "2025-02-02T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 215,
      "coverage": null
    },
    "submission_id": 1528109134
  },
  {
    "id": "contest435_q3754_s0",
    "question_id": 3754,
    "function_name": "maxDistance",
    "code": "class Solution:\n    def maxDistance(self, s: str, k: int) -> int:\n\n        res = 0\n        e = w = n = s_count = 0\n        for i, ch in enumerate(s, 1):\n            if ch == 'E': e += 1\n            elif ch == 'W': w += 1\n            elif ch == 'N': n += 1\n            else: s_count += 1\n            bx = abs(e - w)\n            hx = min(e, w)\n            by = abs(n - s_count)\n            hy = min(n, s_count)\n            cur = bx + by + 2 * min(k, hx + hy)\n            if cur > i: cur = i\n            if cur > res: res = cur\n        return res",
    "input": "maxDistance(s=\"NWSE\", k=1)",
    "output": "3",
    "correct_condition": "maxDistance(s=\"NWSE\", k=1) == 3",
    "contest_id": "weekly-contest-435",
    "contest_date": "2025-02-02T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 18,
      "coverage": null
    },
    "submission_id": 1528089568
  },
  {
    "id": "contest435_q3754_s1",
    "question_id": 3754,
    "function_name": "maxDistance",
    "code": "from collections import Counter\n\nclass Solution:\n    def maxDistance(self, s: str, k: int) -> int:\n        n, a, c = len(s), 0, Counter()\n        \n        u = lambda x: c.update(x)\n        d = lambda x, y: abs(c[x] - c[y])\n        f = lambda x, y: min(c[x], c[y])\n        \n        for i, x in enumerate(s):\n            u(x)\n            dx, dy = d('E', 'W'), d('N', 'S')\n            fc = f('E', 'W') + f('N', 'S')\n            cand = min(dx + dy + 2 * min(k, fc), i + 1)\n            a = max(a, cand)\n        \n        return a\n",
    "input": "maxDistance(s=\"NWSE\", k=1)",
    "output": "3",
    "correct_condition": "maxDistance(s=\"NWSE\", k=1) == 3",
    "contest_id": "weekly-contest-435",
    "contest_date": "2025-02-02T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 18,
      "coverage": null
    },
    "submission_id": 1528113622
  },
  {
    "id": "contest435_q3754_s2",
    "question_id": 3754,
    "function_name": "maxDistance",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def maxDistance(self, s: str, k: int) -> int:\n        n = len(s)\n        pre1 = [0] * (n + 1)\n        pre2 = [0] * (n + 1)\n        pre3 = [0] * (n + 1)\n        pre4 = [0] * (n + 1)\n        \n        for i in range(n):\n            pre1[i+1] = pre1[i] + (s[i] == 'N')\n            pre2[i+1] = pre2[i] + (s[i] == 'S')\n            pre3[i+1] = pre3[i] + (s[i] == 'E')\n            pre4[i+1] = pre4[i] + (s[i] == 'W')\n        \n        ans = 0\n        \n        for m in range(1, n + 1):\n            for z in [(pre1[m] + pre3[m]), (pre1[m] + pre4[m]), (pre2[m] + pre3[m]), (pre2[m] + pre4[m])]:\n                p = m - z\n                cur = m if p <= k else (2 * z + 2 * k - m)\n                ans = max(ans, cur)\n        \n        return ans\n",
    "input": "maxDistance(s=\"NWSE\", k=1)",
    "output": "3",
    "correct_condition": "maxDistance(s=\"NWSE\", k=1) == 3",
    "contest_id": "weekly-contest-435",
    "contest_date": "2025-02-02T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 223,
      "coverage": null
    },
    "submission_id": 1528113125
  },
  {
    "id": "contest435_q3697_s0",
    "question_id": 3697,
    "function_name": "minimumIncrements",
    "code": "from math import gcd\n\n\nclass Solution:\n    def minimumIncrements(self, nums: List[int], target: List[int]) -> int:\n        m = len(target)\n        full = (1 << m) - 1\n        subs = []\n        for s in range(1, 1 << m):\n            lcm_val = 1\n            for i in range(m):\n                if s >> i & 1:\n                    lcm_val = lcm_val * target[i] // gcd(lcm_val, target[i])\n            subs.append((s, lcm_val))\n        INF = 10**19\n        dp = [INF] * (1 << m)\n        dp[0] = 0\n        for a in nums:\n            ndp = dp[:]\n            for mask in range(1 << m):\n                if dp[mask] == INF:\n                    continue\n                for s, l in subs:\n                    nm = mask | s\n                    cost = (l - (a % l)) % l\n                    ndp[nm] = min(ndp[nm], dp[mask] + cost)\n            dp = ndp\n        return dp[full]",
    "input": "minimumIncrements(nums=[1,2,3], target=[4])",
    "output": "1",
    "correct_condition": "minimumIncrements(nums=[1,2,3], target=[4]) == 1",
    "contest_id": "weekly-contest-435",
    "contest_date": "2025-02-02T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 28,
      "coverage": null
    },
    "submission_id": 1528091022
  },
  {
    "id": "contest435_q3697_s1",
    "question_id": 3697,
    "function_name": "minimumIncrements",
    "code": "from math import gcd\nfrom functools import reduce\n\nclass Candidate:\n    def __init__(self, L, mask):\n        self.L = L\n        self.mask = mask\n\nclass MinIncrementsSolver:\n    def lcm(self, a, b):\n        return a // gcd(a, b) * b\n\n    def unique_targets(self, target):\n        return list(set(sorted(target)))\n\n    def generate_candidates(self, target):\n        m = len(target)\n        candidates = []\n        seen = set()\n        total = 1 << m\n        for s in range(1, total):\n            curL = 1\n            for j in range(m):\n                if s & (1 << j):\n                    curL = self.lcm(curL, target[j])\n            cover_mask = 0\n            for j in range(m):\n                if curL % target[j] == 0:\n                    cover_mask |= (1 << j)\n            if curL not in seen:\n                seen.add(curL)\n                candidates.append(Candidate(curL, cover_mask))\n        return candidates\n\n    def compute_cost(self, n, L):\n        rem = n % L\n        return 0 if rem == 0 else (L - rem)\n\n    def solve_dp(self, nums, candidates, full_mask, m):\n        INF = 10**18\n        dp = [INF] * (1 << m)\n        dp[0] = 0\n        for num in nums:\n            new_dp = dp[:]\n            for cand in candidates:\n                cost = self.compute_cost(num, cand.L)\n                for mask in range(1 << m):\n                    if dp[mask] == INF:\n                        continue\n                    nmask = mask | cand.mask\n                    new_dp[nmask] = min(new_dp[nmask], dp[mask] + cost)\n            dp = new_dp\n        return dp[full_mask]\n\n    def minimum_increments(self, nums, target):\n        uniq = self.unique_targets(target)\n        m = len(uniq)\n        full_mask = (1 << m) - 1\n        candidates = self.generate_candidates(uniq)\n        ans = self.solve_dp(nums, candidates, full_mask, m)\n        return ans\n\nclass Solution:\n    def minimumIncrements(self, nums, target):\n        solver = MinIncrementsSolver()\n        result = solver.minimum_increments(nums, target)\n        return int(result)\n\n",
    "input": "minimumIncrements(nums=[1,2,3], target=[4])",
    "output": "1",
    "correct_condition": "minimumIncrements(nums=[1,2,3], target=[4]) == 1",
    "contest_id": "weekly-contest-435",
    "contest_date": "2025-02-02T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 68,
      "coverage": null
    },
    "submission_id": 1528095476
  },
  {
    "id": "contest435_q3697_s2",
    "question_id": 3697,
    "function_name": "minimumIncrements",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nimport math\nfrom itertools import product\n\nclass Solution:\n    def minimumIncrements(self, nums: List[int], target: List[int]) -> int:\n        cpy = nums[:]\n        n = len(cpy)\n        m = len(target)\n        fmsk = (1 << m) - 1\n        mlcm = [1] * (1 << m)\n        for msks in range(1, 1 << m):\n            clcm = 1\n            for j in range(m):\n                if msks & (1 << j):\n                    clcm = (clcm * target[j]) // math.gcd(clcm, target[j])\n            mlcm[msks] = clcm\n        \n        INF = float('inf')\n        dp = [[INF] * (1 << m) for i in range(n + 1)]\n        dp[0][0] = 0\n        \n        for i in range(n):\n            x = cpy[i]\n            ls = []\n            for msks in range(1, 1 << m):\n                z = mlcm[msks]\n                mulx = (x + z - 1) // z \n                nval = mulx * z\n                cstx = nval - x\n                ls.append((msks, cstx))\n            \n            for msks in range(1 << m):\n                dp[i + 1][msks] = min(dp[i + 1][msks], dp[i][msks])\n                for smsk, cstx in ls:\n                    mskn = msks | smsk\n                    dp[i + 1][mskn] = min(dp[i + 1][mskn], dp[i][msks] + cstx)\n        \n        return dp[n][fmsk]",
    "input": "minimumIncrements(nums=[1,2,3], target=[4])",
    "output": "1",
    "correct_condition": "minimumIncrements(nums=[1,2,3], target=[4]) == 1",
    "contest_id": "weekly-contest-435",
    "contest_date": "2025-02-02T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 238,
      "coverage": null
    },
    "submission_id": 1528107386
  },
  {
    "id": "contest435_q3761_s0",
    "question_id": 3761,
    "function_name": "maxDifference",
    "code": "from bisect import bisect_left\nclass Solution:\n    def maxDifference(self, s: str, k: int) -> int:\n        INF = 10**9\n        n = len(s)\n        ans = -10**9\n        for x in range(5):\n            for y in range(5):\n                if x == y:\n                    continue\n                N = n + 1\n                D = [0] * N\n                PX = [0] * N\n                PY = [0] * N\n                CNT = [0] * N\n                sx = str(x)\n                sy = str(y)\n                for i in range(n):\n                    D[i+1] = D[i] + (1 if s[i] == sx else 0) - (1 if s[i] == sy else 0)\n                    PX[i+1] = (PX[i] + (1 if s[i] == sx else 0)) & 1\n                    PY[i+1] = (PY[i] + (1 if s[i] == sy else 0)) & 1\n                    CNT[i+1] = CNT[i] + (1 if s[i] == sy else 0)\n                mp = {(0,0): [], (0,1): [], (1,0): [], (1,1): []}\n                cum = {(0,0): [], (0,1): [], (1,0): [], (1,1): []}\n                key0 = (PX[0], PY[0])\n                mp[key0].append((CNT[0], D[0]))\n                cum[key0].append(D[0])\n                best = -10**9\n                p = 1\n                for r in range(k, N):\n                    while p <= r - k:\n                        key = (PX[p], PY[p])\n                        mp[key].append((CNT[p], D[p]))\n                        if cum[key]:\n                            cum[key].append(min(cum[key][-1], D[p]))\n                        else:\n                            cum[key].append(D[p])\n                        p += 1\n                    keyq = (1 - PX[r], PY[r])\n                    arr = mp[keyq]\n                    if not arr:\n                        continue\n                    pos = bisect_left(arr, (CNT[r], -10**9))\n                    if pos:\n                        cand = D[r] - cum[keyq][pos-1]\n                        if cand > best:\n                            best = cand\n                if best > ans:\n                    ans = best\n        return ans\n\n",
    "input": "maxDifference(s=\"12233\", k=4)",
    "output": "-1",
    "correct_condition": "maxDifference(s=\"12233\", k=4) == -1",
    "contest_id": "weekly-contest-435",
    "contest_date": "2025-02-02T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 51,
      "coverage": null
    },
    "submission_id": 1528104807
  },
  {
    "id": "contest435_q3761_s2",
    "question_id": 3761,
    "function_name": "maxDifference",
    "code": "def build_prefix_arrays(s: str, a: int, b: int, n: int) -> tuple:\n    F = [0] * (n + 1)\n    Ca = [0] * (n + 1)\n    Cb = [0] * (n + 1)\n    for i in range(n):\n        dig = int(s[i])\n        delta = 1 if dig == a else (-1 if dig == b else 0)\n        F[i + 1] = F[i] + delta\n        Ca[i + 1] = Ca[i] + (1 if dig == a else 0)\n        Cb[i + 1] = Cb[i] + (1 if dig == b else 0)\n    return F, Ca, Cb\n\ndef build_best_arr(F: list, Ca: list, Cb: list, n: int, INF: float) -> list:\n    best_arr = [[[INF] * (n + 1) for _ in range(2)] for _ in range(2)]\n    pb0 = Cb[0] & 1\n    pa0 = Ca[0] & 1\n    best_arr[pa0][pb0][0] = F[0]\n    for i in range(1, n + 1):\n        pb = Cb[i] & 1\n        pa = Ca[i] & 1\n        for u in range(2):\n            for t in range(2):\n                best_arr[t][u][i] = best_arr[t][u][i - 1]\n        best_arr[pa][pb][i] = min(best_arr[pa][pb][i], F[i])\n    return best_arr\n\ndef find_largest_index(prefix: list, target: int, j: int) -> int:\n    index = -1\n    lo, hi = 0, j\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if prefix[mid] <= target:\n            index = mid\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return index\n\nclass Solution:\n    def maxDifference(self, s: str, k: int) -> int:\n        INF = float('inf')\n        n = len(s)\n        ans = -INF\n        fnd = False\n        for a in range(5):\n            for b in range(5):\n                if a == b:\n                    continue\n                F, Ca, Cb = build_prefix_arrays(s, a, b, n)\n                best_arr = build_best_arr(F, Ca, Cb, n, INF)\n                for j in range(k, n + 1):\n                    if Ca[j] == 0 or Cb[j] == 0:\n                        continue\n                    X3 = find_largest_index(Cb, Cb[j] - 1, j)\n                    X2 = find_largest_index(Ca, Ca[j] - 1, j)\n                    X1 = j - k\n                    X = min(X1, X2, X3)\n                    if X < 0:\n                        continue\n                    reqB = (Cb[j] & 1)\n                    reqA = (1 - (Ca[j] & 1)) & 1\n                    candidate = best_arr[reqA][reqB][X]\n                    if candidate == INF:\n                        continue\n                    diff = F[j] - candidate\n                    fnd = True\n                    ans = max(ans, diff)\n        if not fnd:\n            return -1\n        return ans",
    "input": "maxDifference(s=\"12233\", k=4)",
    "output": "-1",
    "correct_condition": "maxDifference(s=\"12233\", k=4) == -1",
    "contest_id": "weekly-contest-435",
    "contest_date": "2025-02-02T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 70,
      "coverage": null
    },
    "submission_id": 1528137393
  },
  {
    "id": "contest436_q3748_s0",
    "question_id": 3748,
    "function_name": "sortMatrix",
    "code": "class Solution:\n    def sortMatrix(self, grid: List[List[int]]) -> List[List[int]]:\n        n = len(grid)\n        x = 0\n        y = n - 1\n        while True:\n            pos = []\n            cur = 0\n            while x + cur < n and y + cur < n:\n                pos.append(grid[x + cur][y + cur])\n                cur += 1\n            cur = 0\n            if y > 0:\n                pos.sort()\n            else:\n                pos.sort(reverse=True)\n            while x + cur < n and y + cur < n:\n                grid[x + cur][y + cur] = pos[cur]\n                cur += 1\n            \n\n\n            if y > 0:\n                y -= 1\n            elif x < n - 1:\n                x += 1\n            else:\n                break\n        return grid\n        ",
    "input": "sortMatrix(grid=[[1,7,3],[9,8,2],[4,5,6]])",
    "output": "[[8, 2, 3], [9, 6, 7], [4, 5, 1]]",
    "correct_condition": "sortMatrix(grid=[[1,7,3],[9,8,2],[4,5,6]]) == [[8, 2, 3], [9, 6, 7], [4, 5, 1]]",
    "contest_id": "weekly-contest-436",
    "contest_date": "2025-02-09T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 30,
      "coverage": null
    },
    "submission_id": 1536399828
  },
  {
    "id": "contest436_q3748_s1",
    "question_id": 3748,
    "function_name": "sortMatrix",
    "code": "class Solution:\n    def sortMatrix(self, grid: List[List[int]]) -> List[List[int]]:\n        graph = collections.defaultdict(list)\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                graph[i-j].append(grid[i][j])\n        \n        for key in graph:\n            if key >= 0:\n                graph[key].sort()\n            else:\n                graph[key].sort(reverse=True)\n                \n        #print(graph)\n        \n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                grid[i][j] = graph[i-j].pop()\n        return grid",
    "input": "sortMatrix(grid=[[1,7,3],[9,8,2],[4,5,6]])",
    "output": "[[8, 2, 3], [9, 6, 7], [4, 5, 1]]",
    "correct_condition": "sortMatrix(grid=[[1,7,3],[9,8,2],[4,5,6]]) == [[8, 2, 3], [9, 6, 7], [4, 5, 1]]",
    "contest_id": "weekly-contest-436",
    "contest_date": "2025-02-09T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 21,
      "coverage": null
    },
    "submission_id": 1536396372
  },
  {
    "id": "contest436_q3748_s2",
    "question_id": 3748,
    "function_name": "sortMatrix",
    "code": "class Solution:\n    def sortMatrix(self, grid: List[List[int]]) -> List[List[int]]:\n        n = len(grid)\n        c = defaultdict(list)\n        for i in range(n):\n            for j in range(n):\n                c[i - j].append(grid[i][j])\n        for k in c.keys():\n            if k >= 0:\n                c[k].sort()\n            else:\n                c[k].sort(reverse=True)\n        \n        for i in range(n):\n            for j in range(n):\n                f = i - j\n                grid[i][j] = c[f][-1]\n                c[f].pop()\n        \n        return grid",
    "input": "sortMatrix(grid=[[1,7,3],[9,8,2],[4,5,6]])",
    "output": "[[8, 2, 3], [9, 6, 7], [4, 5, 1]]",
    "correct_condition": "sortMatrix(grid=[[1,7,3],[9,8,2],[4,5,6]]) == [[8, 2, 3], [9, 6, 7], [4, 5, 1]]",
    "contest_id": "weekly-contest-436",
    "contest_date": "2025-02-09T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 20,
      "coverage": null
    },
    "submission_id": 1536461192
  },
  {
    "id": "contest436_q3760_s0",
    "question_id": 3760,
    "function_name": "assignElements",
    "code": "from collections import defaultdict\n\nclass Solution:\n    def assignElements(self, groups: List[int], elements: List[int]) -> List[int]:\n        s = set()\n        dic = defaultdict(int)\n        for i, e in enumerate(elements):\n            if e in s:\n                continue\n            t = 1\n            while e * t <= 100000:\n                if e * t not in dic:\n                    dic[e * t] = i\n                t += 1\n            s.add(e)\n        res = []\n        for g in groups:\n            if g in dic:\n                res.append(dic[g])\n            else:\n                res.append(-1)\n        return res\n\n        \n        \n        ",
    "input": "assignElements(groups=[8,4,3,2,4], elements=[4,2])",
    "output": "[0, 0, -1, 1, 0]",
    "correct_condition": "assignElements(groups=[8,4,3,2,4], elements=[4,2]) == [0, 0, -1, 1, 0]",
    "contest_id": "weekly-contest-436",
    "contest_date": "2025-02-09T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 26,
      "coverage": null
    },
    "submission_id": 1536410003
  },
  {
    "id": "contest436_q3760_s1",
    "question_id": 3760,
    "function_name": "assignElements",
    "code": "class Solution:\n    def assignElements(self, groups: List[int], elements: List[int]) -> List[int]:\n        \n        res = [-1]*len(groups)\n        \n        max_value = max(groups)\n        \n        \n        mapper = collections.defaultdict(list)\n        \n        for i,x in enumerate(groups):\n            mapper[x].append(i)\n        \n        seen = set()\n        for j in range(len(elements)):\n            if elements[j] in seen:\n                continue\n            seen.add(elements[j])\n            curr = elements[j]\n            increment = elements[j]\n            while curr <= max_value:\n                if curr in mapper:\n                    while mapper[curr]:\n                        res[mapper[curr].pop()] = j\n                curr += increment\n        return res",
    "input": "assignElements(groups=[8,4,3,2,4], elements=[4,2])",
    "output": "[0, 0, -1, 1, 0]",
    "correct_condition": "assignElements(groups=[8,4,3,2,4], elements=[4,2]) == [0, 0, -1, 1, 0]",
    "contest_id": "weekly-contest-436",
    "contest_date": "2025-02-09T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 26,
      "coverage": null
    },
    "submission_id": 1536400600
  },
  {
    "id": "contest436_q3760_s2",
    "question_id": 3760,
    "function_name": "assignElements",
    "code": "class Solution:\n    def assignElements(self, groups: List[int], elements: List[int]) -> List[int]:\n        seen = set()\n        T = max(groups)\n        pre = [-1] * (T + 1)\n        for u, e in enumerate(elements):\n            if e in seen:\n                continue\n            seen.add(e)\n            i = e\n            while i <= T:\n                if pre[i] == -1:\n                    pre[i] = u\n                i += e\n        \n        ans = list()\n        for o in groups:\n            ans.append(pre[o])\n        return ans",
    "input": "assignElements(groups=[8,4,3,2,4], elements=[4,2])",
    "output": "[0, 0, -1, 1, 0]",
    "correct_condition": "assignElements(groups=[8,4,3,2,4], elements=[4,2]) == [0, 0, -1, 1, 0]",
    "contest_id": "weekly-contest-436",
    "contest_date": "2025-02-09T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 19,
      "coverage": null
    },
    "submission_id": 1536457071
  },
  {
    "id": "contest436_q3696_s0",
    "question_id": 3696,
    "function_name": "countSubstrings",
    "code": "class Solution:\n    def countSubstrings(self, s: str) -> int:\n        n = len(s)\n        res = 0\n        \n        mod3 = [1, 0, 0]\n        sum3 = 0\n    \n        mod9 = [1] + [0] * 8\n        sum9 = 0\n    \n        mod7 = [1] + [0] * 6\n        sum7 = 0\n        \n        pow5 = 1\n    \n        for i, c in enumerate(s):\n            d = int(c)\n            sum3 = (sum3 + d) % 3\n            sum9 = (sum9 + d) % 9\n            sum7 = (sum7 * 10 + d) % 7\n            R = (sum7 * pow5) % 7\n    \n            if c in '125':\n                res += (i + 1)\n            elif c in '36':\n                res += mod3[sum3]\n            elif c == '9':\n                res += mod9[sum9]\n            elif c == '4':\n                if i == 0:\n                    res += 1\n                else:\n                    v = int(s[i - 1]) * 10 + d\n                    if v % 4 == 0:\n                        res += (i + 1)\n                    else:\n                        res += 1\n            elif c == '8':\n                if i == 0:\n                    res += 1\n                elif i == 1:\n                    v = int(s[i - 1]) * 10 + d\n                    if v % 8 == 0:\n                        res += 2\n                    else:\n                        res += 1\n                else:\n                    v1 = int(s[i - 1]) * 10 + d\n                    v2 = int(s[i - 2]) * 100 + int(s[i - 1]) * 10 + d\n                    add_two = 1 if v1 % 8 == 0 else 0\n                    add_three = (i - 1) if v2 % 8 == 0 else 0\n                    res += 1 + add_two + add_three\n    \n            if c == '7':\n                res += mod7[R]\n    \n            mod3[sum3] += 1\n            mod9[sum9] += 1\n            mod7[R] += 1\n    \n            pow5 = (pow5 * 5) % 7\n            # print(res)\n    \n        return res",
    "input": "countSubstrings(s=\"12936\")",
    "output": "11",
    "correct_condition": "countSubstrings(s=\"12936\") == 11",
    "contest_id": "weekly-contest-436",
    "contest_date": "2025-02-09T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 65,
      "coverage": null
    },
    "submission_id": 1536442634
  },
  {
    "id": "contest436_q3696_s1",
    "question_id": 3696,
    "function_name": "countSubstrings",
    "code": "class Solution:\n    def countSubstrings(self, s: str) -> int:\n        debug = False\n        ans = 0\n\n        hash_table_3 = collections.defaultdict(int)\n        hash_table_3[0] += 1\n        hash_table_9 = collections.defaultdict(int)\n        hash_table_9[0] += 1\n\n        digit_sum_3 = 0\n        digit_sum_9 = 0\n\n        for i,char in enumerate(s):\n            digit_sum_3 += int(char)\n            digit_sum_3 = digit_sum_3%3\n\n\n            digit_sum_9 += int(char)\n            digit_sum_9 = digit_sum_9%9\n\n\n            if char == \"1\":\n                ans += (i+1)\n            elif char == \"2\":\n                ans += (i+1)\n            elif char == \"3\":\n                ans += hash_table_3[digit_sum_3]\n            elif char == \"4\":\n                if i == 0:\n                    ans += 1\n                else:\n                    Z = int(s[i-1])*10 + int(s[i])\n                    if Z%4 == 0:\n                        ans += (i+1)\n                    else:\n                        ans += 1\n            elif char == \"5\":\n                ans += (i+1)\n\n            elif char == \"6\":\n                ans += hash_table_3[digit_sum_3]\n            elif char == \"8\":\n                ans += 1\n\n                if i-1 >= 0:\n                    Z = int(s[i-1])*10 + int(s[i])\n                    if Z%8 == 0:\n                        ans += 1\n                if i-2 >= 0:\n                    Z = int(s[i-2])*100 + int(s[i-1])*10 + int(s[i])\n                    if Z%8 == 0:\n                        ans += (i-2+1)\n            elif char == \"9\":\n                ans += hash_table_9[digit_sum_9]\n            #print(ans,digit_sum_9,hash_table_9,'3_data',digit_sum_3,hash_table_3)\n\n            hash_table_3[digit_sum_3] += 1\n            hash_table_9[digit_sum_9] += 1\n\n        curr_sums = [0]*10\n        curr_sums[0] = 1\n\n        curr = 0\n        #ans = 0\n        for i in range(len(s)):\n            curr = (10*curr + int(s[i]))%7\n            new_curr_sums = [0]*10\n            for j in range(len(curr_sums)):\n                new_curr_sums[(j*10)%7] += curr_sums[j]\n            curr_sums = list(new_curr_sums)\n\n            if s[i] == \"7\":\n                ans += curr_sums[curr]\n            curr_sums[curr] += 1\n\n        return ans\n                ",
    "input": "countSubstrings(s=\"12936\")",
    "output": "11",
    "correct_condition": "countSubstrings(s=\"12936\") == 11",
    "contest_id": "weekly-contest-436",
    "contest_date": "2025-02-09T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 78,
      "coverage": null
    },
    "submission_id": 1536459645
  },
  {
    "id": "contest436_q3696_s2",
    "question_id": 3696,
    "function_name": "countSubstrings",
    "code": "class Solution:\n    def countSubstrings(self, s: str) -> int:\n        ans = 0\n        dp = [[0] * i for i in range(10)]\n        for i in range(1, 10):\n            dp[i][0] = 1\n        for c in s:\n            num = int(c)\n            newdp = [[0] * i for i in range(10)]\n            for i in range(1, 10):\n                for j in range(i):\n                    newdp[i][(j * 10 + num) % i] += dp[i][j]\n            if num != 0:\n                ans += newdp[num][0]\n            for i in range(1, 10):\n                newdp[i][0] += 1\n            dp = newdp\n        return ans\n        ",
    "input": "countSubstrings(s=\"12936\")",
    "output": "11",
    "correct_condition": "countSubstrings(s=\"12936\") == 11",
    "contest_id": "weekly-contest-436",
    "contest_date": "2025-02-09T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 19,
      "coverage": null
    },
    "submission_id": 1536441757
  },
  {
    "id": "contest436_q3762_s0",
    "question_id": 3762,
    "function_name": "maxScore",
    "code": "class Solution:\n    def maxScore(self, points: List[int], m: int) -> int:\n        n = len(points)\n\n        def check(threshold):\n            needs = [0] * n\n            for i in range(n):\n                if threshold == 0:\n                    needs[i] = 0\n                else:\n                    needs[i] = (threshold - 1) // points[i] + 1\n            # print(threshold)\n            # print(needs)\n\n            count = 0\n            for i in range(n):\n                if needs[i] <= 0:\n                    if i != n - 1:\n                        count += 1\n                else:\n                    count += 2 * needs[i] - 1\n                    if i != n - 1:\n                        needs[i + 1] -= (needs[i] - 1)\n            \n            return count <= m\n    \n        left = 0\n        right = m * min(points)\n        while left < right:\n            mid = right - (right - left) // 2\n            if check(mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left\n\n    ",
    "input": "maxScore(points=[2,4], m=3)",
    "output": "4",
    "correct_condition": "maxScore(points=[2,4], m=3) == 4",
    "contest_id": "weekly-contest-436",
    "contest_date": "2025-02-09T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 37,
      "coverage": null
    },
    "submission_id": 1536475077
  },
  {
    "id": "contest436_q3762_s1",
    "question_id": 3762,
    "function_name": "maxScore",
    "code": "class Solution:\n    def maxScore(self, points: List[int], m: int) -> int:\n        \n        l = 1\n        r = 10**15\n        \n        \n        def check(target):\n            used = 0\n            \n            forward_count = 0\n            for i in range(len(points)):\n                needed = target-forward_count #-points[i]\n                if needed > 0 or i+1 < len(points):\n                    used += 1\n                    needed = target-forward_count -points[i]\n                \n                if needed > 0:\n                    G = (needed + points[i] - 1)//points[i]\n                    if i+1 < len(points):\n                        forward_count = G*points[i+1]\n                    else:\n                        forward_count = 0\n                    used += (G*2)\n                else:\n                    forward_count = 0\n                if used > m:\n                    return False\n               \n            return used <= m\n                \n            \n            \n        \n        best_ans = 0\n        while l <= r:\n            mid = l + (r-l)//2\n            #print(mid,check(mid))\n            if check(mid):\n                best_ans = mid\n                l = mid+1\n            else:\n                r = mid-1\n        return best_ans",
    "input": "maxScore(points=[2,4], m=3)",
    "output": "4",
    "correct_condition": "maxScore(points=[2,4], m=3) == 4",
    "contest_id": "weekly-contest-436",
    "contest_date": "2025-02-09T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 44,
      "coverage": null
    },
    "submission_id": 1536483553
  },
  {
    "id": "contest436_q3762_s2",
    "question_id": 3762,
    "function_name": "maxScore",
    "code": "class Solution:\n    def maxScore(self, points: List[int], m: int) -> int:\n        ans = 0\n        n = len(points)\n        left, right = 1, min(points) * (m // 2 + 1)\n\n        def ok(num):\n            index = 0\n            count = 1\n            needs = [ (num - 1) // points[i] + 1 for i in range(n)]\n            needs.append(0)\n            needs[0] -= 1\n            fake = 0\n            while index < n:\n                if needs[index] >= 0:\n                    count += fake\n                    fake = 0\n                # print(num, needs, count, index)\n                if needs[index] <= 0:\n                    index += 1\n                    if index < n:\n                        fake += 1\n                        needs[index] -= 1\n                else:\n                    count += needs[index] * 2\n                    needs[index + 1] -= needs[index]\n                    index += 1\n                    if index < n:\n                        fake += 1\n                        needs[index] -= 1\n            #print(num, needs, count, index)\n            return count <= m\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if ok(mid):\n                ans = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        return ans",
    "input": "maxScore(points=[2,4], m=3)",
    "output": "4",
    "correct_condition": "maxScore(points=[2,4], m=3) == 4",
    "contest_id": "weekly-contest-436",
    "contest_date": "2025-02-09T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 41,
      "coverage": null
    },
    "submission_id": 1536485434
  },
  {
    "id": "contest437_q3709_s0",
    "question_id": 3709,
    "function_name": "hasSpecialSubstring",
    "code": "class Solution:\n    def hasSpecialSubstring(self, s: str, k: int) -> bool:\n        n = len(s)\n        for i in range(n - k + 1):\n            if s[i:i+k] == s[i] * k:\n                if (i == 0 or s[i-1] != s[i]) and (i+k == n or s[i+k] != s[i]):\n                    return True\n        return False",
    "input": "hasSpecialSubstring(s=\"aaabaaa\", k=3)",
    "output": "True",
    "correct_condition": "hasSpecialSubstring(s=\"aaabaaa\", k=3) == True",
    "contest_id": "weekly-contest-437",
    "contest_date": "2025-02-16T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 8,
      "coverage": null
    },
    "submission_id": 1544505653
  },
  {
    "id": "contest437_q3709_s1",
    "question_id": 3709,
    "function_name": "hasSpecialSubstring",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def hasSpecialSubstring(self, s: str, k: int) -> bool:\n        n = len(s)\n        i = 0\n        while i < n:\n            j = i\n            while j < n and s[j] == s[i]:\n                j += 1\n            lenr = j - i\n            if lenr == k:\n                lft = (i == 0 or s[i - 1] != s[i])\n                rgt = (j == n or s[j] != s[i])\n                if lft and rgt:\n                    return True\n            i = j\n        return False",
    "input": "hasSpecialSubstring(s=\"aaabaaa\", k=3)",
    "output": "True",
    "correct_condition": "hasSpecialSubstring(s=\"aaabaaa\", k=3) == True",
    "contest_id": "weekly-contest-437",
    "contest_date": "2025-02-16T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 216,
      "coverage": null
    },
    "submission_id": 1544521510
  },
  {
    "id": "contest437_q3709_s2",
    "question_id": 3709,
    "function_name": "hasSpecialSubstring",
    "code": "class Solution:\n    def hasSpecialSubstring(self, s: str, k: int) -> bool:\n        n = len(s)\n        for i in range(n - k + 1):\n            c = s[i]\n            if all(s[i + j] == c for j in range(k)):\n                if (i == 0 or s[i - 1] != c) and (i + k == n or s[i + k] != c):\n                    return True\n        return False",
    "input": "hasSpecialSubstring(s=\"aaabaaa\", k=3)",
    "output": "True",
    "correct_condition": "hasSpecialSubstring(s=\"aaabaaa\", k=3) == True",
    "contest_id": "weekly-contest-437",
    "contest_date": "2025-02-16T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 9,
      "coverage": null
    },
    "submission_id": 1544547904
  },
  {
    "id": "contest437_q3779_s0",
    "question_id": 3779,
    "function_name": "maxWeight",
    "code": "class Solution:\n    def maxWeight(self, p: List[int]) -> int:\n        p.sort(reverse=True)\n        m = len(p) // 4\n        m1 = (m + 1) // 2\n        m2 = m - m1\n        s = sum(p[:m1])\n        for i in range(m2):\n            s += p[m1 + 2 * i + 1]\n        return s",
    "input": "maxWeight(p=[1,2,3,4,5,6,7,8])",
    "output": "14",
    "correct_condition": "maxWeight(p=[1,2,3,4,5,6,7,8]) == 14",
    "contest_id": "weekly-contest-437",
    "contest_date": "2025-02-16T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 10,
      "coverage": null
    },
    "submission_id": 1544509185
  },
  {
    "id": "contest437_q3779_s1",
    "question_id": 3779,
    "function_name": "maxWeight",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def maxWeight(self, pizzas: List[int]) -> int:\n        pizzas.sort()\n        n = len(pizzas)\n        m = n // 4\n        odds = (m + 1) // 2\n        evens = m // 2\n    \n        ans = 0\n        left = 0\n        right = n - 1\n    \n        for z in range(odds):\n            ans += pizzas[right]\n            right -= 1\n            left += 3\n    \n        for i in range(evens):\n            right -= 1\n            ans += pizzas[right]\n            right -= 1\n            left += 2\n        return ans\n",
    "input": "maxWeight(pizzas=[1,2,3,4,5,6,7,8])",
    "output": "14",
    "correct_condition": "maxWeight(pizzas=[1,2,3,4,5,6,7,8]) == 14",
    "contest_id": "weekly-contest-437",
    "contest_date": "2025-02-16T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 223,
      "coverage": null
    },
    "submission_id": 1544533933
  },
  {
    "id": "contest437_q3779_s2",
    "question_id": 3779,
    "function_name": "maxWeight",
    "code": "class Solution:\n    def maxWeight(self, pizzas: List[int]) -> int:\n        n = len(pizzas)\n        m = n // 4\n        if m == 0:\n            return sum(pizzas) \n\n        ocnt = (m + 1) // 2  \n        ecnt = m // 2       \n        d = sorted(pizzas, reverse=True)\n\n        tot = 0\n        p = 0  \n        for _ in range(ocnt):\n            if p < n:\n                tot += d[p]  \n                p += 1\n\n        for _ in range(ecnt):\n            if p < n:\n                p += 1 \n            if p < n:\n                tot += d[p]  \n                p += 1\n\n        return tot\n",
    "input": "maxWeight(pizzas=[1,2,3,4,5,6,7,8])",
    "output": "14",
    "correct_condition": "maxWeight(pizzas=[1,2,3,4,5,6,7,8]) == 14",
    "contest_id": "weekly-contest-437",
    "contest_date": "2025-02-16T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 26,
      "coverage": null
    },
    "submission_id": 1544559496
  },
  {
    "id": "contest437_q3771_s0",
    "question_id": 3771,
    "function_name": "maxSubstringLength",
    "code": "class Solution:\n    def maxSubstringLength(self, s: str, k: int) -> bool:\n        if k == 0:\n            return True\n        n = len(s)\n        v = {}\n        f = {}\n        l = {}\n        for i, c in enumerate(s):\n            v[c] = v.get(c, 0) + 1\n            if c not in f:\n                f[c] = i\n            l[c] = i\n        ar = []\n        for i in range(n):\n            if i != f[s[i]]:\n                continue\n            r = l[s[i]]\n            j = i\n            ok = True\n            while j <= r:\n                if f[s[j]] < i:\n                    ok = False\n                    break\n                r = max(r, l[s[j]])\n                j += 1\n            if ok and not (i == 0 and r == n - 1):\n                ar.append((i, r))\n        ar.sort(key=lambda x: x[1])\n        cnt = 0\n        end = -1\n        for a, b in ar:\n            if a > end:\n                cnt += 1\n                end = b\n        return cnt >= k",
    "input": "maxSubstringLength(s=\"abcdbaefab\", k=2)",
    "output": "True",
    "correct_condition": "maxSubstringLength(s=\"abcdbaefab\", k=2) == True",
    "contest_id": "weekly-contest-437",
    "contest_date": "2025-02-16T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 36,
      "coverage": null
    },
    "submission_id": 1544514997
  },
  {
    "id": "contest437_q3771_s1",
    "question_id": 3771,
    "function_name": "maxSubstringLength",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def maxSubstringLength(self, s: str, k: int) -> bool:\n        n = len(s)\n        if k == 0:\n            return True\n        \n        s1, s2 = [-1] * 26, [-1] * 26\n        for i in range(n):\n            c = ord(s[i]) - ord('a')\n            if s1[c] == -1:\n                s1[c] = i\n            s2[c] = i\n        \n        ls = []\n        for i in range(n):\n            if i != s1[ord(s[i]) - ord('a')]:\n                continue\n            j = s2[ord(s[i]) - ord('a')]\n            flag = True\n            for p in range(i, j + 1):\n                if s1[ord(s[p]) - ord('a')] < i:\n                    flag = False\n                    break\n                j = max(j, s2[ord(s[p]) - ord('a')])\n            if flag and not (i == 0 and j == n - 1):\n                ls.append((i, j))\n        \n        ls.sort()\n        \n        m = len(ls)\n        dp = [0] * (m + 1)\n        \n        for i in range(m - 1, -1, -1):\n            lo, hi, nidx = i + 1, m, m\n            while lo < hi:\n                mid = lo + (hi - lo) // 2\n                if ls[mid][0] > ls[i][1]:\n                    nidx = mid\n                    hi = mid\n                else:\n                    lo = mid + 1\n            dp[i] = max(1 + (dp[nidx] if nidx < m else 0), dp[i + 1])\n        return dp[0] >= k\n",
    "input": "maxSubstringLength(s=\"abcdbaefab\", k=2)",
    "output": "True",
    "correct_condition": "maxSubstringLength(s=\"abcdbaefab\", k=2) == True",
    "contest_id": "weekly-contest-437",
    "contest_date": "2025-02-16T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 243,
      "coverage": null
    },
    "submission_id": 1544529644
  },
  {
    "id": "contest437_q3771_s2",
    "question_id": 3771,
    "function_name": "maxSubstringLength",
    "code": "class Solution:\n    def maxSubstringLength(self, s: str, k: int) -> bool:\n        n = len(s)\n        if k == 0:\n            return True\n\n        first = [-1] * 26\n        last = [-1] * 26\n\n        for i in range(n):\n            c = ord(s[i]) - ord('a')\n            if first[c] == -1:\n                first[c] = i\n            last[c] = i\n\n        ivals = []\n        for i in range(n):\n            if i != first[ord(s[i]) - ord('a')]:\n                continue\n\n            end = last[ord(s[i]) - ord('a')]\n            found = True\n\n            for j in range(i, end + 1):\n                if first[ord(s[j]) - ord('a')] < i:\n                    found = False\n                    break\n                end = max(end, last[ord(s[j]) - ord('a')])\n\n            if found and not (i == 0 and end == n - 1):\n                ivals.append((i, end))\n\n        ivals.sort(key=lambda x: x[1])\n        cnt, prevs = 0, -1\n        for start, end in ivals:\n            if start > prevs:\n                cnt += 1\n                prevs = end\n\n        return cnt >= k\n\n",
    "input": "maxSubstringLength(s=\"abcdbaefab\", k=2)",
    "output": "True",
    "correct_condition": "maxSubstringLength(s=\"abcdbaefab\", k=2) == True",
    "contest_id": "weekly-contest-437",
    "contest_date": "2025-02-16T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 41,
      "coverage": null
    },
    "submission_id": 1544552595
  },
  {
    "id": "contest437_q3733_s0",
    "question_id": 3733,
    "function_name": "lenOfVDiagonal",
    "code": "class Solution:\n    def lenOfVDiagonal(self, g: List[List[int]]) -> int:\n        n = len(g)\n        m = len(g[0])\n        ds = [(1, 1), (1, -1), (-1, -1), (-1, 1)]\n        t = [1, 2, 3, 0]\n        nx = [1, 2, 1]\n        ex = [1, 2, 0]\n        dp = [[[[0] * m for _ in range(n)] for _ in range(3)] for _ in range(4)]\n        for i, (a, b) in enumerate(ds):\n            rr = range(n - 1, -1, -1) if a == 1 else range(0, n)\n            cc = range(m - 1, -1, -1) if b == 1 else range(0, m)\n            for r in rr:\n                for c in cc:\n                    for s in range(3):\n                        if g[r][c] != ex[s]:\n                            dp[i][s][r][c] = 0\n                        else:\n                            nr = r + a\n                            nc = c + b\n                            if 0 <= nr < n and 0 <= nc < m:\n                                dp[i][s][r][c] = 1 + dp[i][nx[s]][nr][nc]\n                            else:\n                                dp[i][s][r][c] = 1\n        ed = [[[[0] * m for _ in range(n)] for _ in range(3)] for _ in range(4)]\n        for i, (a, b) in enumerate(ds):\n            rr = range(0, n) if a == 1 else range(n - 1, -1, -1)\n            cc = range(0, m) if b == 1 else range(m - 1, -1, -1)\n            for r in rr:\n                for c in cc:\n                    for s in range(3):\n                        if g[r][c] != ex[s]:\n                            ed[i][s][r][c] = 0\n                        else:\n                            pr = r - a\n                            pc = c - b\n                            if s == 0:\n                                ed[i][s][r][c] = 1\n                            elif 0 <= pr < n and 0 <= pc < m:\n                                if s == 1:\n                                    v = 0\n                                    if ed[i][0][pr][pc]:\n                                        v = ed[i][0][pr][pc]\n                                    if ed[i][2][pr][pc] > v:\n                                        v = ed[i][2][pr][pc]\n                                    ed[i][s][r][c] = v + 1 if v else 0\n                                else:\n                                    ed[i][s][r][c] = ed[i][1][pr][pc] + 1 if ed[i][1][pr][pc] else 0\n                            else:\n                                ed[i][s][r][c] = 0\n        cn = 0\n        for i in range(4):\n            for r in range(n):\n                for c in range(m):\n                    if dp[i][0][r][c] > cn: cn = dp[i][0][r][c]\n        for i in range(4):\n            a, b = ds[t[i]]\n            for r in range(n):\n                for c in range(m):\n                    for s in (1, 2):\n                        L = ed[i][s][r][c]\n                        if L >= 2:\n                            nr = r + a\n                            nc = c + b\n                            if 0 <= nr < n and 0 <= nc < m:\n                                ar = L + dp[t[i]][nx[s]][nr][nc]\n                                if ar > cn: cn = ar\n        return cn\n",
    "input": "lenOfVDiagonal(g=[[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]])",
    "output": "5",
    "correct_condition": "lenOfVDiagonal(g=[[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]) == 5",
    "contest_id": "weekly-contest-437",
    "contest_date": "2025-02-16T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 68,
      "coverage": null
    },
    "submission_id": 1544524131
  },
  {
    "id": "contest437_q3733_s1",
    "question_id": 3733,
    "function_name": "lenOfVDiagonal",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\n\nclass Solution:\n    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        dirs = [(1, 1), (-1, -1), (1, -1), (-1, 1)]\n        mps = {0: 2, 2: 1, 1: 3, 3: 0}\n        dp = [[[[0,0] for i in range(m)] for j in range(n)] for k in range(4)]\n        \n        for d in range(4):\n            dr, dc = dirs[d]\n            if d == 0:\n                r1 = range(n-1, -1, -1)\n                r2 = range(m-1, -1, -1)\n            elif d == 1:\n                r1 = range(n)\n                r2 = range(m)\n            elif d == 2:\n                r1 = range(n-1, -1, -1)\n                r2 = range(m)\n            elif d == 3:\n                r1 = range(n)\n                r2 = range(m-1, -1, -1)\n            \n            for i in r1:\n                for j in r2:\n                    for p in (0, 1):\n                        now = 2 if p == 1 else 0\n                        if grid[i][j] == now:\n                            ni, nj = i + dr, j + dc\n                            add = 0\n                            if 0 <= ni < n and 0 <= nj < m:\n                                add = dp[d][ni][nj][1-p]\n                            dp[d][i][j][p] = 1 + add\n                        else:\n                            dp[d][i][j][p] = 0\n        \n        ans = 0\n        \n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] != 1:\n                    continue\n                for d in range(4):\n                    path = [(i, j)]\n                    clen = 1 \n                    r, c = i, j\n                    stp = 0  \n                    while True:\n                        nr = r + dirs[d][0]\n                        nc = c + dirs[d][1]\n                        nxt = stp + 1\n                        now = 2 if nxt % 2 == 1 else 0\n                        if not (0 <= nr < n and 0 <= nc < m):\n                            break\n                        if grid[nr][nc] != now:\n                            break\n                        path.append((nr, nc))\n                        clen += 1\n                        r, c = nr, nc\n                        stp += 1\n                    \n                    ans = max(ans, clen)\n                    ndir = mps[d] \n                    dr2, dc2 = dirs[ndir]\n\n                    for t in range(1, len(path)):\n                        tr, tc = path[t]\n\n                        takes = (t + 1) % 2\n                        nr = tr + dr2\n                        nc = tc + dc2\n                        two = 0\n                        if 0 <= nr < n and 0 <= nc < m:\n                            two = dp[ndir][nr][nc][takes]\n                        tot = t + 1 + two \n                        ans = max(ans, tot)\n        \n        return ans\n",
    "input": "lenOfVDiagonal(grid=[[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]])",
    "output": "5",
    "correct_condition": "lenOfVDiagonal(grid=[[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]) == 5",
    "contest_id": "weekly-contest-437",
    "contest_date": "2025-02-16T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 278,
      "coverage": null
    },
    "submission_id": 1544518419
  },
  {
    "id": "contest437_q3733_s2",
    "question_id": 3733,
    "function_name": "lenOfVDiagonal",
    "code": "class Solution:\n    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        dirs = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\n        dp = [[[[0] * m for i in range(n)] for j in range(3)] for k in range(4)]\n        \n        for d in range(4):\n            dr, dc = dirs[d]\n            si, ei, sti = (n - 1, -1, -1) if dr == 1 else (0, n, 1)\n            sj, ej, stj = (m - 1, -1, -1) if dc == 1 else (0, m, 1)\n            \n            for i in range(si, ei, sti):\n                for j in range(sj, ej, stj):\n                    for s in range(3):\n                        exp = 1 if s == 0 else (2 if s == 1 else 0)\n                        if grid[i][j] == exp:\n                            ni, nj = i + dr, j + dc\n                            ns = 1 if s == 0 else (2 if s == 1 else 1)\n                            plus = dp[d][ns][ni][nj] if 0 <= ni < n and 0 <= nj < m else 0\n                            dp[d][s][i][j] = 1 + plus\n                        else:\n                            dp[d][s][i][j] = 0\n        \n        ans = 0\n        for d in range(4):\n            for i in range(n):\n                for j in range(m):\n                    ans = max(ans, dp[d][0][i][j])\n        \n        for d in range(4):\n            dr, dc = dirs[d]\n            dr2, dc2 = dc, -dr\n            d2 = dirs.index((dr2, dc2))\n            \n            for i in range(n):\n                for j in range(m):\n                    maxs = dp[d][0][i][j]\n                    if maxs <= 0:\n                        continue\n                    \n                    for L in range(1, maxs + 1):\n                        ts, tx = i + (L - 1) * dr, j + (L - 1) * dc\n                        nst = 1 if L % 2 == 1 else 2\n                        nr, nc = ts + dr2, tx + dc2\n                        ext = dp[d2][nst][nr][nc] if 0 <= nr < n and 0 <= nc < m else 0\n                        ans = max(ans, L + ext)\n        \n        return ans\n",
    "input": "lenOfVDiagonal(grid=[[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]])",
    "output": "5",
    "correct_condition": "lenOfVDiagonal(grid=[[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]) == 5",
    "contest_id": "weekly-contest-437",
    "contest_date": "2025-02-16T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 48,
      "coverage": null
    },
    "submission_id": 1544546030
  },
  {
    "id": "contest438_q3768_s0",
    "question_id": 3768,
    "function_name": "hasSameDigits",
    "code": "class Solution:\n    def hasSameDigits(self, s: str) -> bool:\n        n = len(s)\n        if n == 2:\n            return (s[0] == s[1])\n        \n        digits = list(map(int, s))\n        N = n - 2\n    \n        binom_mod5 = [[0]*5 for _ in range(5)]\n        for i in range(5):\n            binom_mod5[i][0] = 1\n            for j in range(1, i+1):\n                from math import comb\n                binom_mod5[i][j] = comb(i, j) % 5\n        \n        combine_map = {}\n        for x in range(10):\n            pair = (x % 2, x % 5)\n            combine_map[pair] = x\n        \n        def binom_mod2(n, k):\n            return 1 if (k & ~n) == 0 else 0\n        \n        def binom_mod5_func(n, k):\n            res = 1\n            while n > 0 or k > 0:\n                n5 = n % 5\n                k5 = k % 5\n                if k5 > n5:\n                    return 0\n                res = (res * binom_mod5[n5][k5]) % 5\n                n //= 5\n                k //= 5\n            return res\n        \n        def binom_mod10(n, k):\n            b2 = binom_mod2(n, k)\n            b5 = binom_mod5_func(n, k)\n            return combine_map[(b2, b5)]\n        \n        binom_table = [0]*(N+1)\n        for k in range(N+1):\n            binom_table[k] = binom_mod10(N, k)\n        d0 = 0\n        d1 = 0\n        for m in range(N+1):\n            c = binom_table[m]\n            d0 = (d0 + digits[m]*c) % 10\n            d1 = (d1 + digits[m+1]*c) % 10    \n        return (d0 == d1)\n",
    "input": "hasSameDigits(s=\"3902\")",
    "output": "True",
    "correct_condition": "hasSameDigits(s=\"3902\") == True",
    "contest_id": "weekly-contest-438",
    "contest_date": "2025-02-23T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 51,
      "coverage": null
    },
    "submission_id": 1552284205
  },
  {
    "id": "contest438_q3768_s1",
    "question_id": 3768,
    "function_name": "hasSameDigits",
    "code": "class Solution:\n    def hasSameDigits(self, s: str) -> bool:\n        while len(s)!=2:\n            res=\"\"\n            for i in range(1,len(s)):\n                res+=str(int(s[i])+int(s[i-1]))[-1]\n            s=res\n        return len(set(s))==1",
    "input": "hasSameDigits(s=\"3902\")",
    "output": "True",
    "correct_condition": "hasSameDigits(s=\"3902\") == True",
    "contest_id": "weekly-contest-438",
    "contest_date": "2025-02-23T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 8,
      "coverage": null
    },
    "submission_id": 1552268304
  },
  {
    "id": "contest438_q3768_s2",
    "question_id": 3768,
    "function_name": "hasSameDigits",
    "code": "class Solution:\n    def hasSameDigits(self, s: str) -> bool:\n        while len(s) > 2:\n            s = \"\".join(\n                str((int(s[i]) + int(s[i + 1])) % 10) for i in range(len(s) - 1)\n            )\n        return s[0] == s[1]\n",
    "input": "hasSameDigits(s=\"3902\")",
    "output": "True",
    "correct_condition": "hasSameDigits(s=\"3902\") == True",
    "contest_id": "weekly-contest-438",
    "contest_date": "2025-02-23T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 7,
      "coverage": null
    },
    "submission_id": 1552267009
  },
  {
    "id": "contest438_q3764_s0",
    "question_id": 3764,
    "function_name": "maxSum",
    "code": "class Solution:\n    def maxSum(self, grid: List[List[int]], limits: List[int], k: int) -> int:\n        n, m = len(grid), len(grid[0])\n        \n        \n        sorted_rows = []\n        for i in range(n):\n            \n            row = [(val, j) for j, val in enumerate(grid[i])]\n            row.sort(reverse=True)\n            sorted_rows.append(row)\n        \n        \n        heap = []  \n        \n        for i in range(n):\n            if limits[i] > 0 and sorted_rows[i]:  \n                val, col = sorted_rows[i][0]\n                \n                heapq.heappush(heap, (-val, i, 0))  \n        \n        result = 0\n        count = 0\n        \n        \n        while heap and count < k:\n            val, row, idx = heapq.heappop(heap)\n            result += -val  \n            count += 1\n            \n            \n            if idx + 1 < len(sorted_rows[row]) and idx + 1 < limits[row]:\n                next_val, next_col = sorted_rows[row][idx + 1]\n                heapq.heappush(heap, (-next_val, row, idx + 1))\n        \n        return result",
    "input": "maxSum(grid=[[1,2],[3,4]], limits=[1,2], k=2)",
    "output": "7",
    "correct_condition": "maxSum(grid=[[1,2],[3,4]], limits=[1,2], k=2) == 7",
    "contest_id": "weekly-contest-438",
    "contest_date": "2025-02-23T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 36,
      "coverage": null
    },
    "submission_id": 1552280360
  },
  {
    "id": "contest438_q3764_s1",
    "question_id": 3764,
    "function_name": "maxSum",
    "code": "class Solution:\n    def maxSum(self, grid: List[List[int]], limits: List[int], k: int) -> int:\n        a = [(sorted(x,reverse=True)[:limits[i]]) for i,x in enumerate(grid)]\n        b=[]\n        for x in a:b.extend(x)\n        a=b.copy()\n        # print(a)\n        return sum(sorted(a,reverse=True)[:k])",
    "input": "maxSum(grid=[[1,2],[3,4]], limits=[1,2], k=2)",
    "output": "7",
    "correct_condition": "maxSum(grid=[[1,2],[3,4]], limits=[1,2], k=2) == 7",
    "contest_id": "weekly-contest-438",
    "contest_date": "2025-02-23T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 8,
      "coverage": null
    },
    "submission_id": 1552272249
  },
  {
    "id": "contest438_q3764_s2",
    "question_id": 3764,
    "function_name": "maxSum",
    "code": "class Solution:\n    def maxSum(self, grid: List[List[int]], limits: List[int], k: int) -> int:\n        arr = []\n\n        for i, r in enumerate(grid):\n            t = sorted(r, reverse=True)[:limits[i]]\n            arr += t\n\n        arr.sort(reverse=True)\n\n        ans = sum(arr[:k])\n\n        # print(arr)\n\n        return ans",
    "input": "maxSum(grid=[[1,2],[3,4]], limits=[1,2], k=2)",
    "output": "7",
    "correct_condition": "maxSum(grid=[[1,2],[3,4]], limits=[1,2], k=2) == 7",
    "contest_id": "weekly-contest-438",
    "contest_date": "2025-02-23T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 15,
      "coverage": null
    },
    "submission_id": 1552278791
  },
  {
    "id": "contest438_q3774_s0",
    "question_id": 3774,
    "function_name": "hasSameDigits",
    "code": "class Solution:\n    def hasSameDigits(self, s: str) -> bool:\n        n = len(s)\n        if n == 2:\n            return (s[0] == s[1])\n        \n        digits = list(map(int, s))\n        N = n - 2\n    \n        binom_mod5 = [[0]*5 for _ in range(5)]\n        for i in range(5):\n            binom_mod5[i][0] = 1\n            for j in range(1, i+1):\n                from math import comb\n                binom_mod5[i][j] = comb(i, j) % 5\n        \n        combine_map = {}\n        for x in range(10):\n            pair = (x % 2, x % 5)\n            combine_map[pair] = x\n        \n        def binom_mod2(n, k):\n            return 1 if (k & ~n) == 0 else 0\n        \n        def binom_mod5_func(n, k):\n            res = 1\n            while n > 0 or k > 0:\n                n5 = n % 5\n                k5 = k % 5\n                if k5 > n5:\n                    return 0\n                res = (res * binom_mod5[n5][k5]) % 5\n                n //= 5\n                k //= 5\n            return res\n        \n        def binom_mod10(n, k):\n            b2 = binom_mod2(n, k)\n            b5 = binom_mod5_func(n, k)\n            return combine_map[(b2, b5)]\n        \n        binom_table = [0]*(N+1)\n        for k in range(N+1):\n            binom_table[k] = binom_mod10(N, k)\n        d0 = 0\n        d1 = 0\n        for m in range(N+1):\n            c = binom_table[m]\n            d0 = (d0 + digits[m]*c) % 10\n            d1 = (d1 + digits[m+1]*c) % 10    \n        return (d0 == d1)\n",
    "input": "hasSameDigits(s=\"3902\")",
    "output": "True",
    "correct_condition": "hasSameDigits(s=\"3902\") == True",
    "contest_id": "weekly-contest-438",
    "contest_date": "2025-02-23T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 51,
      "coverage": null
    },
    "submission_id": 1552283804
  },
  {
    "id": "contest438_q3774_s1",
    "question_id": 3774,
    "function_name": "hasSameDigits",
    "code": "def c2(n, k):\n    while k > 0:\n        if (n & 1) < (k & 1):return 0\n        n >>= 1\n        k >>= 1\n    return 1\n\ndef c5(n, k):\n    t = [[1, 0, 0, 0, 0],[1, 1, 0, 0, 0],[1, 2, 1, 0, 0],[1, 3, 3, 1, 0],[1, 4, 1, 4, 1]]\n    r = 1\n    while n > 0 or k > 0:\n        ni, ki = n % 5, k % 5\n        if ki > ni: return 0\n        r = (r * t[ni][ki]) % 5\n        n //= 5\n        k //= 5\n    return r\n\nclass Solution:\n    def hasSameDigits(self, s: str) -> bool:\n        l, k = len(s), len(s) - 2\n        if k < 0:return True\n        c = [(5 * c2(k, j) + 6 * c5(k, j)) % 10 for j in range(k + 1)]\n        a, b = 0, 0\n        for j in range(l):\n            d = int(s[j])\n            if j <= k: a=(a + d * c[j])%10\n            if j >= 1 and (j - 1) <= k:b=(b + d * c[j - 1])%10\n        return a==b",
    "input": "hasSameDigits(s=\"3902\")",
    "output": "True",
    "correct_condition": "hasSameDigits(s=\"3902\") == True",
    "contest_id": "weekly-contest-438",
    "contest_date": "2025-02-23T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 29,
      "coverage": null
    },
    "submission_id": 1552283656
  },
  {
    "id": "contest438_q3774_s2",
    "question_id": 3774,
    "function_name": "hasSameDigits",
    "code": "class Solution:\n    def hasSameDigits(self, s: str) -> bool:\n        arr = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 1, 4, 1]]\n\n        def c2(n, k):\n            return 1 if (n & k) == k else 0\n\n        def c5(n, k):\n            if k > n:\n                return 0\n\n            if n < 5:\n                return arr[n][k]\n\n            if k % 5 > n % 5:\n                return 0\n\n            return (arr[n % 5][k % 5] * c5(n // 5, k // 5)) % 5\n\n        def check(c2, c5):\n            return c5 if (c5 % 2) == c2 else c5 + 5\n\n        size = len(s)\n        m = size - 2\n        digits = list(map(int, s))\n\n        x = 0\n        y = 0\n\n        for j in range(m + 1):\n            r2 = c2(m, j)\n            r5 = c5(m, j)\n            f = check(r2, r5)\n            x = (x + f * digits[j]) % 10\n            y = (y + f * digits[j + 1]) % 10\n\n        return x == y",
    "input": "hasSameDigits(s=\"3902\")",
    "output": "True",
    "correct_condition": "hasSameDigits(s=\"3902\") == True",
    "contest_id": "weekly-contest-438",
    "contest_date": "2025-02-23T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 37,
      "coverage": null
    },
    "submission_id": 1552295122
  },
  {
    "id": "contest438_q3781_s0",
    "question_id": 3781,
    "function_name": "maxDistance",
    "code": "import sys\nsys.setrecursionlimit(10**7)\n\ndef solve(side, points, k):\n    def boundary_param(x, y, side):\n        if x == 0:\n            return y\n        elif y == side:\n            return side + x\n        elif x == side:\n            return 2*side + (side - y)\n        else:\n            return 3*side + (side - x)\n\n    p = []\n    for x, y in points:\n        p.append(boundary_param(x, y, side))\n    p.sort()\n    n = len(p)\n    e = p + [val + 4*side for val in p]\n\n    def can_pick_start(i, d, next_idx):\n        count = 1\n        cur = i\n        limit = e[i] + 4*side - d\n        while count < k:\n            nxt = next_idx[cur]\n            if nxt >= i + n:\n                return False\n            if e[nxt] > limit:\n                return False\n            cur = nxt\n            count += 1\n        return True\n\n    def feasible(d):\n        next_idx = [0]*(2*n)\n        s = 0\n        for j in range(2*n):\n            while s < 2*n and e[s] < e[j] + d:\n                s += 1\n            next_idx[j] = s\n        for i in range(n):\n            if can_pick_start(i, d, next_idx):\n                return True\n        return False\n\n    left, right = 0, 2*side\n    while left < right:\n        mid = (left + right + 1) // 2\n        if feasible(mid):\n            left = mid\n        else:\n            right = mid - 1\n    return left\n    \nclass Solution:\n    def maxDistance(self, side: int, points: List[List[int]], k: int) -> int:\n        return solve(side, points, k)\n",
    "input": "maxDistance(side=2, points=[[0,2],[2,0],[2,2],[0,0]], k=4)",
    "output": "2",
    "correct_condition": "maxDistance(side=2, points=[[0,2],[2,0],[2,2],[0,0]], k=4) == 2",
    "contest_id": "weekly-contest-438",
    "contest_date": "2025-02-23T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 59,
      "coverage": null
    },
    "submission_id": 1552272304
  },
  {
    "id": "contest438_q3781_s1",
    "question_id": 3781,
    "function_name": "maxDistance",
    "code": "def manhattan(p1, p2):\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef is_valid(p, k, d):\n    for s in combinations(p, k):\n        if all(manhattan(p1, p2) >= d for i, p1 in enumerate(s) for p2 in s[:i]):\n            return True\n    return False\n\nclass Solution:\n    def maxDistance(self, s: int, p: List[List[int]], k: int) -> int:\n        peri = 4 * s\n        arr = []\n        for x, y in p:\n            if x == 0: pos = y\n            elif y == s: pos = s + x\n            elif x == s: pos = 3 * s - y\n            else: pos = 4 * s - x\n            arr.append(pos)\n        arr.sort()\n        lo, hi, ans = 0, 2 * s, 0\n        def is_pos(d):\n            if d == 0:\n                return True\n            n = len(arr)\n            for st in range(n):\n                sel = [arr[st]]\n                cur_v, cur_i = arr[st], st\n                for _ in range(k - 1):\n                    nxt_i = bisect_left(arr, cur_v + d, cur_i + 1, n)\n                    if nxt_i == n: break\n                    cur_v, cur_i = arr[nxt_i], nxt_i\n                    sel.append(cur_v)\n                if len(sel) >= k and peri - (sel[-1] - sel[0]) >= d: return True\n            return False\n    \n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if is_pos(mid): ans, lo = mid, mid + 1\n            else: hi = mid - 1\n        return ans\n",
    "input": "maxDistance(s=2, p=[[0,2],[2,0],[2,2],[0,0]], k=4)",
    "output": "2",
    "correct_condition": "maxDistance(s=2, p=[[0,2],[2,0],[2,2],[0,0]], k=4) == 2",
    "contest_id": "weekly-contest-438",
    "contest_date": "2025-02-23T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 41,
      "coverage": null
    },
    "submission_id": 1552295764
  },
  {
    "id": "contest438_q3781_s2",
    "question_id": 3781,
    "function_name": "maxDistance",
    "code": "class Solution:\n    def maxDistance(self, side: int, points: List[List[int]], k: int) -> int:\n        _side = side\n        arr = []\n\n        for x, y in points:\n            if y == 0:\n                arr.append(x)\n            elif x == _side:\n                arr.append(_side + y)\n            elif y == _side:\n                arr.append(3 * _side - x)\n            else:\n                arr.append(4 * _side - y)\n\n        arr.sort()\n\n        n = len(arr)\n\n        p = 4 * _side\n\n        _arr = arr + [v + p for v in arr]\n        # print(_arr)\n\n        def check(z: int) -> bool:\n            for i in range(n):\n                st = _arr[i]\n                count = 1\n                j = i\n\n                while count < k:\n                    u = bisect.bisect_left(_arr, _arr[j] + z, j + 1, i + n)\n                    # print(u)\n                    if u == i + n:\n                        break\n\n                    j = u\n                    count += 1\n\n                if count == k:\n                    if st + p - _arr[j] >= z:\n                        return True\n\n            return False\n\n        low = 0\n        high = 2 * _side + 1\n\n        while low < high:\n            mid = (low + high) // 2\n            if check(mid):\n                low = mid + 1\n            else:\n                high = mid\n\n        ans = low - 1\n        # print(ans)\n\n        return ans",
    "input": "maxDistance(side=2, points=[[0,2],[2,0],[2,2],[0,0]], k=4)",
    "output": "2",
    "correct_condition": "maxDistance(side=2, points=[[0,2],[2,0],[2,2],[0,0]], k=4) == 2",
    "contest_id": "weekly-contest-438",
    "contest_date": "2025-02-23T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 59,
      "coverage": null
    },
    "submission_id": 1552312689
  },
  {
    "id": "contest439_q3705_s0",
    "question_id": 3705,
    "function_name": "largestInteger",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def largestInteger(self, nums: List[int], k: int) -> int:\n        cnt = {}\n        n = len(nums)\n        for i in range(n - k + 1):\n            st = set(nums[i:i+k])\n            for num in st:\n                cnt[num] = cnt.get(num, 0) + 1\n        ans = -1\n        for num, count in cnt.items():\n            if count == 1:\n                ans = max(ans, num)\n        return ans\n",
    "input": "largestInteger(nums=[3,9,2,1,7], k=3)",
    "output": "7",
    "correct_condition": "largestInteger(nums=[3,9,2,1,7], k=3) == 7",
    "contest_id": "weekly-contest-439",
    "contest_date": "2025-03-02T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 213,
      "coverage": null
    },
    "submission_id": 1559834138
  },
  {
    "id": "contest439_q3705_s1",
    "question_id": 3705,
    "function_name": "largestInteger",
    "code": "class Solution:\n    def largestInteger(self, nums: List[int], k: int) -> int:\n        count = {}\n        for i in range(len(nums)-k+1):\n            n = set(nums[i:i+k])\n            for x in n:\n                count[x] = count.get(x,0)+1\n        seq = [x for x,v in count.items() if v == 1]\n        return max(seq) if len(seq)>0 else -1",
    "input": "largestInteger(nums=[3,9,2,1,7], k=3)",
    "output": "7",
    "correct_condition": "largestInteger(nums=[3,9,2,1,7], k=3) == 7",
    "contest_id": "weekly-contest-439",
    "contest_date": "2025-03-02T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 9,
      "coverage": null
    },
    "submission_id": 1559815348
  },
  {
    "id": "contest439_q3705_s2",
    "question_id": 3705,
    "function_name": "largestInteger",
    "code": "from collections import defaultdict\n\nclass Solution:\n    def largestInteger(self, nums: List[int], k: int) -> int:\n        freq = defaultdict(int)\n        n = len(nums)\n\n        for i in range(n - k + 1):\n            subarray = nums[i:i + k]\n            unique_elements = set(subarray)\n            for num in unique_elements:\n                freq[num] += 1\n\n        result = -1\n        for num, count in freq.items():\n            if count == 1:\n                result = max(result, num)\n\n        return result",
    "input": "largestInteger(nums=[3,9,2,1,7], k=3)",
    "output": "7",
    "correct_condition": "largestInteger(nums=[3,9,2,1,7], k=3) == 7",
    "contest_id": "weekly-contest-439",
    "contest_date": "2025-03-02T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 19,
      "coverage": null
    },
    "submission_id": 1559813970
  },
  {
    "id": "contest439_q3786_s1",
    "question_id": 3786,
    "function_name": "longestPalindromicSubsequence",
    "code": "class Solution:\n    def longestPalindromicSubsequence(self, s: str, k: int) -> int:\n        from functools import lru_cache\n        \n        def cost(a: str, b: str) -> int:\n            diff = abs(ord(a) - ord(b))\n            return min(diff, 26 - diff)\n        \n        n = len(s)\n        \n        @lru_cache(maxsize=None)\n        def dp(i: int, j: int, t: int) -> int:\n            if i > j:\n                return 0\n            if i == j:\n                return 1\n            best = max(dp(i+1, j, t), dp(i, j-1, t))\n            c = cost(s[i], s[j])\n            if c <= t:\n                best = max(best, 2 + dp(i+1, j-1, t-c))\n            return best\n        \n        return dp(0, n-1, k)",
    "input": "longestPalindromicSubsequence(s=\"abced\", k=2)",
    "output": "3",
    "correct_condition": "longestPalindromicSubsequence(s=\"abced\", k=2) == 3",
    "contest_id": "weekly-contest-439",
    "contest_date": "2025-03-02T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 23,
      "coverage": null
    },
    "submission_id": 1559826888
  },
  {
    "id": "contest439_q3786_s2",
    "question_id": 3786,
    "function_name": "longestPalindromicSubsequence",
    "code": "class Solution:\n    def longestPalindromicSubsequence(self, s: str, k: int) -> int:\n        n = len(s)\n        d = lambda x,y:min((x-y)%26,(y-x)%26)\n        \n        pc = [[0]*26 for _ in range(26)]\n        \n        for x in range(26):\n            for y in range(26):\n                pc[x][y] = min(d(x,c)+d(y,c) for c in range(26))\n                \n        dp = [[[0]*(k+1) for _ in range(n)] for _ in range(n)]\n        \n        for i in range(n):\n            for t in range(k+1):\n                dp[i][i][t] = 1\n                \n        for l in range(2,n+1):\n            for i in range(n-l+1):\n                j = i + l - 1\n                for t in range(k+1):\n                    dp[i][j][t] = max(dp[i+1][j][t],dp[i][j-1][t])\n                    c = pc[ord(s[i])-97][ord(s[j])-97]\n                    if c <= t:\n                        dp[i][j][t] = max(dp[i][j][t],(2 if i<j else 1)+dp[i+1][j-1][t-c])\n                        \n        return dp[0][n-1][k]",
    "input": "longestPalindromicSubsequence(s=\"abced\", k=2)",
    "output": "3",
    "correct_condition": "longestPalindromicSubsequence(s=\"abced\", k=2) == 3",
    "contest_id": "weekly-contest-439",
    "contest_date": "2025-03-02T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 27,
      "coverage": null
    },
    "submission_id": 1559817253
  },
  {
    "id": "contest439_q3722_s0",
    "question_id": 3722,
    "function_name": "maxSum",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def maxSum(self, nums: list[int], k: int, m: int) -> int:\n        n = len(nums)\n        pref = [0] * (n + 1)\n        for i in range(n):\n            pref[i+1] = pref[i] + nums[i]\n        dp = [[-10**18] * (n + 1) for i in range(k + 1)]\n        for j in range(n + 1):\n            dp[0][j] = 0\n        for i in range(1, k + 1):\n            last = [-10**18] * (n + 1)\n            last[0] = dp[i-1][0] - pref[0]\n            for j in range(1, n + 1):\n                last[j] = max(last[j-1], dp[i-1][j] - pref[j])\n            for j in range(i * m, n + 1):\n                dp[i][j] = dp[i][j-1] if j > 0 else -10**18\n                dp[i][j] = max(dp[i][j], pref[j] + last[j - m])\n        return dp[k][n]\n\n",
    "input": "maxSum(nums=[1,2,-1,3,3,4], k=2, m=2)",
    "output": "13",
    "correct_condition": "maxSum(nums=[1,2,-1,3,3,4], k=2, m=2) == 13",
    "contest_id": "weekly-contest-439",
    "contest_date": "2025-03-02T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 219,
      "coverage": null
    },
    "submission_id": 1559837023
  },
  {
    "id": "contest439_q3722_s1",
    "question_id": 3722,
    "function_name": "maxSum",
    "code": "class Solution:\n    def maxSum(self, nums: List[int], k: int, m: int) -> int:\n        n = len(nums)\n        P = [0] * (n + 1)\n        for i in range(1, n + 1):\n            P[i] = P[i - 1] + nums[i - 1]\n        dp = [[float('-inf')] * (k + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 0\n        for j in range(1, k + 1):\n            best = float('-inf')\n            for i in range(j * m, n + 1):\n                best = max(best, dp[i - m][j - 1] - P[i - m])\n                dp[i][j] = max(dp[i - 1][j], P[i] + best)\n        return dp[n][k]\n        ",
    "input": "maxSum(nums=[1,2,-1,3,3,4], k=2, m=2)",
    "output": "13",
    "correct_condition": "maxSum(nums=[1,2,-1,3,3,4], k=2, m=2) == 13",
    "contest_id": "weekly-contest-439",
    "contest_date": "2025-03-02T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 16,
      "coverage": null
    },
    "submission_id": 1559833753
  },
  {
    "id": "contest439_q3722_s2",
    "question_id": 3722,
    "function_name": "maxSum",
    "code": "class Solution:\n    def maxSum(self, nums: List[int], k: int, m: int) -> int:\n        n = len(nums)\n        prefix = [0] * (n + 1)\n        \n        for i in range(1, n + 1):\n            prefix[i] = prefix[i - 1] + nums[i - 1]\n            \n        dp = [[float(\"-inf\")] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        \n        for i in range(1, n + 1):\n            dp[i][0] = 0\n            \n        for j in range(1, k + 1):\n            bestArr = [0] * (n + 1)\n            bestArr[0] = dp[0][j - 1] - prefix[0]\n            \n            for i in range(1, n + 1):\n                bestArr[i] = max(bestArr[i - 1], dp[i][j - 1] - prefix[i])\n                \n            for i in range(1, n + 1):\n                dp[i][j] = dp[i - 1][j]\n                if i >= m:\n                    cand = prefix[i] + bestArr[i - m]\n                    dp[i][j] = max(dp[i][j], cand)\n                    \n        return dp[n][k]",
    "input": "maxSum(nums=[1,2,-1,3,3,4], k=2, m=2)",
    "output": "13",
    "correct_condition": "maxSum(nums=[1,2,-1,3,3,4], k=2, m=2) == 13",
    "contest_id": "weekly-contest-439",
    "contest_date": "2025-03-02T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 28,
      "coverage": null
    },
    "submission_id": 1559828565
  },
  {
    "id": "contest439_q3770_s0",
    "question_id": 3770,
    "function_name": "generateString",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def generateString(self, str1: str, str2: str) -> str:\n        n, m, L = len(str1), len(str2), len(str1) + len(str2) - 1\n        ans = ['?'] * L\n        flag = [False] * L\n        \n        if not self.applys(str1, str2, ans, flag):\n            return \"\"\n        \n        self.fills(ans)\n        \n        if not self.applyv(str1, str2, ans, flag):\n            return \"\"\n        \n        if not self.answer(str1, str2, ans):\n            return \"\"\n        \n        return ''.join(ans)\n    \n    def applys(self, str1, str2, ans, flag):\n        n, m = len(str1), len(str2)\n        for i in range(n):\n            if str1[i] == 'T':\n                for j in range(m):\n                    pos = i + j\n                    if ans[pos] == '?':\n                        ans[pos] = str2[j]\n                        flag[pos] = True\n                    elif ans[pos] != str2[j]:\n                        return False\n        return True\n    \n    def fills(self, ans):\n        for i in range(len(ans)):\n            if ans[i] == '?':\n                ans[i] = 'a'\n    \n    def applyv(self, str1, str2, ans, flag):\n        n, m = len(str1), len(str2)\n        for i in range(n):\n            if str1[i] == 'F':\n                diff = any(ans[i + j] != str2[j] for j in range(m))\n                if not diff:\n                    ok = False\n                    for j in range(m - 1, -1, -1):\n                        pos = i + j\n                        if not flag[pos]:\n                            ps = ans[pos]\n                            z = 'b' if str2[j] == 'a' else 'a'\n                            if z <= ps:\n                                z = chr(ord(ps) + 1)\n                            ans[pos] = z\n                            ok = True\n                            break\n                    if not ok:\n                        return False\n        return True\n    \n    def answer(self, str1, str2, ans):\n        n, m = len(str1), len(str2)\n        for i in range(n):\n            if str1[i] == 'T':\n                if any(ans[i + j] != str2[j] for j in range(m)):\n                    return False\n        return True\n",
    "input": "generateString(str1=\"TFTF\", str2=\"ab\")",
    "output": "'ababa'",
    "correct_condition": "generateString(str1=\"TFTF\", str2=\"ab\") == 'ababa'",
    "contest_id": "weekly-contest-439",
    "contest_date": "2025-03-02T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 265,
      "coverage": null
    },
    "submission_id": 1559827825
  },
  {
    "id": "contest439_q3770_s1",
    "question_id": 3770,
    "function_name": "generateString",
    "code": "class Solution:\n    def generateString(self, str1: str, str2: str) -> str:\n        n, m = len(str1), len(str2)\n        L = n + m - 1\n        word = [None] * L\n        fixed = [False] * L\n\n        for i in range(n):\n            if str1[i] == 'T':\n                for j in range(m):\n                    pos = i + j\n                    if word[pos] is not None and word[pos] != str2[j]:\n                        return \"\"\n                    word[pos] = str2[j]\n                    fixed[pos] = True\n\n        for i in range(L):\n            if word[i] is None:\n                word[i] = 'a'\n\n        for i in range(n):\n            if str1[i] == 'F':\n                equal = True\n                for j in range(m):\n                    if word[i+j] != str2[j]:\n                        equal = False\n                        break\n                if equal:\n                    modified = False\n                    for pos in range(i + m - 1, i - 1, -1):\n                        if not fixed[pos]:\n                            word[pos] = 'b'\n                            modified = True\n                            break\n                    if not modified:\n                        return \"\"\n        return \"\".join(word)",
    "input": "generateString(str1=\"TFTF\", str2=\"ab\")",
    "output": "'ababa'",
    "correct_condition": "generateString(str1=\"TFTF\", str2=\"ab\") == 'ababa'",
    "contest_id": "weekly-contest-439",
    "contest_date": "2025-03-02T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 37,
      "coverage": null
    },
    "submission_id": 1559842202
  },
  {
    "id": "contest439_q3770_s2",
    "question_id": 3770,
    "function_name": "generateString",
    "code": "class Solution:\n    def generateString(self, str1: str, str2: str) -> str:\n        \n        n, m = len(str1), len(str2)\n        L = n + m - 1\n        res = [None] * L\n        free = [True] * L\n        \n        for i in range(n):\n            if str1[i] == 'T':\n                for j in range(m):\n                    pos = i + j\n                    c = str2[j]\n                    if res[pos] is None:\n                        res[pos] = c\n                        free[pos] = False\n                    elif res[pos] != c:\n                        return \"\"\n                        \n        for i in range(L):\n            if res[i] is None:\n                res[i] = 'a'\n                \n        for i in range(n):\n            if str1[i] == 'F':\n                eq = True\n                \n                for j in range(m):\n                    if res[i+j] != str2[j]:\n                        eq = False\n                        break\n                        \n                if eq:\n                    cand = -1\n                    for j in range(m):\n                        pos = i + j\n                        if free[pos]:\n                            cand = pos\n                    if cand == -1:\n                        return \"\"\n                    res[cand] = 'b'\n                    free[cand] = False\n                    \n        return \"\".join(res)",
    "input": "generateString(str1=\"TFTF\", str2=\"ab\")",
    "output": "'ababa'",
    "correct_condition": "generateString(str1=\"TFTF\", str2=\"ab\") == 'ababa'",
    "contest_id": "weekly-contest-439",
    "contest_date": "2025-03-02T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 44,
      "coverage": null
    },
    "submission_id": 1559848310
  },
  {
    "id": "contest440_q3790_s0",
    "question_id": 3790,
    "function_name": "numOfUnplacedFruits",
    "code": "class Solution:\n    def numOfUnplacedFruits(self, f: List[int], b: List[int]) -> int:\n        n = len(f)\n        u = [0]*n\n        c = 0\n        for x in f:\n            p = 0\n            for i in range(n):\n                if not u[i] and b[i] >= x:\n                    u[i] = 1\n                    p = 1\n                    break\n            if not p:\n                c += 1\n        return c\n",
    "input": "numOfUnplacedFruits(f=[4,2,5], b=[3,5,4])",
    "output": "1",
    "correct_condition": "numOfUnplacedFruits(f=[4,2,5], b=[3,5,4]) == 1",
    "contest_id": "weekly-contest-440",
    "contest_date": "2025-03-09T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 15,
      "coverage": null
    },
    "submission_id": 1567562189
  },
  {
    "id": "contest440_q3790_s1",
    "question_id": 3790,
    "function_name": "numOfUnplacedFruits",
    "code": "class Solution:\n    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:\n        n = len(fruits)\n        \n        usedBaskets = [False] * n\n        placedFruits = [False] * n\n        \n        for i in range(n):\n            fruitQty = fruits[i]\n            \n            leftmostBasket = -1\n            for j in range(n):\n                if not usedBaskets[j] and baskets[j] >= fruitQty:\n                    leftmostBasket = j\n                    break\n            \n            if leftmostBasket != -1:\n                placedFruits[i] = True\n                usedBaskets[leftmostBasket] = True\n        \n        unplacedCount = sum(1 for placed in placedFruits if not placed)\n        return unplacedCount",
    "input": "numOfUnplacedFruits(fruits=[4,2,5], baskets=[3,5,4])",
    "output": "1",
    "correct_condition": "numOfUnplacedFruits(fruits=[4,2,5], baskets=[3,5,4]) == 1",
    "contest_id": "weekly-contest-440",
    "contest_date": "2025-03-09T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 22,
      "coverage": null
    },
    "submission_id": 1567552337
  },
  {
    "id": "contest440_q3790_s2",
    "question_id": 3790,
    "function_name": "numOfUnplacedFruits",
    "code": "class Solution:\n    def numOfUnplacedFruits(self, a: List[int], b: List[int]) -> int:\n        n = len(a)\n        m = 1 << ((n - 1).bit_length())\n        \n        t = [-1] * (2 * m)\n        for i in range(n):\n            t[m + i] = b[i]\n            \n        for i in range(m - 1, 0, -1):\n            t[i] = max(t[2 * i], t[2 * i + 1])\n        def u(i, v):\n            i += m\n            t[i] = v\n            i //= 2\n            while i:\n                t[i] = max(t[2 * i], t[2 * i + 1])\n                i //= 2\n        def q(x):\n            if t[1] < x:\n                return -1\n            i = 1\n            while i < m:\n                i = 2 * i if t[2 * i] >= x else 2 * i + 1\n            return i - m if i - m < n else -1\n        ans = 0\n        for x in a:\n            i = q(x)\n            if i == -1:\n                ans += 1\n            else:\n                u(i, -1)\n        return ans",
    "input": "numOfUnplacedFruits(a=[4,2,5], b=[3,5,4])",
    "output": "1",
    "correct_condition": "numOfUnplacedFruits(a=[4,2,5], b=[3,5,4]) == 1",
    "contest_id": "weekly-contest-440",
    "contest_date": "2025-03-09T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 33,
      "coverage": null
    },
    "submission_id": 1567581598
  },
  {
    "id": "contest440_q3759_s0",
    "question_id": 3759,
    "function_name": "findMaxSum",
    "code": "class Solution:\n    def findMaxSum(self, a: List[int], b: List[int], k: int) -> List[int]:\n        import heapq\n        n=len(a)\n        L=[(a[i],b[i],i) for i in range(n)]\n        L.sort(key=lambda x:x[0])\n        r=[0]*n\n        h=[]\n        s=0\n        i=0\n        while i<n:\n            v=L[i][0]\n            j=i\n            while j<n and L[j][0]==v:\n                r[L[j][2]]=s\n                j+=1\n            for p in range(i,j):\n                y=L[p][1]\n                if len(h)<k:\n                    heapq.heappush(h,y)\n                    s+=y\n                elif y>h[0]:\n                    t=heapq.heapreplace(h,y)\n                    s+=y-t\n            i=j\n        return r\n",
    "input": "findMaxSum(a=[4,2,1,5,3], b=[10,20,30,40,50], k=2)",
    "output": "[80, 30, 0, 80, 50]",
    "correct_condition": "findMaxSum(a=[4,2,1,5,3], b=[10,20,30,40,50], k=2) == [80, 30, 0, 80, 50]",
    "contest_id": "weekly-contest-440",
    "contest_date": "2025-03-09T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 26,
      "coverage": null
    },
    "submission_id": 1567561194
  },
  {
    "id": "contest440_q3759_s1",
    "question_id": 3759,
    "function_name": "findMaxSum",
    "code": "import heapq\n\nclass Solution:\n    def findMaxSum(self, nums1, nums2, k):\n        n = len(nums1)\n        pairArr = []\n        i = 0\n        while i < n:\n            pairArr.append((nums1[i], nums2[i], i))\n            i += 1\n        pairArr.sort(key=lambda x: x[0])\n        ans = [0] * n\n        heap = []\n        currentSum = 0\n        i = 0\n        while i < n:\n            j = i\n            while j < n and pairArr[j][0] == pairArr[i][0]:\n                j += 1\n            p = i\n            while p < j:\n                origIdx = pairArr[p][2]\n                ans[origIdx] = currentSum\n                p += 1\n            p = i\n            while p < j:\n                val = pairArr[p][1]\n                heapq.heappush(heap, val)\n                currentSum += val\n                if len(heap) > k:\n                    rem = heapq.heappop(heap)\n                    currentSum -= rem\n                p += 1\n            i = j\n        return ans",
    "input": "findMaxSum(nums1=[4,2,1,5,3], nums2=[10,20,30,40,50], k=2)",
    "output": "[80, 30, 0, 80, 50]",
    "correct_condition": "findMaxSum(nums1=[4,2,1,5,3], nums2=[10,20,30,40,50], k=2) == [80, 30, 0, 80, 50]",
    "contest_id": "weekly-contest-440",
    "contest_date": "2025-03-09T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 35,
      "coverage": null
    },
    "submission_id": 1567558204
  },
  {
    "id": "contest440_q3759_s2",
    "question_id": 3759,
    "function_name": "findMaxSum",
    "code": "class Solution:\n    def findMaxSum(self, a: List[int], b: List[int], k: int) -> List[int]:\n        n = len(a)\n        P = sorted(zip(a, b, range(n)), key=lambda x: x[0])\n        R = [0] * n\n        h, s = [], 0\n        i = 0\n        while i < n:\n            j = i\n            while j < n and P[j][0] == P[i][0]:\n                R[P[j][2]] = s\n                j += 1\n            for _, y, _ in P[i:j]:\n                if len(h) < k:\n                    heapq.heappush(h, y)\n                    s += y\n                elif y > h[0]:\n                    s += y - h[0]\n                    heapq.heapreplace(h, y)\n            i = j\n        return R",
    "input": "findMaxSum(a=[4,2,1,5,3], b=[10,20,30,40,50], k=2)",
    "output": "[80, 30, 0, 80, 50]",
    "correct_condition": "findMaxSum(a=[4,2,1,5,3], b=[10,20,30,40,50], k=2) == [80, 30, 0, 80, 50]",
    "contest_id": "weekly-contest-440",
    "contest_date": "2025-03-09T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 21,
      "coverage": null
    },
    "submission_id": 1567577211
  },
  {
    "id": "contest440_q3791_s0",
    "question_id": 3791,
    "function_name": "numOfUnplacedFruits",
    "code": "class Solution:\n    def numOfUnplacedFruits(self, f: List[int], b: List[int]) -> int:\n        n = len(b)\n        s = 1\n        while s < n: s *= 2\n        t = [0]*(2*s)\n        for i in range(n): t[s+i] = b[i]\n        for i in range(s-1, 0, -1): t[i] = max(t[2*i], t[2*i+1])\n        c = 0\n        for x in f:\n            if t[1] < x:\n                c += 1\n            else:\n                i = 1\n                while i < s:\n                    if t[2*i] >= x:\n                        i = 2*i\n                    else:\n                        i = 2*i+1\n                j = i - s\n                t[i] = -1\n                i //= 2\n                while i:\n                    t[i] = max(t[2*i], t[2*i+1])\n                    i //= 2\n        return c\n",
    "input": "numOfUnplacedFruits(f=[4,2,5], b=[3,5,4])",
    "output": "1",
    "correct_condition": "numOfUnplacedFruits(f=[4,2,5], b=[3,5,4]) == 1",
    "contest_id": "weekly-contest-440",
    "contest_date": "2025-03-09T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 26,
      "coverage": null
    },
    "submission_id": 1567552448
  },
  {
    "id": "contest440_q3791_s1",
    "question_id": 3791,
    "function_name": "numOfUnplacedFruits",
    "code": "class Solution:\n    def numOfUnplacedFruits(self, fruits, baskets):\n        n = len(baskets)\n        treeSize = 1\n        while treeSize < n:\n            treeSize *= 2\n        tree = [0] * (2 * treeSize)\n        i = 0\n        while i < n:\n            tree[treeSize + i] = baskets[i]\n            i += 1\n        i = n\n        while i < treeSize:\n            tree[treeSize + i] = 0\n            i += 1\n        i = treeSize - 1\n        while i >= 1:\n            leftChild = tree[2 * i]\n            rightChild = tree[2 * i + 1]\n            if leftChild >= rightChild:\n                tree[i] = leftChild\n            else:\n                tree[i] = rightChild\n            i -= 1\n        def query(val):\n            if tree[1] < val:\n                return -1\n            idx = 1\n            while idx < treeSize:\n                leftIdx = 2 * idx\n                if tree[leftIdx] >= val:\n                    idx = leftIdx\n                else:\n                    idx = leftIdx + 1\n            return idx - treeSize\n        def update(pos, newVal):\n            idx = pos + treeSize\n            tree[idx] = newVal\n            idx //= 2\n            while idx >= 1:\n                leftVal = tree[2 * idx]\n                rightVal = tree[2 * idx + 1]\n                if leftVal >= rightVal:\n                    tree[idx] = leftVal\n                else:\n                    tree[idx] = rightVal\n                idx //= 2\n        unplaced = 0\n        i = 0\n        while i < len(fruits):\n            fVal = fruits[i]\n            pos = query(fVal)\n            if pos == -1:\n                unplaced += 1\n            else:\n                update(pos, 0)\n            i += 1\n        return unplaced",
    "input": "numOfUnplacedFruits(fruits=[4,2,5], baskets=[3,5,4])",
    "output": "1",
    "correct_condition": "numOfUnplacedFruits(fruits=[4,2,5], baskets=[3,5,4]) == 1",
    "contest_id": "weekly-contest-440",
    "contest_date": "2025-03-09T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 58,
      "coverage": null
    },
    "submission_id": 1567569757
  },
  {
    "id": "contest440_q3791_s2",
    "question_id": 3791,
    "function_name": "numOfUnplacedFruits",
    "code": "class Solution:\n    def numOfUnplacedFruits(self, a: List[int], b: List[int]) -> int:\n        n = len(a)\n        m = 1 << ((n - 1).bit_length())\n        \n        t = [-1] * (2 * m)\n        for i in range(n):\n            t[m + i] = b[i]\n            \n        for i in range(m - 1, 0, -1):\n            t[i] = max(t[2 * i], t[2 * i + 1])\n        def u(i, v):\n            i += m\n            t[i] = v\n            i //= 2\n            while i:\n                t[i] = max(t[2 * i], t[2 * i + 1])\n                i //= 2\n        def q(x):\n            if t[1] < x:\n                return -1\n            i = 1\n            while i < m:\n                i = 2 * i if t[2 * i] >= x else 2 * i + 1\n            return i - m if i - m < n else -1\n        ans = 0\n        for x in a:\n            i = q(x)\n            if i == -1:\n                ans += 1\n            else:\n                u(i, -1)\n        return ans",
    "input": "numOfUnplacedFruits(a=[4,2,5], b=[3,5,4])",
    "output": "1",
    "correct_condition": "numOfUnplacedFruits(a=[4,2,5], b=[3,5,4]) == 1",
    "contest_id": "weekly-contest-440",
    "contest_date": "2025-03-09T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 33,
      "coverage": null
    },
    "submission_id": 1567582045
  },
  {
    "id": "contest440_q3789_s0",
    "question_id": 3789,
    "function_name": "maxSubarrays",
    "code": "class Solution:\n    def maxSubarrays(self, n: int, r: List[List[int]]) -> int:\n        for i in range(len(r)):\n            a, b = r[i]\n            if a > b:\n                r[i] = [b, a]\n        M = [[] for _ in range(n+1)]\n        for a, b in r:\n            M[a].append(b)\n        for i in range(1, n+1):\n            M[i].sort()\n        D = [None]*(n+2)\n        D[n+1] = (n+1, 0, n+1)\n        for i in range(n, 0, -1):\n            d = {}\n            for v in M[i]:\n                d[v] = d.get(v, 0) + 1\n            x0, c0, y0 = D[i+1]\n            if c0 > 0:\n                d[x0] = d.get(x0, 0) + c0\n            if c0 == 1:\n                if y0 != x0:\n                    d[y0] = d.get(y0, 0) + 1\n            U = sorted(d.keys()) if d else [n+1]\n            x = U[0]\n            c = d[x] if d else 0\n            y = U[1] if len(U) > 1 else n+1\n            D[i] = (x, c, y)\n        A = 0\n        for i in range(1, n+1):\n            A += D[i][0] - i\n        d2 = {}\n        for i in range(1, n+1):\n            x, c, y = D[i]\n            if x != n+1 and c == 1:\n                if x not in d2:\n                    d2[x] = ([], [])\n                d2[x][0].append(i)\n                d2[x][1].append(y - x)\n        import bisect\n        for k in d2:\n            L, S = d2[k]\n            for i in range(1, len(S)):\n                S[i] += S[i-1]\n        m = 0\n        for a, b in r:\n            if b in d2:\n                i = bisect.bisect_right(d2[b][0], a)\n            else:\n                i = 0\n            s = d2[b][1][i-1] if i else 0\n            if s > m:\n                m = s\n        return A + m\n",
    "input": "maxSubarrays(n=4, r=[[2,3],[1,4]])",
    "output": "9",
    "correct_condition": "maxSubarrays(n=4, r=[[2,3],[1,4]]) == 9",
    "contest_id": "weekly-contest-440",
    "contest_date": "2025-03-09T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 54,
      "coverage": null
    },
    "submission_id": 1567558598
  },
  {
    "id": "contest440_q3789_s1",
    "question_id": 3789,
    "function_name": "maxSubarrays",
    "code": "class Solution:\n    def maxSubarrays(self, n: int, conflictingPairs: List[List[int]]) -> int:\n        pairs = []\n        i = 0\n        \n        while i < len(conflictingPairs):\n            a = conflictingPairs[i][0]\n            b = conflictingPairs[i][1]\n            if a > b:\n                tmp = a\n                a = b\n                b = tmp\n            pairs.append((b, a, i))\n            i += 1\n            \n        pairs.sort(key=lambda x: (x[0], x[1]))\n        curMax = 0\n        curSec = 0\n        curCount = 0\n        curId = -1\n        pointer = 0\n        f0 = 0\n        delta = {}\n        r = 1\n        \n        while r <= n:\n            while pointer < len(pairs) and pairs[pointer][0] == r:\n                bVal = pairs[pointer][0]\n                aVal = pairs[pointer][1]\n                pairId = pairs[pointer][2]\n                if aVal > curMax:\n                    curSec = curMax\n                    curMax = aVal\n                    curCount = 1\n                    curId = pairId\n                elif aVal == curMax:\n                    curCount = curCount + 1\n                    curId = -1\n                else:\n                    if aVal > curSec:\n                        curSec = aVal\n                pointer = pointer + 1\n            f0 = f0 + (r - curMax)\n            if curMax > 0 and curCount == 1 and curId != -1:\n                if curId in delta:\n                    delta[curId] = delta[curId] + (curMax - curSec)\n                else:\n                    delta[curId] = (curMax - curSec)\n            r = r + 1\n        maxDelta = 0\n        \n        for key in delta:\n            if delta[key] > maxDelta:\n                maxDelta = delta[key]\n                \n        return f0 + maxDelta",
    "input": "maxSubarrays(n=4, conflictingPairs=[[2,3],[1,4]])",
    "output": "9",
    "correct_condition": "maxSubarrays(n=4, conflictingPairs=[[2,3],[1,4]]) == 9",
    "contest_id": "weekly-contest-440",
    "contest_date": "2025-03-09T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 56,
      "coverage": null
    },
    "submission_id": 1567583893
  },
  {
    "id": "contest440_q3789_s2",
    "question_id": 3789,
    "function_name": "maxSubarrays",
    "code": "class Solution:\n    def maxSubarrays(self, n: int, cp: List[List[int]]) -> int:\n        NIL = 0\n        I = n + 1\n        p = ((a, b) if a < b else (b, a) for a, b in cp)\n        B = [[] for _ in range(n+1)]\n        for L, R in p:\n            B[L].append(R)\n        d = [None]*(n+2)\n        d[n+1] = (I, 0, I, NIL)\n        for i in range(n, 0, -1):\n            if B[i]:\n                lst = sorted(B[i])\n                f = lst[0]\n                cnt = lst.count(f)\n                s = min((x for x in lst if x > f), default=I)\n                x = (f, cnt, s, i)\n            else:\n                x = (I, 0, I, NIL)\n            y = d[i+1]\n            m = min(x[0], y[0])\n            cnt = 0\n            aid = NIL\n            if x[0] == m:\n                cnt += x[1]\n                if x[1] == 1:\n                    aid = x[3]\n            if y[0] == m:\n                cnt += y[1]\n                if y[1] == 1:\n                    aid = y[3] if aid == NIL else NIL\n            cur = []\n            if x[0] > m: cur.append(x[0])\n            if y[0] > m: cur.append(y[0])\n            if x[2] < I: cur.append(x[2])\n            if y[2] < I: cur.append(y[2])\n            sec = min(cur) if cur else I\n            d[i] = (m, cnt, sec, aid)\n        ans = 0\n        for i in range(1, n+1):\n            ans += (n - i + 1) if d[i][0] == I else (d[i][0] - i)\n        mp = defaultdict(int)\n        for i in range(1, n+1):\n            m, c, s, aid = d[i]\n            if m != I and c == 1 and aid != NIL:\n                sc = s if s != I else (n + 1)\n                mp[aid] += sc - m\n        mx = 0\n        if mp:\n            mx = max(mx, max(mp.values()))\n        return ans + mx",
    "input": "maxSubarrays(n=4, cp=[[2,3],[1,4]])",
    "output": "9",
    "correct_condition": "maxSubarrays(n=4, cp=[[2,3],[1,4]]) == 9",
    "contest_id": "weekly-contest-440",
    "contest_date": "2025-03-09T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 51,
      "coverage": null
    },
    "submission_id": 1567579889
  },
  {
    "id": "contest441_q3788_s0",
    "question_id": 3788,
    "function_name": "maxSum",
    "code": "class Solution:\n    def maxSum(self, a: List[int]) -> int:\n        s = {x for x in a if x > 0}\n        return sum(s) if s else max(a)\n",
    "input": "maxSum(a=[1,2,3,4,5])",
    "output": "15",
    "correct_condition": "maxSum(a=[1,2,3,4,5]) == 15",
    "contest_id": "weekly-contest-441",
    "contest_date": "2025-03-16T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 4,
      "coverage": null
    },
    "submission_id": 1575094028
  },
  {
    "id": "contest441_q3788_s1",
    "question_id": 3788,
    "function_name": "maxSum",
    "code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        positive_set = {num for num in nums if num > 0}\n        \n        if positive_set:\n            return sum(positive_set)\n        else:\n            return max(nums)",
    "input": "maxSum(nums=[1,2,3,4,5])",
    "output": "15",
    "correct_condition": "maxSum(nums=[1,2,3,4,5]) == 15",
    "contest_id": "weekly-contest-441",
    "contest_date": "2025-03-16T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 8,
      "coverage": null
    },
    "submission_id": 1575079192
  },
  {
    "id": "contest441_q3788_s2",
    "question_id": 3788,
    "function_name": "maxSum",
    "code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        positive_set = set()\n        total_sum = 0\n        for num in nums:\n            if num > 0 and num not in positive_set:\n                positive_set.add(num)\n                total_sum += num\n        if total_sum > 0:\n            return total_sum\n        return max(nums)",
    "input": "maxSum(nums=[1,2,3,4,5])",
    "output": "15",
    "correct_condition": "maxSum(nums=[1,2,3,4,5]) == 15",
    "contest_id": "weekly-contest-441",
    "contest_date": "2025-03-16T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 11,
      "coverage": null
    },
    "submission_id": 1575080067
  },
  {
    "id": "contest441_q3750_s0",
    "question_id": 3750,
    "function_name": "solveQueries",
    "code": "class Solution:\n    def solveQueries(self, a: List[int], b: List[int]) -> List[int]:\n        n = len(a)\n        d = {}\n        for i, x in enumerate(a):\n            d.setdefault(x, []).append(i)\n        for x in d: d[x].sort()\n        r = []\n        import bisect\n        for i in b:\n            x = a[i]\n            L = d[x]\n            if len(L) == 1:\n                r.append(-1)\n                continue\n            p = bisect.bisect_left(L, i)\n            m = n\n            if p:\n                j = L[p - 1]\n                k = i - j if i >= j else j - i\n                m = min(m, k, n - k)\n            if p < len(L) - 1:\n                j = L[p + 1]\n                k = j - i if j >= i else i - j\n                m = min(m, k, n - k)\n            if p == 0:\n                j = L[-1]\n                k = i - j if i >= j else j - i\n                m = min(m, k, n - k)\n            if p == len(L) - 1:\n                j = L[0]\n                k = j - i if j >= i else i - j\n                m = min(m, k, n - k)\n            r.append(m)\n        return r\n",
    "input": "solveQueries(a=[1,3,1,4,1,3,2], b=[0,3,5])",
    "output": "[2, -1, 3]",
    "correct_condition": "solveQueries(a=[1,3,1,4,1,3,2], b=[0,3,5]) == [2, -1, 3]",
    "contest_id": "weekly-contest-441",
    "contest_date": "2025-03-16T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 35,
      "coverage": null
    },
    "submission_id": 1575092171
  },
  {
    "id": "contest441_q3750_s1",
    "question_id": 3750,
    "function_name": "solveQueries",
    "code": "class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pos_map = defaultdict(list)\n        for idx, num in enumerate(nums):\n            pos_map[num].append(idx)\n        \n        result = []\n        for q in queries:\n            val = nums[q]\n            indices = pos_map[val]\n            if len(indices) == 1:\n                result.append(-1)\n                continue\n            \n            pos = bisect.bisect_left(indices, q)\n            \n            left_neighbor = indices[pos - 1]\n            right_neighbor = indices[(pos + 1) % len(indices)]\n            \n            def circular_distance(i, j):\n                diff = abs(i - j)\n                return min(diff, n - diff)\n            \n            d_left = circular_distance(q, left_neighbor)\n            d_right = circular_distance(q, right_neighbor)\n            answer = min(d_left, d_right)\n            \n            result.append(answer)\n        \n        return result",
    "input": "solveQueries(nums=[1,3,1,4,1,3,2], queries=[0,3,5])",
    "output": "[2, -1, 3]",
    "correct_condition": "solveQueries(nums=[1,3,1,4,1,3,2], queries=[0,3,5]) == [2, -1, 3]",
    "contest_id": "weekly-contest-441",
    "contest_date": "2025-03-16T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 31,
      "coverage": null
    },
    "submission_id": 1575081382
  },
  {
    "id": "contest441_q3750_s2",
    "question_id": 3750,
    "function_name": "solveQueries",
    "code": "class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        occurrences = {}\n        for index, value in enumerate(nums):\n            occurrences.setdefault(value, []).append(index)\n        for value in occurrences:\n            occurrences[value].sort()\n        answer = []\n        for query in queries:\n            value = nums[query]\n            occ = occurrences[value]\n            if len(occ) < 2:\n                answer.append(-1)\n            else:\n                pos = bisect.bisect_left(occ, query)\n                distances = []\n                if pos > 0:\n                    candidate = occ[pos - 1]\n                    diff = abs(query - candidate)\n                    distances.append(min(diff, n - diff))\n                if pos < len(occ) - 1:\n                    candidate = occ[pos + 1]\n                    diff = abs(query - candidate)\n                    distances.append(min(diff, n - diff))\n                if pos == 0:\n                    candidate = occ[-1]\n                    diff = abs(query - candidate)\n                    distances.append(min(diff, n - diff))\n                if pos == len(occ) - 1:\n                    candidate = occ[0]\n                    diff = abs(query - candidate)\n                    distances.append(min(diff, n - diff))\n                answer.append(min(distances))\n        return answer",
    "input": "solveQueries(nums=[1,3,1,4,1,3,2], queries=[0,3,5])",
    "output": "[2, -1, 3]",
    "correct_condition": "solveQueries(nums=[1,3,1,4,1,3,2], queries=[0,3,5]) == [2, -1, 3]",
    "contest_id": "weekly-contest-441",
    "contest_date": "2025-03-16T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 35,
      "coverage": null
    },
    "submission_id": 1575086006
  },
  {
    "id": "contest441_q3795_s0",
    "question_id": 3795,
    "function_name": "minZeroArray",
    "code": "class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        a = nums\n        n = len(a)\n        if all(x==0 for x in a):\n            return 0\n        d = [1]*n\n        for i, q in enumerate(queries):\n            x, y, z = q\n            for j in range(x, y+1):\n                d[j] |= d[j] << z\n            if all(d[j] & (1 << a[j]) for j in range(n)):\n                return i+1\n        return -1\n",
    "input": "minZeroArray(nums=[2,0,2], queries=[[0,2,1],[0,2,1],[1,1,3]])",
    "output": "2",
    "correct_condition": "minZeroArray(nums=[2,0,2], queries=[[0,2,1],[0,2,1],[1,1,3]]) == 2",
    "contest_id": "weekly-contest-441",
    "contest_date": "2025-03-16T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 14,
      "coverage": null
    },
    "submission_id": 1575088928
  },
  {
    "id": "contest441_q3795_s1",
    "question_id": 3795,
    "function_name": "minZeroArray",
    "code": "class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        total_queries = len(queries)\n        \n        def can_sum_to(vals: List[int], target: int) -> bool:\n            dp = [False] * (target + 1)\n            dp[0] = True\n            for v in vals:\n                for t in range(target, v - 1, -1):\n                    if dp[t - v]:\n                        dp[t] = True\n                if dp[target]:\n                    return True\n            return dp[target]\n        \n        for k in range(total_queries + 1):\n            possible_for_all = True\n            for i in range(n):\n                if nums[i] == 0:\n                    continue\n                available_vals = []\n                for j in range(k):\n                    l, r, val = queries[j]\n                    if l <= i <= r:\n                        available_vals.append(val)\n                if not can_sum_to(available_vals, nums[i]):\n                    possible_for_all = False\n                    break\n            \n            if possible_for_all:\n                return k\n        \n        return -1",
    "input": "minZeroArray(nums=[2,0,2], queries=[[0,2,1],[0,2,1],[1,1,3]])",
    "output": "2",
    "correct_condition": "minZeroArray(nums=[2,0,2], queries=[[0,2,1],[0,2,1],[1,1,3]]) == 2",
    "contest_id": "weekly-contest-441",
    "contest_date": "2025-03-16T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 34,
      "coverage": null
    },
    "submission_id": 1575088850
  },
  {
    "id": "contest441_q3795_s2",
    "question_id": 3795,
    "function_name": "minZeroArray",
    "code": "class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if all(num == 0 for num in nums):\n            return 0\n        def is_feasible(num_queries):\n            for index in range(n):\n                required = nums[index]\n                dp = 1\n                mask = (1 << (required + 1)) - 1\n                for i in range(num_queries):\n                    left_bound, right_bound, query_value = queries[i]\n                    if left_bound <= index <= right_bound:\n                        dp = dp | (dp << query_value)\n                        dp &= mask\n                if (dp >> required) & 1 == 0:\n                    return False\n            return True\n        low = 0\n        high = len(queries)\n        answer = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if is_feasible(mid):\n                answer = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        return answer\n                        \n",
    "input": "minZeroArray(nums=[2,0,2], queries=[[0,2,1],[0,2,1],[1,1,3]])",
    "output": "2",
    "correct_condition": "minZeroArray(nums=[2,0,2], queries=[[0,2,1],[0,2,1],[1,1,3]]) == 2",
    "contest_id": "weekly-contest-441",
    "contest_date": "2025-03-16T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 30,
      "coverage": null
    },
    "submission_id": 1575094269
  },
  {
    "id": "contest441_q3801_s0",
    "question_id": 3801,
    "function_name": "beautifulNumbers",
    "code": "class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def g(x):\n            return list(map(int, str(x)))\n        from functools import lru_cache\n        def h(x):\n            d = g(x)\n            @lru_cache(maxsize=None)\n            def f(i, t, st):\n                if i == len(d): return 1 if st else 0\n                a = 0\n                m = d[i] if t else 9\n                for j in range(m + 1):\n                    nt = t and (j == m)\n                    if not st and j == 0:\n                        a += f(i + 1, nt, False)\n                    else:\n                        if j == 0: continue\n                        a += f(i + 1, nt, True)\n                return a\n            return f(0, True, False)\n        def k(x):\n            d = g(x)\n            @lru_cache(maxsize=None)\n            def f(i, t, st, s, p):\n                if i == len(d): return 1 if st and p % s == 0 else 0\n                a = 0\n                m = d[i] if t else 9\n                for j in range(m + 1):\n                    nt = t and (j == m)\n                    if not st and j == 0:\n                        a += f(i + 1, nt, False, s, p)\n                    else:\n                        if j == 0: continue\n                        a += f(i + 1, nt, True, s + j, p * j)\n                return a\n            return f(0, True, False, 0, 1)\n        def c(x):\n            if x <= 0: return 0\n            return x - h(x) + k(x)\n        return c(r) - c(l - 1)\n",
    "input": "beautifulNumbers(l=10, r=20)",
    "output": "2",
    "correct_condition": "beautifulNumbers(l=10, r=20) == 2",
    "contest_id": "weekly-contest-441",
    "contest_date": "2025-03-16T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 41,
      "coverage": null
    },
    "submission_id": 1575085194
  },
  {
    "id": "contest441_q3801_s1",
    "question_id": 3801,
    "function_name": "beautifulNumbers",
    "code": "class Solution:\n    def beautifulNumbers(self, l: int, r: int) -> int:\n        def countBeautiful(X: int) -> int:\n            if X <= 0:\n                return 0\n            \n            digits = list(map(int, str(X)))\n            n = len(digits)\n            \n            from functools import lru_cache\n            \n            @lru_cache(maxsize=None)\n            def dp(pos, tight, started, hasZero, curr_sum, curr_prod):\n                if pos == n:\n                    if not started:\n                        return 0\n                    if hasZero:\n                        return 1\n                    return 1 if curr_prod % curr_sum == 0 else 0\n                    \n                total = 0\n                upper_bound = digits[pos] if tight else 9\n                \n                for d in range(0, upper_bound + 1):\n                    ntight = tight and (d == upper_bound)\n                    \n                    if not started:\n                        if d == 0:\n                            total += dp(pos+1, ntight, False, False, 0, 1)\n                        else:\n                            total += dp(pos+1, ntight, True, False, d, d)\n                    else:\n                        if d == 0:\n                            total += dp(pos+1, ntight, True, True, curr_sum + d, 0)\n                        else:\n                            if hasZero:\n                                new_prod = 0\n                            else:\n                                new_prod = curr_prod * d\n                            total += dp(pos+1, ntight, True, hasZero, curr_sum + d, new_prod)\n                            \n                return total\n            \n            return dp(0, True, False, False, 0, 1)\n        \n        return countBeautiful(r) - countBeautiful(l - 1)",
    "input": "beautifulNumbers(l=10, r=20)",
    "output": "2",
    "correct_condition": "beautifulNumbers(l=10, r=20) == 2",
    "contest_id": "weekly-contest-441",
    "contest_date": "2025-03-16T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 46,
      "coverage": null
    },
    "submission_id": 1575096103
  },
  {
    "id": "contest441_q3801_s2",
    "question_id": 3801,
    "function_name": "beautifulNumbers",
    "code": "from functools import lru_cache\nclass Solution(object):\n    def beautifulNumbers(self, l, r):\n        def sol(n):\n            if n < 0:\n                return 0\n            a = list(map(int, str(n)))\n            L = len(a)\n            @lru_cache(maxsize=None)\n            def rec(i, t, st, h, s, p):\n                if i == L:\n                    if not st:\n                        return 0\n                    return 1 if h or (p % s == 0) else 0\n                c = 0\n                m = a[i] if t else 9\n                for x in range(m+1):\n                    nt = t and (x == m)\n                    if not st:\n                        if x == 0:\n                            c += rec(i+1, nt, 0, 0, 0, 1)\n                        else:\n                            c += rec(i+1, nt, 1, 0, x, x)\n                    else:\n                        if x == 0:\n                            c += rec(i+1, nt, 1, 1, s, 0)\n                        else:\n                            if h:\n                                c += rec(i+1, nt, 1, 1, s+x, 0)\n                            else:\n                                c += rec(i+1, nt, 1, 0, s+x, p*x)\n                return c\n            return rec(0, True, 0, 0, 0, 1)\n        return sol(r) - sol(l-1)\n",
    "input": "beautifulNumbers(l=10, r=20)",
    "output": "2",
    "correct_condition": "beautifulNumbers(l=10, r=20) == 2",
    "contest_id": "weekly-contest-441",
    "contest_date": "2025-03-16T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 34,
      "coverage": null
    },
    "submission_id": 1575103497
  },
  {
    "id": "contest442_q3817_s0",
    "question_id": 3817,
    "function_name": "maxContainers",
    "code": "class Solution:\n    def maxContainers(self, n: int, w: int, maxWeight: int) -> int:\n        return min(n*n, maxWeight//w)",
    "input": "maxContainers(n=2, w=3, maxWeight=15)",
    "output": "4",
    "correct_condition": "maxContainers(n=2, w=3, maxWeight=15) == 4",
    "contest_id": "weekly-contest-442",
    "contest_date": "2025-03-23T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 3,
      "coverage": null
    },
    "submission_id": 1582808446
  },
  {
    "id": "contest442_q3817_s1",
    "question_id": 3817,
    "function_name": "maxContainers",
    "code": "class Solution:\n    def maxContainers(self, n: int, w: int, maxWeight: int) -> int:\n        return min(n * n, maxWeight // w)\n",
    "input": "maxContainers(n=2, w=3, maxWeight=15)",
    "output": "4",
    "correct_condition": "maxContainers(n=2, w=3, maxWeight=15) == 4",
    "contest_id": "weekly-contest-442",
    "contest_date": "2025-03-23T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 3,
      "coverage": null
    },
    "submission_id": 1582806336
  },
  {
    "id": "contest442_q3817_s2",
    "question_id": 3817,
    "function_name": "maxContainers",
    "code": "class Solution:\n    def maxContainers(self, n: int, w: int, maxWeight: int) -> int:\n        return min(maxWeight // w, n * n)",
    "input": "maxContainers(n=2, w=3, maxWeight=15)",
    "output": "4",
    "correct_condition": "maxContainers(n=2, w=3, maxWeight=15) == 4",
    "contest_id": "weekly-contest-442",
    "contest_date": "2025-03-23T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 3,
      "coverage": null
    },
    "submission_id": 1582820286
  },
  {
    "id": "contest442_q3809_s0",
    "question_id": 3809,
    "function_name": "numberOfComponents",
    "code": "class Solution:\n    def numberOfComponents(self, props, k):\n        n = len(props)\n        uf = list(range(n))\n        \n        def find(u):\n            if uf[u] != u:\n                uf[u] = find(uf[u])\n            return uf[u]\n        \n        def uni(u, v):\n            pu, pv = find(u), find(v)\n            m = pu if pu < pv else pv\n            uf[pu] = m\n            uf[pv] = m\n            \n        def inter(a, b, k):\n            if len(a) < k or len(b) < k:\n                return False\n            r = 0\n            i = j = 0\n            while i < len(a) and j < len(b) and r < k:\n                if a[i] == b[j]:\n                    r += 1\n                    i += 1\n                    j += 1\n                elif a[i] < b[j]:\n                    i += 1\n                else:\n                    j += 1\n            return r >= k\n        \n        for i in range(n):\n            props[i] = sorted(set(props[i]))\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if inter(props[i], props[j], k):\n                    uni(i, j)\n                    \n        res = sum(1 for i in range(n) if find(i) == i)\n        return res",
    "input": "numberOfComponents(props=[[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k=1)",
    "output": "3",
    "correct_condition": "numberOfComponents(props=[[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k=1) == 3",
    "contest_id": "weekly-contest-442",
    "contest_date": "2025-03-23T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 42,
      "coverage": null
    },
    "submission_id": 1582812387
  },
  {
    "id": "contest442_q3809_s1",
    "question_id": 3809,
    "function_name": "numberOfComponents",
    "code": "class Solution:\n    def numberOfComponents(self, properties: List[List[int]], k: int) -> int:\n        n = len(properties)\n        sets = [set(prop) for prop in properties]\n\n        graph = {i: [] for i in range(n)}\n        for i in range(n):\n            for j in range(i + 1, n):\n                if len(sets[i].intersection(sets[j])) >= k:\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        visited = set()\n\n        def dfs(node):\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                if curr not in visited:\n                    visited.add(curr)\n                    for neighbor in graph[curr]:\n                        if neighbor not in visited:\n                            stack.append(neighbor)\n\n        components = 0\n        for i in range(n):\n            if i not in visited:\n                dfs(i)\n                components += 1\n\n        return components",
    "input": "numberOfComponents(properties=[[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k=1)",
    "output": "3",
    "correct_condition": "numberOfComponents(properties=[[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k=1) == 3",
    "contest_id": "weekly-contest-442",
    "contest_date": "2025-03-23T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 31,
      "coverage": null
    },
    "submission_id": 1582811996
  },
  {
    "id": "contest442_q3809_s2",
    "question_id": 3809,
    "function_name": "numberOfComponents",
    "code": "class Solution:\n    def numberOfComponents(self, properties: List[List[int]], k: int) -> int:\n        n = len(properties)\n        s = list(map(set, properties))\n        g = [[] for _ in range(n)]\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if len(s[i] & s[j]) < k:\n                    continue\n                g[i].append(j)\n                g[j].append(i)\n\n        seen = [False] * n\n\n        def dfs(i):\n            seen[i] = True\n            for j in g[i]:\n                if not seen[j]:\n                    dfs(j)\n\n        ans = 0\n        for i in range(n):\n            if seen[i]:\n                continue\n            dfs(i)\n            ans += 1\n\n        return ans\n",
    "input": "numberOfComponents(properties=[[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k=1)",
    "output": "3",
    "correct_condition": "numberOfComponents(properties=[[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k=1) == 3",
    "contest_id": "weekly-contest-442",
    "contest_date": "2025-03-23T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 29,
      "coverage": null
    },
    "submission_id": 1582816211
  },
  {
    "id": "contest442_q3794_s0",
    "question_id": 3794,
    "function_name": "minTime",
    "code": "class Solution:\n    def minTime(self, s, m):\n        n = len(s)\n        f = [0] * n\n        for x in m:\n            nw = f[0]\n            for i in range(1, n):\n                nw = max(nw + s[i - 1] * x, f[i])\n            f[n - 1] = nw + s[n - 1] * x\n            for i in range(n - 2, -1, -1):\n                f[i] = f[i + 1] - s[i + 1] * x\n        return f[n - 1]",
    "input": "minTime(s=[1,5,2,4], m=[5,1,4,2])",
    "output": "110",
    "correct_condition": "minTime(s=[1,5,2,4], m=[5,1,4,2]) == 110",
    "contest_id": "weekly-contest-442",
    "contest_date": "2025-03-23T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 12,
      "coverage": null
    },
    "submission_id": 1582817620
  },
  {
    "id": "contest442_q3794_s1",
    "question_id": 3794,
    "function_name": "minTime",
    "code": "class Solution:\n    def minTime(self, skill: List[int], mana: List[int]) -> int:\n        n, m = len(skill), len(mana)\n        ss = [0] * n\n        ss[0] = skill[0]\n        for i in range(1, n):\n            ss[i] = ss[i - 1] + skill[i]\n        S = 0\n        for j in range(1, m):\n            delay = skill[0] * mana[j - 1]\n            for i in range(1, n):\n                d = ss[i] * mana[j - 1] - ss[i - 1] * mana[j]\n                if d > delay:\n                    delay = d\n            S += delay\n        return S + ss[-1] * mana[-1]",
    "input": "minTime(skill=[1,5,2,4], mana=[5,1,4,2])",
    "output": "110",
    "correct_condition": "minTime(skill=[1,5,2,4], mana=[5,1,4,2]) == 110",
    "contest_id": "weekly-contest-442",
    "contest_date": "2025-03-23T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 16,
      "coverage": null
    },
    "submission_id": 1582823640
  },
  {
    "id": "contest442_q3794_s2",
    "question_id": 3794,
    "function_name": "minTime",
    "code": "class Solution:\n    def minTime(self, skill: List[int], mana: List[int]) -> int:\n        n, m = len(skill), len(mana)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + skill[i - 1]\n        s = 0\n        for j in range(m - 1):\n            s += max(mana[j] * dp[i] - mana[j + 1] * dp[i - 1] for i in range(1, n + 1))\n        return mana[m - 1] * dp[n] + s",
    "input": "minTime(skill=[1,5,2,4], mana=[5,1,4,2])",
    "output": "110",
    "correct_condition": "minTime(skill=[1,5,2,4], mana=[5,1,4,2]) == 110",
    "contest_id": "weekly-contest-442",
    "contest_date": "2025-03-23T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 10,
      "coverage": null
    },
    "submission_id": 1582832026
  },
  {
    "id": "contest442_q3744_s1",
    "question_id": 3744,
    "function_name": "minOperations",
    "code": "class Solution:\n    def minOperations(self, queries: List[List[int]]) -> int:\n        p = [1] * 16\n        for i in range(1, 16):\n            p[i] = p[i - 1] * 4\n        ans = 0\n        for l, r in queries:\n            total = 0\n            for t in range(1, 16):\n                L = p[t - 1]\n                R = p[t] - 1\n                lo = l if l > L else L\n                hi = r if r < R else R\n                if lo <= hi:\n                    total += t * (hi - lo + 1)\n            tmax = 0\n            for t in range(1, 16):\n                if r <= p[t] - 1:\n                    tmax = t\n                    break\n            ops = (total + 1) // 2\n            if tmax > ops:\n                ops = tmax\n            ans += ops\n        return ans",
    "input": "minOperations(queries=[[1,2],[2,4]])",
    "output": "3",
    "correct_condition": "minOperations(queries=[[1,2],[2,4]]) == 3",
    "contest_id": "weekly-contest-442",
    "contest_date": "2025-03-23T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 25,
      "coverage": null
    },
    "submission_id": 1582831208
  },
  {
    "id": "contest442_q3744_s2",
    "question_id": 3744,
    "function_name": "minOperations",
    "code": "class Solution:\n    def minOperations(self, queries: List[List[int]]) -> int:\n        result = []\n        k = 1\n        while True:\n            low = 4 ** (k - 1)\n            high = 4 ** k - 1\n            if low > 10 ** 9:\n                break\n            result.append((low, high, k))\n            k += 1\n\n        # print(result)\n        ans = 0\n        for q in queries:\n            l = q[0]\n            r = q[1]\n            _sum = 0\n            for a, b, c in result:\n                if b >= l and a <= r:\n                    x = max(l, a)\n                    y = min(r, b)\n                    _sum += c * (y - x + 1)\n                    # print(f'x: {x}, y: {y}, c: {c}, _sum: {_sum}')\n            ans += (_sum + 1) // 2\n            # print(f'ans: {ans}')\n        # print(ans)\n        return ans",
    "input": "minOperations(queries=[[1,2],[2,4]])",
    "output": "3",
    "correct_condition": "minOperations(queries=[[1,2],[2,4]]) == 3",
    "contest_id": "weekly-contest-442",
    "contest_date": "2025-03-23T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 28,
      "coverage": null
    },
    "submission_id": 1582837946
  },
  {
    "id": "contest443_q3832_s0",
    "question_id": 3832,
    "function_name": "minCosts",
    "code": "class Solution:\n    def minCosts(self, a: List[int]) -> List[int]:\n        res = a\n        for i in range(1, len(res)):\n            res[i] = min(res[i], res[i - 1])\n        return res",
    "input": "minCosts(a=[5,3,4,1,3,2])",
    "output": "[5, 3, 3, 1, 1, 1]",
    "correct_condition": "minCosts(a=[5,3,4,1,3,2]) == [5, 3, 3, 1, 1, 1]",
    "contest_id": "weekly-contest-443",
    "contest_date": "2025-03-30T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 6,
      "coverage": null
    },
    "submission_id": 1590604607
  },
  {
    "id": "contest443_q3832_s1",
    "question_id": 3832,
    "function_name": "minCosts",
    "code": "class Solution:\n    def minCosts(self, cost: List[int]) -> List[int]:\n        for i in range(1, len(cost)):\n            if cost[i] > cost[i-1]:\n                cost[i] = cost[i-1]\n        return cost",
    "input": "minCosts(cost=[5,3,4,1,3,2])",
    "output": "[5, 3, 3, 1, 1, 1]",
    "correct_condition": "minCosts(cost=[5,3,4,1,3,2]) == [5, 3, 3, 1, 1, 1]",
    "contest_id": "weekly-contest-443",
    "contest_date": "2025-03-30T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 6,
      "coverage": null
    },
    "submission_id": 1590616291
  },
  {
    "id": "contest443_q3832_s2",
    "question_id": 3832,
    "function_name": "minCosts",
    "code": "class Solution:\n    def minCosts(self, cost: List[int]) -> List[int]:\n        prev = float(\"inf\")\n        ans = []\n        for i, c in enumerate(cost):\n            prev = min(prev, c)\n            ans.append(prev)\n        return ans",
    "input": "minCosts(cost=[5,3,4,1,3,2])",
    "output": "[5, 3, 3, 1, 1, 1]",
    "correct_condition": "minCosts(cost=[5,3,4,1,3,2]) == [5, 3, 3, 1, 1, 1]",
    "contest_id": "weekly-contest-443",
    "contest_date": "2025-03-30T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 8,
      "coverage": null
    },
    "submission_id": 1590605154
  },
  {
    "id": "contest443_q3793_s0",
    "question_id": 3793,
    "function_name": "longestPalindrome",
    "code": "class Solution:\n    def longestPalindrome(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        palS = [[False] * n for _ in range(n)]\n        for i in range(n):\n            palS[i][i] = True\n        for i in range(n - 1):\n            palS[i][i + 1] = (s[i] == s[i + 1])\n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                palS[i][j] = (s[i] == s[j] and palS[i + 1][j - 1])\n        left_pal = [0] * n\n        for i in range(n):\n            mx = 0\n            for j in range(i, n):\n                if palS[i][j]:\n                    cur = j - i + 1\n                    if cur > mx:\n                        mx = cur\n            left_pal[i] = mx\n        longest_s = max(left_pal) if n else 0\n\n        palT = [[False] * m for _ in range(m)]\n        for i in range(m):\n            palT[i][i] = True\n        for i in range(m - 1):\n            palT[i][i + 1] = (t[i] == t[i + 1])\n        for length in range(3, m + 1):\n            for i in range(m - length + 1):\n                j = i + length - 1\n                palT[i][j] = (t[i] == t[j] and palT[i + 1][j - 1])\n        right_pal = [0] * m\n        for j in range(m):\n            mx = 0\n            for i in range(j + 1):\n                if palT[i][j]:\n                    cur = j - i + 1\n                    if cur > mx:\n                        mx = cur\n            right_pal[j] = mx\n        longest_t = max(right_pal) if m else 0\n\n        best = max(longest_s, longest_t)\n        R = t[::-1]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == R[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    L = dp[i][j]\n                    extra1 = left_pal[i] if i < n else 0\n                    cand1 = 2 * L + extra1\n                    if cand1 > best:\n                        best = cand1\n                    p = m - j\n                    extra2 = right_pal[p - 1] if p > 0 else 0\n                    cand2 = 2 * L + extra2\n                    if cand2 > best:\n                        best = cand2\n                else:\n                    dp[i][j] = 0\n        return best",
    "input": "longestPalindrome(s=\"a\", t=\"a\")",
    "output": "2",
    "correct_condition": "longestPalindrome(s=\"a\", t=\"a\") == 2",
    "contest_id": "weekly-contest-443",
    "contest_date": "2025-03-30T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 63,
      "coverage": null
    },
    "submission_id": 1590627738
  },
  {
    "id": "contest443_q3793_s1",
    "question_id": 3793,
    "function_name": "longestPalindrome",
    "code": "class Solution:\n    def longestPalindrome(self, ss1: str, ss2: str) -> int:\n        def solve(s1, s2):\n            trie = {}\n            for i in range(len(s2)):\n                cur = trie\n                for j in range(i, len(s2)):\n                    c = s2[j]\n                    if c not in cur:\n                        cur[c] = {}\n                    cur = cur[c]\n            ans = 1\n            for midl in range(len(s1)):\n                for shift in [0, 1]:\n                    midr = midl + shift\n                    l = midl\n                    r = midr\n                    triestarted = False\n                    while l >= 0:\n                        if not triestarted:\n                            if r < len(s1) and s1[r] == s1[l]:\n                                ans = max(ans, r - l + 1)\n                                l -= 1\n                                r += 1\n                            else:\n                                triestarted = True\n                                cur = trie\n                        else:\n                            if s1[l] not in cur:\n                                break\n                            else:\n                                cur = cur[s1[l]]\n                                ans = max(ans, r - l + 1)\n                                l -= 1\n                                r += 1\n            return ans\n        return max(solve(ss1, ss2), solve(ss2[::-1], ss1[::-1]))\n                                \n",
    "input": "longestPalindrome(ss1=\"a\", ss2=\"a\")",
    "output": "2",
    "correct_condition": "longestPalindrome(ss1=\"a\", ss2=\"a\") == 2",
    "contest_id": "weekly-contest-443",
    "contest_date": "2025-03-30T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 38,
      "coverage": null
    },
    "submission_id": 1590624516
  },
  {
    "id": "contest443_q3793_s2",
    "question_id": 3793,
    "function_name": "longestPalindrome",
    "code": "class Solution:\n    def longestPalindrome(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n    \n        # --- Precompute palindromic substrings for s ---\n        # isPalS[i][j] = True if s[i:j+1] is a palindrome.\n        isPalS = [[False] * n for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i < 2 or isPalS[i+1][j-1]):\n                    isPalS[i][j] = True\n        # best_start[i] = length of longest palindrome starting exactly at index i in s.\n        best_start = [0] * n\n        for i in range(n):\n            max_len = 0\n            for j in range(i, n):\n                if isPalS[i][j]:\n                    length = j - i + 1\n                    if length > max_len:\n                        max_len = length\n            best_start[i] = max_len\n        \n        # --- Precompute palindromic substrings for t ---\n        # isPalT[i][j] = True if t[i:j+1] is a palindrome.\n        isPalT = [[False] * m for _ in range(m)]\n        for i in range(m-1, -1, -1):\n            for j in range(i, m):\n                if t[i] == t[j] and (j - i < 2 or isPalT[i+1][j-1]):\n                    isPalT[i][j] = True\n        # best_end[j] = length of longest palindrome ending exactly at index j in t.\n        best_end = [0] * m\n        for j in range(m):\n            max_len = 0\n            for i in range(0, j+1):\n                if isPalT[i][j]:\n                    length = j - i + 1\n                    if length > max_len:\n                        max_len = length\n            best_end[j] = max_len\n        \n        # --- Pure palindromes: those lying entirely in s or entirely in t ---\n        pure = 0\n        if n > 0:\n            pure = max(best_start)  # longest palindrome in s\n        if m > 0:\n            pure = max(pure, max(best_end))  # longest palindrome in t\n        \n        # --- DP for common substrings between s and reverse(t) ---\n        t_rev = t[::-1]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        best_cross = 0\n        \n        # dp[i][j]: longest common suffix of s[:i] and t_rev[:j].\n        # When dp[i][j] = L > 0, it means s[i-L:i] = t_rev[j-L:j],\n        # which corresponds to a substring X in s (ending at index i-1)\n        # and reverse(X) in t. In t, the occurrence of reverse(X) starts at pos = m - j.\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == t_rev[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    L = dp[i][j]\n                    # Case B: extend u in s (u = X + Y, where Y is a palindrome).\n                    # Here, X = s[i - L : i] and we can append Y = (longest palindrome starting at index i).\n                    ext_s = best_start[i] if i < n else 0\n                    candidate_B = 2 * L + ext_s\n                    # Case A: extend v in t (v = p + reverse(X), where p is a palindrome).\n                    # In t, the occurrence of reverse(X) starts at index pos = m - j.\n                    pos = m - j  \n                    ext_t = best_end[pos - 1] if pos > 0 else 0\n                    candidate_A = 2 * L + ext_t\n                    best_cross = max(best_cross, candidate_A, candidate_B)\n        \n        return max(pure, best_cross)",
    "input": "longestPalindrome(s=\"a\", t=\"a\")",
    "output": "2",
    "correct_condition": "longestPalindrome(s=\"a\", t=\"a\") == 2",
    "contest_id": "weekly-contest-443",
    "contest_date": "2025-03-30T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 73,
      "coverage": null
    },
    "submission_id": 1590642799
  },
  {
    "id": "contest443_q3808_s0",
    "question_id": 3808,
    "function_name": "longestPalindrome",
    "code": "class Solution:\n    def longestPalindrome(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        palS = [[False] * n for _ in range(n)]\n        for i in range(n):\n            palS[i][i] = True\n        for i in range(n - 1):\n            palS[i][i + 1] = (s[i] == s[i + 1])\n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                palS[i][j] = (s[i] == s[j] and palS[i + 1][j - 1])\n        left_pal = [0] * n\n        for i in range(n):\n            mx = 0\n            for j in range(i, n):\n                if palS[i][j]:\n                    cur = j - i + 1\n                    if cur > mx:\n                        mx = cur\n            left_pal[i] = mx\n        longest_s = max(left_pal) if n else 0\n\n        palT = [[False] * m for _ in range(m)]\n        for i in range(m):\n            palT[i][i] = True\n        for i in range(m - 1):\n            palT[i][i + 1] = (t[i] == t[i + 1])\n        for length in range(3, m + 1):\n            for i in range(m - length + 1):\n                j = i + length - 1\n                palT[i][j] = (t[i] == t[j] and palT[i + 1][j - 1])\n        right_pal = [0] * m\n        for j in range(m):\n            mx = 0\n            for i in range(j + 1):\n                if palT[i][j]:\n                    cur = j - i + 1\n                    if cur > mx:\n                        mx = cur\n            right_pal[j] = mx\n        longest_t = max(right_pal) if m else 0\n\n        best = max(longest_s, longest_t)\n        R = t[::-1]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == R[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    L = dp[i][j]\n                    extra1 = left_pal[i] if i < n else 0\n                    cand1 = 2 * L + extra1\n                    if cand1 > best:\n                        best = cand1\n                    p = m - j\n                    extra2 = right_pal[p - 1] if p > 0 else 0\n                    cand2 = 2 * L + extra2\n                    if cand2 > best:\n                        best = cand2\n                else:\n                    dp[i][j] = 0\n        return best",
    "input": "longestPalindrome(s=\"a\", t=\"a\")",
    "output": "2",
    "correct_condition": "longestPalindrome(s=\"a\", t=\"a\") == 2",
    "contest_id": "weekly-contest-443",
    "contest_date": "2025-03-30T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 63,
      "coverage": null
    },
    "submission_id": 1590625901
  },
  {
    "id": "contest443_q3808_s1",
    "question_id": 3808,
    "function_name": "longestPalindrome",
    "code": "class Solution:\n    def longestPalindrome(self, ss1: str, ss2: str) -> int:\n        def solve(s1, s2):\n            trie = {}\n            for i in range(len(s2)):\n                cur = trie\n                for j in range(i, len(s2)):\n                    c = s2[j]\n                    if c not in cur:\n                        cur[c] = {}\n                    cur = cur[c]\n            ans = 1\n            for midl in range(len(s1)):\n                for shift in [0, 1]:\n                    midr = midl + shift\n                    l = midl\n                    r = midr\n                    triestarted = False\n                    while l >= 0:\n                        if not triestarted:\n                            if r < len(s1) and s1[r] == s1[l]:\n                                ans = max(ans, r - l + 1)\n                                l -= 1\n                                r += 1\n                            else:\n                                triestarted = True\n                                cur = trie\n                        else:\n                            if s1[l] not in cur:\n                                break\n                            else:\n                                cur = cur[s1[l]]\n                                ans = max(ans, r - l + 1)\n                                l -= 1\n                                r += 1\n            return ans\n        return max(solve(ss1, ss2), solve(ss2[::-1], ss1[::-1]))\n                                \n",
    "input": "longestPalindrome(ss1=\"a\", ss2=\"a\")",
    "output": "2",
    "correct_condition": "longestPalindrome(ss1=\"a\", ss2=\"a\") == 2",
    "contest_id": "weekly-contest-443",
    "contest_date": "2025-03-30T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 38,
      "coverage": null
    },
    "submission_id": 1590624215
  },
  {
    "id": "contest443_q3808_s2",
    "question_id": 3808,
    "function_name": "longestPalindrome",
    "code": "class Solution:\n    def longestPalindrome(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n    \n        # --- Precompute palindromic substrings for s ---\n        # isPalS[i][j] = True if s[i:j+1] is a palindrome.\n        isPalS = [[False] * n for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i < 2 or isPalS[i+1][j-1]):\n                    isPalS[i][j] = True\n        # best_start[i] = length of longest palindrome starting exactly at index i in s.\n        best_start = [0] * n\n        for i in range(n):\n            max_len = 0\n            for j in range(i, n):\n                if isPalS[i][j]:\n                    length = j - i + 1\n                    if length > max_len:\n                        max_len = length\n            best_start[i] = max_len\n        \n        # --- Precompute palindromic substrings for t ---\n        # isPalT[i][j] = True if t[i:j+1] is a palindrome.\n        isPalT = [[False] * m for _ in range(m)]\n        for i in range(m-1, -1, -1):\n            for j in range(i, m):\n                if t[i] == t[j] and (j - i < 2 or isPalT[i+1][j-1]):\n                    isPalT[i][j] = True\n        # best_end[j] = length of longest palindrome ending exactly at index j in t.\n        best_end = [0] * m\n        for j in range(m):\n            max_len = 0\n            for i in range(0, j+1):\n                if isPalT[i][j]:\n                    length = j - i + 1\n                    if length > max_len:\n                        max_len = length\n            best_end[j] = max_len\n        \n        # --- Pure palindromes: those lying entirely in s or entirely in t ---\n        pure = 0\n        if n > 0:\n            pure = max(best_start)  # longest palindrome in s\n        if m > 0:\n            pure = max(pure, max(best_end))  # longest palindrome in t\n        \n        # --- DP for common substrings between s and reverse(t) ---\n        t_rev = t[::-1]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        best_cross = 0\n        \n        # dp[i][j]: longest common suffix of s[:i] and t_rev[:j].\n        # When dp[i][j] = L > 0, it means s[i-L:i] = t_rev[j-L:j],\n        # which corresponds to a substring X in s (ending at index i-1)\n        # and reverse(X) in t. In t, the occurrence of reverse(X) starts at pos = m - j.\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == t_rev[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    L = dp[i][j]\n                    # Case B: extend u in s (u = X + Y, where Y is a palindrome).\n                    # Here, X = s[i - L : i] and we can append Y = (longest palindrome starting at index i).\n                    ext_s = best_start[i] if i < n else 0\n                    candidate_B = 2 * L + ext_s\n                    # Case A: extend v in t (v = p + reverse(X), where p is a palindrome).\n                    # In t, the occurrence of reverse(X) starts at index pos = m - j.\n                    pos = m - j  \n                    ext_t = best_end[pos - 1] if pos > 0 else 0\n                    candidate_A = 2 * L + ext_t\n                    best_cross = max(best_cross, candidate_A, candidate_B)\n        \n        return max(pure, best_cross)",
    "input": "longestPalindrome(s=\"a\", t=\"a\")",
    "output": "2",
    "correct_condition": "longestPalindrome(s=\"a\", t=\"a\") == 2",
    "contest_id": "weekly-contest-443",
    "contest_date": "2025-03-30T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 73,
      "coverage": null
    },
    "submission_id": 1590627076
  },
  {
    "id": "contest443_q3717_s0",
    "question_id": 3717,
    "function_name": "minOperations",
    "code": "class SlidingMedian:\n    def __init__(self):\n        self.small = []  # max-heap, store negatives\n        self.large = []  # min-heap\n        self.delayed_small = {}\n        self.delayed_large = {}\n        self.small_size = 0\n        self.large_size = 0\n        self.sum_small = 0\n        self.sum_large = 0\n\n    def push(self, num: int) -> None:\n        if not self.small or num <= -self.small[0]:\n            heapq.heappush(self.small, -num)\n            self.sum_small += num\n            self.small_size += 1\n        else:\n            heapq.heappush(self.large, num)\n            self.sum_large += num\n            self.large_size += 1\n        self.balance()\n\n    def balance(self) -> None:\n        if self.small_size > self.large_size + 1:\n            val = -heapq.heappop(self.small)\n            self.sum_small -= val\n            self.small_size -= 1\n            heapq.heappush(self.large, val)\n            self.sum_large += val\n            self.large_size += 1\n            self.prune(self.small, self.delayed_small, True)\n        elif self.small_size < self.large_size:\n            val = heapq.heappop(self.large)\n            self.sum_large -= val\n            self.large_size -= 1\n            heapq.heappush(self.small, -val)\n            self.sum_small += val\n            self.small_size += 1\n            self.prune(self.large, self.delayed_large, False)\n\n    def prune(self, heap, delayed, is_small: bool) -> None:\n        while heap:\n            num = -heap[0] if is_small else heap[0]\n            if delayed.get(num, 0):\n                heapq.heappop(heap)\n                delayed[num] -= 1\n                if delayed[num] == 0:\n                    del delayed[num]\n            else:\n                break\n\n    def remove(self, num: int) -> None:\n        med = self.get_median()\n        if num <= med:\n            self.delayed_small[num] = self.delayed_small.get(num, 0) + 1\n            self.sum_small -= num\n            self.small_size -= 1\n            if self.small and -self.small[0] == num:\n                self.prune(self.small, self.delayed_small, True)\n        else:\n            self.delayed_large[num] = self.delayed_large.get(num, 0) + 1\n            self.sum_large -= num\n            self.large_size -= 1\n            if self.large and self.large[0] == num:\n                self.prune(self.large, self.delayed_large, False)\n        self.balance()\n\n    def get_median(self) -> int:\n        return -self.small[0]\n\n    def get_cost(self) -> int:\n        med = self.get_median()\n        return med * self.small_size - self.sum_small + self.sum_large - med * self.large_size\n\nclass Solution:\n    def minOperations(self, nums: List[int], x: int, k: int) -> int:\n        n = len(nums)\n        m = n - x + 1\n        if m < k:\n            return -1\n        seg_cost = [0] * m\n        sm = SlidingMedian()\n        for i in range(x):\n            sm.push(nums[i])\n        seg_cost[0] = sm.get_cost()\n        for i in range(1, m):\n            sm.remove(nums[i-1])\n            sm.push(nums[i+x-1])\n            seg_cost[i] = sm.get_cost()\n        INF = 10**18\n        dp = [[INF]*(m+1) for _ in range(k+1)]\n        for i in range(m+1):\n            dp[0][i] = 0\n        for r in range(1, k+1):\n            for i in range(m-1, -1, -1):\n                if i + x <= m:\n                    candidate = seg_cost[i] + dp[r-1][i+x]\n                else:\n                    candidate = seg_cost[i] if r == 1 else INF\n                dp[r][i] = candidate if candidate < dp[r][i+1] else dp[r][i+1]\n        return dp[k][0] if dp[k][0] < INF else -1",
    "input": "minOperations(nums=[5,-2,1,3,7,3,6,4,-1], x=3, k=2)",
    "output": "8",
    "correct_condition": "minOperations(nums=[5,-2,1,3,7,3,6,4,-1], x=3, k=2) == 8",
    "contest_id": "weekly-contest-443",
    "contest_date": "2025-03-30T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 101,
      "coverage": null
    },
    "submission_id": 1590636659
  },
  {
    "id": "contest443_q3717_s1",
    "question_id": 3717,
    "function_name": "minOperations",
    "code": "import heapq\nimport math\n\nclass SlidingMedian:\n    def __init__(self):\n        self.L = []\n        self.H = []\n        self.d = {}\n        self.nL = 0\n        self.nH = 0\n        self.sL = 0\n        self.sH = 0\n\n    def clean(self, heap):\n        while heap:\n            num = -heap[0] if heap is self.L else heap[0]\n            if self.d.get(num, 0):\n                heapq.heappop(heap)\n                self.d[num] -= 1\n                if self.d[num] == 0:\n                    del self.d[num]\n            else:\n                break\n\n    def balance(self):\n        if self.nL > self.nH + 1:\n            self.clean(self.L)\n            num = -heapq.heappop(self.L)\n            self.nL -= 1\n            self.sL -= num\n            heapq.heappush(self.H, num)\n            self.nH += 1\n            self.sH += num\n        elif self.nL < self.nH:\n            self.clean(self.H)\n            num = heapq.heappop(self.H)\n            self.nH -= 1\n            self.sH -= num\n            heapq.heappush(self.L, -num)\n            self.nL += 1\n            self.sL += num\n\n    def add(self, num):\n        if self.nL == 0 or num <= -self.L[0]:\n            heapq.heappush(self.L, -num)\n            self.nL += 1\n            self.sL += num\n        else:\n            heapq.heappush(self.H, num)\n            self.nH += 1\n            self.sH += num\n        self.balance()\n\n    def rem(self, num):\n        self.d[num] = self.d.get(num, 0) + 1\n        if self.L and num <= -self.L[0]:\n            self.nL -= 1\n            self.sL -= num\n            if num == -self.L[0]:\n                self.clean(self.L)\n        else:\n            self.nH -= 1\n            self.sH -= num\n            if self.H and num == self.H[0]:\n                self.clean(self.H)\n        self.balance()\n\n    def cost(self):\n        self.clean(self.L)\n        m = -self.L[0]\n        return m * self.nL - self.sL + self.sH - m * self.nH\n\nclass Solution:\n    def minOperations(self, nums: List[int], x: int, k: int) -> int:\n        n = len(nums)\n        w = n - x + 1\n        costs = [0] * w\n        sm = SlidingMedian()\n        for i in range(x):\n            sm.add(nums[i])\n        costs[0] = sm.cost()\n        for i in range(w - 1):\n            sm.rem(nums[i])\n            sm.add(nums[i + x])\n            costs[i + 1] = sm.cost()\n        INF = math.inf\n        dp = [[INF] * (k + 1) for _ in range(w + 1)]\n        for i in range(w + 1):\n            dp[i][0] = 0\n        for i in range(w - 1, -1, -1):\n            for j in range(1, k + 1):\n                this = dp[i + 1][j]\n                if i + x <= w:\n                    this = min(this, costs[i] + dp[i + x][j - 1])\n                else:\n                    this = min(this, costs[i] if j == 1 else float('inf'))\n                dp[i][j] = this\n        return dp[0][k]\n",
    "input": "minOperations(nums=[5,-2,1,3,7,3,6,4,-1], x=3, k=2)",
    "output": "8",
    "correct_condition": "minOperations(nums=[5,-2,1,3,7,3,6,4,-1], x=3, k=2) == 8",
    "contest_id": "weekly-contest-443",
    "contest_date": "2025-03-30T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 98,
      "coverage": null
    },
    "submission_id": 1590654673
  },
  {
    "id": "contest443_q3717_s2",
    "question_id": 3717,
    "function_name": "compute_costs",
    "code": "class SlidingMedian:\n    def __init__(self):\n        # Two heaps: left is a max-heap (store negatives), right is a min-heap.\n        self.left = []    # max heap\n        self.right = []   # min heap\n        self.left_sum = 0\n        self.right_sum = 0\n        self.left_count = 0\n        self.right_count = 0\n        # Dictionaries for lazy removals.\n        self.del_left = {}\n        self.del_right = {}\n\n    def add(self, num: int):\n        # Add new number to one of the heaps.\n        if self.left_count == 0 or num <= -self.left[0]:\n            heapq.heappush(self.left, -num)\n            self.left_sum += num\n            self.left_count += 1\n        else:\n            heapq.heappush(self.right, num)\n            self.right_sum += num\n            self.right_count += 1\n        self._rebalance()\n\n    def remove(self, num: int):\n        # Remove a number (mark it for lazy deletion).\n        if self.left_count > 0 and num <= -self.left[0]:\n            self.left_sum -= num\n            self.left_count -= 1\n            self.del_left[-num] = self.del_left.get(-num, 0) + 1\n        else:\n            self.right_sum -= num\n            self.right_count -= 1\n            self.del_right[num] = self.del_right.get(num, 0) + 1\n        self._prune(self.left, self.del_left)\n        self._prune(self.right, self.del_right)\n        self._rebalance()\n\n    def _prune(self, heap, del_dict):\n        # Remove elements that have been marked for deletion.\n        while heap and del_dict.get(heap[0], 0):\n            val = heap[0]\n            del_dict[val] -= 1\n            if del_dict[val] == 0:\n                del del_dict[val]\n            heapq.heappop(heap)\n\n    def _rebalance(self):\n        # Ensure left has either equal number or one more element than right.\n        if self.left_count > self.right_count + 1:\n            self._prune(self.left, self.del_left)\n            num = -heapq.heappop(self.left)\n            self.left_sum -= num\n            self.left_count -= 1\n            heapq.heappush(self.right, num)\n            self.right_sum += num\n            self.right_count += 1\n        elif self.left_count < self.right_count:\n            self._prune(self.right, self.del_right)\n            num = heapq.heappop(self.right)\n            self.right_sum -= num\n            self.right_count -= 1\n            heapq.heappush(self.left, -num)\n            self.left_sum += num\n            self.left_count += 1\n\n    def get_median(self) -> int:\n        self._prune(self.left, self.del_left)\n        return -self.left[0] if self.left else 0\n\n    def get_cost(self) -> int:\n        # For median m, cost = m*(# left) - (sum of left) + (sum of right) - m*(# right)\n        m = self.get_median()\n        return m * self.left_count - self.left_sum + self.right_sum - m * self.right_count\n\nclass Solution:\n    def compute_costs(self, nums: List[int], x: int) -> List[int]:\n        n = len(nums)\n        if n < x:\n            return []\n        sm = SlidingMedian()\n        # Initialize with the first window.\n        for i in range(x):\n            sm.add(nums[i])\n        costs = [sm.get_cost()]\n        # Slide the window across nums.\n        for i in range(x, n):\n            sm.remove(nums[i - x])\n            sm.add(nums[i])\n            costs.append(sm.get_cost())\n        return costs\n    def minOperations(self, nums: List[int], x: int, k: int) -> int:\n        n = len(nums)\n        # If there are not enough elements to form k subarrays.\n        if n < k * x:\n            return -1\n\n        # Compute cost for every window of length x.\n        # cost[i] is the minimal operations to make nums[i:i+x] constant.\n        costs = self.compute_costs(nums, x)\n        N = len(costs)  # This equals n - x + 1\n\n        # dp[i][r] = minimum cost to choose r intervals from windows starting at index i.\n        dp = [[math.inf] * (k + 1) for _ in range(N + 1)]\n        for i in range(N + 1):\n            dp[i][0] = 0  # Cost 0 to choose 0 intervals.\n\n        # Precompute the next index if we take the window starting at i.\n        # Since each window covers x elements, next[i] = i + x (or N if i+x > N).\n        next_index = [min(i + x, N) for i in range(N)]\n        \n        # Fill the DP table in reverse.\n        for i in range(N - 1, -1, -1):\n            for r in range(1, k + 1):\n                # Option 1: Skip current window.\n                opt1 = dp[i + 1][r]\n                # Option 2: Take current window and add its cost.\n                opt2 = costs[i] + dp[next_index[i]][r - 1]\n                dp[i][r] = min(opt1, opt2)\n                \n        return dp[0][k] if dp[0][k] != math.inf else -1",
    "input": "compute_costs(nums=[5,-2,1,3,7,3,6,4,-1], x=3)",
    "output": "[7, 5, 6, 4, 4, 3, 7]",
    "correct_condition": "compute_costs(nums=[5,-2,1,3,7,3,6,4,-1], x=3) == [7, 5, 6, 4, 4, 3, 7]",
    "contest_id": "weekly-contest-443",
    "contest_date": "2025-03-30T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 122,
      "coverage": null
    },
    "submission_id": 1590655367
  },
  {
    "id": "contest444_q3773_s0",
    "question_id": 3773,
    "function_name": "minimumPairRemoval",
    "code": "class Solution:\n    def minimumPairRemoval(self, nums: List[int]) -> int:\n        x = nums\n        o = 0\n        while True:\n            f = True\n            p = 0\n            while p < len(x) - 1:\n                if x[p] > x[p+1]:\n                    f = False\n                    break\n                p += 1\n\n            if f:\n                break\n\n            mi = -1 \n            ms = float('inf')\n            k = 0\n            s = len(x)\n            while k < s - 1:\n                cs = x[k] + x[k+1]\n                if cs < ms:\n                    ms = cs\n                    mi = k\n                k += 1\n\n            if mi != -1:\n                replacement_val = x[mi] + x[mi+1]\n                x[mi] = replacement_val\n                x.pop(mi + 1)\n                o += 1\n            else:\n                break\n\n        return o\n",
    "input": "minimumPairRemoval(nums=[5,2,3,1])",
    "output": "2",
    "correct_condition": "minimumPairRemoval(nums=[5,2,3,1]) == 2",
    "contest_id": "weekly-contest-444",
    "contest_date": "2025-04-06T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 36,
      "coverage": null
    },
    "submission_id": 1597996116
  },
  {
    "id": "contest444_q3773_s1",
    "question_id": 3773,
    "function_name": "minimumPairRemoval",
    "code": "class Solution:\n    def minimumPairRemoval(self, nums: List[int]) -> int:\n        cnt = 0;\n        while nums != sorted(nums):\n            min_sum = inf\n            cnt += 1\n            for i in range(len(nums) - 1):\n                min_sum = min(min_sum, nums[i] + nums[i + 1])\n            for i in range(len(nums) - 1):\n                if nums[i] + nums[i + 1] == min_sum:\n                    nums = nums[:i] + [min_sum] + nums[i+2:]\n                    break\n        return cnt\n        ",
    "input": "minimumPairRemoval(nums=[5,2,3,1])",
    "output": "2",
    "correct_condition": "minimumPairRemoval(nums=[5,2,3,1]) == 2",
    "contest_id": "weekly-contest-444",
    "contest_date": "2025-04-06T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 14,
      "coverage": null
    },
    "submission_id": 1597989422
  },
  {
    "id": "contest444_q3773_s2",
    "question_id": 3773,
    "function_name": "minimumPairRemoval",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def minimumPairRemoval(self, nums: List[int]) -> int:\n        def is_sorted(arr):\n            return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))\n        \n        if is_sorted(nums):\n            return 0\n        \n        midx = 0\n        mins = nums[0] + nums[1]\n        for i in range(1, len(nums)-1):\n            csum = nums[i] + nums[i+1]\n            if csum < mins:\n                mins = csum\n                midx = i\n        \n        add = nums[midx] + nums[midx+1]\n        numn = nums[:midx] + [add] + nums[midx+2:]\n        \n        return 1 + self.minimumPairRemoval(numn)\n\n",
    "input": "minimumPairRemoval(nums=[5,2,3,1])",
    "output": "2",
    "correct_condition": "minimumPairRemoval(nums=[5,2,3,1]) == 2",
    "contest_id": "weekly-contest-444",
    "contest_date": "2025-04-06T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 221,
      "coverage": null
    },
    "submission_id": 1598055455
  },
  {
    "id": "contest444_q3777_s0",
    "question_id": 3777,
    "function_name": "maxProduct",
    "code": "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def maxProduct(self, a: List[int], b: int, c: int) -> int:\n        a = (a.copy(), b, c)\n        d = float('inf')\n        e = defaultdict(set)\n        \n        i = 0\n        while i < len(a[0]):\n            f = defaultdict(set)\n            g = a[0][i]\n            for h in e:\n                f[h] |= e[h]\n            \n            if g == 0:\n                f[(1, 0)].add(0)\n            else:\n                if g <= c:\n                    f[(1, g)].add(g)\n                else:\n                    f[(1, d)].add(g)\n            \n            j = list(e.keys())\n            k = 0\n            while k < len(j):\n                (l, m) = j[k]\n                for n in e[(l, m)]:\n                    o = 1 - l\n                    p = n + g if l == 0 else n - g\n                    if g == 0:\n                        q = 0\n                    else:\n                        if m == d:\n                            q = d\n                        else:\n                            r = m * g\n                            q = r if r <= c else d\n                    f[(o, q)].add(p)\n                k += 1\n            \n            e = f\n            i += 1\n        \n        s = -1\n        j = list(e.keys())\n        t = 0\n        while t < len(j):\n            (l, m) = j[t]\n            if m != d and b in e[(l, m)]:\n                s = max(s, m)\n            t += 1\n        \n        return s\n",
    "input": "maxProduct(a=[1,2,3], b=2, c=10)",
    "output": "6",
    "correct_condition": "maxProduct(a=[1,2,3], b=2, c=10) == 6",
    "contest_id": "weekly-contest-444",
    "contest_date": "2025-04-06T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 55,
      "coverage": null
    },
    "submission_id": 1598062192
  },
  {
    "id": "contest444_q3777_s1",
    "question_id": 3777,
    "function_name": "maxProduct",
    "code": "class Solution:\n    def maxProduct(self, nums: List[int], k: int, limit: int) -> int:\n        dp = set([(0, 0, 1, True)])\n        for num in nums:\n            newdp = []\n            for s, f, p, flag in dp:\n                if f == 0:\n                    news = s + num\n                else:\n                    news = s - num\n                newf = 1 - f\n                newp = p * num\n                if newp > limit:\n                    newp = limit + 1\n                newdp.append((news, newf, newp, False))\n            for t in newdp:\n                dp.add(t)\n        ans = -1\n        # print(dp)\n        for s, f, p, flag in dp:\n            if flag == False and s == k and p <= limit:\n                ans = max(ans, p)\n        return ans",
    "input": "maxProduct(nums=[1,2,3], k=2, limit=10)",
    "output": "6",
    "correct_condition": "maxProduct(nums=[1,2,3], k=2, limit=10) == 6",
    "contest_id": "weekly-contest-444",
    "contest_date": "2025-04-06T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 23,
      "coverage": null
    },
    "submission_id": 1598041064
  },
  {
    "id": "contest444_q3777_s2",
    "question_id": 3777,
    "function_name": "maxProduct",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nfrom collections import defaultdict\nfrom typing import List, Dict, Set, Tuple\n\ndef cdp(dp: Dict[Tuple[int, int], Set[int]]) -> Dict[Tuple[int, int], Set[int]]:\n    ndp = defaultdict(set)\n    for state, ast in dp.items():\n        ndp[state] |= ast\n    return ndp\n\ndef updates(ndp: Dict[Tuple[int, int], Set[int]], x: int, limit: int, INF: float) -> None:\n    if x == 0:\n        ndp[(1, 0)].add(0)\n    else:\n        if x <= limit:\n            ndp[(1, x)].add(x)\n        else:\n            ndp[(1, INF)].add(x)\n\ndef updates2(ndp: Dict[Tuple[int, int], Set[int]], dp: Dict[Tuple[int, int], Set[int]], x: int, limit: int, INF: float) -> None:\n    for (parity, prod), ast in dp.items():\n        for alt in ast:\n            npp = 1 - parity\n            na = alt + x if parity == 0 else alt - x\n            if x == 0:\n                prodn = 0\n            else:\n                if prod == INF:\n                    prodn = INF\n                else:\n                    cd = prod * x\n                    prodn = cd if cd <= limit else INF\n            ndp[(npp, prodn)].add(na)\n\ndef solve(nums: List[int], limit: int, INF: float) -> Dict[Tuple[int, int], Set[int]]:\n    dp = defaultdict(set)\n    for x in nums:\n        ndp = cdp(dp)\n        updates(ndp, x, limit, INF)\n        updates2(ndp, dp, x, limit, INF)\n        dp = ndp\n    return dp\n\nclass Solution:\n    def maxProduct(self, nums: List[int], k: int, limit: int) -> int:\n        INF = float('inf')\n        \n        dp = solve(nums, limit, INF)\n        \n        best = -1\n        for (parity, prod), ast in dp.items():\n            if prod != INF and k in ast:\n                best = max(best, prod)\n        return best\n",
    "input": "maxProduct(nums=[1,2,3], k=2, limit=10)",
    "output": "6",
    "correct_condition": "maxProduct(nums=[1,2,3], k=2, limit=10) == 6",
    "contest_id": "weekly-contest-444",
    "contest_date": "2025-04-06T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 253,
      "coverage": null
    },
    "submission_id": 1598066053
  },
  {
    "id": "contest444_q3772_s0",
    "question_id": 3772,
    "function_name": "minimumPairRemoval",
    "code": "import heapq\n\nclass Node:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n        self.prev = None\n        self.next = None\n        self.removed = False\n\nclass Pair:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n    \n    def __lt__(self, other):\n        if self.a == other.a:\n            return self.b.b < other.b.b\n        return self.a < other.a\n\n\nclass Solution:\n    def minimumPairRemoval(self, nums: List[int]) -> int:\n        a = nums\n        b = list(map(int, a))\n        c = len(b)\n        if c == 0:\n            return 0\n        d = Node(b[0], 0)\n        e = d\n        f = 1\n        while f < c:\n            g = Node(b[f], f)\n            g.prev = e\n            e.next = g\n            e = g\n            f += 1\n        h = 0\n        i = d\n        while i and i.next:\n            if i.a > i.next.a:\n                h += 1\n            i = i.next\n        j = []\n        i = d\n        while i and i.next:\n            heapq.heappush(j, Pair(i.a + i.next.a, i))\n            i = i.next\n        k = 0\n        while h > 0 and j:\n            l = heapq.heappop(j)\n            m = l.b\n            if m.removed or not m.next or m.next.removed:\n                continue\n            if m.a + m.next.a != l.a:\n                continue\n            n = m.next\n            if m.prev and m.prev.a > m.a:\n                h -= 1\n            if n.next and n.a > n.next.a:\n                h -= 1\n            if m.a > n.a:\n                h -= 1\n            o = Node(m.a + n.a, m.b)\n            o.prev = m.prev\n            o.next = n.next\n            if o.prev:\n                o.prev.next = o\n                if o.prev.a > o.a:\n                    h += 1\n            if o.next:\n                o.next.prev = o\n                if o.a > o.next.a:\n                    h += 1\n            m.removed = True\n            n.removed = True\n            k += 1\n            if o.prev:\n                heapq.heappush(j, Pair(o.prev.a + o.a, o.prev))\n            if o.next:\n                heapq.heappush(j, Pair(o.a + o.next.a, o))\n        return k\n",
    "input": "minimumPairRemoval(nums=[5,2,3,1])",
    "output": "2",
    "correct_condition": "minimumPairRemoval(nums=[5,2,3,1]) == 2",
    "contest_id": "weekly-contest-444",
    "contest_date": "2025-04-06T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 82,
      "coverage": null
    },
    "submission_id": 1598020045
  },
  {
    "id": "contest444_q3772_s2",
    "question_id": 3772,
    "function_name": "minimumPairRemoval",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def minimumPairRemoval(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n <= 1:\n            return 0\n        if all(nums[i] <= nums[i+1] for i in range(n-1)):\n            return 0\n        \n        maxn = 2 * n  \n        val    = [0] * maxn  \n        left   = [-1] * maxn\n        right  = [-1] * maxn \n        pos    = [0] * maxn  \n        ls = [False] * maxn  \n        for i, num in enumerate(nums):\n            val[i] = num\n            pos[i] = i\n            ls[i] = True\n            left[i] = i - 1 if i > 0 else -1\n            right[i] = i + 1 if i < n - 1 else -1\n        \n        st = set()\n        i = 0\n        while i != -1:\n            r = right[i]\n            if r != -1 and ls[i] and ls[r] and val[i] > val[r]:\n                st.add(i)\n            i = right[i]\n\n        heap = []\n        for i in range(n - 1):\n            j = right[i]\n            heappush(heap, (val[i] + val[j], pos[i], i))\n        \n        ans = 0\n        nid = n \n        \n        def updates(idx):\n            if idx == -1 or not ls[idx]:\n                return\n            r = right[idx]\n            if r != -1 and ls[r] and val[idx] > val[r]:\n                st.add(idx)\n            else:\n                st.discard(idx)\n        \n        while st:\n            while heap:\n                sump, p, i = heappop(heap)\n                if not ls[i]:\n                    continue\n                j = right[i]\n                if j == -1 or not ls[j]:\n                    continue\n                if sump != val[i] + val[j]:\n                    continue\n                break\n            else:\n                i = next(iter(st))\n                j = right[i]\n            \n            ns = val[i] + val[j]\n            npos = pos[i] \n            indn = nid\n            nid += 1\n            val[indn] = ns\n            pos[indn] = npos\n            ls[indn] = True\n            \n            l = left[i]    \n            r = right[j]   \n            left[indn] = l\n            right[indn] = r\n            if l != -1:\n                right[l] = indn\n            if r != -1:\n                left[r] = indn\n            \n            ls[i] = False\n            ls[j] = False\n            st.discard(i)\n            st.discard(j)\n            \n            updates(l)\n            updates(indn)\n            updates(r)\n            \n            if l != -1 and ls[l]:\n                heappush(heap, (val[l] + val[indn], pos[l], l))\n            if r != -1 and ls[r]:\n                heappush(heap, (val[indn] + val[r], npos, indn))\n            \n            ans += 1\n        \n        return ans\n\n",
    "input": "minimumPairRemoval(nums=[5,2,3,1])",
    "output": "2",
    "correct_condition": "minimumPairRemoval(nums=[5,2,3,1]) == 2",
    "contest_id": "weekly-contest-444",
    "contest_date": "2025-04-06T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 298,
      "coverage": null
    },
    "submission_id": 1598048935
  },
  {
    "id": "contest445_q3830_s0",
    "question_id": 3830,
    "function_name": "findClosest",
    "code": "class Solution:\n    def findClosest(self, x: int, y: int, z: int) -> int:\n        if abs(z-x) < abs(z-y):\n            return 1\n        elif abs(z-y) < abs(z-x):\n            return 2\n        return 0\n",
    "input": "findClosest(x=2, y=7, z=4)",
    "output": "1",
    "correct_condition": "findClosest(x=2, y=7, z=4) == 1",
    "contest_id": "weekly-contest-445",
    "contest_date": "2025-04-13T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 7,
      "coverage": null
    },
    "submission_id": 1605121226
  },
  {
    "id": "contest445_q3830_s1",
    "question_id": 3830,
    "function_name": "findClosest",
    "code": "class Solution:\n    def findClosest(self, x: int, y: int, z: int) -> int:\n        if abs(z - y) == abs(z - x):\n            return 0\n        elif abs(z - y) < abs(z - x):\n            return 2\n        else:\n            return 1",
    "input": "findClosest(x=2, y=7, z=4)",
    "output": "1",
    "correct_condition": "findClosest(x=2, y=7, z=4) == 1",
    "contest_id": "weekly-contest-445",
    "contest_date": "2025-04-13T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 8,
      "coverage": null
    },
    "submission_id": 1605117709
  },
  {
    "id": "contest445_q3830_s2",
    "question_id": 3830,
    "function_name": "findClosest",
    "code": "class Solution:\n    def findClosest(self, x: int, y: int, z: int) -> int:\n        d1, d2 = abs(x - z), abs(y - z)\n        return 1 if d1 < d2 else 2 if d2 < d1 else 0\n",
    "input": "findClosest(x=2, y=7, z=4)",
    "output": "1",
    "correct_condition": "findClosest(x=2, y=7, z=4) == 1",
    "contest_id": "weekly-contest-445",
    "contest_date": "2025-04-13T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 4,
      "coverage": null
    },
    "submission_id": 1605121176
  },
  {
    "id": "contest445_q3812_s0",
    "question_id": 3812,
    "function_name": "smallestPalindrome",
    "code": "class Solution:\n    def smallestPalindrome(self, s: str) -> str:\n        freq = [0] * 26\n        for ch in s:\n            freq[ord(ch) - ord('a')] += 1\n    \n        center = \"\"\n        for i in range(26):\n            if freq[i] % 2 == 1:\n                center = chr(i + ord('a'))\n                freq[i] -= 1\n                break\n        \n        first_half = []\n        for i in range(26):\n            first_half.append(chr(i + ord('a')) * (freq[i] // 2))\n        \n        first_half_str = \"\".join(first_half)\n        result = first_half_str + center + first_half_str[::-1]\n        return result\n",
    "input": "smallestPalindrome(s=\"z\")",
    "output": "'z'",
    "correct_condition": "smallestPalindrome(s=\"z\") == 'z'",
    "contest_id": "weekly-contest-445",
    "contest_date": "2025-04-13T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 20,
      "coverage": null
    },
    "submission_id": 1605113299
  },
  {
    "id": "contest445_q3812_s1",
    "question_id": 3812,
    "function_name": "smallestPalindrome",
    "code": "class Solution:\n    def smallestPalindrome(self, s: str) -> str:\n        charCount = {}\n        for char in s:\n            charCount[char] = charCount.get(char, 0) + 1\n        \n        oddChar = None\n        for char, count in charCount.items():\n            if count % 2 == 1:\n                if oddChar is None or char < oddChar:\n                    oddChar = char\n        \n        leftHalf = []\n        for char in sorted(charCount.keys()):\n            if char == oddChar:\n                leftHalf.extend([char] * ((charCount[char] - 1) // 2))\n            else:\n                leftHalf.extend([char] * (charCount[char] // 2))\n        \n        middle = [oddChar] if oddChar is not None else []\n        \n        rightHalf = leftHalf.copy()\n        rightHalf.reverse()\n        \n        return ''.join(leftHalf + middle + rightHalf)",
    "input": "smallestPalindrome(s=\"z\")",
    "output": "'z'",
    "correct_condition": "smallestPalindrome(s=\"z\") == 'z'",
    "contest_id": "weekly-contest-445",
    "contest_date": "2025-04-13T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 25,
      "coverage": null
    },
    "submission_id": 1605120842
  },
  {
    "id": "contest445_q3812_s2",
    "question_id": 3812,
    "function_name": "smallestPalindrome",
    "code": "class Solution:\n    def smallestPalindrome(self, s: str) -> str:\n        c = Counter(s)\n        arr = []\n        mid = \"\"\n        for x in sorted(c):\n            n = c[x] // 2\n            arr.append(x * n)\n            if c[x] % 2:\n                mid = x\n        left = \"\".join(arr)\n        return left + mid + left[::-1]\n",
    "input": "smallestPalindrome(s=\"z\")",
    "output": "'z'",
    "correct_condition": "smallestPalindrome(s=\"z\") == 'z'",
    "contest_id": "weekly-contest-445",
    "contest_date": "2025-04-13T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 12,
      "coverage": null
    },
    "submission_id": 1605125714
  },
  {
    "id": "contest445_q3813_s0",
    "question_id": 3813,
    "function_name": "smallestPalindrome",
    "code": "class Solution:\n    def smallestPalindrome(self, s: str, k: int) -> str:\n        freq = [0] * 26\n        for ch in s:\n            freq[ord(ch) - ord('a')] += 1\n\n        half_counts = [count // 2 for count in freq]\n        L = sum(half_counts)\n        center = \"\"\n        for i in range(26):\n            if freq[i] % 2 == 1:\n                center = chr(i + ord('a'))\n                break\n        \n        def count_permutations(counts, cap_value):\n            total = sum(counts)\n            result = 1\n            rem = total\n            for m in counts:\n                if m > 0:\n                    result *= comb(rem, m)\n                    if result > cap_value:\n                        return cap_value\n                    rem -= m\n            return result\n\n        total_count = count_permutations(half_counts, k + 1)\n        if total_count < k:\n            return \"\"\n\n        first_half = []\n        for _ in range(L):\n            for letter in range(26):\n                if half_counts[letter] > 0:\n                    half_counts[letter] -= 1\n                    count_here = count_permutations(half_counts, k + 1)\n                    if count_here >= k:\n                        first_half.append(chr(letter + ord('a')))\n                        break\n                    else:\n                        k -= count_here\n                        half_counts[letter] += 1\n            else:\n                return \"\"\n        first_half_str = \"\".join(first_half)\n        return first_half_str + center + first_half_str[::-1]\n",
    "input": "smallestPalindrome(s=\"abba\", k=2)",
    "output": "'baab'",
    "correct_condition": "smallestPalindrome(s=\"abba\", k=2) == 'baab'",
    "contest_id": "weekly-contest-445",
    "contest_date": "2025-04-13T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 46,
      "coverage": null
    },
    "submission_id": 1605121925
  },
  {
    "id": "contest445_q3813_s1",
    "question_id": 3813,
    "function_name": "smallestPalindrome",
    "code": "import math\nfrom collections import Counter\n\nclass Solution:\n    def smallestPalindrome(self, s: str, k: int) -> str:\n        def getCount(countMap, total, limit):\n            ways = 1\n            for ch in sorted(countMap):\n                cnt = countMap[ch]\n                if cnt:\n                    ways *= math.comb(total, cnt)\n                    total -= cnt\n                    if ways > limit:\n                        return ways\n            return ways\n        countMap = Counter(s)\n        oddChar = \"\"\n        halfMap = {}\n        for ch in sorted(countMap.keys()):\n            if countMap[ch] % 2 != 0:\n                oddChar = ch\n            halfMap[ch] = countMap[ch] // 2\n        totalHalf = sum(halfMap.values())\n        totalWays = getCount(halfMap, totalHalf, k)\n        if totalWays < k:\n            return \"\"\n        leftHalf = []\n        for _ in range(totalHalf):\n            for ch in sorted(halfMap.keys()):\n                if halfMap[ch] > 0:\n                    halfMap[ch] -= 1\n                    ways = getCount(halfMap, totalHalf - len(leftHalf) - 1, k)\n                    if ways >= k:\n                        leftHalf.append(ch)\n                        break\n                    else:\n                        k -= ways\n                        halfMap[ch] += 1\n        return \"\".join(leftHalf) + oddChar + \"\".join(leftHalf[::-1])",
    "input": "smallestPalindrome(s=\"abba\", k=2)",
    "output": "'baab'",
    "correct_condition": "smallestPalindrome(s=\"abba\", k=2) == 'baab'",
    "contest_id": "weekly-contest-445",
    "contest_date": "2025-04-13T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 39,
      "coverage": null
    },
    "submission_id": 1605122324
  },
  {
    "id": "contest445_q3813_s2",
    "question_id": 3813,
    "function_name": "smallestPalindrome",
    "code": "class Solution:\n    def smallestPalindrome(self, s: str, k: int) -> str:\n        c = Counter(s)\n        mid = \"\"\n        h = {}\n        for x in sorted(c):\n            if c[x] % 2:\n                mid = x\n            h[x] = c[x] // 2\n\n        n = sum(h.values())\n        et = math.factorial(n)\n        # print(\"et\", et)\n\n        for v in h.values():\n            et //= math.factorial(v)\n        # print(\"et\", et)\n\n        if et < k:\n            ans = \"\"\n            return ans\n\n        arr = []\n        while n:\n            for x in sorted(h):\n                if h[x]:\n                    w = et * h[x] // n\n                    if k > w:\n                        k -= w\n                    else:\n                        arr.append(x)\n                        et = w\n                        h[x] -= 1\n                        n -= 1\n                        break\n        ans = \"\".join(arr) + mid + \"\".join(arr[::-1])\n        # print(\"arr\", arr)\n\n        return ans\n",
    "input": "smallestPalindrome(s=\"abba\", k=2)",
    "output": "'baab'",
    "correct_condition": "smallestPalindrome(s=\"abba\", k=2) == 'baab'",
    "contest_id": "weekly-contest-445",
    "contest_date": "2025-04-13T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 39,
      "coverage": null
    },
    "submission_id": 1605133535
  },
  {
    "id": "contest445_q3810_s0",
    "question_id": 3810,
    "function_name": "countNumbers",
    "code": "\nfrom functools import lru_cache\n\nMOD = 10**9 + 7\n\ndef to_base(n: int, b: int) -> list:\n    if n == 0:\n        return [0]\n    digits = []\n    while n:\n        digits.append(n % b)\n        n //= b\n    return digits[::-1]\n\ndef str_decrement(s: str) -> str:\n    n = int(s)\n    return str(n - 1) if n > 0 else \"0\"\n\n\ndef count_non_decreasing(s: str, b: int) -> int:\n    digits = to_base(int(s), b)\n    n = len(digits)\n    \n    @lru_cache(maxsize=None)\n    def dp(pos: int, prev: int, tight: bool, leading_zero: bool) -> int:\n        if pos == n:\n            return 0 if leading_zero else 1\n\n        limit = digits[pos] if tight else b - 1\n        total = 0\n\n        for d in range(0, limit + 1):\n            if not leading_zero and d < prev:\n                continue\n\n            new_tight = tight and (d == limit)\n            new_leading_zero = leading_zero and (d == 0)\n            new_prev = d if not new_leading_zero else 0\n            total = (total + dp(pos + 1, new_prev, new_tight, new_leading_zero)) % MOD\n        \n        return total\n\n    return dp(0, 0, True, True)\n\nclass Solution:\n    def countNumbers(self, l: str, r: str, b: int) -> int:\n        count_r = count_non_decreasing(r, b)\n        count_l_minus = count_non_decreasing(str_decrement(l), b)\n        return (count_r - count_l_minus) % MOD\n        ",
    "input": "countNumbers(l=\"23\", r=\"28\", b=8)",
    "output": "3",
    "correct_condition": "countNumbers(l=\"23\", r=\"28\", b=8) == 3",
    "contest_id": "weekly-contest-445",
    "contest_date": "2025-04-13T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 50,
      "coverage": null
    },
    "submission_id": 1605124396
  },
  {
    "id": "contest445_q3810_s1",
    "question_id": 3810,
    "function_name": "countNumbers",
    "code": "import sys\nsys.setrecursionlimit(10000)\n\nMOD = 10**9 + 7\n\nclass Solution:\n    def countNumbers(self, l: str, r: str, b: int) -> int:\n        def conv(x):\n            n = []\n            if x == 0:\n                return [0]\n            while x:\n                n.append(x % b)\n                x //= b\n            return n[::-1]\n        def calc(x):\n            d = conv(x)\n            n = len(d)\n            from functools import lru_cache\n            @lru_cache(maxsize = None)\n            def dp(i, last, tight):\n                if i == n:\n                    return 1\n                lim = d[i] if tight else b - 1\n                s = 0\n                if last == -1:\n                    for x in range(0, lim + 1):\n                        nt = tight and (x == lim)\n                        if x == 0:\n                            s = (s + dp(i + 1, -1, nt)) % MOD\n                        else:\n                            s = (s + dp(i + 1, x, nt)) % MOD\n                else:\n                    for x in range(last, lim + 1):\n                        nt = tight and (x == lim)\n                        s = (s + dp(i + 1, x, nt)) % MOD\n                return s\n            return dp(0, -1, True)\n        L = int(l)\n        R = int(r)\n        a = calc(R)\n        bVal = calc(L - 1) if L > 0 else 0\n        return (a - bVal) % MOD",
    "input": "countNumbers(l=\"23\", r=\"28\", b=8)",
    "output": "3",
    "correct_condition": "countNumbers(l=\"23\", r=\"28\", b=8) == 3",
    "contest_id": "weekly-contest-445",
    "contest_date": "2025-04-13T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 43,
      "coverage": null
    },
    "submission_id": 1605130930
  },
  {
    "id": "contest445_q3810_s2",
    "question_id": 3810,
    "function_name": "countNumbers",
    "code": "MOD = 10 ** 9 + 7\n\n\nclass Solution:\n    def countNumbers(self, l: str, r: str, b: int) -> int:\n        def g(n):\n            n = int(n)\n            if n <= 0:\n                return []\n            arr = []\n            while n:\n                arr.append(n % b)\n                n //= b\n            return arr[::-1]\n\n        def f(n):\n            n = int(n)\n            if n <= 0:\n                return 0\n            x = g(str(n))\n            LIM = len(x)\n\n            @lru_cache(maxsize=None)\n            def dp(i, j, k, flag):\n                if i == LIM:\n                    return 1 if flag else 0\n\n                lim = x[i] if k else b - 1\n                # print(\"i\", i, \"j\", j, \"k\", k, \"flag\", flag, \"lim\", lim)\n\n                val = 0\n                for d in range(lim + 1):\n                    next_val = k and (d == lim)\n                    if not flag:\n                        if d == 0:\n                            val += dp(i + 1, 0, next_val, False)\n                            # print(\"i\", i, \"j\", j, \"k\", k, \"flag\", flag, \"d\", d, \"val\", val)\n                        else:\n                            val += dp(i + 1, d, next_val, True)\n                            # print(\"i\", i, \"j\", j, \"k\", k, \"flag\", flag, \"d\", d, \"val\", val)\n                    else:\n                        if d < j:\n                            continue\n                        val += dp(i + 1, d, next_val, True)\n                        # print(\"i\", i, \"j\", j, \"k\", k, \"flag\", flag, \"d\", d, \"val\", val)\n                return val % MOD\n\n            return dp(0, 0, True, False)\n\n        # print(\"l\", l)\n        return (f(r) - f(str(int(l) - 1))) % MOD\n",
    "input": "countNumbers(l=\"23\", r=\"28\", b=8)",
    "output": "3",
    "correct_condition": "countNumbers(l=\"23\", r=\"28\", b=8) == 3",
    "contest_id": "weekly-contest-445",
    "contest_date": "2025-04-13T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 51,
      "coverage": null
    },
    "submission_id": 1605144099
  },
  {
    "id": "contest446_q3732_s0",
    "question_id": 3732,
    "function_name": "calculateScore",
    "code": "class Solution:\n    def calculateScore(self, instructions: List[str], values: List[int]) -> int:\n        n = len(instructions)\n        v = set()\n        i = 0\n        s = 0\n\n        while 0 <= i < n:\n            if i in v:\n                break\n            v.add(i)\n            if instructions[i] == \"add\":\n                s += values[i]\n                i += 1\n            else:\n                i += values[i]\n\n        return s\n",
    "input": "calculateScore(instructions=[\"jump\",\"add\",\"add\",\"jump\",\"add\",\"jump\"], values=[2,1,3,1,-2,-3])",
    "output": "1",
    "correct_condition": "calculateScore(instructions=[\"jump\",\"add\",\"add\",\"jump\",\"add\",\"jump\"], values=[2,1,3,1,-2,-3]) == 1",
    "contest_id": "weekly-contest-446",
    "contest_date": "2025-04-20T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 18,
      "coverage": null
    },
    "submission_id": 1612012426
  },
  {
    "id": "contest446_q3732_s1",
    "question_id": 3732,
    "function_name": "calculateScore",
    "code": "class Solution:\n    def calculateScore(self, instructions: List[str], values: List[int]) -> int:\n        n = len(instructions)\n        visited = [False] * n\n        i = 0\n        score = 0\n        while 0 <= i < n and not visited[i]:\n            visited[i] = True\n            if instructions[i] == \"add\":\n                score += values[i]\n                i += 1\n            else:\n                i += values[i]\n        return score",
    "input": "calculateScore(instructions=[\"jump\",\"add\",\"add\",\"jump\",\"add\",\"jump\"], values=[2,1,3,1,-2,-3])",
    "output": "1",
    "correct_condition": "calculateScore(instructions=[\"jump\",\"add\",\"add\",\"jump\",\"add\",\"jump\"], values=[2,1,3,1,-2,-3]) == 1",
    "contest_id": "weekly-contest-446",
    "contest_date": "2025-04-20T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 14,
      "coverage": null
    },
    "submission_id": 1612022105
  },
  {
    "id": "contest446_q3732_s2",
    "question_id": 3732,
    "function_name": "calculateScore",
    "code": "class Solution:\n    def calculateScore(self, instructions: List[str], values: List[int]) -> int:\n        n = len(instructions)\n        visited = set()\n        score = 0\n        i = 0\n        \n        while 0 <= i < n:\n            if i in visited:\n                break\n                \n            visited.add(i)\n            if instructions[i] == \"add\":\n                score += values[i]\n                i += 1\n            elif instructions[i] == \"jump\":\n                i = i + values[i]\n                \n        return score",
    "input": "calculateScore(instructions=[\"jump\",\"add\",\"add\",\"jump\",\"add\",\"jump\"], values=[2,1,3,1,-2,-3])",
    "output": "1",
    "correct_condition": "calculateScore(instructions=[\"jump\",\"add\",\"add\",\"jump\",\"add\",\"jump\"], values=[2,1,3,1,-2,-3]) == 1",
    "contest_id": "weekly-contest-446",
    "contest_date": "2025-04-20T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 19,
      "coverage": null
    },
    "submission_id": 1611993158
  },
  {
    "id": "contest446_q3738_s0",
    "question_id": 3738,
    "function_name": "maximumPossibleSize",
    "code": "class Solution:\n    def maximumPossibleSize(self, nums: List[int]) -> int:\n        a = []\n        for b in nums:\n            a.append(b)\n            while len(a) >= 2 and a[-2] > a[-1]:\n                a.pop()\n        return len(a)\n",
    "input": "maximumPossibleSize(nums=[4,2,5,3,5])",
    "output": "3",
    "correct_condition": "maximumPossibleSize(nums=[4,2,5,3,5]) == 3",
    "contest_id": "weekly-contest-446",
    "contest_date": "2025-04-20T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 8,
      "coverage": null
    },
    "submission_id": 1612012595
  },
  {
    "id": "contest446_q3738_s1",
    "question_id": 3738,
    "function_name": "maximumPossibleSize",
    "code": "class Solution:\n    def maximumPossibleSize(self, nums: List[int]) -> int:\n        res = 0\n        mx = float('-inf')\n        for el in nums:\n            if el >= mx:\n                mx = el\n                res += 1\n        return res",
    "input": "maximumPossibleSize(nums=[4,2,5,3,5])",
    "output": "3",
    "correct_condition": "maximumPossibleSize(nums=[4,2,5,3,5]) == 3",
    "contest_id": "weekly-contest-446",
    "contest_date": "2025-04-20T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 9,
      "coverage": null
    },
    "submission_id": 1612019160
  },
  {
    "id": "contest446_q3738_s2",
    "question_id": 3738,
    "function_name": "maximumPossibleSize",
    "code": "class Solution:\n    def maximumPossibleSize(self, nums: List[int]) -> int:\n        stack = []\n        for currVal in nums:\n            stack.append(currVal)\n            while len(stack) > 1 and stack[-2] > stack[-1]:\n                lastVal = stack.pop()\n                prevVal = stack.pop()\n                stack.append(lastVal if lastVal > prevVal else prevVal)\n        return len(stack)",
    "input": "maximumPossibleSize(nums=[4,2,5,3,5])",
    "output": "3",
    "correct_condition": "maximumPossibleSize(nums=[4,2,5,3,5]) == 3",
    "contest_id": "weekly-contest-446",
    "contest_date": "2025-04-20T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 10,
      "coverage": null
    },
    "submission_id": 1612002603
  },
  {
    "id": "contest446_q3831_s0",
    "question_id": 3831,
    "function_name": "resultArray",
    "code": "class Solution:\n    def resultArray(self, nums: List[int], k: int) -> List[int]:\n        res = [0] * k\n        prev = [0] * k\n\n        for n in nums:\n            m = n % k\n            cur = [0] * k\n            cur[m] += 1\n            for r in range(k):\n                if prev[r]:\n                    new_r = (r * m) % k\n                    cur[new_r] += prev[r]\n            for r in range(k):\n                res[r] += cur[r]\n            prev = cur\n\n        return res\n",
    "input": "resultArray(nums=[1,2,3,4,5], k=3)",
    "output": "[9, 2, 4]",
    "correct_condition": "resultArray(nums=[1,2,3,4,5], k=3) == [9, 2, 4]",
    "contest_id": "weekly-contest-446",
    "contest_date": "2025-04-20T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 18,
      "coverage": null
    },
    "submission_id": 1612012857
  },
  {
    "id": "contest446_q3831_s1",
    "question_id": 3831,
    "function_name": "resultArray",
    "code": "class Solution:\n    def resultArray(self, nums: List[int], k: int) -> List[int]:\n        res = [0] * k\n        dp = [0] * k\n        for a in nums:\n            ndp = [0] * k\n            am = a % k\n            ndp[am] += 1\n            for r in range(k):\n                if dp[r]:\n                    ndp[(r * am) % k] += dp[r]\n            for r in range(k):\n                res[r] += ndp[r]\n            dp = ndp\n        return res",
    "input": "resultArray(nums=[1,2,3,4,5], k=3)",
    "output": "[9, 2, 4]",
    "correct_condition": "resultArray(nums=[1,2,3,4,5], k=3) == [9, 2, 4]",
    "contest_id": "weekly-contest-446",
    "contest_date": "2025-04-20T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 15,
      "coverage": null
    },
    "submission_id": 1612015311
  },
  {
    "id": "contest446_q3831_s2",
    "question_id": 3831,
    "function_name": "resultArray",
    "code": "class Solution:\n    def resultArray(self, nums: List[int], k: int) -> List[int]:\n        result = [0] * k\n        curr = [0] * k\n        for num in nums:\n            m = num % k\n            newCurr = [0] * k\n            for r in range(k):\n                newCurr[(r * m) % k] += curr[r]\n            newCurr[m] += 1\n            curr = newCurr\n            for r in range(k):\n                result[r] += curr[r]\n        return result",
    "input": "resultArray(nums=[1,2,3,4,5], k=3)",
    "output": "[9, 2, 4]",
    "correct_condition": "resultArray(nums=[1,2,3,4,5], k=3) == [9, 2, 4]",
    "contest_id": "weekly-contest-446",
    "contest_date": "2025-04-20T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 14,
      "coverage": null
    },
    "submission_id": 1612005272
  },
  {
    "id": "contest446_q3840_s0",
    "question_id": 3840,
    "function_name": "resultArray",
    "code": "class Solution:\n    def resultArray(self, nums: List[int], k: int, queries: List[List[int]]) -> List[int]:\n        def range_query(left, right):\n            left_prod, right_prod = 1, 1\n            left_counts = [0] * k\n            right_counts = [0] * k\n            l, r = left + seg_size, right + seg_size\n\n            while l < r:\n                if l & 1:\n                    merged = [0] * k\n                    for i in range(k):\n                        merged[i] += left_counts[i]\n                    for i in range(k):\n                        if tree_counts[l][i]:\n                            merged[(left_prod * i) % k] += tree_counts[l][i]\n                    left_prod = (left_prod * tree_product[l]) % k\n                    left_counts = merged\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    merged = [0] * k\n                    for i in range(k):\n                        merged[i] += tree_counts[r][i]\n                    for i in range(k):\n                        if right_counts[i]:\n                            merged[(tree_product[r] * i) % k] += right_counts[i]\n                    right_prod = (tree_product[r] * right_prod) % k\n                    right_counts = merged\n                l //= 2\n                r //= 2\n\n            total_product = (left_prod * right_prod) % k\n            result = [0] * k\n            for i in range(k):\n                result[i] += left_counts[i]\n            for i in range(k):\n                if right_counts[i]:\n                    result[(left_prod * i) % k] += right_counts[i]\n            return total_product, result\n        \n        original_state = (nums.copy(), k, [q[:] for q in queries])\n\n        n = len(nums)\n        seg_size = 1\n        while seg_size < n: \n            seg_size <<= 1\n\n        tree_product = [1] * (2 * seg_size)\n        tree_counts = [[0] * k for _ in range(2 * seg_size)]\n\n        for i in range(n):\n            mod_val = nums[i] % k\n            tree_product[seg_size + i] = mod_val\n            tree_counts[seg_size + i][mod_val] = 1\n\n        for i in range(seg_size - 1, 0, -1):\n            left_prod, right_prod = tree_product[2 * i], tree_product[2 * i + 1]\n            tree_product[i] = (left_prod * right_prod) % k\n            merged = [0] * k\n            for j in range(k):\n                merged[j] += tree_counts[2 * i][j]\n            for j in range(k):\n                if tree_counts[2 * i + 1][j]:\n                    new_mod = (left_prod * j) % k\n                    merged[new_mod] += tree_counts[2 * i + 1][j]\n            tree_counts[i] = merged\n            \n        \n\n        def update(index, value):\n            pos = seg_size + index\n            mod_val = value % k\n            tree_product[pos] = mod_val\n            tree_counts[pos] = [0] * k\n            tree_counts[pos][mod_val] = 1\n\n            pos //= 2\n            while pos:\n                left_prod, right_prod = tree_product[2 * pos], tree_product[2 * pos + 1]\n                tree_product[pos] = (left_prod * right_prod) % k\n                merged = [0] * k\n                for j in range(k):\n                    merged[j] += tree_counts[2 * pos][j]\n                for j in range(k):\n                    if tree_counts[2 * pos + 1][j]:\n                        new_mod = (left_prod * j) % k\n                        merged[new_mod] += tree_counts[2 * pos + 1][j]\n                tree_counts[pos] = merged\n                pos //= 2\n                \n        \n\n        answers = []\n        for idx, val, l, target_mod in queries:\n            update(idx, val)\n            _, mod_counts = range_query(l, n)\n            answers.append(mod_counts[target_mod])\n        return answers\n\n\n        ",
    "input": "resultArray(nums=[1,2,3,4,5], k=3, queries=[[2,2,0,2],[3,3,3,0],[0,1,0,1]])",
    "output": "[2, 2, 2]",
    "correct_condition": "resultArray(nums=[1,2,3,4,5], k=3, queries=[[2,2,0,2],[3,3,3,0],[0,1,0,1]]) == [2, 2, 2]",
    "contest_id": "weekly-contest-446",
    "contest_date": "2025-04-20T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 102,
      "coverage": null
    },
    "submission_id": 1612019119
  },
  {
    "id": "contest446_q3840_s1",
    "question_id": 3840,
    "function_name": "resultArray",
    "code": "class SegTree:\n    def __init__(self, arr, k):\n        self.n = len(arr)\n        self.k = k\n        self.size = 1\n        while self.size < self.n:\n            self.size <<= 1\n        self.tree = [None] * (2 * self.size)\n        for i in range(self.size):\n            if i < self.n:\n                tot = arr[i] % k\n                freq = [0] * k\n                freq[tot] = 1\n                self.tree[self.size + i] = (tot, freq)\n            else:\n                self.tree[self.size + i] = (1, [0] * k)\n        for i in range(self.size - 1, 0, -1):\n            self.tree[i] = self._merge(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def _merge(self, left, right):\n        tot = (left[0] * right[0]) % self.k\n        freq = [0] * self.k\n        for i in range(self.k):\n            freq[i] += left[1][i]\n        for j in range(self.k):\n            freq[(left[0] * j) % self.k] += right[1][j]\n        return (tot, freq)\n\n    def update(self, pos, val):\n        p = pos + self.size\n        tot = val % self.k\n        freq = [0] * self.k\n        freq[tot] = 1\n        self.tree[p] = (tot, freq)\n        p //= 2\n        while p:\n            self.tree[p] = self._merge(self.tree[2 * p], self.tree[2 * p + 1])\n            p //= 2\n\n    def query(self, l, r):\n        resl = (1, [0] * self.k)\n        resr = (1, [0] * self.k)\n        l += self.size\n        r += self.size\n        while l < r:\n            if l & 1:\n                resl = self._merge(resl, self.tree[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                resr = self._merge(self.tree[r], resr)\n            l //= 2\n            r //= 2\n        res = self._merge(resl, resr)\n        return res[1]\n\n\nclass Solution:\n    def resultArray(self, nums: List[int], k: int, queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        seg = SegTree(nums, k)\n        res = []\n        for i, v, l, x in queries:\n            seg.update(i, v)\n            res.append(seg.query(l, n)[x])\n        return res",
    "input": "resultArray(nums=[1,2,3,4,5], k=3, queries=[[2,2,0,2],[3,3,3,0],[0,1,0,1]])",
    "output": "[2, 2, 2]",
    "correct_condition": "resultArray(nums=[1,2,3,4,5], k=3, queries=[[2,2,0,2],[3,3,3,0],[0,1,0,1]]) == [2, 2, 2]",
    "contest_id": "weekly-contest-446",
    "contest_date": "2025-04-20T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 66,
      "coverage": null
    },
    "submission_id": 1612008963
  },
  {
    "id": "contest446_q3840_s2",
    "question_id": 3840,
    "function_name": "resultArray",
    "code": "class Solution:\n    def resultArray(self, nums: List[int], k: int, queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        tree = [None] * (4 * n)\n        \n        def merge(leftNode, rightNode):\n            leftProd, leftHist = leftNode\n            rightProd, rightHist = rightNode\n            totalProd = (leftProd * rightProd) % k\n            newHist = [0] * k\n            for v in range(k):\n                newHist[v] += leftHist[v]\n            for u in range(k):\n                v = (leftProd * u) % k\n                newHist[v] += rightHist[u]\n            return (totalProd, newHist)\n        \n        def build(node, l, r):\n            if l == r:\n                prod = nums[l] % k\n                hist = [0] * k\n                hist[prod] = 1\n                tree[node] = (prod, hist)\n            else:\n                m = (l + r) // 2\n                build(node*2, l, m)\n                build(node*2+1, m+1, r)\n                tree[node] = merge(tree[node*2], tree[node*2+1])\n        \n        def update(node, l, r, idx, val):\n            if l == r:\n                prod = val % k\n                hist = [0] * k\n                hist[prod] = 1\n                tree[node] = (prod, hist)\n            else:\n                m = (l + r) // 2\n                if idx <= m:\n                    update(node*2, l, m, idx, val)\n                else:\n                    update(node*2+1, m+1, r, idx, val)\n                tree[node] = merge(tree[node*2], tree[node*2+1])\n        \n        def query(node, l, r, ql, qr):\n            if ql > r or qr < l:\n                return (1, [0] * k)\n            if ql <= l and r <= qr:\n                return tree[node]\n            m = (l + r) // 2\n            leftRes = query(node*2, l, m, ql, qr)\n            rightRes = query(node*2+1, m+1, r, ql, qr)\n            return merge(leftRes, rightRes)\n        \n        build(1, 0, n-1)\n        result = []\n        for idx, val, start, x in queries:\n            update(1, 0, n-1, idx, val)\n            _, hist = query(1, 0, n-1, start, n-1)\n            result.append(hist[x])\n        return result",
    "input": "resultArray(nums=[1,2,3,4,5], k=3, queries=[[2,2,0,2],[3,3,3,0],[0,1,0,1]])",
    "output": "[2, 2, 2]",
    "correct_condition": "resultArray(nums=[1,2,3,4,5], k=3, queries=[[2,2,0,2],[3,3,3,0],[0,1,0,1]]) == [2, 2, 2]",
    "contest_id": "weekly-contest-446",
    "contest_date": "2025-04-20T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 60,
      "coverage": null
    },
    "submission_id": 1612023624
  },
  {
    "id": "contest447_q3819_s0",
    "question_id": 3819,
    "function_name": "countCoveredBuildings",
    "code": "class Solution:\n    def countCoveredBuildings(self, n: int, buildings: List[List[int]]) -> int:\n        rMin, rMax, cMin, cMax = {}, {}, {}, {}\n        for x, y in buildings:\n            if x in rMin:\n                rMin[x] = min(rMin[x], y)\n                rMax[x] = max(rMax[x], y)\n            else:\n                rMin[x] = y\n                rMax[x] = y\n            if y in cMin:\n                cMin[y] = min(cMin[y], x)\n                cMax[y] = max(cMax[y], x)\n            else:\n                cMin[y] = x\n                cMax[y] = x\n        cnt = 0\n        for x, y in buildings:\n            if y > rMin[x] and y < rMax[x] and x > cMin[y] and x < cMax[y]:\n                cnt += 1\n        return cnt",
    "input": "countCoveredBuildings(n=3, buildings=[[1,2],[2,2],[3,2],[2,1],[2,3]])",
    "output": "1",
    "correct_condition": "countCoveredBuildings(n=3, buildings=[[1,2],[2,2],[3,2],[2,1],[2,3]]) == 1",
    "contest_id": "weekly-contest-447",
    "contest_date": "2025-04-27T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 21,
      "coverage": null
    },
    "submission_id": 1618869457
  },
  {
    "id": "contest447_q3819_s1",
    "question_id": 3819,
    "function_name": "countCoveredBuildings",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nclass Solution:\n    def countCoveredBuildings(self, n: int, buildings: List[List[int]]) -> int:\n        mn1 = [float('inf')] * (n + 1)\n        mx1 = [-float('inf')] * (n + 1)\n        mn2 = [float('inf')] * (n + 1)\n        mx2 = [-float('inf')] * (n + 1)\n        \n        for b in buildings:\n            x, y = b[0], b[1]\n            mn1[x] = min(mn1[x], y)\n            mx1[x] = max(mx1[x], y)\n            mn2[y] = min(mn2[y], x)\n            mx2[y] = max(mx2[y], x)\n        \n        ans = 0\n        for b in buildings:\n            x, y = b[0], b[1]\n            left  = y > mn1[x]\n            right = y < mx1[x]\n            upp    = x > mn2[y]\n            down  = x < mx2[y]\n            if left and right and upp and down:\n                ans += 1\n        \n        return ans\n\n",
    "input": "countCoveredBuildings(n=3, buildings=[[1,2],[2,2],[3,2],[2,1],[2,3]])",
    "output": "1",
    "correct_condition": "countCoveredBuildings(n=3, buildings=[[1,2],[2,2],[3,2],[2,1],[2,3]]) == 1",
    "contest_id": "weekly-contest-447",
    "contest_date": "2025-04-27T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 226,
      "coverage": null
    },
    "submission_id": 1618873054
  },
  {
    "id": "contest447_q3819_s2",
    "question_id": 3819,
    "function_name": "countCoveredBuildings",
    "code": "class Solution:\n    def countCoveredBuildings(self, n: int, buildings: List[List[int]]) -> int:\n        rows = {}\n        cols = {}\n        for x, y in buildings:\n            rows.setdefault(x, []).append(y)\n            cols.setdefault(y, []).append(x)\n        for r in rows:\n            rows[r].sort()\n        for c in cols:\n            cols[c].sort()\n\n        covered = 0\n        for x, y in buildings:\n            ys = rows[x]\n            i = bisect.bisect_left(ys, y)\n            has_left  = (i > 0)\n            has_right = (i+1 < len(ys))\n\n            xs = cols[y]\n            j = bisect.bisect_left(xs, x)\n            has_up    = (j > 0)\n            has_down  = (j+1 < len(xs))\n\n            if has_left and has_right and has_up and has_down:\n                covered += 1\n\n        return covered",
    "input": "countCoveredBuildings(n=3, buildings=[[1,2],[2,2],[3,2],[2,1],[2,3]])",
    "output": "1",
    "correct_condition": "countCoveredBuildings(n=3, buildings=[[1,2],[2,2],[3,2],[2,1],[2,3]]) == 1",
    "contest_id": "weekly-contest-447",
    "contest_date": "2025-04-27T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 28,
      "coverage": null
    },
    "submission_id": 1618870819
  },
  {
    "id": "contest447_q3838_s0",
    "question_id": 3838,
    "function_name": "pathExistenceQueries",
    "code": "class Solution:\n    def pathExistenceQueries(self, n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[bool]:\n        comp = [0] * n\n        cid = 0\n        for i in range(1, n):\n            if nums[i] - nums[i - 1] <= maxDiff:\n                comp[i] = cid\n            else:\n                cid += 1\n                comp[i] = cid\n        res = []\n        for u, v in queries:\n            res.append(comp[u] == comp[v])\n        return res",
    "input": "pathExistenceQueries(n=2, nums=[1,3], maxDiff=1, queries=[[0,0],[0,1]])",
    "output": "[True, False]",
    "correct_condition": "pathExistenceQueries(n=2, nums=[1,3], maxDiff=1, queries=[[0,0],[0,1]]) == [True, False]",
    "contest_id": "weekly-contest-447",
    "contest_date": "2025-04-27T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 14,
      "coverage": null
    },
    "submission_id": 1618871052
  },
  {
    "id": "contest447_q3838_s1",
    "question_id": 3838,
    "function_name": "pathExistenceQueries",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nclass Solution:\n    def pathExistenceQueries(self, n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[bool]:\n        ls = [0] * n\n        for i in range(1, n):\n            ls[i] = ls[i-1] + (nums[i] - nums[i-1] > maxDiff)\n        \n        ans = []\n        for u, v in queries:\n            ans.append(ls[u] == ls[v])\n        return ans\n\n\n",
    "input": "pathExistenceQueries(n=2, nums=[1,3], maxDiff=1, queries=[[0,0],[0,1]])",
    "output": "[True, False]",
    "correct_condition": "pathExistenceQueries(n=2, nums=[1,3], maxDiff=1, queries=[[0,0],[0,1]]) == [True, False]",
    "contest_id": "weekly-contest-447",
    "contest_date": "2025-04-27T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 212,
      "coverage": null
    },
    "submission_id": 1618873557
  },
  {
    "id": "contest447_q3838_s2",
    "question_id": 3838,
    "function_name": "pathExistenceQueries",
    "code": "class Solution:\n    def pathExistenceQueries(self, n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[bool]:\n        comp = [0] * n\n        cid = 0\n        for i in range(1, n):\n            if nums[i] - nums[i-1] > maxDiff:\n                cid += 1\n            comp[i] = cid\n\n        ans = []\n        for u, v in queries:\n            ans.append(comp[u] == comp[v])\n        return ans",
    "input": "pathExistenceQueries(n=2, nums=[1,3], maxDiff=1, queries=[[0,0],[0,1]])",
    "output": "[True, False]",
    "correct_condition": "pathExistenceQueries(n=2, nums=[1,3], maxDiff=1, queries=[[0,0],[0,1]]) == [True, False]",
    "contest_id": "weekly-contest-447",
    "contest_date": "2025-04-27T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 13,
      "coverage": null
    },
    "submission_id": 1618872111
  },
  {
    "id": "contest447_q3841_s0",
    "question_id": 3841,
    "function_name": "concatenatedDivisibility",
    "code": "class Solution:\n    def concatenatedDivisibility(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        p = [pow(10, len(str(x)), k) for x in nums]\n        order = sorted(range(n), key=lambda i: nums[i])\n        full = (1 << n) - 1\n        dp = {}\n        def rec(mask, rem):\n            if mask == full:\n                return [] if rem == 0 else None\n            key = (mask, rem)\n            if key in dp:\n                return dp[key]\n            for i in order:\n                if mask & (1 << i) == 0:\n                    nr = (rem * p[i] + nums[i]) % k\n                    res = rec(mask | (1 << i), nr)\n                    if res is not None:\n                        dp[key] = [nums[i]] + res\n                        return dp[key]\n            dp[key] = None\n            return None\n        ans = rec(0, 0)\n        return ans if ans is not None else []",
    "input": "concatenatedDivisibility(nums=[3,12,45], k=5)",
    "output": "[3, 12, 45]",
    "correct_condition": "concatenatedDivisibility(nums=[3,12,45], k=5) == [3, 12, 45]",
    "contest_id": "weekly-contest-447",
    "contest_date": "2025-04-27T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 24,
      "coverage": null
    },
    "submission_id": 1618873220
  },
  {
    "id": "contest447_q3841_s1",
    "question_id": 3841,
    "function_name": "concatenatedDivisibility",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nclass Solution:\n    def concatenatedDivisibility(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        cp = nums[:]\n        \n        szz = [0] * n\n        mval = [0] * n\n        for i in range(n):\n            x = nums[i]\n            mval[i] = x % k\n            if x == 0:\n                szz[i] = 1\n            else:\n                while x:\n                    szz[i] += 1\n                    x //= 10\n        \n        totd = sum(szz)\n        pow10 = [0] * (totd + 1)\n        pow10[0] = 1 % k\n        for i in range(1, totd + 1):\n            pow10[i] = (pow10[i-1] * 10) % k\n        \n        psz = [0] * n\n        for i in range(n):\n            psz[i] = pow10[szz[i]]\n        \n        fmsk = (1 << n) - 1\n        tlen = [0] * (1 << n)\n        for mask in range(1, fmsk + 1):\n            b = (mask & -mask).bit_length() - 1\n            tlen[mask] = tlen[mask ^ (1 << b)] + szz[b]\n        \n        dp = [[False] * k for _ in range(1 << n)]\n        dp[0][0] = True\n        for mask in range(1, fmsk + 1):\n            for j in range(n):\n                if mask & (1 << j):\n                    pm = mask ^ (1 << j)\n                    for r in range(k):\n                        if dp[pm][r]:\n                            nr = (r * psz[j] + mval[j]) % k\n                            dp[mask][nr] = True\n        \n        if not dp[fmsk][0]:\n            return []\n        \n        idx = list(range(n))\n        idx.sort(key=lambda a: (nums[a], a))\n        \n        res = []\n        pmask = 0\n        prem = 0\n        for step in range(n):\n            ok = False\n            for j in idx:\n                if pmask & (1 << j):\n                    continue\n                nm = pmask | (1 << j)\n                nr = (prem * psz[j] + mval[j]) % k\n                sufm = fmsk ^ nm\n                sufl = tlen[sufm]\n                need = (k - (nr * pow10[sufl]) % k) % k\n                if dp[sufm][need]:\n                    res.append(nums[j])\n                    pmask = nm\n                    prem = nr\n                    ok = True\n                    break\n            if not ok:\n                return []\n        \n        return res\n",
    "input": "concatenatedDivisibility(nums=[3,12,45], k=5)",
    "output": "[3, 12, 45]",
    "correct_condition": "concatenatedDivisibility(nums=[3,12,45], k=5) == [3, 12, 45]",
    "contest_id": "weekly-contest-447",
    "contest_date": "2025-04-27T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 273,
      "coverage": null
    },
    "submission_id": 1618882554
  },
  {
    "id": "contest447_q3841_s2",
    "question_id": 3841,
    "function_name": "concatenatedDivisibility",
    "code": "class Solution:\n    def concatenatedDivisibility(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        FULL = (1<<n) - 1\n\n        L = [len(str(x)) for x in nums]\n        pow10L = [pow(10, L[i], k) for i in range(n)]\n\n        idxs = sorted(range(n), key=lambda i: nums[i])\n\n        dq = deque()\n        seen = set()\n\n        for i in idxs:\n            m = 1<<i\n            r = nums[i] % k\n            seq = [nums[i]]\n            state = (m, r)\n            dq.append((m, r, seq))\n            seen.add(state)\n\n        while dq:\n            mask, rem, seq = dq.popleft()\n            if mask == FULL and rem == 0:\n                return seq\n\n            for i in idxs:\n                bit = 1<<i\n                if mask & bit: \n                    continue\n                nm = mask | bit\n\n                nr = (rem * pow10L[i] + nums[i]) % k\n                st = (nm, nr)\n                if st in seen:\n                    continue\n                seen.add(st)\n                dq.append((nm, nr, seq + [nums[i]]))\n\n        return []  ",
    "input": "concatenatedDivisibility(nums=[3,12,45], k=5)",
    "output": "[3, 12, 45]",
    "correct_condition": "concatenatedDivisibility(nums=[3,12,45], k=5) == [3, 12, 45]",
    "contest_id": "weekly-contest-447",
    "contest_date": "2025-04-27T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 40,
      "coverage": null
    },
    "submission_id": 1618878091
  },
  {
    "id": "contest447_q3852_s0",
    "question_id": 3852,
    "function_name": "pathExistenceQueries",
    "code": "class Solution:\n    def pathExistenceQueries(self, n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[int]:\n        arr = [(nums[i], i) for i in range(n)]\n        arr.sort(key=lambda x: x[0])\n        sv = [a for a, _ in arr]\n        si = [i for _, i in arr]\n        pos = [0] * n\n        for j in range(n):\n            pos[si[j]] = j\n        comp = [0] * n\n        for i in range(1, n):\n            comp[i] = comp[i - 1] + (1 if sv[i] - sv[i - 1] > maxDiff else 0)\n        r = [0] * n\n        j = 0\n        for i in range(n):\n            while j < n and sv[j] - sv[i] <= maxDiff:\n                j += 1\n            r[i] = j - 1\n        L = n.bit_length()\n        f = [r[:]]\n        for p in range(1, L):\n            fp = [0] * n\n            for i in range(n):\n                fp[i] = f[p - 1][f[p - 1][i]]\n            f.append(fp)\n        def jump(a, b):\n            if sv[b] - sv[a] <= maxDiff:\n                return 1\n            steps, cur = 0, a\n            for p in range(L - 1, -1, -1):\n                if f[p][cur] < b:\n                    cur = f[p][cur]\n                    steps += 1 << p\n            return steps + 1 if f[0][cur] >= b else -1\n        res = []\n        for u, v in queries:\n            if u == v:\n                res.append(0)\n                continue\n            a, b = pos[u], pos[v]\n            if a > b:\n                a, b = b, a\n            if comp[a] != comp[b]:\n                res.append(-1)\n            else:\n                res.append(jump(a, b))\n        return res",
    "input": "pathExistenceQueries(n=5, nums=[1,8,3,4,2], maxDiff=3, queries=[[0,3],[2,4]])",
    "output": "[1, 1]",
    "correct_condition": "pathExistenceQueries(n=5, nums=[1,8,3,4,2], maxDiff=3, queries=[[0,3],[2,4]]) == [1, 1]",
    "contest_id": "weekly-contest-447",
    "contest_date": "2025-04-27T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 47,
      "coverage": null
    },
    "submission_id": 1618879937
  },
  {
    "id": "contest447_q3852_s1",
    "question_id": 3852,
    "function_name": "pathExistenceQueries",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nfrom bisect import bisect_left, bisect_right\n\nclass Solution:\n    def pathExistenceQueries(self, n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[int]:\n        ls = nums.copy()\n\n        nodes = sorted((val, idx) for idx, val in enumerate(nums))\n        vs = [v for v, _ in nodes]\n        pos = [0] * n\n        for rank, (_, idx) in enumerate(nodes):\n            pos[idx] = rank\n\n        ll = [0] * n\n        for i in range(1, n):\n            ll[i] = ll[i-1] + (vs[i] - vs[i-1] > maxDiff)\n\n        ps = [0] * n\n        j = 0\n        for i in range(n):\n            while j + 1 < n and vs[j+1] - vs[i] <= maxDiff:\n                j += 1\n            ps[i] = j\n\n        ps2 = [0] * n\n        k = 0\n        for i in range(n):\n            while k < i and vs[i] - vs[k] > maxDiff:\n                k += 1\n            ps2[i] = k\n\n        logg = (n-1).bit_length()\n        up1 = [ps[:]]\n        up2 = [ps2[:]]\n        for r in range(1, logg):\n            prev1 = up1[r-1]\n            prev2 = up2[r-1]\n            cur1 = [0] * n\n            cur2 = [0] * n\n            for i in range(n):\n                cur1[i] = prev1[prev1[i]]\n                cur2[i] = prev2[prev2[i]]\n            up1.append(cur1)\n            up2.append(cur2)\n\n        res = []\n        for u, v in queries:\n            pu, pv = pos[u], pos[v]\n            if ll[pu] != ll[pv]:\n                res.append(-1)\n                continue\n            if pu == pv:\n                res.append(0)\n                continue\n            if pu < pv:\n                hv = 0\n                cur = pu\n                for r in reversed(range(logg)):\n                    nxt = up1[r][cur]\n                    if nxt < pv:\n                        cur = nxt\n                        hv |= (1 << r)\n                res.append(hv + 1)\n            else:\n                hv = 0\n                cur = pu\n                for r in reversed(range(logg)):\n                    nxt = up2[r][cur]\n                    if nxt > pv:\n                        cur = nxt\n                        hv |= (1 << r)\n                res.append(hv + 1)\n        return res\n",
    "input": "pathExistenceQueries(n=5, nums=[1,8,3,4,2], maxDiff=3, queries=[[0,3],[2,4]])",
    "output": "[1, 1]",
    "correct_condition": "pathExistenceQueries(n=5, nums=[1,8,3,4,2], maxDiff=3, queries=[[0,3],[2,4]]) == [1, 1]",
    "contest_id": "weekly-contest-447",
    "contest_date": "2025-04-27T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 272,
      "coverage": null
    },
    "submission_id": 1618878058
  },
  {
    "id": "contest447_q3852_s2",
    "question_id": 3852,
    "function_name": "pathExistenceQueries",
    "code": "class Solution:\n    def pathExistenceQueries(self, n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[int]:\n        pairs = sorted((val, idx) for idx, val in enumerate(nums))\n        values = [val for val, _ in pairs]\n        pos = [0] * n\n        for i, (_, idx) in enumerate(pairs):\n            pos[idx] = i\n        \n        comp = [0] * n\n        cid = 0\n        for i in range(1, n):\n            if values[i] - values[i-1] > maxDiff:\n                cid += 1\n            comp[i] = cid\n        \n        R = [0] * n\n        j = 0\n        for i in range(n):\n            while j + 1 < n and values[j+1] <= values[i] + maxDiff:\n                j += 1\n            R[i] = j\n        \n        LOG = math.ceil(math.log2(n)) + 1\n        nxt = [R]\n        for k in range(1, LOG):\n            prev = nxt[k-1]\n            curr = [0] * n\n            for i in range(n):\n                curr[i] = prev[prev[i]]\n            nxt.append(curr)\n        \n        def dist(pu, pv):\n            if pu == pv:\n                return 0\n            steps = 0\n            cur = pu\n            for k in range(LOG-1, -1, -1):\n                if nxt[k][cur] < pv:\n                    cur = nxt[k][cur]\n                    steps += 1 << k\n            \n            return steps + 1\n        \n        ans = []\n        for u, v in queries:\n            pu, pv = pos[u], pos[v]\n            if comp[pu] != comp[pv]:\n                ans.append(-1)\n            else:\n                if pu > pv:\n                    pu, pv = pv, pu\n                ans.append(dist(pu, pv))\n        return ans",
    "input": "pathExistenceQueries(n=5, nums=[1,8,3,4,2], maxDiff=3, queries=[[0,3],[2,4]])",
    "output": "[1, 1]",
    "correct_condition": "pathExistenceQueries(n=5, nums=[1,8,3,4,2], maxDiff=3, queries=[[0,3],[2,4]]) == [1, 1]",
    "contest_id": "weekly-contest-447",
    "contest_date": "2025-04-27T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 53,
      "coverage": null
    },
    "submission_id": 1618886059
  },
  {
    "id": "contest448_q3859_s0",
    "question_id": 3859,
    "function_name": "maxProduct",
    "code": "class Solution:\n    def maxProduct(self, n: int) -> int:\n        l = []\n        while n:\n            l.append(n % 10)\n            n = n//10\n        l.sort()\n        return l[-1] * l[-2]",
    "input": "maxProduct(n=31)",
    "output": "3",
    "correct_condition": "maxProduct(n=31) == 3",
    "contest_id": "weekly-contest-448",
    "contest_date": "2025-05-04T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 8,
      "coverage": null
    },
    "submission_id": 1624858658
  },
  {
    "id": "contest448_q3859_s1",
    "question_id": 3859,
    "function_name": "maxProduct",
    "code": "class Solution:\n    def maxProduct(self, n: int) -> int:\n        s = str(n)\n        arr = sorted(int(_) for _ in s)\n        return arr[-1] * arr[-2]\n",
    "input": "maxProduct(n=31)",
    "output": "3",
    "correct_condition": "maxProduct(n=31) == 3",
    "contest_id": "weekly-contest-448",
    "contest_date": "2025-05-04T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 5,
      "coverage": null
    },
    "submission_id": 1624852966
  },
  {
    "id": "contest448_q3859_s2",
    "question_id": 3859,
    "function_name": "maxProduct",
    "code": "class Solution:\n    def maxProduct(self, n: int) -> int:\n        d = sorted([int(x) for x in str(n)], reverse=True)\n        return d[0] * d[1]",
    "input": "maxProduct(n=31)",
    "output": "3",
    "correct_condition": "maxProduct(n=31) == 3",
    "contest_id": "weekly-contest-448",
    "contest_date": "2025-05-04T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 4,
      "coverage": null
    },
    "submission_id": 1624854518
  },
  {
    "id": "contest448_q3822_s0",
    "question_id": 3822,
    "function_name": "specialGrid",
    "code": "class Solution:\n    def specialGrid(self, N: int) -> List[List[int]]:\n        grid = [[0]]\n        for _ in range(N):\n            m = len(grid)\n            M = m * m\n            size = m * 2\n            new = [[0] * size for _ in range(size)]\n            for i in range(m):\n                for j in range(m):\n                    v = grid[i][j]\n                    new[i][j + m]     = v + 0 * M\n                    new[i + m][j + m] = v + 1 * M\n                    new[i + m][j]     = v + 2 * M\n                    new[i][j]         = v + 3 * M\n            grid = new\n        return grid",
    "input": "specialGrid(N=0)",
    "output": "[[0]]",
    "correct_condition": "specialGrid(N=0) == [[0]]",
    "contest_id": "weekly-contest-448",
    "contest_date": "2025-05-04T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 17,
      "coverage": null
    },
    "submission_id": 1624861294
  },
  {
    "id": "contest448_q3822_s1",
    "question_id": 3822,
    "function_name": "specialGrid",
    "code": "class Solution:\n\n    @lru_cache(None)\n    def specialGrid(self, N: int) -> List[List[int]]:\n        if N == 0:\n            return [[0]]\n        M = 1 << (N - 1)\n        G = self.specialGrid(N - 1)\n        A = M * M\n        ans = [[0] * (M * 2) for _ in range(M * 2)]\n        for i in range(M):\n            for j in range(M):\n                r = G[i][j]\n                ans[i][j + M] = r\n                ans[i + M][j + M] = r + A\n                ans[i + M][j] = r + 2 * A\n                # print(f\"i={i}, j={j}, r={r}, A={A}, M={M}\")\n                ans[i][j] = r + 3 * A\n                # print(f\"i={i}, j={j}, r={r}, A={A}, M={M}\")\n        # print(f\"ans={ans}\")\n        return ans\n",
    "input": "specialGrid(N=0)",
    "output": "[[0]]",
    "correct_condition": "specialGrid(N=0) == [[0]]",
    "contest_id": "weekly-contest-448",
    "contest_date": "2025-05-04T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 21,
      "coverage": null
    },
    "submission_id": 1624858454
  },
  {
    "id": "contest448_q3822_s2",
    "question_id": 3822,
    "function_name": "specialGrid",
    "code": "class Solution:\n    def specialGrid(self, n: int) -> List[List[int]]:\n        if n==0: return [[0]]\n        p=self.specialGrid(n-1)\n        d=len(p)\n        b=d*d\n        m=[[0]*(d*2) for _ in range(d*2)]\n        o=[0,b,2*b,3*b]\n        for i in range(d):\n            for j in range(d):\n                v=p[i][j]\n                m[i][j+d]=o[0]+v\n                m[i+d][j+d]=o[1]+v\n                m[i+d][j]=o[2]+v\n                m[i][j]=o[3]+v\n        return m\n",
    "input": "specialGrid(n=0)",
    "output": "[[0]]",
    "correct_condition": "specialGrid(n=0) == [[0]]",
    "contest_id": "weekly-contest-448",
    "contest_date": "2025-05-04T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 16,
      "coverage": null
    },
    "submission_id": 1624857145
  },
  {
    "id": "contest448_q3833_s0",
    "question_id": 3833,
    "function_name": "minTravelTime",
    "code": "class Solution:\n    def minTravelTime(self, l: int, n: int, k: int, position: List[int], time: List[int]) -> int:\n        P = position\n        T0 = time[:n-1]\n        prefix = [0] * n\n        prefix[0] = T0[0]\n        for i in range(1, n-1):\n            prefix[i] = prefix[i-1] + T0[i]\n        prefix[n-1] = prefix[n-2]\n        INF = 10**18\n        max_t = prefix[n-1]\n        dp = [[[INF] * (max_t + 1) for _ in range(k + 1)] for _ in range(n)]\n        dp[0][0][prefix[0]] = 0\n        for i in range(n):\n            for used in range(k + 1):\n                for t_val in range(max_t + 1):\n                    cost = dp[i][used][t_val]\n                    if cost == INF:\n                        continue\n                    for j in range(i+1, n):\n                        merges = j - i - 1\n                        new_used = used + merges\n                        if new_used > k:\n                            break\n                        dist = P[j] - P[i]\n                        new_cost = cost + t_val * dist\n                        new_t = prefix[j] - prefix[i]\n                        if new_cost < dp[j][new_used][new_t]:\n                            dp[j][new_used][new_t] = new_cost\n        return min(dp[n-1][k])\n\n\n\n\n\n\n\n",
    "input": "minTravelTime(l=10, n=4, k=1, position=[0,3,8,10], time=[5,8,3,6])",
    "output": "62",
    "correct_condition": "minTravelTime(l=10, n=4, k=1, position=[0,3,8,10], time=[5,8,3,6]) == 62",
    "contest_id": "weekly-contest-448",
    "contest_date": "2025-05-04T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 37,
      "coverage": null
    },
    "submission_id": 1624871140
  },
  {
    "id": "contest448_q3833_s1",
    "question_id": 3833,
    "function_name": "minTravelTime",
    "code": "class Solution:\n    def minTravelTime(self, l: int, n: int, k: int, position: List[int], time: List[int]) -> int:\n        p, t = position, time\n\n        pre = [0] * (n + 1)\n        for i in range(n):\n            pre[i + 1] = pre[i] + t[i]\n\n        dp = {(0, 0, 0, t[0]): 0}\n        for i in range(1, n - 1):\n            _dp = {}\n            for (_r, _p, q, w), c in dp.items():\n\n                if _r < k:\n\n                    ks = (_r + 1, _p, q + 1, w)\n                    # print(f\"i={i}, _r={_r}, _p={_p}, q={q}, w={w}, c={c}\")\n                    if c >= _dp.get(ks, float('inf')):\n                        continue\n                    _dp[ks] = c\n\n                cost = (p[i] - p[_p]) * w\n                # print(f\"i={i}, _r={_r}, _p={_p}, q={q}, w={w}, c={c}, cost={cost}\")\n                ks = (_r, i, 0, t[i] + pre[i] - pre[i - q])\n                # print(f\"i={i}, _r={_r}, _p={_p}, q={q}, w={w}, c={c}, cost={cost}\")\n                if (c + cost) >= _dp.get(ks, float('inf')):\n                    continue\n                _dp[ks] = c + cost\n\n            dp = _dp\n\n        ans = float('inf')\n        for (_r, _p, q, w), c in dp.items():\n            if _r != k:\n                continue\n            val = c + (p[n - 1] - p[_p]) * w\n            # print(f\"i={n - 1}, _r={_r}, _p={_p}, q={q}, w={w}, c={c}, val={val}\")\n            if val < ans:\n                ans = val\n\n        # print(f\"ans={ans}\")\n        return ans\n",
    "input": "minTravelTime(l=10, n=4, k=1, position=[0,3,8,10], time=[5,8,3,6])",
    "output": "62",
    "correct_condition": "minTravelTime(l=10, n=4, k=1, position=[0,3,8,10], time=[5,8,3,6]) == 62",
    "contest_id": "weekly-contest-448",
    "contest_date": "2025-05-04T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 42,
      "coverage": null
    },
    "submission_id": 1624876072
  },
  {
    "id": "contest448_q3833_s2",
    "question_id": 3833,
    "function_name": "minTravelTime",
    "code": "class Solution:\n    def minTravelTime(self, l: int, n: int, k: int, position: List[int], time: List[int]) -> int:\n        S = [0] * (n + 1)\n        for i in range(1, n):\n            S[i] = S[i - 1] + time[i - 1]\n        \n        dp = [[{} for _ in range(k + 1)] for _ in range(n)]\n        dp[0][0] = {0: 0}\n        \n        for i in range(n):\n            for r in range(k + 1):\n                for extra, cost in list(dp[i][r].items()):\n                    if i == n - 1:\n                        continue\n                    for j in range(i + 1, n):\n                        removed = j - i - 1\n                        newR = r + removed\n                        if newR > k:\n                            break\n                        newExtra = S[j] - S[i + 1] if removed > 0 else 0\n                        dist = position[j] - position[i]\n                        seg_cost = dist * (time[i] + extra)\n                        newCost = cost + seg_cost\n                        oldCost = dp[j][newR].get(newExtra)\n                        if oldCost is None or newCost < oldCost:\n                            dp[j][newR][newExtra] = newCost\n            \n            for r in range(k + 1):\n                items = sorted(dp[i][r].items(), key=lambda x: (x[0], x[1]))\n                bestCost = float('inf')\n                pruned = {}\n                for extra, cost in items:\n                    if cost < bestCost:\n                        pruned[extra] = cost\n                        bestCost = cost\n                dp[i][r] = pruned\n        \n        return min(dp[n - 1][k].values())\n",
    "input": "minTravelTime(l=10, n=4, k=1, position=[0,3,8,10], time=[5,8,3,6])",
    "output": "62",
    "correct_condition": "minTravelTime(l=10, n=4, k=1, position=[0,3,8,10], time=[5,8,3,6]) == 62",
    "contest_id": "weekly-contest-448",
    "contest_date": "2025-05-04T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 38,
      "coverage": null
    },
    "submission_id": 1624877855
  },
  {
    "id": "contest448_q3851_s0",
    "question_id": 3851,
    "function_name": "magicalSum",
    "code": "class Solution:\n    def magicalSum(self, M: int, K: int, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        fact = [1] * (M + 1)\n        for i in range(1, M + 1):\n            fact[i] = fact[i - 1] * i % mod\n        inv_fact = [1] * (M + 1)\n        inv_fact[M] = pow(fact[M], mod - 2, mod)\n        for i in range(M, 0, -1):\n            inv_fact[i - 1] = inv_fact[i] * i % mod\n        num_pow = [[pow(nums[i], c, mod) for c in range(M + 1)] for i in range(n)]\n        dp = [[[0] * (K + 1) for _ in range(M + 1)] for __ in range(M + 1)]\n        dp[0][0][0] = 1\n        for i in range(n):\n            new_dp = [[[0] * (K + 1) for _ in range(M + 1)] for __ in range(M + 1)]\n            np_i = num_pow[i]\n            for used in range(M + 1):\n                for carry in range(M + 1):\n                    for pop in range(K + 1):\n                        w = dp[used][carry][pop]\n                        if not w:\n                            continue\n                        max_c = M - used\n                        for c in range(max_c + 1):\n                            total = c + carry\n                            bit = total & 1\n                            new_pop = pop + bit\n                            if new_pop > K:\n                                continue\n                            new_carry = total >> 1\n                            new_used = used + c\n                            new_dp[new_used][new_carry][new_pop] = (\n                                new_dp[new_used][new_carry][new_pop]\n                                + w * np_i[c] * inv_fact[c]\n                            ) % mod\n            dp = new_dp\n        res = 0\n        for carry in range(M + 1):\n            bc = carry.bit_count()\n            for pop in range(K + 1):\n                if pop + bc == K:\n                    res = (res + dp[M][carry][pop]) % mod\n        return res * fact[M] % mod",
    "input": "magicalSum(M=5, K=5, nums=[1,10,100,10000,1000000])",
    "output": "991600007",
    "correct_condition": "magicalSum(M=5, K=5, nums=[1,10,100,10000,1000000]) == 991600007",
    "contest_id": "weekly-contest-448",
    "contest_date": "2025-05-04T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 44,
      "coverage": null
    },
    "submission_id": 1624873692
  },
  {
    "id": "contest448_q3851_s1",
    "question_id": 3851,
    "function_name": "magicalSum",
    "code": "MOD = 10**9 + 7\n\n\nclass Solution:\n    def magicalSum(self, M: int, K: int, nums: List[int]) -> int:\n        N = len(nums)\n\n        F = [1] * (M + 1)\n        for i in range(1, M + 1):\n            F[i] = F[i - 1] * i % MOD\n\n        iF = [1] * (M + 1)\n        iF[M] = pow(F[M], MOD - 2, MOD)\n        for i in range(M, 0, -1):\n            iF[i - 1] = iF[i] * i % MOD\n        # print(f\"F={F}, iF={iF}\")\n\n        P = []\n        for x in nums:\n            _p = [1] * (M + 1)\n            for i in range(1, M + 1):\n                _p[i] = _p[i - 1] * x % MOD\n            P.append(_p)\n        # print(f\"P={P}\")\n\n        dp = {(M, 0, 0): 1}\n        for j in range(N):\n            _p = P[j]\n            _dp = {}\n            for (_r, _c, _k), v in dp.items():\n                for c in range(_r + 1):\n                    v2 = v * _p[c] % MOD * iF[c] % MOD\n                    bit = (c + _c) & 1\n                    ncr = (c + _c) >> 1\n                    # print(f\"j={j}, _r={_r}, _c={_c}, c={c}, v={v}, v2={v2}, bit={bit}, ncr={ncr}\")\n                    nk = _k + bit\n                    if nk > K:\n                        continue\n                    _dp[(_r - c, ncr, nk)] = (_dp.get((_r - c, ncr, nk), 0) + v2) % MOD\n                    # print(f\"j={j}, _r={_r}, _c={_c}, c={c}, v={v}, v2={v2}, bit={bit}, ncr={ncr}, nk={nk}\")\n            dp = _dp\n\n        ans = 0\n        for (_r, _c, _k), v in dp.items():\n            if _r == 0 and _k + bin(_c).count(\"1\") == K:\n                ans = (ans + v) % MOD\n\n        # print(f\"dp={dp}\")\n        # print(f\"ans={ans}\")\n        return ans * F[M] % MOD\n",
    "input": "magicalSum(M=5, K=5, nums=[1,10,100,10000,1000000])",
    "output": "991600007",
    "correct_condition": "magicalSum(M=5, K=5, nums=[1,10,100,10000,1000000]) == 991600007",
    "contest_id": "weekly-contest-448",
    "contest_date": "2025-05-04T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 50,
      "coverage": null
    },
    "submission_id": 1624870301
  },
  {
    "id": "contest448_q3851_s2",
    "question_id": 3851,
    "function_name": "magicalSum",
    "code": "class Solution:\n    def magicalSum(self, M: int, K: int, nums: List[int]) -> int:\n        MOD = (10**9)+7\n        fact = [1] * (M+1)\n        for i in range(1, M+1):\n            fact[i] = fact[i-1] * i % MOD\n        inv_fact = [1] * (M+1)\n        inv_fact[M] = pow(fact[M], MOD-2, MOD)\n        for i in range(M, 0, -1):\n            inv_fact[i-1] = inv_fact[i] * i % MOD\n\n        dp = [[[0] * (K+1) for _ in range(M+1)] for _ in range(M+1)]\n        dp[0][0][0] = 1\n\n        for i, v in enumerate(nums):\n            ndp = [[[0] * (K+1) for _ in range(M+1)] for _ in range(M+1)]\n            pw = [1] * (M+1)\n            for c in range(1, M+1):\n                pw[c] = pw[c-1] * v % MOD\n\n            for p in range(M+1):\n                for carry in range(M+1):\n                    for b in range(K+1):\n                        cur = dp[p][carry][b]\n                        if not cur:\n                            continue\n                        max_c = M - p\n                        for c in range(max_c+1):\n                            new_p = p + c\n                            tot = carry + c\n                            bit = tot & 1\n                            new_b = b + bit\n                            if new_b > K:\n                                continue\n                            carry_out = tot >> 1\n                            val = cur * inv_fact[c] % MOD * pw[c] % MOD\n                            ndp[new_p][carry_out][new_b] = (ndp[new_p][carry_out][new_b] + val) % MOD\n\n            dp = ndp\n\n        ans = 0\n        for carry in range(M+1):\n            bc = carry.bit_count()\n            for b in range(K+1):\n                if b + bc == K:\n                    ans = (ans + dp[M][carry][b]) % MOD\n\n        ans = ans * fact[M] % MOD\n        return ans\n",
    "input": "magicalSum(M=5, K=5, nums=[1,10,100,10000,1000000])",
    "output": "991600007",
    "correct_condition": "magicalSum(M=5, K=5, nums=[1,10,100,10000,1000000]) == 991600007",
    "contest_id": "weekly-contest-448",
    "contest_date": "2025-05-04T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 49,
      "coverage": null
    },
    "submission_id": 1624869195
  },
  {
    "id": "contest449_q3871_s0",
    "question_id": 3871,
    "function_name": "minDeletion",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def minDeletion(self, s: str, k: int) -> int:\n        freq = [0] * 26\n        for c in s:\n            freq[ord(c) - ord('a')] += 1\n        \n        poss = [f for f in freq if f > 0]\n        \n        D = len(poss)  \n        if D <= k:\n            return 0  \n            \n        poss.sort()\n        minus = D - k\n        ans = sum(poss[i] for i in range(minus))\n        \n        return ans\n",
    "input": "minDeletion(s=\"abc\", k=2)",
    "output": "1",
    "correct_condition": "minDeletion(s=\"abc\", k=2) == 1",
    "contest_id": "weekly-contest-449",
    "contest_date": "2025-05-11T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 217,
      "coverage": null
    },
    "submission_id": 1630603873
  },
  {
    "id": "contest449_q3871_s1",
    "question_id": 3871,
    "function_name": "minDeletion",
    "code": "class Solution:\n    def minDeletion(self, s: str, k: int) -> int:\n        arr = sorted(Counter(s).values())\n        n = len(arr)\n        return sum(arr[:n - k]) if n > k else 0",
    "input": "minDeletion(s=\"abc\", k=2)",
    "output": "1",
    "correct_condition": "minDeletion(s=\"abc\", k=2) == 1",
    "contest_id": "weekly-contest-449",
    "contest_date": "2025-05-11T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 5,
      "coverage": null
    },
    "submission_id": 1630586515
  },
  {
    "id": "contest449_q3871_s2",
    "question_id": 3871,
    "function_name": "minDeletion",
    "code": "class Solution:\n    def minDeletion(self, s: str, k: int) -> int:\n        freq = {}\n        for ch in s:\n            freq[ch] = freq.get(ch, 0) + 1\n\n        if len(freq) <= k:\n            return 0\n\n        sorted_freqs = sorted(freq.values(), reverse=True)\n        keep_count = sum(sorted_freqs[:k])\n        return len(s) - keep_count",
    "input": "minDeletion(s=\"abc\", k=2)",
    "output": "1",
    "correct_condition": "minDeletion(s=\"abc\", k=2) == 1",
    "contest_id": "weekly-contest-449",
    "contest_date": "2025-05-11T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 12,
      "coverage": null
    },
    "submission_id": 1630586123
  },
  {
    "id": "contest449_q3849_s0",
    "question_id": 3849,
    "function_name": "canPartitionGrid",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def canPartitionGrid(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        \n        ls = [[0] * (n + 1) for i in range(m + 1)]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                ls[i][j] = (\n                    grid[i - 1][j - 1] + ls[i - 1][j] + ls[i][j - 1] - ls[i - 1][j - 1])\n        \n        tot = ls[m][n]\n        if tot % 2 != 0:\n            return False\n        minus = tot // 2\n        \n        for k in range(1, m):\n            if ls[k][n] == minus:\n                return True\n        \n        for k in range(1, n):\n            if ls[m][k] == minus:\n                return True\n        \n        return False\n",
    "input": "canPartitionGrid(grid=[[1,4],[2,3]])",
    "output": "True",
    "correct_condition": "canPartitionGrid(grid=[[1,4],[2,3]]) == True",
    "contest_id": "weekly-contest-449",
    "contest_date": "2025-05-11T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 225,
      "coverage": null
    },
    "submission_id": 1630602257
  },
  {
    "id": "contest449_q3849_s1",
    "question_id": 3849,
    "function_name": "canPartitionGrid",
    "code": "class Solution:\n    def canPartitionGrid(self, grid: List[List[int]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        P = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m):\n            for j in range(n):\n                P[i + 1][j + 1] = grid[i][j] + P[i][j + 1] + P[i + 1][j] - P[i][j]\n        x = P[m][n]\n        if x & 1:\n            return False\n        y = x // 2\n        for i in range(1, m):\n            if P[i][n] == y:\n                return True\n        for j in range(1, n):\n            if P[m][j] == y:\n                return True\n        return False",
    "input": "canPartitionGrid(grid=[[1,4],[2,3]])",
    "output": "True",
    "correct_condition": "canPartitionGrid(grid=[[1,4],[2,3]]) == True",
    "contest_id": "weekly-contest-449",
    "contest_date": "2025-05-11T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 19,
      "coverage": null
    },
    "submission_id": 1630589792
  },
  {
    "id": "contest449_q3849_s2",
    "question_id": 3849,
    "function_name": "canPartitionGrid",
    "code": "class Solution:\n    def canPartitionGrid(self, grid: List[List[int]]) -> bool:\n        total_sum = 0\n        for row in grid:\n            total_sum += sum(row)\n        \n        if total_sum % 2 != 0:\n            return False\n        \n        half_sum = total_sum // 2\n        \n        current_sum = 0\n        for i in range(len(grid) - 1):\n            current_sum += sum(grid[i])\n            if current_sum == half_sum:\n                return True\n                \n        m = len(grid)\n        n = len(grid[0])\n        col_sums = [0] * n\n        for i in range(m):\n            for j in range(n):\n                col_sums[j] += grid[i][j]\n        \n        current_sum = 0\n        for j in range(n - 1):\n            current_sum += col_sums[j]\n            if current_sum == half_sum:\n                return True\n        \n        return False",
    "input": "canPartitionGrid(grid=[[1,4],[2,3]])",
    "output": "True",
    "correct_condition": "canPartitionGrid(grid=[[1,4],[2,3]]) == True",
    "contest_id": "weekly-contest-449",
    "contest_date": "2025-05-11T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 31,
      "coverage": null
    },
    "submission_id": 1630587537
  },
  {
    "id": "contest449_q3845_s0",
    "question_id": 3845,
    "function_name": "maxScore",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def maxScore(self, n: int, edges: List[List[int]]) -> int:\n        cp = edges.copy()\n        adj = [[] for i in range(n)]\n        for u, v in cp:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        vis = [False] * n\n        ls = []\n\n        class Comp:\n            def __init__(self, ps, type_, size):\n                self.ps = ps\n                self.type = type_\n                self.size = size\n\n        for i in range(n):\n            if not vis[i] and len(adj[i]) == 0:\n                vis[i] = True\n                ls.append(Comp([i], 0, 1))\n\n        for i in range(n):\n            if not vis[i] and len(adj[i]) == 1:\n                ps = []\n                curr, prev = i, -1\n                while True:\n                    ps.append(curr)\n                    vis[curr] = True\n                    nxt = -1\n                    for nb in adj[curr]:\n                        if nb != prev:\n                            nxt = nb\n                            break\n                    if nxt == -1:\n                        break\n                    prev, curr = curr, nxt\n                ls.append(Comp(ps, 1, len(ps)))\n\n        for i in range(n):\n            if not vis[i]:\n                cnode = []\n                stk = [i]\n                vis[i] = True\n                cnode.append(i)\n                while stk:\n                    u = stk.pop()\n                    for nb in adj[u]:\n                        if not vis[nb]:\n                            vis[nb] = True\n                            cnode.append(nb)\n                            stk.append(nb)\n                k = len(cnode)\n                ps = []\n                curr, prev = cnode[0], -1\n                for _ in range(k):\n                    ps.append(curr)\n                    nxt = -1\n                    for nb in adj[curr]:\n                        if nb != prev:\n                            nxt = nb\n                            break\n                    prev, curr = curr, nxt\n                ls.append(Comp(ps, 2, k))\n\n        ls.sort(key=lambda c: (-c.type, -c.size))\n\n        val = [0] * n\n        nxl = n\n        ans = 0\n\n        for C in ls:\n            k = C.size\n            L = [0] * k\n            for j in range(k - 1, -1, -1):\n                L[j] = nxl\n                nxl -= 1\n            l, r, idx = 0, k - 1, 0\n            while l <= r:\n                val[C.ps[l]] = L[idx]\n                idx += 1\n                if l == r:\n                    break\n                val[C.ps[r]] = L[idx]\n                idx += 1\n                l += 1\n                r -= 1\n            for j in range(k - 1):\n                ans += val[C.ps[j]] * val[C.ps[j + 1]]\n            if C.type == 2:\n                ans += val[C.ps[0]] * val[C.ps[-1]]\n\n        return ans\n\n",
    "input": "maxScore(n=4, edges=[[0,1],[1,2],[2,3]])",
    "output": "23",
    "correct_condition": "maxScore(n=4, edges=[[0,1],[1,2],[2,3]]) == 23",
    "contest_id": "weekly-contest-449",
    "contest_date": "2025-05-11T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 294,
      "coverage": null
    },
    "submission_id": 1630609738
  },
  {
    "id": "contest449_q3845_s1",
    "question_id": 3845,
    "function_name": "maxScore",
    "code": "class Solution:\n    def maxScore(self, n: int, edges: List[List[int]]) -> int:\n        G = [[] for _ in range(n)]\n        D = [0] * n\n        for u, v in edges:\n            G[u].append(v)\n            G[v].append(u)\n            D[u] += 1\n            D[v] += 1\n\n        seen = [0] * n\n        cp = []\n        for i in range(n):\n            if seen[i]:\n                continue\n            _t = [i]\n            seen[i] = 1\n            nodes = []\n            _sum = 0\n            while _t:\n                u = _t.pop()\n                nodes.append(u)\n                _sum += D[u]\n                # print(u, D[u])\n                for v in G[u]:\n                    if seen[v]:\n                        continue\n                    seen[v] = 1\n                    _t.append(v)\n\n            E = _sum // 2\n            B = None\n            if E == len(nodes):\n                for u in nodes:\n                    for v in G[u]:\n                        if u < v and v in nodes:\n                            B = (u, v)\n                            break\n                    if B:\n                        break\n            cp.append((2 * E / len(nodes), len(nodes), E, nodes, B))\n        # print(cp)\n        # print(\"is\", n - sum(c for _, c, _, _, _ in cp))\n        cp.sort(key=lambda x: (-x[0], -x[1]))\n        ret = [0] * n\n\n        # print(\"cp\", cp)\n        high = n\n        for _, c, E, nodes, B in cp:\n            low = high - c + 1\n            high -= c\n            arr = list(range(low, low + c))\n            L = {u: len(G[u])\n                    - (1 if B\n                            and ((u == B[0] and B[1] in G[u])\n                                 or (u == B[1] and B[0] in G[u])) else 0) for u in nodes}\n\n            t = 0\n            q = deque(u for u in nodes if L[u] <= 1)\n            # print(\"arr\", arr)\n            while q:\n                u = q.popleft()\n                if ret[u]:\n                    continue\n                ret[u] = arr[t]\n                t += 1\n\n                # print(\"u\", u, \"arr\", arr, \"t\", t, \"L\", L)\n                for v in G[u]:\n                    if B:\n                        if (u == B[0] and v == B[1]) or (u == B[1] and v == B[0]):\n                            continue\n                    L[v] -= 1\n                    if L[v] == 1:\n                        q.append(v)\n\n        ans = 0\n        for u, v in edges:\n            ans += ret[u] * ret[v]\n            # print(\"u\", u, \"v\", v, \"ret[u]\", ret[u], \"ret[v]\", ret[v], \"ans\", ans)\n        return ans\n",
    "input": "maxScore(n=4, edges=[[0,1],[1,2],[2,3]])",
    "output": "23",
    "correct_condition": "maxScore(n=4, edges=[[0,1],[1,2],[2,3]]) == 23",
    "contest_id": "weekly-contest-449",
    "contest_date": "2025-05-11T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 81,
      "coverage": null
    },
    "submission_id": 1630614540
  },
  {
    "id": "contest449_q3845_s2",
    "question_id": 3845,
    "function_name": "maxScore",
    "code": "class Solution:\n    def maxScore(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = [False] * n\n        components = []\n        for i in range(n):\n            if not visited[i]:\n                comp = []\n                dq = deque([i])\n                visited[i] = True\n                while dq:\n                    cur = dq.popleft()\n                    comp.append(cur)\n                    for nb in graph[cur]:\n                        if not visited[nb]:\n                            visited[nb] = True\n                            dq.append(nb)\n                components.append(comp)\n        comp_infos = []\n        def optimal_path_order(k: int) -> List[int]:\n            arr = list(range(1, k + 1))\n            res = [None] * k\n            mid = k // 2\n            res[mid] = arr.pop()\n            left_ptr = mid - 1\n            right_ptr = mid + 1\n            flag = True\n            while arr:\n                val = arr.pop()\n                if flag:\n                    if left_ptr >= 0:\n                        res[left_ptr] = val\n                        left_ptr -= 1\n                    else:\n                        res[right_ptr] = val\n                        right_ptr += 1\n                else:\n                    if right_ptr < k:\n                        res[right_ptr] = val\n                        right_ptr += 1\n                    else:\n                        res[left_ptr] = val\n                        left_ptr -= 1\n                flag = not flag\n            return res\n\n        def optimal_cycle_order(k: int) -> List[int]:\n            arr = list(range(1, k + 1))\n            left = arr[::2]\n            right = arr[1::2][::-1]\n            return left + right\n\n        for comp in components:\n            if len(comp) == 1:\n                continue\n            comp_set = set(comp)\n            comp_deg = {}\n            for u in comp:\n                d = sum(1 for nb in graph[u] if nb in comp_set)\n                comp_deg[u] = d\n            total_edges = sum(comp_deg.values()) // 2\n            k = len(comp)\n            isCycle = (k >= 3 and all(deg == 2 for deg in comp_deg.values()))\n            if isCycle:\n                order = optimal_cycle_order(k)\n                m_edges = k\n            else:\n                order = optimal_path_order(k)\n                m_edges = k - 1\n            base_score = 0\n            base_adj_sum = 0\n            if isCycle:\n                for i in range(k):\n                    j = (i + 1) % k\n                    base_score += order[i] * order[j]\n                    base_adj_sum += order[i] + order[j]\n            else:\n                for i in range(k - 1):\n                    base_score += order[i] * order[i + 1]\n                    base_adj_sum += order[i] + order[i + 1]\n            comp_infos.append((k, base_score, base_adj_sum, m_edges))\n        S = sum(info[0] for info in comp_infos)\n        if S == 0:\n            return 0\n        base_shift = n - S\n        def cmp(a, b):\n            k1, bs1, adj1, m1 = a\n            k2, bs2, adj2, m2 = b\n            diff = (adj2 * k1 - adj1 * k2) + (m2 * (k1**2) - m1 * (k2**2)) + 2 * base_shift * (m2 * k1 - m1 * k2)\n            if diff > 0:\n                return -1\n            elif diff < 0:\n                return 1\n            else:\n                return 0\n        comp_infos.sort(key=cmp_to_key(cmp))\n        total_score = 0\n        cum = 0\n        for (k, base_score, base_adj_sum, m_edges) in comp_infos:\n            d = base_shift + cum\n            total_score += base_score + d * base_adj_sum + m_edges * d * d\n            cum += k\n        return total_score",
    "input": "maxScore(n=4, edges=[[0,1],[1,2],[2,3]])",
    "output": "23",
    "correct_condition": "maxScore(n=4, edges=[[0,1],[1,2],[2,3]]) == 23",
    "contest_id": "weekly-contest-449",
    "contest_date": "2025-05-11T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 106,
      "coverage": null
    },
    "submission_id": 1630597722
  },
  {
    "id": "contest449_q3850_s0",
    "question_id": 3850,
    "function_name": "canPartitionGrid",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nfrom typing import List\nfrom collections import Counter\n\nclass Solution:\n    def canPartitionGrid(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        maxv = max(max(row) for row in grid)\n\n        rsum = []\n        psum = []\n        tsum = 0\n        for i in range(m):\n            s = sum(grid[i])\n            rsum.append(s)\n            tsum += s\n            psum.append(tsum)\n\n        topc = [0] * (maxv + 1)\n        botc = [0] * (maxv + 1)\n        for i in range(m):\n            for j in range(n):\n                botc[grid[i][j]] += 1\n\n        for i in range(m - 1):\n            for j in range(n):\n                val = grid[i][j]\n                botc[val] -= 1\n                topc[val] += 1\n\n            tops = psum[i]\n            bots = tsum - tops\n            if tops == bots:\n                return True\n\n            mins = abs(tops - bots)\n            comp = tops > bots\n            r = i + 1 if comp else m - (i + 1)\n            c = n\n            hcnt = topc if comp else botc\n\n            if mins <= maxv and hcnt[mins] > 0:\n                if r >= 2 and c >= 2:\n                    return True\n\n                ends = []\n                if r == 1 and c >= 2:\n                    row = 0 if comp else i + 1\n                    ends.append((row, 0))\n                    ends.append((row, n - 1))\n                elif c == 1 and r >= 2:\n                    col = 0\n                    rst = 0 if comp else i + 1\n                    rend = i if comp else m - 1\n                    ends.append((rst, col))\n                    ends.append((rend, col))\n\n                for x, y in ends:\n                    if grid[x][y] == mins:\n                        return True\n\n        csum = []\n        pcsum = []\n        ctot = 0\n        for j in range(n):\n            s = sum(grid[i][j] for i in range(m))\n            csum.append(s)\n            ctot += s\n            pcsum.append(ctot)\n\n        lcnt = [0] * (maxv + 1)\n        rcnt = [0] * (maxv + 1)\n        for i in range(m):\n            for j in range(n):\n                rcnt[grid[i][j]] += 1\n\n        for j in range(n - 1):\n            for i in range(m):\n                val = grid[i][j]\n                rcnt[val] -= 1\n                lcnt[val] += 1\n\n            lsum = pcsum[j]\n            rsum = tsum - lsum\n            if lsum == rsum:\n                return True\n\n            mins = abs(lsum - rsum)\n            hls = lsum > rsum\n            r = m\n            c = j + 1 if hls else n - (j + 1)\n            hcnt = lcnt if hls else rcnt\n\n            if mins <= maxv and hcnt[mins] > 0:\n                if r >= 2 and c >= 2:\n                    return True\n\n                ends = []\n                if r == 1 and c >= 2:\n                    row = 0\n                    cs = 0 if hls else j + 1\n                    ce = j if hls else n - 1\n                    ends.append((0, cs))\n                    ends.append((0, ce))\n                elif c == 1 and r >= 2:\n                    col = j if hls else j + 1\n                    ends.append((0, col))\n                    ends.append((m - 1, col))\n\n                for x, y in ends:\n                    if grid[x][y] == mins:\n                        return True\n\n        return False\n",
    "input": "canPartitionGrid(grid=[[1,4],[2,3]])",
    "output": "True",
    "correct_condition": "canPartitionGrid(grid=[[1,4],[2,3]]) == True",
    "contest_id": "weekly-contest-449",
    "contest_date": "2025-05-11T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 313,
      "coverage": null
    },
    "submission_id": 1630601076
  },
  {
    "id": "contest449_q3850_s1",
    "question_id": 3850,
    "function_name": "canPartitionGrid",
    "code": "class Solution:\n    def canPartitionGrid(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        r = [sum(rw) for rw in grid]\n        c = [sum(col) for col in zip(*grid)]\n\n        _sum = sum(r)\n\n        top = Counter()\n        bottom = Counter(x for rw in grid for x in rw)\n\n        st = 0\n        for k in range(1, m):\n            st += r[k - 1]\n            sb = _sum - st\n            for v in grid[k - 1]:\n                bottom[v] -= 1\n                if bottom[v] == 0:\n                    del bottom[v]\n                top[v] += 1\n\n            if st == sb:\n                return True\n\n            d = st - sb\n            D = abs(d)\n\n            count = top if d > 0 else bottom\n            if d > 0:\n                r0, c0, h, w = 0, 0, k, n\n            else:\n                r0, c0, h, w = k, 0, m - k, n\n\n            if (D in count\n                    and (\n                            (h > 1 and w > 1)\n                            or (h == 1 and D in (grid[r0][c0], grid[r0][c0 + w - 1]))\n                            or (w == 1 and D in (grid[r0][c0], grid[r0 + h - 1][c0]))\n                    )):\n                return True\n\n        L = Counter()\n        R = Counter(x for _ in grid for x in _)\n\n        win = 0\n        for l in range(1, n):\n            win += c[l - 1]\n\n            sr = _sum - win\n            for i in range(m):\n                v = grid[i][l - 1]\n                R[v] -= 1\n                if R[v] == 0:\n                    del R[v]\n                L[v] += 1\n\n            if win == sr:\n                return True\n\n            d = win - sr\n            D = abs(d)\n            # print(d, D)\n\n            count = L if d > 0 else R\n            # print(count)\n\n            if d > 0:\n                r0, c0, h, w = 0, 0, m, l\n            else:\n                r0, c0, h, w = 0, l, m, n - l\n\n            # print(r0, c0, h, w)\n\n            if D in count and (\n                    (h > 1 and w > 1) or\n                    (h == 1 and D in (grid[r0][c0], grid[r0][c0 + w - 1])) or\n                    (w == 1 and D in (grid[r0][c0], grid[r0 + h - 1][c0]))\n            ):\n                return True\n        return False\n",
    "input": "canPartitionGrid(grid=[[1,4],[2,3]])",
    "output": "True",
    "correct_condition": "canPartitionGrid(grid=[[1,4],[2,3]]) == True",
    "contest_id": "weekly-contest-449",
    "contest_date": "2025-05-11T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 80,
      "coverage": null
    },
    "submission_id": 1630621200
  },
  {
    "id": "contest449_q3850_s2",
    "question_id": 3850,
    "function_name": "canPartitionGrid",
    "code": "class Solution:\n    def canPartitionGrid(self, grid: List[List[int]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        total = sum(sum(row) for row in grid)\n        prefix = [0]*m\n        prefix[0] = sum(grid[0])\n        for i in range(1, m):\n            prefix[i] = prefix[i-1] + sum(grid[i])\n        col_sums = [0]*n\n        for j in range(n):\n            s = 0\n            for i in range(m):\n                s += grid[i][j]\n            col_sums[j] = s\n        vprefix = [0]*n\n        vprefix[0] = col_sums[0]\n        for j in range(1, n):\n            vprefix[j] = vprefix[j-1] + col_sums[j]\n        \n        value_map = {}\n        for i in range(m):\n            for j in range(n):\n                v = grid[i][j]\n                if v not in value_map:\n                    value_map[v] = {}\n                if i not in value_map[v]:\n                    value_map[v][i] = []\n                value_map[v][i].append(j)\n        for v in value_map:\n            for r in value_map[v]:\n                value_map[v][r].sort()\n        \n        def query_value_in_region(v, rlow, rhigh, clow, chigh):\n            if v not in value_map:\n                return False\n            for r in range(rlow, rhigh + 1):\n                if r in value_map[v]:\n                    lst = value_map[v][r]\n                    idx = bisect.bisect_left(lst, clow)\n                    if idx < len(lst) and lst[idx] <= chigh:\n                        return True\n            return False\n\n        def check_partition(rlow, rhigh, clow, chigh, diff):\n            rows = rhigh - rlow + 1\n            cols = chigh - clow + 1\n            if rows * cols == 1:\n                return False\n            if rows > 1 and cols > 1:\n                return query_value_in_region(diff, rlow, rhigh, clow, chigh)\n            else:\n                if rows == 1:\n                    if diff == grid[rlow][clow] or diff == grid[rlow][chigh]:\n                        return True\n                if cols == 1:\n                    if diff == grid[rlow][clow] or diff == grid[rhigh][clow]:\n                        return True\n            return False\n\n        for i in range(m - 1):\n            sum_top = prefix[i]\n            sum_bottom = total - sum_top\n            if sum_top == sum_bottom:\n                return True\n            if sum_top > sum_bottom:\n                diff = sum_top - sum_bottom\n                if check_partition(0, i, 0, n - 1, diff):\n                    return True\n            else:\n                diff = sum_bottom - sum_top\n                if check_partition(i + 1, m - 1, 0, n - 1, diff):\n                    return True\n\n        for j in range(n - 1):\n            sum_left = vprefix[j]\n            sum_right = total - sum_left\n            if sum_left == sum_right:\n                return True\n            if sum_left > sum_right:\n                diff = sum_left - sum_right\n                if check_partition(0, m - 1, 0, j, diff):\n                    return True\n            else:\n                diff = sum_right - sum_left\n                if check_partition(0, m - 1, j + 1, n - 1, diff):\n                    return True\n\n        return False",
    "input": "canPartitionGrid(grid=[[1,4],[2,3]])",
    "output": "True",
    "correct_condition": "canPartitionGrid(grid=[[1,4],[2,3]]) == True",
    "contest_id": "weekly-contest-449",
    "contest_date": "2025-05-11T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 89,
      "coverage": null
    },
    "submission_id": 1630614238
  },
  {
    "id": "contest450_q3869_s0",
    "question_id": 3869,
    "function_name": "smallestIndex",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def smallestIndex(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            x = nums[i]\n            s = 0\n            while x > 0:\n                s += x % 10\n                x //= 10\n            if s == i:\n                return i\n        return -1",
    "input": "smallestIndex(nums=[1,3,2])",
    "output": "2",
    "correct_condition": "smallestIndex(nums=[1,3,2]) == 2",
    "contest_id": "weekly-contest-450",
    "contest_date": "2025-05-18T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 211,
      "coverage": null
    },
    "submission_id": 1636871607
  },
  {
    "id": "contest450_q3869_s1",
    "question_id": 3869,
    "function_name": "smallestIndex",
    "code": "class Solution:\n    def smallestIndex(self, a: List[int]) -> int:\n        for i, x in enumerate(a):\n            if sum(int(d) for d in str(x)) == i: return i\n        return -1\n",
    "input": "smallestIndex(a=[1,3,2])",
    "output": "2",
    "correct_condition": "smallestIndex(a=[1,3,2]) == 2",
    "contest_id": "weekly-contest-450",
    "contest_date": "2025-05-18T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 5,
      "coverage": null
    },
    "submission_id": 1636851239
  },
  {
    "id": "contest450_q3869_s2",
    "question_id": 3869,
    "function_name": "smallestIndex",
    "code": "class Solution:\n    def smallestIndex(self, nums: List[int]) -> int:\n        for i, num in enumerate(nums):\n            if sum(int(d) for d in str(abs(num))) == i:\n                return i\n        return -1",
    "input": "smallestIndex(nums=[1,3,2])",
    "output": "2",
    "correct_condition": "smallestIndex(nums=[1,3,2]) == 2",
    "contest_id": "weekly-contest-450",
    "contest_date": "2025-05-18T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 6,
      "coverage": null
    },
    "submission_id": 1636853379
  },
  {
    "id": "contest450_q3847_s0",
    "question_id": 3847,
    "function_name": "minSwaps",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def minSwaps(self, nums: List[int]) -> int:\n        n = len(nums)\n        ls = []\n        for i in range(n):\n            x = nums[i]\n            s = 0\n            while x > 0:\n                s += x % 10\n                x //= 10\n            ls.append((s, nums[i], i))\n        \n        ls.sort(key=lambda x: (x[0], x[1]))\n        \n        P = [0] * n\n        for zs in range(n):\n            ind = ls[zs][2]\n            P[ind] = zs\n        \n        seen = [False] * n\n        swaps = 0\n        for i in range(n):\n            if seen[i] or P[i] == i:\n                continue\n            sz = 0\n            j = i\n            while not seen[j]:\n                seen[j] = True\n                j = P[j]\n                sz += 1\n            if sz > 0:\n                swaps += sz - 1\n        \n        return swaps\n",
    "input": "minSwaps(nums=[37,100])",
    "output": "1",
    "correct_condition": "minSwaps(nums=[37,100]) == 1",
    "contest_id": "weekly-contest-450",
    "contest_date": "2025-05-18T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 234,
      "coverage": null
    },
    "submission_id": 1636872497
  },
  {
    "id": "contest450_q3847_s1",
    "question_id": 3847,
    "function_name": "minSwaps",
    "code": "class Solution:\n    def minSwaps(self, A: List[int]) -> int:\n        s = lambda x: sum(int(d) for d in str(x))\n        B = sorted(A, key = lambda x: (s(x), x))\n        M = {v: i for i, v in enumerate(B)}\n        V, c = [0] * len(A), 0\n        for i in range(len(A)):\n            if V[i] or M[A[i]] == i: continue\n            j, l = i, 0\n            while not V[j]: V[j] = 1; j = M[A[j]]; l += 1\n            c += l - 1\n        return c\n",
    "input": "minSwaps(A=[37,100])",
    "output": "1",
    "correct_condition": "minSwaps(A=[37,100]) == 1",
    "contest_id": "weekly-contest-450",
    "contest_date": "2025-05-18T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 12,
      "coverage": null
    },
    "submission_id": 1636860563
  },
  {
    "id": "contest450_q3847_s2",
    "question_id": 3847,
    "function_name": "minSwaps",
    "code": "class Solution:\n    def minSwaps(self, nums: List[int]) -> int:\n        def digit_sum(x):\n            s = 0\n            while x:\n                s += x % 10\n                x //= 10\n            return s\n\n        sorted_nums = sorted(nums, key=lambda x: (digit_sum(x), x))\n        \n        pos = {val: i for i, val in enumerate(sorted_nums)}\n        perm = [pos[val] for val in nums]\n\n        n = len(nums)\n        visited = [False] * n\n        ret = 0\n\n        for i in range(n):\n            if visited[i] or perm[i] == i:\n                continue\n            cycle_size = 0\n            j = i\n            while not visited[j]:\n                visited[j] = True\n                j = perm[j]\n                cycle_size += 1\n            ret += cycle_size - 1\n\n        return ret",
    "input": "minSwaps(nums=[37,100])",
    "output": "1",
    "correct_condition": "minSwaps(nums=[37,100]) == 1",
    "contest_id": "weekly-contest-450",
    "contest_date": "2025-05-18T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 30,
      "coverage": null
    },
    "submission_id": 1636857131
  },
  {
    "id": "contest450_q3837_s0",
    "question_id": 3837,
    "function_name": "minMoves",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nimport heapq\nclass Solution:\n    def minMoves(self, matrix: List[str]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        ls = matrix[:]\n\n        dd = defaultdict(list)\n        for i in range(m):\n            for j in range(n):\n                c = ls[i][j]\n                if 'A' <= c <= 'Z':\n                    dd[c].append((i, j))\n\n        INF = float('inf')\n        dist = [[INF] * n for i in range(m)]\n        dist[0][0] = 0\n\n        pq = [(0, 0, 0)]\n        ps = [False] * 26\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        while pq:\n            d, x, y = heapq.heappop(pq)\n            if d > dist[x][y]:\n                continue\n            if x == m - 1 and y == n - 1:\n                break\n\n            c = ls[x][y]\n            if 'A' <= c <= 'Z':\n                idx = ord(c) - ord('A')\n                if not ps[idx]:\n                    ps[idx] = True\n                    for px, py in dd[c]:\n                        if dist[px][py] > d:\n                            dist[px][py] = d\n                            heapq.heappush(pq, (d, px, py))\n                    dd[c].clear()\n\n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and ls[nx][ny] != '#':\n                    if dist[nx][ny] > d + 1:\n                        dist[nx][ny] = d + 1\n                        heapq.heappush(pq, (d + 1, nx, ny))\n\n        return -1 if dist[m-1][n-1] == INF else dist[m-1][n-1]\n",
    "input": "minMoves(matrix=[\"A..\",\".A.\",\"...\"])",
    "output": "2",
    "correct_condition": "minMoves(matrix=[\"A..\",\".A.\",\"...\"]) == 2",
    "contest_id": "weekly-contest-450",
    "contest_date": "2025-05-18T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 247,
      "coverage": null
    },
    "submission_id": 1636871333
  },
  {
    "id": "contest450_q3837_s1",
    "question_id": 3837,
    "function_name": "minMoves",
    "code": "from collections import deque, defaultdict\nclass Solution:\n    def minMoves(self, M: List[str]) -> int:\n        m, n, P = len(M), len(M[0]), defaultdict(list)\n        for i in range(m):\n            for j in range(n):\n                c = M[i][j]\n                if 'A' <= c <= 'Z': P[c].append((i, j))\n        D = [[1e9]*n for _ in range(m)]\n        D[0][0], Q, U = 0, deque([(0, 0)]), set()\n        while Q:\n            x, y = Q.popleft()\n            if (x, y) == (m-1, n-1): return D[x][y]\n            c = M[x][y]\n            if 'A' <= c <= 'Z' and c not in U:\n                for a, b in P[c]:\n                    if D[a][b] > D[x][y]: D[a][b] = D[x][y]; Q.appendleft((a, b))\n                U.add(c)\n            for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\n                a, b = x+dx, y+dy\n                if 0<=a<m and 0<=b<n and M[a][b] != '#' and D[a][b] > D[x][y]+1: D[a][b] = D[x][y]+1; Q.append((a, b))\n        return -1\n",
    "input": "minMoves(M=[\"A..\",\".A.\",\"...\"])",
    "output": "2",
    "correct_condition": "minMoves(M=[\"A..\",\".A.\",\"...\"]) == 2",
    "contest_id": "weekly-contest-450",
    "contest_date": "2025-05-18T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 22,
      "coverage": null
    },
    "submission_id": 1636869616
  },
  {
    "id": "contest450_q3837_s2",
    "question_id": 3837,
    "function_name": "minMoves",
    "code": "class Solution:\n    def minMoves(self, matrix: List[str]) -> int:\n        m, n = len(matrix), len(matrix[0])\n\n        portals = defaultdict(list)\n        for i in range(m):\n            for j in range(n):\n                c = matrix[i][j]\n                if 'A' <= c <= 'Z':\n                    portals[c].append((i, j))\n\n        INF = float('inf')\n        dist = [[INF]*n for _ in range(m)]\n        if matrix[0][0] == '#':\n            return -1\n        dist[0][0] = 0\n\n        dq = deque([(0, 0)])\n        used_portal = set()\n\n\n        while dq:\n            i, j = dq.popleft()\n            d = dist[i][j]\n\n            if i == m-1 and j == n-1:\n                return d\n\n\n            c = matrix[i][j]\n            if 'A' <= c <= 'Z' and c not in used_portal:\n                used_portal.add(c)\n                for ti, tj in portals[c]:\n                    if dist[ti][tj] > d:\n                        dist[ti][tj] = d\n                        dq.appendleft((ti, tj))\n\n            for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] != '#' and dist[ni][nj] > d+1:\n                    dist[ni][nj] = d+1\n                    dq.append((ni, nj))\n\n        return -1\n",
    "input": "minMoves(matrix=[\"A..\",\".A.\",\"...\"])",
    "output": "2",
    "correct_condition": "minMoves(matrix=[\"A..\",\".A.\",\"...\"]) == 2",
    "contest_id": "weekly-contest-450",
    "contest_date": "2025-05-18T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 44,
      "coverage": null
    },
    "submission_id": 1636866823
  },
  {
    "id": "contest450_q3853_s0",
    "question_id": 3853,
    "function_name": "minimumWeight",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nimport math\nclass Solution:\n    def minimumWeight(self, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n        n = len(edges) + 1\n        adj = [[] for _ in range(n)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n\n        LOG = math.ceil(math.log2(n))\n        depth = [0] * n\n        dist = [0] * n\n        up = [[0] * n for _ in range(LOG + 1)]\n\n        def dfs(u, p):\n            up[0][u] = p\n            for v, w in adj[u]:\n                if v == p:\n                    continue\n                depth[v] = depth[u] + 1\n                dist[v] = dist[u] + w\n                dfs(v, u)\n\n        dfs(0, 0)\n\n        for i in range(1, LOG + 1):\n            for v in range(n):\n                up[i][v] = up[i - 1][up[i - 1][v]]\n\n        def lca(u, v):\n            if depth[u] < depth[v]:\n                u, v = v, u\n            diff = depth[u] - depth[v]\n            for i in range(LOG + 1):\n                if diff & (1 << i):\n                    u = up[i][u]\n            if u == v:\n                return u\n            for i in range(LOG, -1, -1):\n                if up[i][u] != up[i][v]:\n                    u = up[i][u]\n                    v = up[i][v]\n            return up[0][u]\n\n        def gdist(x, y):\n            z = lca(x, y)\n            return dist[x] + dist[y] - 2 * dist[z]\n\n\n        ans = []\n        for a, b, c in queries:\n            d1 = gdist(a, b)\n            d2 = gdist(b, c)\n            d3 = gdist(a, c)\n            tot = (d1 + d2 + d3) // 2\n            ans.append(int(tot))\n\n        return ans\n",
    "input": "minimumWeight(edges=[[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], queries=[[2,3,4],[0,2,5]])",
    "output": "[12, 11]",
    "correct_condition": "minimumWeight(edges=[[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], queries=[[2,3,4],[0,2,5]]) == [12, 11]",
    "contest_id": "weekly-contest-450",
    "contest_date": "2025-05-18T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 258,
      "coverage": null
    },
    "submission_id": 1636870214
  },
  {
    "id": "contest450_q3853_s1",
    "question_id": 3853,
    "function_name": "minimumWeight",
    "code": "import sys\nclass Solution:\n    def minimumWeight(self, edges, queries):\n        n = len(edges) + 1\n        adj = [[] for _ in range(n)]\n        for u, v, w in edges: adj[u].append((v, w)); adj[v].append((u, w))\n        \n        sys.setrecursionlimit(n + 5000); K = n.bit_length()\n        depth, dist, up = [-1] * n, [-1] * n, [[0] * K for _ in range(n)]\n        \n        def dfs(u, p, dep, dsum):\n            depth[u], dist[u], up[u][0] = dep, dsum, p\n            for v, w in adj[u]:\n                if v != p: dfs(v, u, dep + 1, dsum + w)    \n        dfs(0, 0, 0, 0)\n        for k in range(1, K):\n            for i in range(n): up[i][k] = up[up[i][k-1]][k-1]\n        def get_lca(u, v):\n            if depth[u] < depth[v]: u, v = v, u\n            for k in range(K-1, -1, -1):\n                if depth[u] - (1 << k) >= depth[v]: u = up[u][k]\n            if u == v: return u\n            for k in range(K-1, -1, -1):\n                if up[u][k] != up[v][k]: u, v = up[u][k], up[v][k]\n            return up[u][0]\n        \n        def get_dist(u, v): return dist[u] + dist[v] - 2 * dist[get_lca(u, v)]\n        \n        return [(get_dist(x, y) + get_dist(x, z) + get_dist(y, z)) // 2 for x, y, z in queries]",
    "input": "minimumWeight(edges=[[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], queries=[[2,3,4],[0,2,5]])",
    "output": "[12, 11]",
    "correct_condition": "minimumWeight(edges=[[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], queries=[[2,3,4],[0,2,5]]) == [12, 11]",
    "contest_id": "weekly-contest-450",
    "contest_date": "2025-05-18T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 29,
      "coverage": null
    },
    "submission_id": 1636875750
  },
  {
    "id": "contest450_q3853_s2",
    "question_id": 3853,
    "function_name": "minimumWeight",
    "code": "class Solution:\n    def minimumWeight(self, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n        n = max(max(u, v) for u, v, _ in edges) + 1\n        adj = [[] for _ in range(n)]\n    \n        for u, v, w in edges:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n            \n        LOG = (n-1).bit_length() + 1\n        parent = [[-1]*n for _ in range(LOG)]\n        depth = [0]*n\n        dist_root = [0]*n\n        \n        stack = [(0, -1)]\n        \n        while stack:\n            u, p = stack.pop()\n            parent[0][u] = p\n            for v, w in adj[u]:\n                if v == p:\n                    continue\n                depth[v] = depth[u] + 1\n                dist_root[v] = dist_root[u] + w\n                stack.append((v, u))\n                \n        for k in range(1, LOG):\n            for v in range(n):\n                pp = parent[k-1][v]\n                parent[k][v] = -1 if pp < 0 else parent[k-1][pp]      \n        \n        def lca(u, v):\n            if depth[u] < depth[v]:\n                u, v = v, u\n            diff = depth[u] - depth[v]\n            \n            for k in range(LOG):\n                if diff >> k & 1:\n                    u = parent[k][u]\n            if u == v:\n                return u\n\n            for k in reversed(range(LOG)):\n                if parent[k][u] != parent[k][v]:\n                    u = parent[k][u]\n                    v = parent[k][v]\n            return parent[0][u]\n        \n        def dist(u, v):\n            w = lca(u, v)\n            return dist_root[u] + dist_root[v] - 2*dist_root[w]\n\n        ret = []\n        \n        for s1, s2, d in queries:\n            d12 = dist(s1, s2)\n            d1d = dist(s1, d)\n            d2d = dist(s2, d)\n            ret.append((d12 + d1d + d2d) // 2)\n        return ret\n\n",
    "input": "minimumWeight(edges=[[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], queries=[[2,3,4],[0,2,5]])",
    "output": "[12, 11]",
    "correct_condition": "minimumWeight(edges=[[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], queries=[[2,3,4],[0,2,5]]) == [12, 11]",
    "contest_id": "weekly-contest-450",
    "contest_date": "2025-05-18T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 61,
      "coverage": null
    },
    "submission_id": 1636875390
  },
  {
    "id": "contest451_q3879_s0",
    "question_id": 3879,
    "function_name": "minCuttingCost",
    "code": "class Solution:\n  def minCuttingCost(self, n: int, m: int, k: int) -> int:\n    return (n - k) * k * (n > k) + (m - k) * k * (m > k)\n",
    "input": "minCuttingCost(n=6, m=5, k=5)",
    "output": "5",
    "correct_condition": "minCuttingCost(n=6, m=5, k=5) == 5",
    "contest_id": "weekly-contest-451",
    "contest_date": "2025-05-25T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 3,
      "coverage": null
    },
    "submission_id": 1643574218
  },
  {
    "id": "contest451_q3879_s1",
    "question_id": 3879,
    "function_name": "minCuttingCost",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def minCuttingCost(self, n: int, m: int, k: int) -> int:\n        if n <= k and m <= k:\n            return 0\n        if n > k:\n            return k * (n - k)\n        else:\n            return k * (m - k)\n\n\n",
    "input": "minCuttingCost(n=6, m=5, k=5)",
    "output": "5",
    "correct_condition": "minCuttingCost(n=6, m=5, k=5) == 5",
    "contest_id": "weekly-contest-451",
    "contest_date": "2025-05-25T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 210,
      "coverage": null
    },
    "submission_id": 1643581820
  },
  {
    "id": "contest451_q3879_s2",
    "question_id": 3879,
    "function_name": "minCuttingCost",
    "code": "class Solution:\n    def minCuttingCost(self, n: int, m: int, k: int) -> int:\n        if n <= k and m <= k:\n            return 0\n        L = max(n, m)\n        return k * (L - k)",
    "input": "minCuttingCost(n=6, m=5, k=5)",
    "output": "5",
    "correct_condition": "minCuttingCost(n=6, m=5, k=5) == 5",
    "contest_id": "weekly-contest-451",
    "contest_date": "2025-05-25T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 6,
      "coverage": null
    },
    "submission_id": 1643562222
  },
  {
    "id": "contest451_q3860_s0",
    "question_id": 3860,
    "function_name": "resultingString",
    "code": "import collections\n\nclass Solution:\n  def resultingString(self, s: str) -> str:\n    r = []\n    for c in s:\n      if r and (abs(ord(c) - ord(r[-1])) == 1 or abs(ord(c) - ord(r[-1])) == 25): r.pop()\n      else: r.append(c)\n    return \"\".join(r)",
    "input": "resultingString(s=\"abc\")",
    "output": "'c'",
    "correct_condition": "resultingString(s=\"abc\") == 'c'",
    "contest_id": "weekly-contest-451",
    "contest_date": "2025-05-25T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 9,
      "coverage": null
    },
    "submission_id": 1643564642
  },
  {
    "id": "contest451_q3860_s1",
    "question_id": 3860,
    "function_name": "resultingString",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def resultingString(self, s: str) -> str:\n        stk = []\n        for c in s:\n            if stk:\n                t = stk[-1]\n                d = abs(ord(t) - ord(c))\n                if d == 1 or d == 25:\n                    stk.pop()\n                    continue\n            stk.append(c)\n        return ''.join(stk)\n\n",
    "input": "resultingString(s=\"abc\")",
    "output": "'c'",
    "correct_condition": "resultingString(s=\"abc\") == 'c'",
    "contest_id": "weekly-contest-451",
    "contest_date": "2025-05-25T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 213,
      "coverage": null
    },
    "submission_id": 1643582626
  },
  {
    "id": "contest451_q3860_s2",
    "question_id": 3860,
    "function_name": "resultingString",
    "code": "class Solution:\n    def resultingString(self, s: str) -> str:\n        def fn(a, b):\n            d = abs(ord(a) - ord(b))\n            return d == 1 or d == 25\n\n        st = []\n        for c in s:\n            if st and fn(st[-1], c):\n                st.pop()\n            else:\n                st.append(c)\n        return \"\".join(st)",
    "input": "resultingString(s=\"abc\")",
    "output": "'c'",
    "correct_condition": "resultingString(s=\"abc\") == 'c'",
    "contest_id": "weekly-contest-451",
    "contest_date": "2025-05-25T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 13,
      "coverage": null
    },
    "submission_id": 1643570457
  },
  {
    "id": "contest451_q3854_s0",
    "question_id": 3854,
    "function_name": "maxProfit",
    "code": "import collections\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, n: int, p: List[int], f: List[int], h: List[List[int]], b: int) -> int:\n        z = (n, p, f, h, b)\n        a = collections.defaultdict(list)\n        [a[u].append(v) for u, v in h]\n        m, o, s = {}, {}, [1]\n        while s:\n            u = s[-1]\n            if u in m: s.pop(); continue\n            if u not in o:\n                o[u] = 1\n                s += a[u]\n                continue\n            s.pop()\n            cb = cn = [0] + [-1e9]*b\n            for v in a[u]:\n                vb, vn = m[v]\n                nb = [-1e9]*(b+1)\n                for x in range(b+1):\n                    if cb[x] > -1e9:\n                        for y in range(b - x + 1):\n                            if vb[y] > -1e9:\n                                nb[x + y] = max(nb[x + y], cb[x] + vb[y])\n                cb = nb\n                nn = [-1e9]*(b+1)\n                for x in range(b+1):\n                    if cn[x] > -1e9:\n                        for y in range(b - x + 1):\n                            if vn[y] > -1e9: nn[x + y] = max(nn[x + y], cn[x] + vn[y])\n                cn = nn\n            f0 = cn[:]; f1 = cn[:]\n            c, pr = p[u - 1], f[u - 1]\n            if c <= b:\n                for x in range(b - c + 1):\n                    if cb[x] > -1e9: f1[x + c] = max(f1[x + c], cb[x] + pr - c)\n            c //= 2\n            if c <= b:\n                for x in range(b - c + 1):\n                    if cb[x] > -1e9: f0[x + c] = max(f0[x + c], cb[x] + pr - c)\n            m[u] = (f0, f1)\n        return max(max(m[1][1]), 0)\n",
    "input": "maxProfit(n=2, p=[1,2], f=[4,3], h=[[1,2]], b=3)",
    "output": "5",
    "correct_condition": "maxProfit(n=2, p=[1,2], f=[4,3], h=[[1,2]], b=3) == 5",
    "contest_id": "weekly-contest-451",
    "contest_date": "2025-05-25T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 44,
      "coverage": null
    },
    "submission_id": 1643590961
  },
  {
    "id": "contest451_q3854_s1",
    "question_id": 3854,
    "function_name": "maxProfit",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nimport sys\nsys.setrecursionlimit(10**7)\n\nclass Solution:\n    def maxProfit(self, n: int, present: List[int], future: List[int], hierarchy: List[List[int]], budget: int) -> int:\n\n        childs = [[] for _ in range(n)]\n        for u, v in hierarchy:\n            childs[u-1].append(v-1)\n\n        negg = -10**15\n        dp = [\n            [[negg] * (budget+1) for _ in range(2)]\n            for _ in range(n)\n        ]\n\n        def dfs(u: int) -> None:\n            for v in childs[u]:\n                dfs(v)\n\n            for eligible in (0, 1):\n                nb = [negg] * (budget+1)\n                nb[0] = 0\n                for v in childs[u]:\n                    nxt = [negg] * (budget+1)\n                    for cost1 in range(budget+1):\n                        if nb[cost1] < 0:\n                            continue\n                        for cost2 in range(budget+1 - cost1):\n                            prof2 = dp[v][0][cost2]\n                            if prof2 < 0:\n                                continue\n                            val = nb[cost1] + prof2\n                            if val > nxt[cost1 + cost2]:\n                                nxt[cost1 + cost2] = val\n                    nb = nxt\n\n                pr1 = (present[u] // 2) if eligible else present[u]\n                pr2 = future[u] - pr1\n                yb = [negg] * (budget+1)\n                if pr1 <= budget:\n                    yb[pr1] = pr2\n\n                for v in childs[u]:\n                    nxt = [negg] * (budget+1)\n                    for cost1 in range(budget+1):\n                        if yb[cost1] <= negg//2:\n                            continue\n                        for cost2 in range(budget+1 - cost1):\n                            prof2 = dp[v][1][cost2]\n                            if prof2 < 0:\n                                continue\n                            val = yb[cost1] + prof2\n                            if val > nxt[cost1 + cost2]:\n                                nxt[cost1 + cost2] = val\n                    yb = nxt\n\n                for c in range(budget+1):\n                    dp[u][eligible][c] = max(nb[c], yb[c])\n\n        dfs(0)\n        ans = max(dp[0][0])\n        return ans\n\n\n",
    "input": "maxProfit(n=2, present=[1,2], future=[4,3], hierarchy=[[1,2]], budget=3)",
    "output": "5",
    "correct_condition": "maxProfit(n=2, present=[1,2], future=[4,3], hierarchy=[[1,2]], budget=3) == 5",
    "contest_id": "weekly-contest-451",
    "contest_date": "2025-05-25T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 265,
      "coverage": null
    },
    "submission_id": 1643598764
  },
  {
    "id": "contest451_q3854_s2",
    "question_id": 3854,
    "function_name": "maxProfit",
    "code": "class Solution:\n    def maxProfit(self, n: int, p: List[int], f: List[int], hierarchy: List[List[int]], budget: int) -> int:\n        ch = [[] for _ in range(n + 1)]\n        for u, v in hierarchy:\n            ch[u].append(v)\n        MIN = -10**9\n        def merge(dp_list):\n            f = [0] + [MIN] * budget\n            for dp in dp_list:\n                nf = [MIN] * (budget + 1)\n                for spent in range(budget + 1):\n                    if f[spent] < 0:\n                        continue\n                    for b in range(budget - spent + 1):\n                        if dp[b] < 0:\n                            continue\n                        c = f[spent] + dp[b]\n                        if c > nf[spent + b]:\n                            nf[spent + b] = c\n                f = nf\n            return f\n        def dfs(u):\n            dp0 = []\n            dp1 = []\n            for v in ch[u]:\n                d0, d1 = dfs(v)\n                dp0.append(d0)\n                dp1.append(d1)\n            comb0 = merge(dp0) if dp0 else [0] + [MIN] * budget\n            comb1 = merge(dp1) if dp1 else [0] + [MIN] * budget\n            dp0u = [MIN] * (budget + 1)\n            dp1u = [MIN] * (budget + 1)\n            for b in range(budget + 1):\n                dp1u[b] = comb0[b]\n            cost = p[u - 1] >> 1\n            prof = f[u - 1] - cost\n            for b in range(cost, budget + 1):\n                if comb1[b - cost] < 0:\n                    continue\n                c = prof + comb1[b - cost]\n                if c > dp1u[b]:\n                    dp1u[b] = c\n            for b in range(budget + 1):\n                dp0u[b] = comb0[b]\n            costf = p[u - 1]\n            proff = f[u - 1] - costf\n            for b in range(costf, budget + 1):\n                if comb1[b - costf] < 0:\n                    continue\n                c = proff + comb1[b - costf]\n                if c > dp0u[b]:\n                    dp0u[b] = c\n            return dp0u, dp1u\n        dp0_root, _ = dfs(1)\n        return max(dp0_root)",
    "input": "maxProfit(n=2, p=[1,2], f=[4,3], hierarchy=[[1,2]], budget=3)",
    "output": "5",
    "correct_condition": "maxProfit(n=2, p=[1,2], f=[4,3], hierarchy=[[1,2]], budget=3) == 5",
    "contest_id": "weekly-contest-451",
    "contest_date": "2025-05-25T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 55,
      "coverage": null
    },
    "submission_id": 1643586884
  },
  {
    "id": "contest451_q3867_s0",
    "question_id": 3867,
    "function_name": "lexicographicallySmallestString",
    "code": "class Solution:\n  def lexicographicallySmallestString(self, a: str) -> str:\n    b = len(a)\n    if b == 0: return \"\"\n    def f(x, y): return abs(ord(x) - ord(y)) == 1 or {x, y} == {'a', 'z'}\n    c = [[False] * b for _ in range(b)]\n    for d in range(2, b + 1, 2):\n      for e in range(b - d + 1):\n        j = e + d - 1\n        if f(a[e], a[j]) and (j - e == 1 or c[e + 1][j - 1]): c[e][j] = True\n        else:\n          for g in range(2, d, 2):\n            if c[e][e + g - 1] and c[e + g][j]: c[e][j] = True; break\n    h = [\"\"] * (b + 1)\n    for i in range(b - 1, -1, -1):\n      j = min(a[i:], a[i] + h[i + 1])\n      for k in range(i + 1, b):\n        if f(a[i], a[k]) and (k - i == 1 or c[i + 1][k - 1]): j = min(j, h[k + 1])\n      h[i] = j\n    return h[0]\n",
    "input": "lexicographicallySmallestString(a=\"abc\")",
    "output": "'a'",
    "correct_condition": "lexicographicallySmallestString(a=\"abc\") == 'a'",
    "contest_id": "weekly-contest-451",
    "contest_date": "2025-05-25T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 20,
      "coverage": null
    },
    "submission_id": 1643600049
  },
  {
    "id": "contest451_q3867_s1",
    "question_id": 3867,
    "function_name": "lexicographicallySmallestString",
    "code": "class Solution:\n    def lexicographicallySmallestString(self, s: str) -> str:\n        n = len(s)\n        v = [ord(c) - ord('a') for c in s]\n        arr = [[False]*26 for _ in range(26)]\n        for c in range(26):\n            arr[c][(c+1)%26] = True\n            arr[c][(c-1)%26] = True\n        red = [[False]*n for _ in range(n)]\n        for le in range(2, n+1, 2):\n            for i in range(n - le + 1):\n                j = i + le - 1\n                c1 = v[i]\n                for k in range(i+1, j+1, 2):\n                    c2 = v[k]\n                    if not arr[c1][c2]:\n                        continue\n                    if i+1 <= k-1 and not red[i+1][k-1]:\n                        continue\n                    if k+1 <= j and not red[k+1][j]:\n                        continue\n                    red[i][j] = True\n                    break\n        keep = [0]*(n+1)\n        keepp = [0]*(n+1)\n        keep[n] = 2\n        compMemo = {}\n        \n        def first(h, p):\n            if h is not None:\n                return v[h], (None, p)\n            while p < n:\n                k = keep[p]\n                if k == 2:\n                    return None, (None, n)\n                if k == 0:\n                    return v[p], (None, p+1)\n                p = keepp[p] + 1\n            return None, (None, n)\n        \n        def small(h1, p1, h2, p2):\n            key = (h1, p1, h2, p2)\n            if key in compMemo:\n                return compMemo[key]\n            c1, nxt1 = first(h1, p1)\n            c2, nxt2 = first(h2, p2)\n            if c1 is None and c2 is None:\n                compMemo[key] = False\n                return False\n            if c1 is None:\n                compMemo[key] = True\n                return True\n            if c2 is None:\n                compMemo[key] = False\n                return False\n            if c1 != c2:\n                res = c1 < c2\n                compMemo[key] = res\n                return res\n            res = small(nxt1[0], nxt1[1], nxt2[0], nxt2[1])\n            compMemo[key] = res\n            return res\n        \n        for i in range(n-1, -1, -1):\n            best_h, best_p = i, i+1\n            c1 = v[i]\n            for k in range(i+1, n, 2):\n                c2 = v[k]\n                if not arr[c1][c2]:\n                    continue\n                if i+1 <= k-1 and not red[i+1][k-1]:\n                    continue\n                cand_h, cand_p = None, k+1\n                if small(cand_h, cand_p, best_h, best_p):\n                    best_h, best_p = cand_h, cand_p\n            if best_h == i:\n                keep[i] = 0\n            else:\n                keep[i] = 1\n                keepp[i] = best_p - 1\n        \n        res = []\n        h, p = None, 0\n        while True:\n            c, (nh, np) = first(h, p)\n            if c is None:\n                break\n            res.append(chr(c + ord('a')))\n            h, p = nh, np\n        \n        return \"\".join(res)\n",
    "input": "lexicographicallySmallestString(s=\"abc\")",
    "output": "'a'",
    "correct_condition": "lexicographicallySmallestString(s=\"abc\") == 'a'",
    "contest_id": "weekly-contest-451",
    "contest_date": "2025-05-25T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 91,
      "coverage": null
    },
    "submission_id": 1643613833
  },
  {
    "id": "contest451_q3867_s2",
    "question_id": 3867,
    "function_name": "lexicographicallySmallestString",
    "code": "class Solution:\n    def lexicographicallySmallestString(self, s: str) -> str:\n        n = len(s)\n\n        def helper(c1 ,c2):\n          o1, o2 = ord(c1), ord(c2)\n          return abs(o1 - o2) == 1 or abs(o1 - o2) == 25\n\n        mp = collections.defaultdict(bool)\n\n        for l in range(2, n + 1, 2):\n          for i in range(n - l + 1):\n            j = i + l - 1\n\n            if helper(s[i], s[j]):\n              if l == 2 or mp[i + 1, j - 1]:\n                mp[i, j] = True\n                continue\n\n            for k in range(i + 1, j, 2):\n              if mp[i, k] and mp[k + 1, j]:\n                mp[i, j] = True\n                break\n\n        dp = [\"\"] * (n + 1)\n        \n        for i in range(n - 1, -1, -1):\n          dp[i] = s[i] + dp[i + 1]\n          for j in range(i + 1, n, 2):\n            if mp[i, j]:\n              if dp[j + 1] < dp[i]:\n                dp[i] = dp[j + 1]\n                \n        return dp[0]",
    "input": "lexicographicallySmallestString(s=\"abc\")",
    "output": "'a'",
    "correct_condition": "lexicographicallySmallestString(s=\"abc\") == 'a'",
    "contest_id": "weekly-contest-451",
    "contest_date": "2025-05-25T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 34,
      "coverage": null
    },
    "submission_id": 1643592447
  },
  {
    "id": "contest452_q3843_s0",
    "question_id": 3843,
    "function_name": "checkEqualPartitions",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def checkEqualPartitions(self, nums: List[int], target: int) -> bool:\n        ps = 1\n        for x in nums:\n            ps *= x\n\n        if ps != target * target:\n            return False\n\n        nums.sort(reverse=True)\n        n = len(nums)\n\n        def dfs(i, curr, count):\n            if curr == target:\n                return count < n\n            if i >= n or curr > target:\n                return False\n            if curr * nums[i] <= target:\n                if dfs(i + 1, curr * nums[i], count + 1):\n                    return True\n            if dfs(i + 1, curr, count):\n                return True\n            return False\n\n        return dfs(0, 1, 0)\n",
    "input": "checkEqualPartitions(nums=[3,1,6,8,4], target=24)",
    "output": "True",
    "correct_condition": "checkEqualPartitions(nums=[3,1,6,8,4], target=24) == True",
    "contest_id": "weekly-contest-452",
    "contest_date": "2025-06-01T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 225,
      "coverage": null
    },
    "submission_id": 1650242381
  },
  {
    "id": "contest452_q3843_s1",
    "question_id": 3843,
    "function_name": "checkEqualPartitions",
    "code": "class Solution:\n    def checkEqualPartitions(self, nums: List[int], target: int) -> bool:\n        n = len(nums)\n        total = 1\n        for v in nums:\n            total *= v\n        if total != target * target:\n            return False\n        for mask in range(1, (1 << n)-1):\n            prod = 1\n            for i in range(n):\n                if (mask >> i) & 1:\n                    prod *= nums[i]\n            if prod == target:\n                return True\n        return False",
    "input": "checkEqualPartitions(nums=[3,1,6,8,4], target=24)",
    "output": "True",
    "correct_condition": "checkEqualPartitions(nums=[3,1,6,8,4], target=24) == True",
    "contest_id": "weekly-contest-452",
    "contest_date": "2025-06-01T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 16,
      "coverage": null
    },
    "submission_id": 1650219505
  },
  {
    "id": "contest452_q3843_s2",
    "question_id": 3843,
    "function_name": "checkEqualPartitions",
    "code": "class Solution:\n    def checkEqualPartitions(self, nums: List[int], target: int) -> bool:\n        if prod(nums) != target * target:\n            return False\n\n        n = len(nums)\n        for k in range(1, n):\n            for c in combinations(nums, k):\n                if prod(c) == target:\n                    return True\n\n        return False\n",
    "input": "checkEqualPartitions(nums=[3,1,6,8,4], target=24)",
    "output": "True",
    "correct_condition": "checkEqualPartitions(nums=[3,1,6,8,4], target=24) == True",
    "contest_id": "weekly-contest-452",
    "contest_date": "2025-06-01T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 12,
      "coverage": null
    },
    "submission_id": 1650218659
  },
  {
    "id": "contest452_q3884_s0",
    "question_id": 3884,
    "function_name": "minAbsDiff",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def minAbsDiff(self, grid: List[List[int]], k: int) -> List[List[int]]:\n        m = len(grid)\n        n = len(grid[0])\n        rows = m - k + 1\n        cols = n - k + 1\n        \n        ans = [[0] * cols for _ in range(rows)]\n        \n        for i in range(m - k + 1):\n            for j in range(n - k + 1):\n                vals = []\n                for xx in range(i, i + k):\n                    for yy in range(j, j + k):\n                        vals.append(grid[xx][yy])\n                \n                if len(vals) < 2:\n                    ans[i][j] = 0\n                    continue\n                \n                vals.sort()\n                vals = list(dict.fromkeys(vals))\n                \n                if len(vals) < 2:\n                    ans[i][j] = 0\n                    continue\n                \n                mind = float('inf')\n                for idx in range(1, len(vals)):\n                    diff = vals[idx] - vals[idx - 1]\n                    if diff < mind:\n                        mind = diff\n                        if mind == 0:\n                            break\n                \n                ans[i][j] = mind\n        \n        return ans\n",
    "input": "minAbsDiff(grid=[[1,8],[3,-2]], k=2)",
    "output": "[[2]]",
    "correct_condition": "minAbsDiff(grid=[[1,8],[3,-2]], k=2) == [[2]]",
    "contest_id": "weekly-contest-452",
    "contest_date": "2025-06-01T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 238,
      "coverage": null
    },
    "submission_id": 1650241797
  },
  {
    "id": "contest452_q3884_s1",
    "question_id": 3884,
    "function_name": "minAbsDiff",
    "code": "class Solution:\n    def minAbsDiff(self, grid: List[List[int]], k: int) -> List[List[int]]:\n        m = len(grid)\n        n = len(grid[0])\n        rows = m - k + 1\n        cols = n - k + 1\n        result = [[0 for _ in range(cols)] for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                values = []\n                for x in range(i, i + k):\n                    for y in range(j, j + k):\n                        values.append(grid[x][y])\n                uniq = sorted(set(values))\n                if len(uniq) <= 1:\n                    result[i][j] = 0\n                else:\n                    mindiff = abs(uniq[1] - uniq[0])\n                    for idx in range(2, len(uniq)):\n                        diff = abs(uniq[idx] - uniq[idx - 1])\n                        if diff < mindiff:\n                            mindiff = diff\n                    result[i][j] = mindiff\n        return result",
    "input": "minAbsDiff(grid=[[1,8],[3,-2]], k=2)",
    "output": "[[2]]",
    "correct_condition": "minAbsDiff(grid=[[1,8],[3,-2]], k=2) == [[2]]",
    "contest_id": "weekly-contest-452",
    "contest_date": "2025-06-01T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 24,
      "coverage": null
    },
    "submission_id": 1650226503
  },
  {
    "id": "contest452_q3884_s2",
    "question_id": 3884,
    "function_name": "minAbsDiff",
    "code": "class Solution:\n    def minAbsDiff(self, grid: List[List[int]], k: int) -> List[List[int]]:\n        m = len(grid)\n        n = len(grid[0])\n\n        def f(i, j):\n            sg = sorted({grid[x][y] for x in range(i, i + k) for y in range(j, j + k)})\n            # print(f\" subgrid   ({i}, {j}): {sg}\")\n\n            return min((b - a for a, b in zip(sg, sg[1:])), default=0)\n\n        return [[f(i, j) for j in range(n - k + 1)] for i in range(m - k + 1)]\n",
    "input": "minAbsDiff(grid=[[1,8],[3,-2]], k=2)",
    "output": "[[2]]",
    "correct_condition": "minAbsDiff(grid=[[1,8],[3,-2]], k=2) == [[2]]",
    "contest_id": "weekly-contest-452",
    "contest_date": "2025-06-01T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 12,
      "coverage": null
    },
    "submission_id": 1650223478
  },
  {
    "id": "contest452_q3870_s0",
    "question_id": 3870,
    "function_name": "minMoves",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def minMoves(self, classroom: List[str], energy: int) -> int:\n        grid = classroom\n        m, n = len(grid), len(grid[0])\n        dr = (-1, 1, 0, 0)\n        dc = (0, 0, -1, 1)\n\n        ls = []\n        idx = [[-1]*n for _ in range(m)]\n        sr = sc = -1\n\n        for i in range(m):\n            for j in range(n):\n                c = grid[i][j]\n                if c == 'S':\n                    sr, sc = i, j\n                elif c == 'L':\n                    lid = len(ls)\n                    ls.append((i, j))\n                    idx[i][j] = lid\n\n        sz = len(ls)\n        if sz == 0:\n            return 0\n        msk = (1 << sz) - 1\n        msksz = 1 << sz\n\n        vis = [[[-1] * msksz for _ in range(n)] for __ in range(m)]\n        dq = deque()\n        vis[sr][sc][0] = energy\n        dq.append((sr, sc, 0, energy, 0))\n\n        while dq:\n            r, c, mask, rems, steps = dq.popleft()\n            for d in range(4):\n                nr, nc = r + dr[d], c + dc[d]\n                ne = rems - 1\n                if not (0 <= nr < m and 0 <= nc < n):\n                    continue\n                if grid[nr][nc] == 'X' or ne < 0:\n                    continue\n                if grid[nr][nc] == 'R':\n                    ne = energy\n                nmsk = mask\n                if grid[nr][nc] == 'L':\n                    lid = idx[nr][nc]\n                    nmsk = mask | (1 << lid)\n                if nmsk == msk:\n                    return steps + 1\n                if vis[nr][nc][nmsk] >= ne:\n                    continue\n                vis[nr][nc][nmsk] = ne\n                dq.append((nr, nc, nmsk, ne, steps + 1))\n\n        return -1\n",
    "input": "minMoves(classroom=[\"S.\", \"XL\"], energy=2)",
    "output": "2",
    "correct_condition": "minMoves(classroom=[\"S.\", \"XL\"], energy=2) == 2",
    "contest_id": "weekly-contest-452",
    "contest_date": "2025-06-01T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 255,
      "coverage": null
    },
    "submission_id": 1650244035
  },
  {
    "id": "contest452_q3870_s1",
    "question_id": 3870,
    "function_name": "minMoves",
    "code": "from collections import deque\n\nclass Solution:\n    def minMoves(self, classroom: List[str], energy: int) -> int:\n        m = len(classroom)\n        n = len(classroom[0])\n        startI = startJ = 0\n        litterMap = {}\n        idx = 0\n        for i in range(m):\n            for j in range(n):\n                c = classroom[i][j]\n                if c == 'S':\n                    startI, startJ = i, j\n                elif c == 'L':\n                    litterMap[(i, j)] = idx\n                    idx += 1\n        allMask = (1 << idx) - 1\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[[-1] * (1 << idx) for _ in range(n)] for __ in range(m)]\n        dq = deque()\n        visited[startI][startJ][0] = energy\n        dq.append((startI, startJ, 0, energy, 0))\n        while dq:\n            i, j, mask, e, moves = dq.popleft()\n            if mask == allMask:\n                return moves\n            for di, dj in dirs:\n                ni, nj = i + di, j + dj\n                if ni < 0 or ni >= m or nj < 0 or nj >= n:\n                    continue\n                cell = classroom[ni][nj]\n                if cell == 'X':\n                    continue\n                ne = e - 1\n                if ne < 0:\n                    continue\n                if cell == 'R':\n                    ne = energy\n                nm = mask\n                if cell == 'L':\n                    nm = mask | (1 << litterMap[(ni, nj)])\n                if visited[ni][nj][nm] >= ne:\n                    continue\n                visited[ni][nj][nm] = ne\n                dq.append((ni, nj, nm, ne, moves + 1))\n        return -1",
    "input": "minMoves(classroom=[\"S.\", \"XL\"], energy=2)",
    "output": "2",
    "correct_condition": "minMoves(classroom=[\"S.\", \"XL\"], energy=2) == 2",
    "contest_id": "weekly-contest-452",
    "contest_date": "2025-06-01T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 47,
      "coverage": null
    },
    "submission_id": 1650270272
  },
  {
    "id": "contest452_q3870_s2",
    "question_id": 3870,
    "function_name": "minMoves",
    "code": "class Solution:\n    def minMoves(self, classroom: List[str], energy: int) -> int:\n        graph = classroom\n        _m = {}\n\n        m = len(classroom)\n        n = len(classroom[0])\n\n        DIRS = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        k = 0\n        for i in range(m):\n            for j in range(n):\n                if graph[i][j] == \"S\":\n                    _x, _y = i, j\n                elif graph[i][j] == \"L\":\n                    _m[i, j] = k\n                    k += 1\n\n        target = (1 << k) - 1\n        if target == 0:\n            return 0\n\n        dp = [[[-1] * (1 << k) for _ in range(n)] for _ in range(m)]\n        q = [(0, _x, _y, energy, 0)]\n\n        while q:\n            d, x, y, e, mask = heapq.heappop(q)\n            if mask == target:\n                return d\n\n            if dp[x][y][mask] >= e:\n                continue\n            dp[x][y][mask] = e\n\n            for dx, dy in DIRS:\n                nx = x + dx\n                ny = y + dy\n                if 0 <= nx < m and 0 <= ny < n:\n                    if graph[nx][ny] != \"X\":\n                        v = e - 1\n                        if v < 0:\n                            continue\n\n                        _mask = mask\n\n                        if graph[nx][ny] == \"R\":\n                            v = energy\n                        elif graph[nx][ny] == \"L\":\n                            _mask |= 1 << _m[nx, ny]\n                        # print(f\"seen  ({nx}, {ny}) with energy {v} and mask {_mask:0{len(_m)}b}\")\n                        if dp[nx][ny][_mask] < v:\n                            heapq.heappush(q, (d + 1, nx, ny, v, _mask))\n        return -1\n",
    "input": "minMoves(classroom=[\"S.\", \"XL\"], energy=2)",
    "output": "2",
    "correct_condition": "minMoves(classroom=[\"S.\", \"XL\"], energy=2) == 2",
    "contest_id": "weekly-contest-452",
    "contest_date": "2025-06-01T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 54,
      "coverage": null
    },
    "submission_id": 1650235495
  },
  {
    "id": "contest452_q3878_s0",
    "question_id": 3878,
    "function_name": "maximumCount",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nimport bisect\n\nclass Solution:\n    def maximumCount(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        N = n - 1\n        maxv = 0\n        for v in nums:\n            if v > maxv:\n                maxv = v\n        for _, v in queries:\n            if v > maxv:\n                maxv = v\n        isprime = [True] * (maxv + 1)\n        if maxv >= 0:\n            isprime[0] = False\n        if maxv >= 1:\n            isprime[1] = False\n        p = 2\n        while p * p <= maxv:\n            if isprime[p]:\n                for j in range(p * p, maxv + 1, p):\n                    isprime[j] = False\n            p += 1\n        pos = {}\n        for i, v in enumerate(nums):\n            if v <= maxv and isprime[v]:\n                pos.setdefault(v, []).append(i)\n        diff = [0] * (N + 2)\n        for p, lst in pos.items():\n            L = lst[0]\n            R = lst[-1]\n            start = L + 1\n            if start <= N:\n                diff[start] += 1\n                diff[N + 1] -= 1\n            end = R if R <= N else N\n            if end >= 1:\n                diff[1] += 1\n                diff[end + 1] -= 1\n        f = [0] * (N + 1)\n        if N >= 1:\n            f[1] = diff[1]\n            for k in range(2, N + 1):\n                f[k] = f[k - 1] + diff[k]\n        st = [0] * (4 * (N + 1))\n        lz = [0] * (4 * (N + 1))\n        def build(node, l, r):\n            if l == r:\n                st[node] = f[l]\n                return\n            mid = (l + r) >> 1\n            build(node << 1, l, mid)\n            build(node << 1 | 1, mid + 1, r)\n            st[node] = st[node << 1] if st[node << 1] > st[node << 1 | 1] else st[node << 1 | 1]\n        def apply(node, val):\n            st[node] += val\n            lz[node] += val\n        def push(node):\n            v = lz[node]\n            if v:\n                apply(node << 1, v)\n                apply(node << 1 | 1, v)\n                lz[node] = 0\n        def update(node, l, r, ql, qr, val):\n            if ql > r or qr < l:\n                return\n            if ql <= l and r <= qr:\n                apply(node, val)\n                return\n            push(node)\n            mid = (l + r) >> 1\n            update(node << 1, l, mid, ql, qr, val)\n            update(node << 1 | 1, mid + 1, r, ql, qr, val)\n            st[node] = st[node << 1] if st[node << 1] > st[node << 1 | 1] else st[node << 1 | 1]\n        if N >= 1:\n            build(1, 1, N)\n        ans = []\n        for idx, nval in queries:\n            valo = nums[idx]\n            if valo <= maxv and isprime[valo]:\n                lst = pos[valo]\n                lx = lst[0]\n                rx = lst[-1]\n                i = bisect.bisect_left(lst, idx)\n                lst.pop(i)\n                if not lst:\n                    lp = lx + 1\n                    if lp <= N:\n                        update(1, 1, N, lp, N, -1)\n                    end = rx if rx <= N else N\n                    if end >= 1:\n                        update(1, 1, N, 1, end, -1)\n                    del pos[valo]\n                else:\n                    lp = lst[0]\n                    rp = lst[-1]\n                    if idx == lx:\n                        left = lx + 1\n                        right = lp\n                        if left <= right and left <= N:\n                            update(1, 1, N, left, right if right <= N else N, -1)\n                    if idx == rx:\n                        left = rp + 1\n                        right = rx\n                        if left <= right and left <= N:\n                            update(1, 1, N, left, right if right <= N else N, -1)\n            nums[idx] = nval\n            if nval <= maxv and isprime[nval]:\n                lst = pos.get(nval)\n                if lst is None:\n                    pos[nval] = [idx]\n                    start = idx + 1\n                    if start <= N:\n                        update(1, 1, N, start, N, 1)\n                    end = idx if idx <= N else N\n                    if end >= 1:\n                        update(1, 1, N, 1, end, 1)\n                else:\n                    lx = lst[0]\n                    rx = lst[-1]\n                    bisect.insort(lst, idx)\n                    lp = lst[0]\n                    rp = lst[-1]\n                    if idx < lx:\n                        left = idx + 1\n                        right = lx\n                        if left <= right and left <= N:\n                            update(1, 1, N, left, right if right <= N else N, 1)\n                    if idx > rx:\n                        left = rx + 1\n                        right = idx\n                        if left <= right and left <= N:\n                            update(1, 1, N, left, right if right <= N else N, 1)\n            best = st[1] if N >= 1 else 0\n            ans.append(best)\n        return ans\n",
    "input": "maximumCount(nums=[2,1,3,1,2], queries=[[1,2],[3,3]])",
    "output": "[3, 4]",
    "correct_condition": "maximumCount(nums=[2,1,3,1,2], queries=[[1,2],[3,3]]) == [3, 4]",
    "contest_id": "weekly-contest-452",
    "contest_date": "2025-06-01T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 337,
      "coverage": null
    },
    "submission_id": 1650238669
  },
  {
    "id": "contest452_q3878_s1",
    "question_id": 3878,
    "function_name": "maximumCount",
    "code": "import bisect\n\nclass SegmentTree:\n    def __init__(self, n):\n        size = 1\n        while size < n:\n            size <<= 1\n        self.n = size\n        self.tree = [0] * (2 * size)\n        self.lazy = [0] * (2 * size)\n\n    def _apply(self, x, val, length):\n        self.tree[x] += val\n        self.lazy[x] += val\n\n    def _push(self, x):\n        if self.lazy[x] != 0:\n            self._apply(x * 2, self.lazy[x], 0)\n            self._apply(x * 2 + 1, self.lazy[x], 0)\n            self.lazy[x] = 0\n\n    def _update(self, x, lx, rx, l, r, val):\n        if l > rx or r < lx:\n            return\n        if l <= lx and rx <= r:\n            self._apply(x, val, rx - lx + 1)\n            return\n        self._push(x)\n        m = (lx + rx) // 2\n        self._update(x * 2, lx, m, l, r, val)\n        self._update(x * 2 + 1, m + 1, rx, l, r, val)\n        self.tree[x] = max(self.tree[x * 2], self.tree[x * 2 + 1])\n\n    def rangeAdd(self, l, r, val):\n        if l > r:\n            return\n        self._update(1, 1, self.n, l, r, val)\n\n    def queryMax(self):\n        return self.tree[1]\n\nclass Solution:\n    def maximumCount(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        maxVal = 100000\n        isPrime = [True] * (maxVal + 1)\n        isPrime[0] = False\n        isPrime[1] = False\n        for i in range(2, int(maxVal ** 0.5) + 1):\n            if isPrime[i]:\n                for j in range(i * i, maxVal + 1, i):\n                    isPrime[j] = False\n\n        occ = {}\n        for i, v in enumerate(nums):\n            if isPrime[v]:\n                if v not in occ:\n                    occ[v] = []\n                occ[v].append(i)\n\n        for v in occ:\n            occ[v].sort()\n\n        seg = SegmentTree(n)\n        totP = 0\n        for v, lst in occ.items():\n            totP += 1\n            i1 = lst[0]\n            im = lst[-1]\n            l = i1 + 1\n            r = im\n            if l <= r:\n                seg.rangeAdd(l + 1 - 1, r + 1 - 1, 1)\n\n        res = []\n        for idx, val in queries:\n            old = nums[idx]\n            if old != val:\n                if isPrime[old]:\n                    lst = occ[old]\n                    i = bisect.bisect_left(lst, idx)\n                    oldI1 = lst[0]\n                    oldIm = lst[-1]\n                    l = oldI1 + 1\n                    r = oldIm\n                    if l <= r:\n                        seg.rangeAdd(l, r, -1)\n                    lst.pop(i)\n                    if lst:\n                        newI1 = lst[0]\n                        newIm = lst[-1]\n                        l2 = newI1 + 1\n                        r2 = newIm\n                        if l2 <= r2:\n                            seg.rangeAdd(l2, r2, 1)\n                    else:\n                        totP -= 1\n                        del occ[old]\n                if isPrime[val]:\n                    if val in occ:\n                        lst2 = occ[val]\n                        oldI1 = lst2[0]\n                        oldIm = lst2[-1]\n                        l = oldI1 + 1\n                        r = oldIm\n                        if l <= r:\n                            seg.rangeAdd(l, r, -1)\n                        bisect.insort(lst2, idx)\n                        newI1 = lst2[0]\n                        newIm = lst2[-1]\n                        l2 = newI1 + 1\n                        r2 = newIm\n                        if l2 <= r2:\n                            seg.rangeAdd(l2, r2, 1)\n                    else:\n                        occ[val] = [idx]\n                        totP += 1\n                        l = idx + 1\n                        r = idx\n                        # no range add for single occurrence\n                nums[idx] = val\n\n            res.append(totP + seg.queryMax())\n        return res",
    "input": "maximumCount(nums=[2,1,3,1,2], queries=[[1,2],[3,3]])",
    "output": "[3, 4]",
    "correct_condition": "maximumCount(nums=[2,1,3,1,2], queries=[[1,2],[3,3]]) == [3, 4]",
    "contest_id": "weekly-contest-452",
    "contest_date": "2025-06-01T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 124,
      "coverage": null
    },
    "submission_id": 1650263361
  },
  {
    "id": "contest452_q3878_s2",
    "question_id": 3878,
    "function_name": "maximumCount",
    "code": "LIM = 100000\n_L = int(LIM**0.5) + 1\n\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.ft = [0] * (n + 1)\n\n    def add(self, i, v):\n        while i <= self.n:\n            self.ft[i] += v\n            i += i & -i\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.ft[i]\n            i -= i & -i\n        return s\n\n\nclass DS:\n    def __init__(self):\n        self.s = set()\n        self.hmin = []\n        self.hmax = []\n\n\nclass Solution:\n    def maximumCount(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n\n        PS = [False, False] + [True] * LIM\n        for i in range(2, _L):\n            if PS[i]:\n                for j in range(i * i, LIM + 1, i):\n                    PS[j] = False\n\n        def gf(o):\n            h, s = o.hmin, o.s\n            while h and h[0] not in s:\n                heapq.heappop(h)\n            return h[0]\n\n        def gl(o):\n            h, s = o.hmax, o.s\n            while h and -h[0] not in s:\n                heapq.heappop(h)\n            return -h[0]\n\n        _map = {}\n        for i, v in enumerate(nums):\n            if v <= LIM and PS[v]:\n                if v not in _map:\n                    _map[v] = DS()\n                o = _map[v]\n                o.s.add(i)\n                heapq.heappush(o.hmin, i)\n                heapq.heappush(o.hmax, -i)\n\n        size = 1\n        while size < n + 1:\n            size <<= 1\n        mx = [0] * (2 * size)\n        lz = [0] * (2 * size)\n\n        def pull(p):\n            lc = p * 2\n            rc = lc + 1\n            mx[p] = mx[lc] if mx[lc] > mx[rc] else mx[rc]\n\n        def apply(p, v):\n            mx[p] += v\n            lz[p] += v\n\n        def push(p):\n            if lz[p]:\n                v = lz[p]\n                apply(p * 2, v)\n                apply(p * 2 + 1, v)\n                lz[p] = 0\n\n        def update(p, l, r, ql, qr, v):\n            if ql > r or qr < l:\n                return\n            if ql <= l and r <= qr:\n                apply(p, v)\n                return\n            push(p)\n            m = (l + r) >> 1\n            update(p * 2, l, m, ql, qr, v)\n            update(p * 2 + 1, m + 1, r, ql, qr, v)\n            pull(p)\n\n        for o in _map.values():\n            if len(o.s) >= 2:\n                f = gf(o)\n                l = f + 1\n                r = gl(o)\n                if l <= r:\n                    update(1, 1, n, l, r, 1)\n\n        P = len(_map)\n        ans = []\n\n        def rem(o):\n            f0 = gf(o)\n            l0 = f0 + 1\n            r0 = gl(o)\n            if l0 <= r0:\n                update(1, 1, n, l0, r0, -1)\n\n        def add(o):\n            f = gf(o)\n            l = f + 1\n            r = gl(o)\n            if l <= r:\n                update(1, 1, n, l, r, 1)\n\n        for i, v in queries:\n            prev_val = nums[i]\n            if prev_val == v:\n                ans.append(P + max(mx[1], 0))\n                continue\n\n            if prev_val <= LIM and PS[prev_val] and prev_val in _map:\n                o = _map[prev_val]\n                c = len(o.s)\n                if c >= 2:\n                    rem(o)\n                o.s.remove(i)\n                if c == 1:\n                    del _map[prev_val]\n                    P -= 1\n                elif c - 1 >= 2:\n                    add(o)\n\n            if v <= LIM and PS[v]:\n                if v not in _map:\n                    _map[v] = DS()\n                    o = _map[v]\n                    c = 0\n                    P += 1\n                else:\n                    o = _map[v]\n                    c = len(o.s)\n                if c >= 2:\n                    rem(o)\n                o.s.add(i)\n                heapq.heappush(o.hmin, i)\n                heapq.heappush(o.hmax, -i)\n                if c + 1 >= 2:\n                    add(o)\n\n            nums[i] = v\n            ans.append(P + max(mx[1], 0))\n            # print(f\"  {i}, {v}: ans = {ans[-1]}, P = {P}, mx[1] = {mx[1]}\")\n\n        return ans\n",
    "input": "maximumCount(nums=[2,1,3,1,2], queries=[[1,2],[3,3]])",
    "output": "[3, 4]",
    "correct_condition": "maximumCount(nums=[2,1,3,1,2], queries=[[1,2],[3,3]]) == [3, 4]",
    "contest_id": "weekly-contest-452",
    "contest_date": "2025-06-01T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 160,
      "coverage": null
    },
    "submission_id": 1650274450
  },
  {
    "id": "contest453_q3876_s0",
    "question_id": 3876,
    "function_name": "canMakeEqual",
    "code": "class Solution:\n    def canMakeEqual(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        for t in (1, -1):\n            b = [1 if nums[i] != t else 0 for i in range(n)]\n            cnt = 0\n            for i in range(n - 1):\n                if b[i]:\n                    cnt += 1\n                    b[i] = 0\n                    b[i + 1] ^= 1\n            if b[-1] == 0 and cnt <= k:\n                return True\n        return False",
    "input": "canMakeEqual(nums=[1,-1,1,-1,1], k=3)",
    "output": "True",
    "correct_condition": "canMakeEqual(nums=[1,-1,1,-1,1], k=3) == True",
    "contest_id": "weekly-contest-453",
    "contest_date": "2025-06-08T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 14,
      "coverage": null
    },
    "submission_id": 1657158036
  },
  {
    "id": "contest453_q3876_s1",
    "question_id": 3876,
    "function_name": "canMakeEqual",
    "code": "class Solution:\n    def canMakeEqual(self, nums: List[int], k: int) -> bool:\n        def can_t(target:int) -> bool:\n            arr= nums[:]\n            ops=0\n            for i in range(len(arr)-1):\n                if arr[i]!=target:\n                    arr[i]*=-1\n                    arr[i+1]*=-1\n                    ops+=1\n            return arr[-1]==target and ops<=k\n        return can_t(1) or can_t(-1)",
    "input": "canMakeEqual(nums=[1,-1,1,-1,1], k=3)",
    "output": "True",
    "correct_condition": "canMakeEqual(nums=[1,-1,1,-1,1], k=3) == True",
    "contest_id": "weekly-contest-453",
    "contest_date": "2025-06-08T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 12,
      "coverage": null
    },
    "submission_id": 1657169141
  },
  {
    "id": "contest453_q3876_s2",
    "question_id": 3876,
    "function_name": "canMakeEqual",
    "code": "class Solution:\n    def canMakeEqual(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        for x in (1, -1):\n            c = 0\n            r = 0\n\n            arr = [0] * (n + 2)\n            for i in range(n):\n                c += arr[i]\n\n                if nums[i] * (1 if c % 2 == 0 else -1) != x:\n                    if i == n - 1 or r == k:\n                        break\n                    # print(f\"i: {i}, c: {c}, r: {r}, arr: {arr}\")\n                    r += 1\n                    c += 1\n                    arr[i + 2] -= 1\n            else:\n                return True\n\n        return False\n",
    "input": "canMakeEqual(nums=[1,-1,1,-1,1], k=3)",
    "output": "True",
    "correct_condition": "canMakeEqual(nums=[1,-1,1,-1,1], k=3) == True",
    "contest_id": "weekly-contest-453",
    "contest_date": "2025-06-08T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 22,
      "coverage": null
    },
    "submission_id": 1657152717
  },
  {
    "id": "contest453_q3864_s0",
    "question_id": 3864,
    "function_name": "countPermutations",
    "code": "class Solution:\n    def countPermutations(self, c: List[int]) -> int:\n        mod = 10**9+7\n        n = len(c)\n        for i in range(1, n):\n            if c[i] <= c[0]:\n                return 0\n        res = 1\n        for i in range(1, n):\n            res = res * i % mod\n        return res",
    "input": "countPermutations(c=[1,2,3])",
    "output": "2",
    "correct_condition": "countPermutations(c=[1,2,3]) == 2",
    "contest_id": "weekly-contest-453",
    "contest_date": "2025-06-08T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 11,
      "coverage": null
    },
    "submission_id": 1657151639
  },
  {
    "id": "contest453_q3864_s1",
    "question_id": 3864,
    "function_name": "countPermutations",
    "code": "class Solution:\n    def countPermutations(self, complexity: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(complexity)\n\n        # check feasibility: comp[0] must be strictly the smallest\n        root = complexity[0]\n        for x in complexity[1:]:\n            if x <= root:\n                return 0\n\n        # all other n1 computers can be unlocked in any order\n        res = 1\n        for k in range(1, n):\n            res = res * k % MOD\n        return res\n",
    "input": "countPermutations(complexity=[1,2,3])",
    "output": "2",
    "correct_condition": "countPermutations(complexity=[1,2,3]) == 2",
    "contest_id": "weekly-contest-453",
    "contest_date": "2025-06-08T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 16,
      "coverage": null
    },
    "submission_id": 1657189523
  },
  {
    "id": "contest453_q3864_s2",
    "question_id": 3864,
    "function_name": "countPermutations",
    "code": "MOD = 10**9 + 7\n\n\nclass Solution:\n    def countPermutations(self, complexity: List[int]) -> int:\n        n = len(complexity)\n        m = min(complexity)\n        if complexity[0] != m or complexity.count(m) > 1:\n            return 0\n        return math.prod(range(1, n)) % MOD\n",
    "input": "countPermutations(complexity=[1,2,3])",
    "output": "2",
    "correct_condition": "countPermutations(complexity=[1,2,3]) == 2",
    "contest_id": "weekly-contest-453",
    "contest_date": "2025-06-08T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 10,
      "coverage": null
    },
    "submission_id": 1657156029
  },
  {
    "id": "contest453_q3835_s0",
    "question_id": 3835,
    "function_name": "countPartitions",
    "code": "class Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        MOD, n = 10**9+7,  len(nums)\n        dp = [0] * (n + 1)\n        ps = [0] * (n + 1)\n        dp[0] = 1; ps[0] = 1;  l = 0\n        \n        maxdq = deque()\n        mindq = deque()\n        for i in range(n):\n            while maxdq and nums[i] > nums[maxdq[-1]]:\n                maxdq.pop()\n                \n            maxdq.append(i)\n            while mindq and nums[i] < nums[mindq[-1]]:\n                mindq.pop()\n                \n            mindq.append(i)\n            while nums[maxdq[0]] - nums[mindq[0]] > k:\n                l += 1\n                if maxdq[0] < l: maxdq.popleft()\n                if mindq[0] < l: mindq.popleft()\n                    \n            dp[i+1] = ps[i] - (ps[l-1] if l > 0 else 0)\n            dp[i+1] %= MOD\n            ps[i+1] = (ps[i] + dp[i+1]) % MOD\n            \n        return dp[n]",
    "input": "countPartitions(nums=[9,4,1,3,7], k=4)",
    "output": "6",
    "correct_condition": "countPartitions(nums=[9,4,1,3,7], k=4) == 6",
    "contest_id": "weekly-contest-453",
    "contest_date": "2025-06-08T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 28,
      "coverage": null
    },
    "submission_id": 1657154777
  },
  {
    "id": "contest453_q3835_s1",
    "question_id": 3835,
    "function_name": "countPartitions",
    "code": "from collections import deque\nfrom typing import List\n\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # prefix[i] = dp[0] + dp[1] + ... + dp[i]\n        # where dp[0]=1 (empty prefix) and dp[i] = #ways to partition nums[:i]\n        prefix = [0] * (n+1)\n        prefix[0] = 1\n        \n        maxD = deque()   # will store pairs (value, index), decreasing by value\n        minD = deque()   # will store pairs (value, index), increasing by value\n        low = 1          # 1-based left edge of our current valid window\n        \n        dp_n = 0\n        for i in range(1, n+1):\n            x = nums[i-1]\n            # push x into maxDeque\n            while maxD and maxD[-1][0] < x:\n                maxD.pop()\n            maxD.append((x, i))\n            # push x into minDeque\n            while minD and minD[-1][0] > x:\n                minD.pop()\n            minD.append((x, i))\n            \n            # shrink from the left until window [low..i] is valid\n            while maxD[0][0] - minD[0][0] > k:\n                # if the outgoing index matches deque fronts, pop them\n                if maxD[0][1] == low:\n                    maxD.popleft()\n                if minD[0][1] == low:\n                    minD.popleft()\n                low += 1\n            \n            # now every start j in [low..i] gives a valid segment [j..i]\n            # so dp[i] = sum(dp[j-1] for j in [low..i]) \n            #          = prefix[i-1] - prefix[low-2]   (if low>=2)\n            if low >= 2:\n                dp_i = prefix[i-1] - prefix[low-2]\n            else:\n                dp_i = prefix[i-1]\n            dp_i %= MOD\n            \n            # update prefix sum\n            prefix[i] = (prefix[i-1] + dp_i) % MOD\n            \n            if i == n:\n                dp_n = dp_i\n        \n        return dp_n\n",
    "input": "countPartitions(nums=[9,4,1,3,7], k=4)",
    "output": "6",
    "correct_condition": "countPartitions(nums=[9,4,1,3,7], k=4) == 6",
    "contest_id": "weekly-contest-453",
    "contest_date": "2025-06-08T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 54,
      "coverage": null
    },
    "submission_id": 1657193577
  },
  {
    "id": "contest453_q3835_s2",
    "question_id": 3835,
    "function_name": "countPartitions",
    "code": "MOD = 10**9 + 7\n\n\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        N = len(nums)\n\n        mq = deque()\n        nq = deque()\n\n        l = 0\n\n        pre = [0] * (N + 1)\n        pre[0] = 1\n\n        dp = [0] * (N + 1)\n        dp[0] = 1\n\n        for i in range(N):\n            v = nums[i]\n            while mq and mq[-1] < v:\n                mq.pop()\n            mq.append(v)\n            # print(f\"mq: {mq}\")\n\n            while nq and nq[-1] > v:\n                nq.pop()\n            nq.append(v)\n            # print(f\"nq: {nq}\")\n\n            while mq[0] - nq[0] > k:\n                if nums[l] == mq[0]:\n                    mq.popleft()\n                if nums[l] == nq[0]:\n                    nq.popleft()\n                l += 1\n                # print(f\"l: {l}, mq: {mq}, nq: {nq}\")\n\n            dp[i + 1] = (pre[i] - (pre[l - 1] if l > 0 else 0)) % MOD\n            # print(f\"i: {i}, v: {v}, dp[i + 1]: {dp[i + 1]}, pre: {pre}, l: {l}\")\n            pre[i + 1] = (pre[i] + dp[i + 1]) % MOD\n            # print(f\"i: {i}, v: {v}, pre[i + 1]: {pre[i + 1]}, dp: {dp}\")\n\n        # return dp[N - 1] if N > 0 else 1\n        return dp[N]\n",
    "input": "countPartitions(nums=[9,4,1,3,7], k=4)",
    "output": "6",
    "correct_condition": "countPartitions(nums=[9,4,1,3,7], k=4) == 6",
    "contest_id": "weekly-contest-453",
    "contest_date": "2025-06-08T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 45,
      "coverage": null
    },
    "submission_id": 1657171764
  },
  {
    "id": "contest453_q3866_s0",
    "question_id": 3866,
    "function_name": "minOperations",
    "code": "class Solution:\n    def minOperations(self,w1: str,w2: str) -> int:\n        n = len(w1)\n        s = [ord(c)-97 for c in w1]\n        t = [ord(c)-97 for c in w2]\n        INF = 10**9\n        dp = [INF]*(n+1)\n        dp[0] = 0\n        for i in range(n):\n            for j in range(i,n):\n                m = 0\n                cnt = {}\n                for k in range(i,j+1):\n                    if s[k]!=t[k]:\n                        m += 1\n                        cnt[(s[k],t[k])] = cnt.get((s[k],t[k]),0) + 1\n                g = 0\n                for (x,y),v in cnt.items():\n                    if x<y:\n                        g += min(v, cnt.get((y,x),0))\n                cost0 = m - g\n                m2 = 0\n                cnt2 = {}\n                for k in range(i,j+1):\n                    a = s[j-(k-i)]\n                    b = t[k]\n                    if a!=b:\n                        m2 += 1\n                        cnt2[(a,b)] = cnt2.get((a,b),0) + 1\n                g2 = 0\n                for (x,y),v in cnt2.items():\n                    if x<y:\n                        g2 += min(v, cnt2.get((y,x),0))\n                cost1 = 1 + m2 - g2\n                c = cost0 if cost0<cost1 else cost1\n                v = dp[i] + c\n                if v < dp[j+1]:\n                    dp[j+1] = v\n        return dp[n]\n\n        ",
    "input": "minOperations(w1=\"abcdf\", w2=\"dacbe\")",
    "output": "4",
    "correct_condition": "minOperations(w1=\"abcdf\", w2=\"dacbe\") == 4",
    "contest_id": "weekly-contest-453",
    "contest_date": "2025-06-08T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 41,
      "coverage": null
    },
    "submission_id": 1657170503
  },
  {
    "id": "contest453_q3866_s1",
    "question_id": 3866,
    "function_name": "minOperations",
    "code": "class Solution:\n    def minOperations(self, word1: str, word2: str) -> int:\n        n = len(word1)\n        A = [ord(c) - 97 for c in word1]\n        B = [ord(c) - 97 for c in word2]\n\n        def segment_cost(j: int, i: int) -> int:\n            # original st\n            M = 0\n            cnt = [[0]*26 for _ in range(26)]\n            for k in range(j, i):\n                a, b = A[k], B[k]\n                if a != b:\n                    M += 1\n                    cnt[a][b] += 1\n            K = 0\n            for a in range(26):\n                for b in range(a+1, 26):\n                    K += min(cnt[a][b], cnt[b][a])\n            best = M - K\n\n            # try reverse once\n            M2 = 0\n            cnt2 = [[0]*26 for _ in range(26)]\n            L = i - j\n            for off in range(L):\n                a = A[j + (L-1 - off)]\n                b = B[j +    off      ]\n                if a != b:\n                    M2 += 1\n                    cnt2[a][b] += 1\n            K2 = 0\n            for a in range(26):\n                for b in range(a+1, 26):\n                    K2 += min(cnt2[a][b], cnt2[b][a])\n\n            # pay 1 operation for the reverse itself\n            best = min(best, 1 + (M2 - K2))\n            return best\n\n        # DP over prefixes\n        INF = 10**9\n        dp = [INF] * (n+1)\n        dp[0] = 0\n\n        for i in range(1, n+1):\n            best = INF\n            for j in range(i):\n                c = segment_cost(j, i)\n                # if segment_cost ever returns INF you can skip, but here it's always finite\n                best = min(best, dp[j] + c)\n            dp[i] = best\n\n        return dp[n]\n        ",
    "input": "minOperations(word1=\"abcdf\", word2=\"dacbe\")",
    "output": "4",
    "correct_condition": "minOperations(word1=\"abcdf\", word2=\"dacbe\") == 4",
    "contest_id": "weekly-contest-453",
    "contest_date": "2025-06-08T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 55,
      "coverage": null
    },
    "submission_id": 1657197336
  },
  {
    "id": "contest453_q3866_s2",
    "question_id": 3866,
    "function_name": "minOperations",
    "code": "class Solution:\n    def minOperations(self, word1: str, word2: str) -> int:\n        n = len(word1)\n        dp = list(range(n + 1))\n\n        for i in range(1, n + 1):\n            for j in range(i):\n                x = [(a, b) for a, b in zip(word1[j:i], word2[j:i]) if a != b]\n                len_x = len(x)\n                if len_x == 0:\n                    c = 0\n                else:\n                    counter_x = Counter(x)\n                    sum_x = sum(\n                        min(counter_x[p], counter_x[(p[1], p[0])])\n                        for p in counter_x\n                        if p[0] < p[1]\n                    )\n                    # print(f\"i: {i}, j: {j}, x: {x}, len_x: {len_x}, sum_x: {sum_x}\")\n                    c = len_x - sum_x\n                    if len_x > 1:\n                        y = [\n                            (a, b)\n                            for a, b in zip(word1[j:i][::-1], word2[j:i])\n                            if a != b\n                        ]\n                        # print(f\"y: {y}\")\n                        counter_y = Counter(y)\n                        sum_y = sum(\n                            min(counter_y[p], counter_y[(p[1], p[0])])\n                            for p in counter_y\n                            if p[0] < p[1]\n                        )\n                        c = min(c, len(y) - sum_y + 1)\n                        # print(f\"i: {i}, j: {j}, x: {x}, y: {y}, c: {c}\")\n                dp[i] = min(dp[i], dp[j] + c)\n                # print(f\"i: {i}, j: {j}, dp[i]: {dp[i]}\")\n\n        # return dp[n - 1]\n        return dp[n]\n",
    "input": "minOperations(word1=\"abcdf\", word2=\"dacbe\")",
    "output": "4",
    "correct_condition": "minOperations(word1=\"abcdf\", word2=\"dacbe\") == 4",
    "contest_id": "weekly-contest-453",
    "contest_date": "2025-06-08T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 40,
      "coverage": null
    },
    "submission_id": 1657190618
  },
  {
    "id": "contest454_q3893_s0",
    "question_id": 3893,
    "function_name": "generateTag",
    "code": "class Solution:\n    def generateTag(self, s: str) -> str:\n        w = s.split()\n        if not w: return \"#\"\n        t = w[0].lower() + ''.join(x.capitalize() for x in w[1:])\n        t = ''.join(c for c in t if c.isalpha())\n        return '#' + t[:99]",
    "input": "generateTag(s=\"Leetcode daily streak achieved\")",
    "output": "'#leetcodeDailyStreakAchieved'",
    "correct_condition": "generateTag(s=\"Leetcode daily streak achieved\") == '#leetcodeDailyStreakAchieved'",
    "contest_id": "weekly-contest-454",
    "contest_date": "2025-06-15T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 7,
      "coverage": null
    },
    "submission_id": 1664365781
  },
  {
    "id": "contest454_q3893_s1",
    "question_id": 3893,
    "function_name": "generateTag",
    "code": "class Solution:\n    def generateTag(self, c: str) -> str:\n        w,s=c.split(),'#'\n        if w:\n            s+=w[0].lower()\n            for x in w[1:]:\n                s+=x.lower().capitalize()\n        s2=s[0]+''.join(ch for ch in s[1:] if ch.isalpha())\n        return s2[:100]",
    "input": "generateTag(c=\"Leetcode daily streak achieved\")",
    "output": "'#leetcodeDailyStreakAchieved'",
    "correct_condition": "generateTag(c=\"Leetcode daily streak achieved\") == '#leetcodeDailyStreakAchieved'",
    "contest_id": "weekly-contest-454",
    "contest_date": "2025-06-15T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 9,
      "coverage": null
    },
    "submission_id": 1664363072
  },
  {
    "id": "contest454_q3893_s2",
    "question_id": 3893,
    "function_name": "generateTag",
    "code": "class Solution:\n    def generateTag(self, caption: str) -> str:\n        # caption = \"   \"\n        \n        arr = []\n        word = []\n        for c in caption:\n            if c == ' ':\n                if word:\n                    arr.append(''.join(word))\n                    word = []\n            else:\n                word.append(c)\n        if word:\n            arr.append(''.join(word))\n        # print(arr)\n\n        if not arr:\n            return '#'\n\n        for i in range(len(arr)):\n            w = arr[i]\n            w = w.lower()\n            if i != 0:\n                w = w[:1].upper() + w[1:]\n            else:\n                w = w\n            arr[i] = w\n\n        final = '#' + ''.join(arr)\n        final = final[:100]\n        return final\n            \n        ",
    "input": "generateTag(caption=\"Leetcode daily streak achieved\")",
    "output": "'#leetcodeDailyStreakAchieved'",
    "correct_condition": "generateTag(caption=\"Leetcode daily streak achieved\") == '#leetcodeDailyStreakAchieved'",
    "contest_id": "weekly-contest-454",
    "contest_date": "2025-06-15T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 34,
      "coverage": null
    },
    "submission_id": 1664371377
  },
  {
    "id": "contest454_q3885_s0",
    "question_id": 3885,
    "function_name": "specialTriplets",
    "code": "from collections import Counter\nclass Solution:\n    def specialTriplets(self, a: list[int]) -> int:\n        m = 10**9+7; n = len(a); l, r = Counter(), Counter(a); s = 0\n        for i in range(n):\n            r[a[i]] -= 1; d = a[i] * 2\n            s += l[d] * r[d]; s %= m\n            l[a[i]] += 1\n        return s\n",
    "input": "specialTriplets(a=[6,3,6])",
    "output": "1",
    "correct_condition": "specialTriplets(a=[6,3,6]) == 1",
    "contest_id": "weekly-contest-454",
    "contest_date": "2025-06-15T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 9,
      "coverage": null
    },
    "submission_id": 1664369401
  },
  {
    "id": "contest454_q3885_s1",
    "question_id": 3885,
    "function_name": "specialTriplets",
    "code": "class Solution:\n    def specialTriplets(self, a: List[int]) -> int:\n        mod,R,L,res=10**9+7,Counter(a),{},0\n        for x in a:\n            R[x]-=1\n            if R[x]==0: del R[x]\n            y=x*2\n            res=(res+L.get(y,0)*R.get(y,0))%mod\n            L[x]=L.get(x,0)+1\n        return res",
    "input": "specialTriplets(a=[6,3,6])",
    "output": "1",
    "correct_condition": "specialTriplets(a=[6,3,6]) == 1",
    "contest_id": "weekly-contest-454",
    "contest_date": "2025-06-15T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 10,
      "coverage": null
    },
    "submission_id": 1664370474
  },
  {
    "id": "contest454_q3885_s2",
    "question_id": 3885,
    "function_name": "specialTriplets",
    "code": "class Solution:\n    def specialTriplets(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n\n        seenLeft = Counter()\n        seenRight = Counter(nums)\n        seenRight[nums[0]] -= 1\n        # print(seenRight)\n\n        res = 0\n        for j in range(1, len(nums) - 1):\n            seenLeft[nums[j-1]] += 1\n            seenRight[nums[j]] -= 1\n            # print(seenLeft)\n            res += seenLeft[nums[j] * 2] * seenRight[nums[j] * 2]\n        return res % MOD\n            ",
    "input": "specialTriplets(nums=[6,3,6])",
    "output": "1",
    "correct_condition": "specialTriplets(nums=[6,3,6]) == 1",
    "contest_id": "weekly-contest-454",
    "contest_date": "2025-06-15T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 17,
      "coverage": null
    },
    "submission_id": 1664364578
  },
  {
    "id": "contest454_q3755_s0",
    "question_id": 3755,
    "function_name": "maximumProduct",
    "code": "import math\nfrom typing import List\n\nclass Solution:\n    def maximumProduct(self, a: List[int], m: int) -> int:\n        n = len(a)\n        if m == 1: return max(x*x for x in a)\n        x, y = [a[0]]*n, [a[0]]*n\n        for i in range(1, n):\n            x[i] = max(x[i-1], a[i])\n            y[i] = min(y[i-1], a[i])\n        r = -math.inf\n        for j in range(m-1, n):\n            t = a[j]; i = j-m+1\n            r = max(r, t*x[i], t*y[i])\n        return int(r)\n",
    "input": "maximumProduct(a=[-1,-9,2,3,-2,-3,1], m=1)",
    "output": "81",
    "correct_condition": "maximumProduct(a=[-1,-9,2,3,-2,-3,1], m=1) == 81",
    "contest_id": "weekly-contest-454",
    "contest_date": "2025-06-15T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 16,
      "coverage": null
    },
    "submission_id": 1664372751
  },
  {
    "id": "contest454_q3755_s1",
    "question_id": 3755,
    "function_name": "maximumProduct",
    "code": "class Solution:\n    def maximumProduct(self, a: List[int], m: int) -> int:\n        n = len(a)\n        if m == 1:\n            return max(x*x for x in a)\n        curr_max = a[0]\n        curr_min = a[0]\n        res = -inf\n        for j in range(m-1,n):\n            if j > m-1:\n                x = a[j-m+1]\n                if x > curr_max: curr_max = x\n                if x < curr_min: curr_min = x\n            xj = a[j]\n            p1 = curr_max * xj\n            p2 = curr_min * xj\n            if p1 > res: res = p1\n            if p2 > res: res = p2\n        return res",
    "input": "maximumProduct(a=[-1,-9,2,3,-2,-3,1], m=1)",
    "output": "81",
    "correct_condition": "maximumProduct(a=[-1,-9,2,3,-2,-3,1], m=1) == 81",
    "contest_id": "weekly-contest-454",
    "contest_date": "2025-06-15T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 19,
      "coverage": null
    },
    "submission_id": 1664384582
  },
  {
    "id": "contest454_q3755_s2",
    "question_id": 3755,
    "function_name": "maximumProduct",
    "code": "class Solution:\n    def maximumProduct(self, nums: List[int], m: int) -> int:\n        bigLeft = {}\n        smallLeft = {}\n        big = -inf\n        small = inf\n        for i in range(len(nums)):\n            big = max(big, nums[i])\n            small = min(small, nums[i])\n            bigLeft[i] = big\n            smallLeft[i] = small\n\n        bigRight = {}\n        smallRight = {}\n        big = -inf\n        small = inf\n        for i in range(len(nums) - 1, -1, -1):\n            big = max(big, nums[i])\n            small = min(small, nums[i])\n            bigRight[i] = big\n            smallRight[i] = small\n\n        res = -inf\n\n        for i in range(len(nums)):\n            right = i + m - 1\n            if right >= len(nums):\n                break\n            curr = nums[i]\n            opt1 = curr * bigRight[right]\n            opt2 = curr * smallRight[right]\n            res = max(res, opt1, opt2)\n        return res\n            ",
    "input": "maximumProduct(nums=[-1,-9,2,3,-2,-3,1], m=1)",
    "output": "81",
    "correct_condition": "maximumProduct(nums=[-1,-9,2,3,-2,-3,1], m=1) == 81",
    "contest_id": "weekly-contest-454",
    "contest_date": "2025-06-15T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 34,
      "coverage": null
    },
    "submission_id": 1664376454
  },
  {
    "id": "contest454_q3900_s0",
    "question_id": 3900,
    "function_name": "findMedian",
    "code": "from collections import deque\n\nclass Solution:\n    def findMedian(self, n: int, e: list[list[int]], q: list[list[int]]) -> list[int]:\n        L = n.bit_length(); a = [[] for _ in range(n)]\n        for u, v, w in e: a[u].append((v, w)); a[v].append((u, w))\n        p = [[-1]*L for _ in range(n)]; d = [[0]*L for _ in range(n)]; h = [-1]*n; s = [0]*n\n        z = deque([(0, -1, 0, 0)]); h[0] = 0\n        while z:\n            u, par, dep, dist = z.popleft(); p[u][0] = par; s[u] = dist\n            for v, w in a[u]:\n                if v != par: h[v] = dep+1; d[v][0] = w; z.append((v, u, dep+1, dist+w))\n        for j in range(1, L):\n            for i in range(n):\n                x = p[i][j-1]\n                if x != -1: p[i][j] = p[x][j-1]; d[i][j] = d[i][j-1]+d[x][j-1] if p[i][j] != -1 else d[i][j]\n        def lca(u, v):\n            if h[u] < h[v]: u, v = v, u\n            for j in range(L-1, -1, -1): \n                if h[u]-(1<<j) >= h[v]: u = p[u][j]\n            if u == v: return u\n            for j in range(L-1, -1, -1): \n                if p[u][j] != -1 and p[u][j] != p[v][j]: u, v = p[u][j], p[v][j]\n            return p[u][0]\n        r = []\n        for u, v in q:\n            if u == v: r.append(u); continue\n            x = lca(u, v); tot = s[u]+s[v]-2*s[x]; half = tot/2; su = s[u]-s[x]\n            if half <= su:\n                cur, rem = u, half\n                for j in range(L-1, -1, -1):\n                    par = p[cur][j]\n                    if par != -1 and h[par] >= h[x] and d[cur][j] < rem: rem -= d[cur][j]; cur = par\n                r.append(p[cur][0])\n            else:\n                cur, rem = v, s[v]-s[x]-(half-su)\n                for j in range(L-1, -1, -1):\n                    par = p[cur][j]\n                    if par != -1 and h[par] >= h[x] and d[cur][j] <= rem: rem -= d[cur][j]; cur = par\n                r.append(cur)\n        return r\n",
    "input": "findMedian(n=2, e=[[0,1,7]], q=[[1,0],[0,1]])",
    "output": "[0, 1]",
    "correct_condition": "findMedian(n=2, e=[[0,1,7]], q=[[1,0],[0,1]]) == [0, 1]",
    "contest_id": "weekly-contest-454",
    "contest_date": "2025-06-15T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 41,
      "coverage": null
    },
    "submission_id": 1664378551
  },
  {
    "id": "contest454_q3900_s1",
    "question_id": 3900,
    "function_name": "findMedian",
    "code": "class Solution:\n    def findMedian(self, n: int, e: List[List[int]], qs: List[List[int]]) -> List[int]:\n        def lca(x,y):\n            if depth[x]<depth[y]: x,y=y,x\n            diff=depth[x]-depth[y]\n            for i in range(P):\n                if diff>>i&1: x=parent[i][x]\n            if x==y: return x\n            for i in range(P-1,-1,-1):\n                if parent[i][x]!=parent[i][y]:\n                    x=parent[i][x]; y=parent[i][y]\n            return parent[0][x]\n\n        def dfs(u,p):\n            for v,w in g[u]:\n                if v!=p:\n                    parent[0][v]=u; upsum[0][v]=w\n                    depth[v]=depth[u]+1; dsum[v]=dsum[u]+w\n                    dfs(v,u)\n\n        P=(n-1).bit_length()\n        g=[[] for _ in range(n)]\n        for u,v,w in e:\n            g[u].append((v,w)); g[v].append((u,w))\n        parent=[[-1]*n for _ in range(P)]\n        upsum=[[0]*n for _ in range(P)]\n        depth=[0]*n; dsum=[0]*n\n\n        dfs(0,-1)\n        for i in range(1,P):\n            for v in range(n):\n                p0=parent[i-1][v]\n                if p0!=-1:\n                    parent[i][v]=parent[i-1][p0]\n                    upsum[i][v]=upsum[i-1][v]+upsum[i-1][p0]\n\n        res=[]\n        for u,v in qs:\n            if u==v:\n                res.append(u)\n                continue\n            w=lca(u,v)\n            d1=dsum[u]-dsum[w]; d2=dsum[v]-dsum[w]; total=d1+d2\n            if 2*d1>=total:\n                c=u; acc=0\n                for i in range(P-1,-1,-1):\n                    nz=parent[i][c]\n                    if nz!=-1 and acc+2*upsum[i][c]<total:\n                        acc+=2*upsum[i][c]; c=nz\n                c=parent[0][c]\n            else:\n                c=v; acc=0\n                for i in range(P-1,-1,-1):\n                    nz=parent[i][c]\n                    if nz!=-1 and acc+2*upsum[i][c]<=total:\n                        acc+=2*upsum[i][c]; c=nz\n            res.append(c)\n        return res",
    "input": "findMedian(n=2, e=[[0,1,7]], qs=[[1,0],[0,1]])",
    "output": "[0, 1]",
    "correct_condition": "findMedian(n=2, e=[[0,1,7]], qs=[[1,0],[0,1]]) == [0, 1]",
    "contest_id": "weekly-contest-454",
    "contest_date": "2025-06-15T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 58,
      "coverage": null
    },
    "submission_id": 1664400150
  },
  {
    "id": "contest454_q3900_s2",
    "question_id": 3900,
    "function_name": "findMedian",
    "code": "class Solution:\n    def findMedian(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n        adjMap = defaultdict(list)\n        for u, v, w in edges:\n            adjMap[u].append((v, w))\n            adjMap[v].append((u, w))\n\n        parents = [None] * n\n        depths = [0] * n\n        distRoot = [0] * n\n        children = defaultdict(list)\n\n        def dfs(node, parent):\n            for nxt, w in adjMap[node]:\n                if nxt == parent:\n                    continue\n                parents[nxt] = node\n                depths[nxt] = depths[node] + 1\n                distRoot[nxt] = distRoot[node] + w\n                children[node].append(nxt)\n                dfs(nxt, node)\n        parents[0] = -1\n        dfs(0, -1)\n\n        maxPow = n.bit_length()\n\n        @cache\n        def ancestor(node, power):\n            if node == -1:\n                return -1\n            if power == 0:\n                return parents[node]\n            half = ancestor(node, power - 1)\n            return ancestor(half, power - 1)\n\n        @cache\n        def kthAncestor(node, k):\n            if k == 0 or node == -1:\n                return node\n            bit = k.bit_length() - 1\n            return kthAncestor(ancestor(node, bit), k - (1 << bit))\n\n        def lca(a, b):\n            if depths[a] < depths[b]:\n                a, b = b, a\n            diff = depths[a] - depths[b]\n            a = kthAncestor(a, diff)\n            if a == b:\n                return a\n            for p in range(maxPow, -1, -1):\n                jumpA = ancestor(a, p)\n                jumpB = ancestor(b, p)\n                if jumpA != jumpB:\n                    a = jumpA\n                    b = jumpB\n            return parents[a]\n\n        def pathWeight(a, b):\n            z = lca(a, b)\n            return distRoot[a] + distRoot[b] - 2 * distRoot[z]\n\n        def aToBX(a, b, x):\n            z = lca(a, b)\n            up = depths[a] - depths[z]\n            if x <= up:\n                return kthAncestor(a, x)\n            down = depths[b] - depths[z]\n            return kthAncestor(b, down - (x - up))\n\n        res = []\n        for a, b in queries:\n            tot = pathWeight(a, b)\n            z = lca(a, b)\n            pathLength = depths[a] + depths[b] - (2 * depths[z]) + 1\n            l, r = 0, pathLength - 1\n            resNode = b\n            while l <= r:\n                m = (l+r)//2\n                nodeMid = aToBX(a, b, m)\n                if pathWeight(a, nodeMid) * 2 >= tot:\n                    resNode = nodeMid\n                    r = m - 1\n                else:\n                    l = m + 1\n            res.append(resNode)\n        return res",
    "input": "findMedian(n=2, edges=[[0,1,7]], queries=[[1,0],[0,1]])",
    "output": "[0, 1]",
    "correct_condition": "findMedian(n=2, edges=[[0,1,7]], queries=[[1,0],[0,1]]) == [0, 1]",
    "contest_id": "weekly-contest-454",
    "contest_date": "2025-06-15T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 86,
      "coverage": null
    },
    "submission_id": 1664394809
  },
  {
    "id": "contest455_q3914_s0",
    "question_id": 3914,
    "function_name": "checkPrimeFrequency",
    "code": "from collections import Counter\n\nclass Solution:\n    def checkPrimeFrequency(self, nums):\n        for cnt in Counter(nums).values():\n            if cnt > 1:\n                if cnt < 4:\n                    return True\n                if cnt % 2 and cnt % 3:\n                    i, lim = 5, int(cnt ** 0.5)\n                    while i <= lim and cnt % i and cnt % (i + 2):\n                        i += 6\n                    if i > lim:\n                        return True\n        return False\n",
    "input": "checkPrimeFrequency(nums=[1,2,3,4,5,4])",
    "output": "True",
    "correct_condition": "checkPrimeFrequency(nums=[1,2,3,4,5,4]) == True",
    "contest_id": "weekly-contest-455",
    "contest_date": "2025-06-22T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 15,
      "coverage": null
    },
    "submission_id": 1672147390
  },
  {
    "id": "contest455_q3914_s1",
    "question_id": 3914,
    "function_name": "checkPrimeFrequency",
    "code": "class Solution:\n    def checkPrimeFrequency(self, nums: List[int]) -> bool:\n        cnt = Counter(nums)\n\n        def isPrime(x):\n            if x < 2:\n                return False\n            for i in range(2, int(x**0.5) + 1):\n                if x % i == 0:\n                    return False\n            return True\n\n        for v in cnt.values():\n            if isPrime(v):\n                return True\n        return False\n",
    "input": "checkPrimeFrequency(nums=[1,2,3,4,5,4])",
    "output": "True",
    "correct_condition": "checkPrimeFrequency(nums=[1,2,3,4,5,4]) == True",
    "contest_id": "weekly-contest-455",
    "contest_date": "2025-06-22T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 16,
      "coverage": null
    },
    "submission_id": 1672123316
  },
  {
    "id": "contest455_q3914_s2",
    "question_id": 3914,
    "function_name": "checkPrimeFrequency",
    "code": "from collections import Counter\nfrom math import isqrt\nfrom typing import List\n\nclass Solution:\n    def checkPrimeFrequency(self, nums: List[int]) -> bool:\n        # frequency map\n        freq = Counter(nums)\n\n        # find if n is prime\n        def is_prime(n: int) -> bool:\n            if n <= 1:\n                return False\n            if n <= 3:\n                return True\n            if n % 2 == 0:\n                return False\n            limit = isqrt(n)\n            for d in range(3, limit + 1, 2):\n                if n % d == 0:\n                    return False\n            return True\n\n        for f in freq.values():\n            if is_prime(f):\n                return True\n        return False",
    "input": "checkPrimeFrequency(nums=[1,2,3,4,5,4])",
    "output": "True",
    "correct_condition": "checkPrimeFrequency(nums=[1,2,3,4,5,4]) == True",
    "contest_id": "weekly-contest-455",
    "contest_date": "2025-06-22T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 27,
      "coverage": null
    },
    "submission_id": 1672125677
  },
  {
    "id": "contest455_q3903_s0",
    "question_id": 3903,
    "function_name": "findCoins",
    "code": "class Solution:\n    def findCoins(self, w):\n        n = len(w)\n        dp = [1] + [0] * n\n        res = []\n        for i in range(1, n + 1):\n            c = dp[i]\n            d = w[i - 1]\n            if c > d:\n                return []\n            if c < d:\n                res.append(i)\n                for j in range(i, n + 1):\n                    dp[j] += dp[j - i]\n        return res if dp[1:] == w else []\n",
    "input": "findCoins(w=[0,1,0,2,0,3,0,4,0,5])",
    "output": "[2, 4, 6]",
    "correct_condition": "findCoins(w=[0,1,0,2,0,3,0,4,0,5]) == [2, 4, 6]",
    "contest_id": "weekly-contest-455",
    "contest_date": "2025-06-22T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 15,
      "coverage": null
    },
    "submission_id": 1672149294
  },
  {
    "id": "contest455_q3903_s1",
    "question_id": 3903,
    "function_name": "findCoins",
    "code": "class Solution:\n    def findCoins(self, numWays: List[int]) -> List[int]:\n        l = len(numWays)\n        dp = [0] * (l + 1)\n        dp[0] = 1\n        sa = []\n        for d in range(1, l + 1):\n            if dp[d] < numWays[d - 1]:\n                if numWays[d - 1] - dp[d] != 1:\n                    return []\n                sa.append(d)\n                for i in range(d, l + 1):\n                    dp[i] += dp[i - d]\n            if dp[d] > numWays[d - 1]:\n                return []\n        for i in range(1, l + 1):\n            if dp[i] != numWays[i - 1]:\n                return []\n        return sa\n",
    "input": "findCoins(numWays=[0,1,0,2,0,3,0,4,0,5])",
    "output": "[2, 4, 6]",
    "correct_condition": "findCoins(numWays=[0,1,0,2,0,3,0,4,0,5]) == [2, 4, 6]",
    "contest_id": "weekly-contest-455",
    "contest_date": "2025-06-22T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 19,
      "coverage": null
    },
    "submission_id": 1672129964
  },
  {
    "id": "contest455_q3903_s2",
    "question_id": 3903,
    "function_name": "findCoins",
    "code": "from typing import List\n\nclass Solution:\n    def findCoins(self, numWays: List[int]) -> List[int]:\n        n = len(numWays)\n        dp = [0]*(n+1)\n        dp[0] = 1\n        coins = [] # we will build this answer\n\n        for val in range(1, n+1):\n            cur = dp[val]\n            need = numWays[val-1]\n\n            # already matches\n            if cur == need:\n                continue\n\n            # fix deficit of exactly 1\n            if need - cur == 1:\n                coins.append(val)\n\n                for x in range(val, n+1):\n                    dp[x] += dp[x-val]\n\n                if dp[val] != need:\n                    return[]\n            else:\n                return[]\n        return coins",
    "input": "findCoins(numWays=[0,1,0,2,0,3,0,4,0,5])",
    "output": "[2, 4, 6]",
    "correct_condition": "findCoins(numWays=[0,1,0,2,0,3,0,4,0,5]) == [2, 4, 6]",
    "contest_id": "weekly-contest-455",
    "contest_date": "2025-06-22T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 29,
      "coverage": null
    },
    "submission_id": 1672133304
  },
  {
    "id": "contest455_q3909_s0",
    "question_id": 3909,
    "function_name": "minIncrease",
    "code": "class Solution:\n    def minIncrease(self, n, e, w):\n        import sys\n        sys.setrecursionlimit(300000)\n        a = [[] for _ in range(n)]\n        for x, y in e:\n            a[x].append(y)\n            a[y].append(x)\n        q = [-1] * n\n        s = [0]\n        for i in s:\n            for j in a[i]:\n                if j != q[i]:\n                    q[j] = i\n                    s.append(j)\n        m = [0] * n\n        r = [0] * n\n        for i in reversed(s):\n            t = 0\n            for j in a[i]:\n                if j != q[i]:\n                    t = max(t, m[j])\n            for j in a[i]:\n                if j != q[i]:\n                    r[i] += r[j] + (m[j] < t)\n            m[i] = w[i] + t\n        return r[0]\n",
    "input": "minIncrease(n=3, e=[[0,1],[0,2]], w=[2,1,3])",
    "output": "1",
    "correct_condition": "minIncrease(n=3, e=[[0,1],[0,2]], w=[2,1,3]) == 1",
    "contest_id": "weekly-contest-455",
    "contest_date": "2025-06-22T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 27,
      "coverage": null
    },
    "submission_id": 1672149562
  },
  {
    "id": "contest455_q3909_s1",
    "question_id": 3909,
    "function_name": "minIncrease",
    "code": "class Solution:\n    def minIncrease(self, n: int, edges: List[List[int]], cost: List[int]) -> int:\n        g = defaultdict(list)\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        res = 0\n\n        def dfs(u, p):\n            mx = 0\n            ch = []\n            for v in g[u]:\n                if v != p:\n                    s, cnt = dfs(v, u)\n                    mx = max(mx, s)\n                    ch.append((s, cnt))\n            cnt = 0\n            for s, c in ch:\n                if s < mx:\n                    cnt += c + 1\n                else:\n                    cnt += c\n            return cost[u] + mx, cnt\n\n        return dfs(0, -1)[1]\n",
    "input": "minIncrease(n=3, edges=[[0,1],[0,2]], cost=[2,1,3])",
    "output": "1",
    "correct_condition": "minIncrease(n=3, edges=[[0,1],[0,2]], cost=[2,1,3]) == 1",
    "contest_id": "weekly-contest-455",
    "contest_date": "2025-06-22T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 25,
      "coverage": null
    },
    "submission_id": 1672151557
  },
  {
    "id": "contest455_q3909_s2",
    "question_id": 3909,
    "function_name": "minIncrease",
    "code": "from typing import List\nimport sys\nsys.setrecursionlimit(300_000)\n\nclass Solution:\n    def minIncrease(self, n: int, edges: List[List[int]], cost: List[int]) -> int:\n        g = [[] for _ in range(n)]\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n\n        def dfs(u: int, parent: int) -> tuple[int, int]:\n            child_scores = []\n            ops = 0\n\n            for v in g[u]:\n                if v == parent:\n                    continue\n                score, sub_ops = dfs(v, u)\n                child_scores.append(score)\n                ops += sub_ops\n\n            # leaf node - only its own cost matters\n            if not child_scores:\n                return cost[u], ops\n\n            max_child = max(child_scores)\n\n            for score in child_scores:\n                if score < max_child:\n                    ops += 1\n            return cost[u] + max_child, ops\n\n        _, answer = dfs(0, -1)\n        return answer",
    "input": "minIncrease(n=3, edges=[[0,1],[0,2]], cost=[2,1,3])",
    "output": "1",
    "correct_condition": "minIncrease(n=3, edges=[[0,1],[0,2]], cost=[2,1,3]) == 1",
    "contest_id": "weekly-contest-455",
    "contest_date": "2025-06-22T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 35,
      "coverage": null
    },
    "submission_id": 1672145060
  },
  {
    "id": "contest455_q3896_s0",
    "question_id": 3896,
    "function_name": "minTime",
    "code": "class Solution:\n    def minTime(self, n, k, m, t, f):\n        if n > 1 and k == 1:\n            return -1.0\n\n        import sys, heapq, math\n        from itertools import combinations\n\n        full = (1 << n) - 1\n        pq = [(0.0, 0, 0, 0)]\n        vis = {}\n\n        while pq:\n            x, a, b, c = heapq.heappop(pq)\n            if vis.get((a, b, c), sys.maxsize) <= x:\n                continue\n            vis[(a, b, c)] = x\n            if a == full and c:\n                return round(x, 5)\n            if c == 0:\n                rem = [i for i in range(n) if not (a >> i & 1)]\n                for j in range(1, min(k, len(rem)) + 1):\n                    for grp in combinations(rem, j):\n                        d = max(t[i] for i in grp) * f[b]\n                        nb = (b + math.floor(d)) % m\n                        na = a\n                        for i in grp:\n                            na |= 1 << i\n                        heapq.heappush(pq, (x + d, na, nb, 1))\n            else:\n                if a != full:\n                    for i in range(n):\n                        if a >> i & 1:\n                            d = t[i] * f[b]\n                            nb = (b + math.floor(d)) % m\n                            na = a & ~(1 << i)\n                            heapq.heappush(pq, (x + d, na, nb, 0))\n\n        return -1.0\n",
    "input": "minTime(n=1, k=1, m=2, t=[5], f=[1.0,1.3])",
    "output": "5.0",
    "correct_condition": "minTime(n=1, k=1, m=2, t=[5], f=[1.0,1.3]) == 5.0",
    "contest_id": "weekly-contest-455",
    "contest_date": "2025-06-22T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 39,
      "coverage": null
    },
    "submission_id": 1672149867
  },
  {
    "id": "contest455_q3896_s1",
    "question_id": 3896,
    "function_name": "minTime",
    "code": "class Solution:\n    def minTime(\n        self, n: int, k: int, m: int, time: List[int], mul: List[float]\n    ) -> float:\n        full = (1 << n) - 1\n        dp = {}\n        start = (0, 0, 0)\n        dp[start] = 0.0\n        pq = [(0.0, start)]\n        while pq:\n            c, (msk, bt, st) = heapq.heappop(pq)\n            if dp.get((msk, bt, st), float(\"inf\")) < c - 1e-12:\n                continue\n            if msk == full and bt == 1:\n                return round(c, 5)\n            if bt == 0:\n                rem = [i for i in range(n) if (msk >> i) & 1 == 0]\n                for sz in range(1, min(k, len(rem)) + 1):\n                    for group in itertools.combinations(rem, sz):\n                        tmax = 0\n                        bitmask = 0\n                        for i in group:\n                            if time[i] > tmax:\n                                tmax = time[i]\n                            bitmask |= 1 << i\n                        T = tmax * mul[st]\n                        nstage = (st + int(math.floor(T))) % m\n                        nmask = msk | bitmask\n                        nboat = 1\n                        nc = c + T\n                        state = (nmask, nboat, nstage)\n                        if dp.get(state, float(\"inf\")) > nc + 1e-12:\n                            dp[state] = nc\n                            heapq.heappush(pq, (nc, state))\n            else:\n                if msk != full:\n                    for i in range(n):\n                        if (msk >> i) & 1:\n                            T = time[i] * mul[st]\n                            nstage = (st + int(math.floor(T))) % m\n                            nmask = msk & ~(1 << i)\n                            nboat = 0\n                            nc = c + T\n                            state = (nmask, nboat, nstage)\n                            if dp.get(state, float(\"inf\")) > nc + 1e-12:\n                                dp[state] = nc\n                                heapq.heappush(pq, (nc, state))\n        return -1\n",
    "input": "minTime(n=1, k=1, m=2, time=[5], mul=[1.0,1.3])",
    "output": "5.0",
    "correct_condition": "minTime(n=1, k=1, m=2, time=[5], mul=[1.0,1.3]) == 5.0",
    "contest_id": "weekly-contest-455",
    "contest_date": "2025-06-22T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 48,
      "coverage": null
    },
    "submission_id": 1672143232
  },
  {
    "id": "contest455_q3896_s2",
    "question_id": 3896,
    "function_name": "minTime",
    "code": "from typing import List, Tuple\nimport heapq\nimport math\nfrom itertools import combinations\n\nclass Solution:\n    def minTime(self, n: int, k: int, m: int, time: List[int], mul: List[float]) -> float:\n        # check impossibility\n        if n > 1 and k == 1:\n            return -1.0\n        FULL = (1 << n) - 1\n        start = (0,0,0)\n        best = {start: 0.0}\n        pq: List[Tuple[float, Tuple[int, int, int]]] = [(0.0, start)]\n\n        # pre compute groups\n        groups_by_size: List[List[Tuple[int, int]]] = [[] for _ in range(k+1)]\n        for sz in range(1, k + 1):\n            for combo in combinations(range(n), sz):\n                bitmask = 0\n                slowest = 0\n                for p in combo:\n                    bitmask |= 1 << p\n                    slowest = max(slowest, time[p])\n                groups_by_size[sz].append((bitmask, slowest))\n\n        while pq:\n            tot_t, (mask, stage, side) = heapq.heappop(pq)\n            if tot_t > best[(mask, stage, side)] + 1e-12:\n                continue\n            if mask == FULL and side == 1:\n                return round(tot_t, 5)\n\n            if side == 0: # boat at base\n                waiting = FULL ^ mask\n                count_waiting = bin(waiting).count(\"1\")\n                for sz in range(1, min(k, count_waiting) + 1):\n                    for gmask, slowest in groups_by_size[sz]:\n                        if gmask & waiting != gmask: # must be a subset of waiting\n                            continue\n                        t = slowest * mul[stage]\n                        nxt_stage = (stage + math.floor(t)) % m\n                        nxt_state = (mask | gmask, nxt_stage, 1)\n                        nxt_t = tot_t + t\n                        if nxt_t < best.get(nxt_state, float(\"inf\")) - 1e-12:\n                            best[nxt_state] = nxt_t\n                            heapq.heappush(pq, (nxt_t, nxt_state))\n                        \n            else: # boat at destination\n                for p in range(n):\n                    if (mask >> p) & 1 == 0:\n                        continue\n                    t = time[p] * mul[stage]\n                    nxt_stage = (stage + math.floor(t)) % m\n                    nxt_state = (mask ^ (1 << p), nxt_stage, 0)\n                    nxt_t = tot_t + t\n                    if nxt_t < best.get(nxt_state, float(\"inf\")) - 1e-12:\n                        best[nxt_state] = nxt_t\n                    heapq.heappush(pq, (nxt_t, nxt_state))\n        return -1.0\n                \n            ",
    "input": "minTime(n=1, k=1, m=2, time=[5], mul=[1.0,1.3])",
    "output": "5.0",
    "correct_condition": "minTime(n=1, k=1, m=2, time=[5], mul=[1.0,1.3]) == 5.0",
    "contest_id": "weekly-contest-455",
    "contest_date": "2025-06-22T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 62,
      "coverage": null
    },
    "submission_id": 1672158055
  },
  {
    "id": "contest456_q3905_s0",
    "question_id": 3905,
    "function_name": "partitionString",
    "code": "class Solution:\n    def partitionString(self, s: str) -> List[str]:\n        se, rs, n, i = set(), [], len(s), 0\n        while i < n:\n            cu, j = '', i\n            while j < n:\n                cu += s[j]\n                if cu not in se:\n                    se.add(cu)\n                    rs.append(cu)\n                    i = j + 1\n                    break\n                j += 1\n            else: break\n        return rs\n",
    "input": "partitionString(s=\"abbccccd\")",
    "output": "['a', 'b', 'bc', 'c', 'cc', 'd']",
    "correct_condition": "partitionString(s=\"abbccccd\") == ['a', 'b', 'bc', 'c', 'cc', 'd']",
    "contest_id": "weekly-contest-456",
    "contest_date": "2025-06-29T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 15,
      "coverage": null
    },
    "submission_id": 1679827104
  },
  {
    "id": "contest456_q3905_s1",
    "question_id": 3905,
    "function_name": "partitionString",
    "code": "class Solution:\n    def partitionString(self, s: str) -> List[str]:\n        r, t, i = [], set(), 0\n        for j in range(len(s)):\n            c = s[i:j+1]\n            if c not in t: r.append(c); t.add(c); i = j + 1\n        return r",
    "input": "partitionString(s=\"abbccccd\")",
    "output": "['a', 'b', 'bc', 'c', 'cc', 'd']",
    "correct_condition": "partitionString(s=\"abbccccd\") == ['a', 'b', 'bc', 'c', 'cc', 'd']",
    "contest_id": "weekly-contest-456",
    "contest_date": "2025-06-29T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 7,
      "coverage": null
    },
    "submission_id": 1679826968
  },
  {
    "id": "contest456_q3905_s2",
    "question_id": 3905,
    "function_name": "partitionString",
    "code": "class Solution:\n    def partitionString(self, txt):\n        op, mem, tmp = [], set(), \"\"\n        for z in txt:\n            k = tmp + z\n            if k not in mem:\n                op.append(k)\n                mem.add(k)\n                tmp = \"\"\n            else:\n                tmp = k\n        return op\n",
    "input": "partitionString(txt=\"abbccccd\")",
    "output": "['a', 'b', 'bc', 'c', 'cc', 'd']",
    "correct_condition": "partitionString(txt=\"abbccccd\") == ['a', 'b', 'bc', 'c', 'cc', 'd']",
    "contest_id": "weekly-contest-456",
    "contest_date": "2025-06-29T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 12,
      "coverage": null
    },
    "submission_id": 1679848786
  },
  {
    "id": "contest456_q3800_s0",
    "question_id": 3800,
    "function_name": "longestCommonPrefix",
    "code": "class Solution:\n    def longestCommonPrefix(self, words: List[str]) -> List[int]:\n        n = len(words)\n        if n < 2:\n            return [0]*n\n        l = [0]*(n-1)\n        for i in range(n-1):\n            a, b = words[i], words[i+1]\n            m, j = min(len(a), len(b)), 0\n            while j < m and a[j] == b[j]: j += 1\n            l[i] = j\n        pm = [0]*(n-1)\n        pm[0] = l[0]\n        for i in range(1, n-1): pm[i] = pm[i-1] if pm[i-1] > l[i] else l[i]\n        sm = [0]*(n-1)\n        sm[n-2] = l[n-2]\n        for i in range(n-3, -1, -1): sm[i] = sm[i+1] if sm[i+1] > l[i] else l[i]\n\n        res = [0]*n\n        for i in range(n):\n            left = pm[i-2] if i >= 2 else 0\n            right = sm[i+1] if i+1 <= n-2 else 0\n            mx = left if left > right else right\n            if 0 < i < n-1:\n                a, b = words[i-1], words[i+1]\n                m = min(len(a), len(b))\n                j = 0\n                while j < m and a[j] == b[j]: j += 1\n                t = j\n                mx = mx if mx > t else t\n            res[i] = mx\n        return res",
    "input": "longestCommonPrefix(words=[\"jump\",\"run\",\"run\",\"jump\",\"run\"])",
    "output": "[3, 0, 0, 3, 3]",
    "correct_condition": "longestCommonPrefix(words=[\"jump\",\"run\",\"run\",\"jump\",\"run\"]) == [3, 0, 0, 3, 3]",
    "contest_id": "weekly-contest-456",
    "contest_date": "2025-06-29T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 32,
      "coverage": null
    },
    "submission_id": 1679829840
  },
  {
    "id": "contest456_q3800_s1",
    "question_id": 3800,
    "function_name": "longestCommonPrefix",
    "code": "from typing import List\n\nclass Solution:\n  def longestCommonPrefix(self, w: List[str]) -> List[int]:\n    n = len(w)\n    if n <= 1: return [0] * n\n\n    def f(a: str, b: str) -> int:\n      c = 0\n      for x, y in zip(a, b):\n        if x == y: c += 1\n        else: break\n      return c\n\n    a = [f(w[i], w[i+1]) for i in range(n-1)]\n    p, s = [0]*(n-1), [0]*(n-1); p[0], s[-1] = a[0], a[-1]\n    for i in range(1, n-1): p[i] = max(p[i-1], a[i])\n    for i in range(n-3, -1, -1): s[i] = max(s[i+1], a[i])\n\n    r = [0]*n; r[0] = s[1] if n > 2 else 0; r[-1] = p[-2] if n > 2 else 0\n\n    for i in range(1, n-1):\n      x = f(w[i-1], w[i+1])\n      r[i] = max(x, p[i-2] if i > 1 else 0, s[i+1] if i < n-2 else 0)\n\n    return r",
    "input": "longestCommonPrefix(w=[\"jump\",\"run\",\"run\",\"jump\",\"run\"])",
    "output": "[3, 0, 0, 3, 3]",
    "correct_condition": "longestCommonPrefix(w=[\"jump\",\"run\",\"run\",\"jump\",\"run\"]) == [3, 0, 0, 3, 3]",
    "contest_id": "weekly-contest-456",
    "contest_date": "2025-06-29T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 26,
      "coverage": null
    },
    "submission_id": 1679830179
  },
  {
    "id": "contest456_q3800_s2",
    "question_id": 3800,
    "function_name": "longestCommonPrefix",
    "code": "import sys\n\nclass Solution:\n    def longestCommonPrefix(self, w):\n        n = len(w)\n        if n < 3:\n            return [0] * n\n\n        def lcp(a, b):\n            i, m = 0, min(len(a), len(b))\n            while i < m and a[i] == b[i]:\n                i += 1\n            return i\n\n        pairwise = [lcp(w[i], w[i + 1]) for i in range(n - 1)]\n        pref = [0] * (n - 1)\n        suff = [0] * (n - 1)\n\n        pref[0] = pairwise[0]\n        for i in range(1, n - 1):\n            pref[i] = max(pref[i - 1], pairwise[i])\n\n        suff[-1] = pairwise[-1]\n        for i in range(n - 3, -1, -1):\n            suff[i] = max(suff[i + 1], pairwise[i])\n\n        res = [suff[1]]\n        for i in range(1, n - 1):\n            left = pref[i - 2] if i > 1 else -sys.maxsize\n            right = suff[i + 1] if i + 1 < n - 1 else -sys.maxsize\n            mid = lcp(w[i - 1], w[i + 1])\n            res.append(max(left, right, mid))\n        res.append(pref[-2])\n        return res\n",
    "input": "longestCommonPrefix(w=[\"jump\",\"run\",\"run\",\"jump\",\"run\"])",
    "output": "[3, 0, 0, 3, 3]",
    "correct_condition": "longestCommonPrefix(w=[\"jump\",\"run\",\"run\",\"jump\",\"run\"]) == [3, 0, 0, 3, 3]",
    "contest_id": "weekly-contest-456",
    "contest_date": "2025-06-29T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 34,
      "coverage": null
    },
    "submission_id": 1679850881
  },
  {
    "id": "contest456_q3913_s0",
    "question_id": 3913,
    "function_name": "minXor",
    "code": "class Solution:\n    def minXor(self, a: List[int], k: int) -> int:\n        n=len(a)\n        p=[0]*(n+1)\n        for i in range(n): p[i+1]=p[i]^a[i]\n        d=[[float('inf')]*(n+1) for _ in range(k+1)]\n        d[0][0]=0\n        for j in range(1,k+1):\n            for i in range(j,n+1):\n                m=float('inf')\n                for t in range(j-1,i):\n                    x=p[i]^p[t]\n                    y=d[j-1][t] if d[j-1][t]>x else x\n                    if y<m: m=y\n                d[j][i]=m\n        return d[k][n]",
    "input": "minXor(a=[1,2,3], k=2)",
    "output": "1",
    "correct_condition": "minXor(a=[1,2,3], k=2) == 1",
    "contest_id": "weekly-contest-456",
    "contest_date": "2025-06-29T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 16,
      "coverage": null
    },
    "submission_id": 1679835369
  },
  {
    "id": "contest456_q3913_s1",
    "question_id": 3913,
    "function_name": "minXor",
    "code": "class Solution:\n    def minXor(self, arr, parts):\n        pre = [0]\n        for num in arr:\n            pre.append(pre[-1] ^ num)\n        n = len(arr)\n        dp = [[sys.maxsize] * (parts + 1) for _ in range(n + 1)]\n        dp[0][0] = -sys.maxsize\n        for i in range(1, n + 1):\n            for j in range(1, min(i, parts) + 1):\n                dp[i][j] = min(max(dp[t][j - 1], pre[i] ^ pre[t]) for t in range(j - 1, i))\n        return dp[n][parts]\n",
    "input": "minXor(arr=[1,2,3], parts=2)",
    "output": "1",
    "correct_condition": "minXor(arr=[1,2,3], parts=2) == 1",
    "contest_id": "weekly-contest-456",
    "contest_date": "2025-06-29T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 12,
      "coverage": null
    },
    "submission_id": 1679850323
  },
  {
    "id": "contest456_q3913_s2",
    "question_id": 3913,
    "function_name": "minXor",
    "code": "from typing import List\n\nclass Solution:\n    def minXor(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        prefix = [0] * (n + 1)\n        for i in range(1, n + 1):\n            prefix[i] = prefix[i - 1] ^ nums[i - 1]\n        inf = 10**18\n        dp = [[inf] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(1, n + 1):\n            dp[i][1] = prefix[i]\n        for j in range(2, k + 1):\n            for i in range(j, n + 1):\n                best = inf\n                for t in range(j - 1, i):\n                    val = dp[t][j - 1]\n                    curr = prefix[i] ^ prefix[t]\n                    m = curr if curr > val else val\n                    if m < best:\n                        best = m\n                dp[i][j] = best\n        return dp[n][k]",
    "input": "minXor(nums=[1,2,3], k=2)",
    "output": "1",
    "correct_condition": "minXor(nums=[1,2,3], k=2) == 1",
    "contest_id": "weekly-contest-456",
    "contest_date": "2025-06-29T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 24,
      "coverage": null
    },
    "submission_id": 1679840404
  },
  {
    "id": "contest456_q3902_s0",
    "question_id": 3902,
    "function_name": "maxStability",
    "code": "class Solution:\n    def maxStability(self,n,e,k):\n        def f(x):\n            if p[x]!=x:         p[x]=f(p[x])\n            return p[x]\n            \n        def u(a,b):\n            ra,rb=f(a),f(b)\n            if ra==rb:          return False\n            if r[ra]<r[rb]:     p[ra]=rb\n            elif r[ra]>r[rb]:   p[rb]=ra\n            else: p[rb]=ra;     r[ra]+=1\n            return True\n\n        def ok(s):\n            for i in range(n):      p[i]=i; r[i]=0\n            for a,b,s0,m0 in e:\n                if m0==1:\n                    if s0< s:       return False\n                    if not u(a,b):  return False\n            for a,b,s0,m0 in e:\n                if m0==0 and s0>=s:     u(a,b)\n            rem=k\n            for a,b,s0,m0 in e:\n                if m0==0 and s0< s and s0*2>=s and rem>0:\n                    if u(a,b):      rem-=1\n            root=f(0)\n            for i in range(1,n):\n                if f(i)!=root:      return False\n            return True\n        \n        p=list(range(n))\n        r=[0]*n\n        lo,hi=1,max((s0*2 if m0==0 else s0) for _,_,s0,m0 in e)\n        res=-1\n        while lo<=hi:\n            mid=(lo+hi)//2\n            if ok(mid):  res=mid; lo=mid+1\n            else:        hi=mid-1\n        return res\n\n        ",
    "input": "maxStability(n=3, e=[[0,1,2,1],[1,2,3,0]], k=1)",
    "output": "2",
    "correct_condition": "maxStability(n=3, e=[[0,1,2,1],[1,2,3,0]], k=1) == 2",
    "contest_id": "weekly-contest-456",
    "contest_date": "2025-06-29T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 42,
      "coverage": null
    },
    "submission_id": 1679841662
  },
  {
    "id": "contest456_q3902_s1",
    "question_id": 3902,
    "function_name": "maxStability",
    "code": "class Solution:\n  def maxStability(self, n: int, e: list[list[int]], k: int) -> int:\n    class D:\n      def __init__(s, z): s.p, s.c = list(range(z)), z\n      def f(s, i): s.p[i] = s.f(s.p[i]) if s.p[i] != i else i; return s.p[i]\n      def u(s, i, j):\n        x, y = s.f(i), s.f(j)\n        if x != y: s.p[y] = x; s.c -= 1; return 1\n        return 0\n\n    d1 = D(n)\n    for u, v, _, m in e:\n      if m and not d1.u(u, v): return -1\n\n    d2 = D(n)\n    for u, v, _, _ in e: d2.u(u, v)\n    if d2.c > 1: return -1\n\n    x = {'n': n, 'e': e, 'k': k}\n\n    def g(t):\n      d, cnt = D(n), 0\n      for u, v, s, m in e:\n        if m:\n          if s < t: return 0\n          d.u(u, v)\n        elif s >= t: d.u(u, v)\n      if d.c > 1:\n        for u, v, s, m in e:\n          if not m and s < t and 2*s >= t and d.u(u, v): cnt += 1\n      return d.c == 1 and cnt <= k\n\n    l, h, ans = 1, 2*10**5+1, 0\n    while l <= h:\n      m = (l + h) // 2\n      if m == 0: l = m + 1; continue\n      if g(m): ans = m; l = m + 1\n      else: h = m - 1\n    return ans\n",
    "input": "maxStability(n=3, e=[[0,1,2,1],[1,2,3,0]], k=1)",
    "output": "2",
    "correct_condition": "maxStability(n=3, e=[[0,1,2,1],[1,2,3,0]], k=1) == 2",
    "contest_id": "weekly-contest-456",
    "contest_date": "2025-06-29T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 39,
      "coverage": null
    },
    "submission_id": 1679836304
  },
  {
    "id": "contest456_q3902_s2",
    "question_id": 3902,
    "function_name": "maxStability",
    "code": "class Solution:\n    def maxStability(self, n, edges, k):\n        def go(mid):\n            par = list(range(n))\n\n            def find(x):\n                while par[x] != x:\n                    par[x] = par[par[x]]\n                    x = par[x]\n                return x\n\n            used = 0\n            for x, y, w, typ in edges:\n                if typ and w < mid:\n                    return None\n                if typ:\n                    rx, ry = find(x), find(y)\n                    if rx == ry:\n                        return None\n                    par[ry] = rx\n\n            for x, y, w, typ in edges:\n                if not typ and w >= mid:\n                    rx, ry = find(x), find(y)\n                    if rx != ry:\n                        par[ry] = rx\n\n            for x, y, w, typ in edges:\n                if not typ and w * 2 >= mid and used < k:\n                    rx, ry = find(x), find(y)\n                    if rx != ry:\n                        par[ry] = rx\n                        used += 1\n\n            return par\n\n        def isConnected(p):\n            if p is None:\n                return False\n\n            def trace(x):\n                return x if p[x] == x else trace(p[x])\n\n            return len({trace(i) for i in range(n)}) == 1\n\n        lo, hi, res = 0, max(e[2] for e in edges) * 2, -1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if isConnected(go(mid)):\n                res, lo = mid, mid + 1\n            else:\n                hi = mid - 1\n        return res\n",
    "input": "maxStability(n=3, edges=[[0,1,2,1],[1,2,3,0]], k=1)",
    "output": "2",
    "correct_condition": "maxStability(n=3, edges=[[0,1,2,1],[1,2,3,0]], k=1) == 2",
    "contest_id": "weekly-contest-456",
    "contest_date": "2025-06-29T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 53,
      "coverage": null
    },
    "submission_id": 1679851418
  },
  {
    "id": "contest457_q3863_s0",
    "question_id": 3863,
    "function_name": "processQueries",
    "code": "class Solution:\n    def processQueries(self, c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:\n        rank = [0] * (c + 1)\n        parent = list(range(c + 1))\n\n        def find(x):\n            while parent[x] != x:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return x\n\n        def union(a, b):\n            a, b = find(a), find(b)\n            if a == b:\n                return\n            if rank[a] < rank[b]:\n                a, b = b, a\n            parent[b] = a\n            if rank[a] == rank[b]:\n                rank[a] += 1\n\n        for a, b in connections:\n            union(a, b)\n\n        _map = defaultdict(list)\n\n        for a in range(1, c + 1):\n            _map[find(a)].append(a)\n\n        for b in _map:\n            heapq.heapify(_map[b])\n\n        arr = [True] * (c + 1)\n\n        ans = []\n        for x, y in queries:\n            if x != 1:\n                arr[y] = False\n            else:\n                if arr[y]:\n                    ans.append(y)\n                else:\n                    h = _map[find(y)]\n                    while h and not arr[h[0]]:\n                        heapq.heappop(h)\n                    ans.append(h[0] if h else -1)\n                    # print(f\"query ({x}, {y}): pop, new val: {ans[-1]}\")\n\n        return ans\n",
    "input": "processQueries(c=5, connections=[[1,2],[2,3],[3,4],[4,5]], queries=[[1,3],[2,1],[1,1],[2,2],[1,2]])",
    "output": "[3, 2, 3]",
    "correct_condition": "processQueries(c=5, connections=[[1,2],[2,3],[3,4],[4,5]], queries=[[1,3],[2,1],[1,1],[2,2],[1,2]]) == [3, 2, 3]",
    "contest_id": "weekly-contest-457",
    "contest_date": "2025-07-06T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 49,
      "coverage": null
    },
    "submission_id": 1687854117
  },
  {
    "id": "contest457_q3863_s1",
    "question_id": 3863,
    "function_name": "processQueries",
    "code": "class Solution:\n    def processQueries(self,c,e,q):\n        def f(i):\n            while p[i]!=i:\n                p[i]=p[p[i]]\n                i=p[i]\n            return i\n        def u(a,b):\n            ra,rb=f(a),f(b)\n            if ra==rb: return\n            if s[ra]<s[rb]: p[ra]=rb\n            elif s[ra]>s[rb]: p[rb]=ra\n            else:\n                p[rb]=ra; s[ra]+=1\n\n        p=list(range(c+1)); s=[0]*(c+1)\n        for a,b in e: u(a,b)\n\n        d={}\n        for i in range(1,c+1):\n            r0=f(i)\n            d.setdefault(r0,[]).append(i)\n\n        for k0 in d: heapify(d[k0])\n        ok=[True]*(c+1); res=[]\n        for t,x in q:\n            if t==1:\n                if ok[x]: res.append(x)\n                else:\n                    h=d[f(x)]\n                    while h and not ok[h[0]]: heappop(h)\n                    res.append(h[0] if h else -1)\n            else: ok[x]=False\n        return res\n\n        ",
    "input": "processQueries(c=5, e=[[1,2],[2,3],[3,4],[4,5]], q=[[1,3],[2,1],[1,1],[2,2],[1,2]])",
    "output": "[3, 2, 3]",
    "correct_condition": "processQueries(c=5, e=[[1,2],[2,3],[3,4],[4,5]], q=[[1,3],[2,1],[1,1],[2,2],[1,2]]) == [3, 2, 3]",
    "contest_id": "weekly-contest-457",
    "contest_date": "2025-07-06T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 36,
      "coverage": null
    },
    "submission_id": 1687846549
  },
  {
    "id": "contest457_q3863_s2",
    "question_id": 3863,
    "function_name": "processQueries",
    "code": "import heapq\n\nclass Solution:\n    def processQueries(self, c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:\n        parent = list(range(c))\n        size = [1] * c\n\n        def find(x: int) -> int:\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(a: int, b: int) -> None:\n            ra, rb = find(a), find(b)\n            if ra == rb:\n                return\n            if size[ra] < size[rb]:\n                ra, rb = rb, ra\n            parent[rb] = ra\n            size[ra] += size[rb]\n\n        for u, v in connections:\n            union(u - 1, v - 1)\n\n        heaps = [[] for _ in range(c)]\n        for i in range(c):\n            root = find(i)\n            heapq.heappush(heaps[root], i + 1)\n\n        online = [True] * (c + 1)\n        ans: List[int] = []\n\n        for t, x in queries:\n            if t == 1:\n                if online[x]:\n                    ans.append(x)\n                    continue\n                root = find(x - 1)\n                heap = heaps[root]\n                while heap and not online[heap[0]]:\n                    heapq.heappop(heap)\n                ans.append(heap[0] if heap else -1)\n            elif t == 2:\n                online[x] = False\n\n        return ans\n",
    "input": "processQueries(c=5, connections=[[1,2],[2,3],[3,4],[4,5]], queries=[[1,3],[2,1],[1,1],[2,2],[1,2]])",
    "output": "[3, 2, 3]",
    "correct_condition": "processQueries(c=5, connections=[[1,2],[2,3],[3,4],[4,5]], queries=[[1,3],[2,1],[1,1],[2,2],[1,2]]) == [3, 2, 3]",
    "contest_id": "weekly-contest-457",
    "contest_date": "2025-07-06T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 46,
      "coverage": null
    },
    "submission_id": 1687855064
  },
  {
    "id": "contest457_q3908_s0",
    "question_id": 3908,
    "function_name": "minTime",
    "code": "class Solution:\n    def minTime(self, n: int, edges: List[List[int]], k: int) -> int:\n        edges.sort(key=lambda x: x[2])\n\n        parent = list(range(n))\n        rank = [0] * n\n\n        arr = sorted({0, *[w for *_, w in edges]}, reverse=True)\n\n        # print(f\"arr: {arr}\")\n\n        def find(x: int) -> int:\n            while parent[x] != x:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return x\n\n        i = len(edges) - 1\n        count = n\n\n        ans = 0\n        for w in arr:\n            while i >= 0 and edges[i][2] > w:\n                u, v, _ = edges[i]\n                a, b = find(u), find(v)\n                if a != b:\n                    if rank[a] < rank[b]:\n                        a, b = b, a\n                    parent[b] = a\n                    if rank[a] == rank[b]:\n                        rank[a] += 1\n                    # print(f\" union {u} and  {v}. time: {w}\")\n                    count -= 1\n                i -= 1\n\n            # print(f\"w: {w}, count: {count}, i: {i}\")\n            if count >= k:\n                ans = w\n\n        return ans\n",
    "input": "minTime(n=2, edges=[[0,1,3]], k=2)",
    "output": "3",
    "correct_condition": "minTime(n=2, edges=[[0,1,3]], k=2) == 3",
    "contest_id": "weekly-contest-457",
    "contest_date": "2025-07-06T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 40,
      "coverage": null
    },
    "submission_id": 1687869450
  },
  {
    "id": "contest457_q3908_s1",
    "question_id": 3908,
    "function_name": "minTime",
    "code": "class Solution:\n    def minTime(self,n,e,k):\n        def f(tt):\n            p=[-1]*n\n            def ff(i):\n                while p[i]>=0:\n                    if p[p[i]]>=0: p[i]=p[p[i]]\n                    i=p[i]\n                return i\n            cnt=n\n            for a,b,t0 in e:\n                if t0>tt:\n                    ra=ff(a); rb=ff(b)\n                    if ra!=rb:\n                        if p[ra]>p[rb]: ra,rb=rb,ra\n                        p[ra]+=p[rb]; p[rb]=ra\n                        cnt-=1\n            return cnt\n\n        v=sorted({x[2] for x in e})\n        v=[0]+v\n        l=0; r=len(v)-1; res=v[-1]\n        while l<=r:\n            m=(l+r)//2\n            if f(v[m])>=k:  res=v[m]; r=m-1\n            else:           l=m+1\n        return res",
    "input": "minTime(n=2, e=[[0,1,3]], k=2)",
    "output": "3",
    "correct_condition": "minTime(n=2, e=[[0,1,3]], k=2) == 3",
    "contest_id": "weekly-contest-457",
    "contest_date": "2025-07-06T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 27,
      "coverage": null
    },
    "submission_id": 1687859842
  },
  {
    "id": "contest457_q3908_s2",
    "question_id": 3908,
    "function_name": "minTime",
    "code": "class Solution:\n    def minTime(self, n: int, edges: List[List[int]], k: int) -> int:\n        class DSU:\n            def __init__(self, size: int):\n                self.parent = list(range(size))\n                self.size = [1] * size\n            def find(self, x: int) -> int:\n                if self.parent[x] != x:\n                    self.parent[x] = self.find(self.parent[x])\n                return self.parent[x]\n            def union(self, a: int, b: int) -> bool:\n                ra = self.find(a)\n                rb = self.find(b)\n                if ra == rb:\n                    return False\n                if self.size[ra] < self.size[rb]:\n                    ra, rb = rb, ra\n                self.parent[rb] = ra\n                self.size[ra] += self.size[rb]\n                return True\n\n        dsu = DSU(n)\n        comps = n\n        edges.sort(key=lambda x: -x[2])\n        ans = -1\n        for u, v, w in edges:\n            if comps >= k:\n                ans = w\n            if dsu.union(u, v):\n                comps -= 1\n        return 0 if comps >= k else ans\n",
    "input": "minTime(n=2, edges=[[0,1,3]], k=2)",
    "output": "3",
    "correct_condition": "minTime(n=2, edges=[[0,1,3]], k=2) == 3",
    "contest_id": "weekly-contest-457",
    "contest_date": "2025-07-06T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 31,
      "coverage": null
    },
    "submission_id": 1687862517
  },
  {
    "id": "contest457_q3922_s0",
    "question_id": 3922,
    "function_name": "minMoves",
    "code": "from functools import lru_cache\n\nINF = 10 ** 18\n\n\nclass Solution:\n    def minMoves(self, sx: int, sy: int, tx: int, ty: int) -> int:\n        _sx, _sy = sx, sy\n\n        @lru_cache(None)\n        def solve(x, y):\n            if x == _sx and y == _sy:\n                return 0\n            if x < _sx or y < _sy:\n                return INF\n\n            arr = []\n            if x > y:\n                if x % 2 == 0 and x >= 2 * y:\n                    arr.append((x // 2, y))\n                elif x < 2 * y:\n                    arr.append((x - y, y))\n                # print(f\"x > y: {x} > {y}, arr: {arr}\")\n            elif y > x:\n                if y % 2 == 0 and y >= 2 * x:\n                    arr.append((x, y // 2))\n                elif y < 2 * x:\n                    arr.append((x, y - x))\n                # print(f\"y > x: {y} > {x}, arr: {arr}\")\n            else:\n                if x > 0:\n                    arr.append((0, x))\n                    # arr.append((0, x - 1))\n\n                    arr.append((x, 0))\n                    # arr.append((x + 1, 0))\n\n            ret = INF\n            for x, y in arr:\n                ret = min(ret, solve(x, y) + 1)\n                # print(solve\"solve({x}, {y}) = {solve(x, y)}\")\n                # print(solve\"solve({a}, {b}) -> solve({x}, {y}) + 1 = {solve(x, y) + 1}\")\n            return ret\n\n        ans = solve(tx, ty)\n        # print(f\"s({tx}, {ty}) = {ans}\")\n\n        return ans if ans < INF else -1\n",
    "input": "minMoves(sx=1, sy=2, tx=5, ty=4)",
    "output": "2",
    "correct_condition": "minMoves(sx=1, sy=2, tx=5, ty=4) == 2",
    "contest_id": "weekly-contest-457",
    "contest_date": "2025-07-06T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 48,
      "coverage": null
    },
    "submission_id": 1687865580
  },
  {
    "id": "contest457_q3922_s1",
    "question_id": 3922,
    "function_name": "minMoves",
    "code": "class Solution:\n    def minMoves(self,sx,sy,tx,ty):\n        if sx==tx and sy==ty: return 0\n        if sx>tx or sy>ty: return -1\n        t=0\n        while True:\n            if tx==sx and ty==sy: return t\n            if tx<sx or ty<sy:    return -1\n            if tx>ty:\n                if ty==0 or tx>=2*ty:\n                    if tx%2: return -1\n                    tx//=2\n                    t+=1\n                else:       tx-=ty; t+=1\n            elif ty>tx:\n                if tx==0 or ty>=2*tx:\n                    if ty%2: return -1\n                    ty//=2\n                    t+=1\n                else:       ty-=tx; t+=1\n            else:\n                if tx>sx and tx-ty>=sx:   tx-=ty; t+=1\n                elif ty>sy and ty-tx>=sy: ty-=tx; t+=1\n                else:                     return -1",
    "input": "minMoves(sx=1, sy=2, tx=5, ty=4)",
    "output": "2",
    "correct_condition": "minMoves(sx=1, sy=2, tx=5, ty=4) == 2",
    "contest_id": "weekly-contest-457",
    "contest_date": "2025-07-06T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 24,
      "coverage": null
    },
    "submission_id": 1687863473
  },
  {
    "id": "contest457_q3922_s2",
    "question_id": 3922,
    "function_name": "minMoves",
    "code": "from collections import deque\n\nclass Solution:\n    def minMoves(self, sx: int, sy: int, tx: int, ty: int) -> int:\n        if sx == tx and sy == ty:\n            return 0\n        if sx == 0 and sy == 0:\n            return -1\n        q = deque([(tx, ty, 0)])\n        seen = {(tx, ty)}\n        while q:\n            x, y, d = q.popleft()\n            if x == sx and y == sy:\n                return d\n            if x < sx or y < sy:\n                continue\n            if x == y:\n                for nx, ny in ((x, 0), (0, y)):\n                    if (nx, ny) not in seen:\n                        seen.add((nx, ny))\n                        q.append((nx, ny, d + 1))\n            elif x > y:\n                diff = x - y\n                if diff <= y and (diff, y) not in seen:\n                    seen.add((diff, y))\n                    q.append((diff, y, d + 1))\n                if x % 2 == 0:\n                    half = x // 2\n                    if half >= y and (half, y) not in seen:\n                        seen.add((half, y))\n                        q.append((half, y, d + 1))\n            else:\n                diff = y - x\n                if diff <= x and (x, diff) not in seen:\n                    seen.add((x, diff))\n                    q.append((x, diff, d + 1))\n                if y % 2 == 0:\n                    half = y // 2\n                    if half >= x and (x, half) not in seen:\n                        seen.add((x, half))\n                        q.append((x, half, d + 1))\n        return -1\n",
    "input": "minMoves(sx=1, sy=2, tx=5, ty=4)",
    "output": "2",
    "correct_condition": "minMoves(sx=1, sy=2, tx=5, ty=4) == 2",
    "contest_id": "weekly-contest-457",
    "contest_date": "2025-07-06T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 42,
      "coverage": null
    },
    "submission_id": 1687870593
  },
  {
    "id": "contest458_q3931_s0",
    "question_id": 3931,
    "function_name": "processStr",
    "code": "class Solution:\n    def processStr(self, s: str) -> str:\n        r = \"\"\n        for c in s:\n            if 'a' <= c <= 'z':\n                r += c\n            elif c == '*':\n                r = r[:-1]\n            elif c == '#':\n                r += r\n            else: r = r[::-1]\n        return r",
    "input": "processStr(s=\"a#b%*\")",
    "output": "'ba'",
    "correct_condition": "processStr(s=\"a#b%*\") == 'ba'",
    "contest_id": "weekly-contest-458",
    "contest_date": "2025-07-13T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 12,
      "coverage": null
    },
    "submission_id": 1695807070
  },
  {
    "id": "contest458_q3931_s1",
    "question_id": 3931,
    "function_name": "processStr",
    "code": "class Solution:\n    def processStr(self, s: str) -> str:\n        res = []\n        for ch in s:\n            if 'a' <= ch <= 'z':\n                res.append(ch)\n            elif ch == '*':\n                if res:\n                    res.pop()\n            elif ch == '#':\n                # duplicate the current result\n                res = res + res\n            elif ch == '%':\n                # reverse the current result\n                res.reverse()\n        return ''.join(res)\n",
    "input": "processStr(s=\"a#b%*\")",
    "output": "'ba'",
    "correct_condition": "processStr(s=\"a#b%*\") == 'ba'",
    "contest_id": "weekly-contest-458",
    "contest_date": "2025-07-13T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 16,
      "coverage": null
    },
    "submission_id": 1695797581
  },
  {
    "id": "contest458_q3931_s2",
    "question_id": 3931,
    "function_name": "processStr",
    "code": "class Solution:\n    def processStr(self, s: str) -> str:\n        res = []\n        for c in s:\n            if c == '*':\n                if res: res.pop()\n            elif c == '#':\n                res = res + res\n            elif c == '%':\n                res.reverse()\n            else:\n                res.append(c)\n        return ''.join(res)",
    "input": "processStr(s=\"a#b%*\")",
    "output": "'ba'",
    "correct_condition": "processStr(s=\"a#b%*\") == 'ba'",
    "contest_id": "weekly-contest-458",
    "contest_date": "2025-07-13T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 13,
      "coverage": null
    },
    "submission_id": 1695795684
  },
  {
    "id": "contest458_q3881_s0",
    "question_id": 3881,
    "function_name": "minCost",
    "code": "class Solution:\n    def minCost(self, n: int, ed: List[List[int]], k: int) -> int:\n        ed.sort(key = lambda x: x[2])\n        lo, hi = 0, max((w for *_, w in ed), default = 0)\n        def ok(x):\n            p = list(range(n))\n            def f(i):\n                while p[i] != i:\n                    p[i] = p[p[i]]\n                    i = p[i]\n                return i\n            c = n\n            for u, v, w in ed:\n                if w > x:\n                    break\n                a, b = f(u), f(v)\n                if a != b:\n                    p[b] = a\n                    c -= 1\n            return c<= k\n        ans = hi\n        while lo <= hi:\n            m = (lo + hi) // 2\n            if ok(m):\n                ans = m\n                hi = m - 1\n            else :\n                lo = m + 1\n        return ans\n        \n        ",
    "input": "minCost(n=5, ed=[[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k=2)",
    "output": "4",
    "correct_condition": "minCost(n=5, ed=[[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k=2) == 4",
    "contest_id": "weekly-contest-458",
    "contest_date": "2025-07-13T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 31,
      "coverage": null
    },
    "submission_id": 1695812833
  },
  {
    "id": "contest458_q3881_s1",
    "question_id": 3881,
    "function_name": "minCost",
    "code": "from typing import List\n\nclass Solution:\n    def minCost(self, n: int, edges: List[List[int]], k: int) -> int:\n        if k >= n:\n            return 0\n        parent = list(range(n))\n        def find(x):\n            while parent[x] != x:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return x\n        def union(x, y):\n            rx, ry = find(x), find(y)\n            if rx != ry:\n                parent[ry] = rx\n        weights = sorted({w for _, _, w in edges})\n        ans = weights[-1]\n        lo, hi = 0, len(weights) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            thresh = weights[mid]\n            for i in range(n):\n                parent[i] = i\n            for u, v, w in edges:\n                if w <= thresh:\n                    union(u, v)\n            comps = len({find(i) for i in range(n)})\n            if comps <= k:\n                ans = thresh\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        return ans\n",
    "input": "minCost(n=5, edges=[[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k=2)",
    "output": "4",
    "correct_condition": "minCost(n=5, edges=[[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k=2) == 4",
    "contest_id": "weekly-contest-458",
    "contest_date": "2025-07-13T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 34,
      "coverage": null
    },
    "submission_id": 1695801097
  },
  {
    "id": "contest458_q3881_s2",
    "question_id": 3881,
    "function_name": "minCost",
    "code": "class Solution:\n    def minCost(self, n: int, edges: List[List[int]], k: int) -> int:\n        if k >= n:\n            return 0\n        edges.sort(key = lambda x: x[2])\n        parent = list(range(n))\n        #finder\n        def find(x):\n            while parent[x] != x:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return x\n        comp = n\n        for u, v, w in edges:\n            ru, rv = find(u), find(v)\n            if ru != rv:\n                parent[rv] = ru\n                comp -= 1\n                if comp == k:\n                    return w\n        return 0",
    "input": "minCost(n=5, edges=[[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k=2)",
    "output": "4",
    "correct_condition": "minCost(n=5, edges=[[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k=2) == 4",
    "contest_id": "weekly-contest-458",
    "contest_date": "2025-07-13T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 21,
      "coverage": null
    },
    "submission_id": 1695808971
  },
  {
    "id": "contest458_q3939_s0",
    "question_id": 3939,
    "function_name": "processStr",
    "code": "class Solution:\n    def processStr(self, s: str, k: int) -> str:\n        n = len(s)\n        l = [0] * (n + 1)\n        for i, c in enumerate(s):\n            if c == '*':\n                l[i + 1] = max(l[i] - 1, 0)\n            elif c == '#':\n                l[i + 1] = l[i] * 2\n            elif c == '%':\n                l[i + 1] = l[i]\n            else :\n                l[i + 1] = l[i] + 1\n        if k < 0 or k >= l[n]:\n            return '.'\n\n        x = k\n        for i in range(n, 0, -1):\n            c = s[i - 1]\n            p = l[i - 1]\n            if c == '#':\n                if x >= p:\n                    x -= p\n            elif c == '%':\n                x = p - 1 - x\n            elif c == '*':\n                continue\n            else:\n                if x == p:\n                    return c\n        return '.'",
    "input": "processStr(s=\"a#b%*\", k=1)",
    "output": "'a'",
    "correct_condition": "processStr(s=\"a#b%*\", k=1) == 'a'",
    "contest_id": "weekly-contest-458",
    "contest_date": "2025-07-13T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 31,
      "coverage": null
    },
    "submission_id": 1695796312
  },
  {
    "id": "contest458_q3939_s1",
    "question_id": 3939,
    "function_name": "processStr",
    "code": "class Solution:\n    def processStr(self, s: str, k: int) -> str:\n        ops = []\n        length = 0\n        for ch in s:\n            if 'a' <= ch <= 'z':\n                length += 1\n                ops.append(('lett', ch))\n            elif ch == '*':\n                if length > 0:\n                    length -= 1\n                    ops.append(('rem', True))\n                else:\n                    ops.append(('rem', False))\n            elif ch == '#':\n                length *= 2\n                ops.append(('dup', None))\n            elif ch == '%':\n                ops.append(('rev', None))\n\n        if k < 0 or k >= length:\n            return '.'\n\n        idx = k\n        cur_len = length\n        for op in reversed(ops):\n            typ, val = op\n            if typ == 'lett':\n                if idx == cur_len - 1:\n                    return val\n                cur_len -= 1\n            elif typ == 'rem':\n                if val:\n                    cur_len += 1\n            elif typ == 'dup':\n                prev_len = cur_len // 2\n                if idx >= prev_len:\n                    idx -= prev_len\n                cur_len = prev_len\n            elif typ == 'rev':\n                idx = cur_len - 1 - idx\n\n        return '.'\n",
    "input": "processStr(s=\"a#b%*\", k=1)",
    "output": "'a'",
    "correct_condition": "processStr(s=\"a#b%*\", k=1) == 'a'",
    "contest_id": "weekly-contest-458",
    "contest_date": "2025-07-13T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 43,
      "coverage": null
    },
    "submission_id": 1695809620
  },
  {
    "id": "contest458_q3939_s2",
    "question_id": 3939,
    "function_name": "processStr",
    "code": "class Solution:\n    def processStr(self, s: str, k: int) -> str:\n        n = len(s)\n        Ls = [0] * n\n        cur = 0\n        \n        # forward pass: track length\n        for i, c in enumerate(s):\n            if c == '*':\n                if cur: cur -= 1\n            elif c == '#':\n                cur *= 2\n            elif c == '%':\n                pass\n            else:\n                cur += 1\n            Ls[i] = cur\n        \n        # out of bounds?\n        if k < 0 or k >= Ls[-1]:\n            return '.'\n\n        idx = k\n        # backward pass: undo ops\n        for i in range(n - 1, -1, -1):\n            c = s[i]\n            prev = Ls[i - 1] if i else 0\n\n            if c == '*':\n                continue\n            if c == '#':\n                if prev:\n                    idx %= prev\n            elif c == '%':\n                if prev:\n                    idx = prev - idx - 1\n            else:\n                if idx == prev:\n                    return c\n                # otherwise idx < prev and we keep going\n\n        return '.'\n",
    "input": "processStr(s=\"a#b%*\", k=1)",
    "output": "'a'",
    "correct_condition": "processStr(s=\"a#b%*\", k=1) == 'a'",
    "contest_id": "weekly-contest-458",
    "contest_date": "2025-07-13T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 42,
      "coverage": null
    },
    "submission_id": 1695823832
  },
  {
    "id": "contest458_q3930_s0",
    "question_id": 3930,
    "function_name": "maxLen",
    "code": "class Solution:\n    def maxLen(self, n: int, e: List[List[int]], l: str) -> int:\n        g = [[] for _ in range(n)]\n        for u, v in e:\n            g[u].append(v); g[v].append(u)\n        q = deque(); vis = set(); ans = 1\n        for i in range(n):\n            m = 1 << i; st = (m, i ,i); q.append(st); vis.add(st)\n        for u, v in e:\n            if l[u] == l[v]:\n                m = (1 << u) | (1 << v); st = (m, u, v); q.append(st); vis.add(st);ans = 2\n\n        while q:\n            m, u, v = q.popleft(); c = m.bit_count()\n            if c > ans: ans = c\n            for x in g[u]:\n                if m >> x & 1: continue\n                for y in g[v]:\n                    if x == y or m >> y & 1: continue\n                    if l[x] != l[y]: continue\n                    nm = m | (1 << x) | (1 << y); st2 = (nm, x, y)\n                    if st2 in vis: continue\n                    vis.add(st2); q.append(st2)\n        return ans\n        ",
    "input": "maxLen(n=3, e=[[0,1],[1,2]], l=\"aba\")",
    "output": "3",
    "correct_condition": "maxLen(n=3, e=[[0,1],[1,2]], l=\"aba\") == 3",
    "contest_id": "weekly-contest-458",
    "contest_date": "2025-07-13T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 25,
      "coverage": null
    },
    "submission_id": 1695805176
  },
  {
    "id": "contest458_q3930_s1",
    "question_id": 3930,
    "function_name": "maxLen",
    "code": "from collections import deque\nfrom typing import List\n\nclass Solution:\n    def maxLen(self, n: int, edges: List[List[int]], label: str) -> int:\n        g = [[] for _ in range(n)]\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        lbl = label\n        size = 1 << n\n        vis = [[[False] * n for _ in range(n)] for _ in range(size)]\n        q = deque()\n        ans = 1\n        for i in range(n):\n            m = 1 << i\n            vis[m][i][i] = True\n            q.append((m, i, i, 1))\n        for u in range(n):\n            for v in g[u]:\n                if lbl[u] == lbl[v]:\n                    m = (1 << u) | (1 << v)\n                    if not vis[m][u][v]:\n                        vis[m][u][v] = True\n                        q.append((m, u, v, 2))\n                        ans = 2\n        while q:\n            mask, u, v, length = q.popleft()\n            for nu in g[u]:\n                if mask & (1 << nu):\n                    continue\n                for nv in g[v]:\n                    if nu == nv or (mask & (1 << nv)) or lbl[nu] != lbl[nv]:\n                        continue\n                    new_mask = mask | (1 << nu) | (1 << nv)\n                    if not vis[new_mask][nu][nv]:\n                        vis[new_mask][nu][nv] = True\n                        q.append((new_mask, nu, nv, length + 2))\n                        ans = max(ans, length + 2)\n        return ans\n",
    "input": "maxLen(n=3, edges=[[0,1],[1,2]], label=\"aba\")",
    "output": "3",
    "correct_condition": "maxLen(n=3, edges=[[0,1],[1,2]], label=\"aba\") == 3",
    "contest_id": "weekly-contest-458",
    "contest_date": "2025-07-13T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 40,
      "coverage": null
    },
    "submission_id": 1695822416
  },
  {
    "id": "contest458_q3930_s2",
    "question_id": 3930,
    "function_name": "maxLen",
    "code": "class Solution:\n    def maxLen(self, n: int, edges: List[List[int]], label: str) -> int:\n        adj = [[] for _ in range(n)]\n        for u,v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        # bucket neighbors by character\n        from collections import defaultdict\n        buckets = [defaultdict(list) for _ in range(n)]\n        for u in range(n):\n            for w in adj[u]:\n                buckets[u][label[w]].append(w)\n\n        best = 1\n        full = n\n        popc = int.bit_count\n\n        from functools import lru_cache\n        @lru_cache(None)\n        def dfs(u,v,mask):\n            nonlocal best\n            cnt = popc(mask)\n            if cnt > best: best = cnt\n            if best == full: \n                return True\n            # optimistic bound\n            rem = full - cnt\n            if cnt + (rem//2)*2 <= best:\n                return False\n            for ch in buckets[u].keys() & buckets[v].keys():\n                for nu in buckets[u][ch]:\n                    if mask>>nu & 1: continue\n                    for nv in buckets[v][ch]:\n                        if nu==nv or (mask>>nv & 1): continue\n                        a,b = sorted((nu,nv))\n                        if dfs(a,b, mask | (1<<nu) | (1<<nv)):\n                            return True\n            return False\n\n        # try all centers u<=v\n        for u in range(n):\n            if dfs(u,u, 1<<u): return best\n        for u,v in edges:\n            if label[u]==label[v]:\n                a,b = sorted((u,v))\n                if dfs(a,b, (1<<u)|(1<<v)):\n                    return best\n        return best",
    "input": "maxLen(n=3, edges=[[0,1],[1,2]], label=\"aba\")",
    "output": "3",
    "correct_condition": "maxLen(n=3, edges=[[0,1],[1,2]], label=\"aba\") == 3",
    "contest_id": "weekly-contest-458",
    "contest_date": "2025-07-13T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 48,
      "coverage": null
    },
    "submission_id": 1695835727
  },
  {
    "id": "contest459_q3918_s0",
    "question_id": 3918,
    "function_name": "checkDivisibility",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nimport math\n\nclass Solution:\n    def checkDivisibility(self, n: int) -> bool:\n        ds = list(map(int, str(n)))\n        return n % (sum(ds) + math.prod(ds)) == 0\n\n\n",
    "input": "checkDivisibility(n=99)",
    "output": "True",
    "correct_condition": "checkDivisibility(n=99) == True",
    "contest_id": "weekly-contest-459",
    "contest_date": "2025-07-20T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 208,
      "coverage": null
    },
    "submission_id": 1704194566
  },
  {
    "id": "contest459_q3918_s1",
    "question_id": 3918,
    "function_name": "checkDivisibility",
    "code": "class Solution:\n    def checkDivisibility(self, n: int) -> bool:\n        o, s, p = n, 0, 1\n        while n:\n            d = n % 10\n            s += d\n            p *= d\n            n //= 10\n        return o % (s + p) == 0\n",
    "input": "checkDivisibility(n=99)",
    "output": "True",
    "correct_condition": "checkDivisibility(n=99) == True",
    "contest_id": "weekly-contest-459",
    "contest_date": "2025-07-20T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 9,
      "coverage": null
    },
    "submission_id": 1704179630
  },
  {
    "id": "contest459_q3918_s2",
    "question_id": 3918,
    "function_name": "checkDivisibility",
    "code": "class Solution:\n    def checkDivisibility(self, n: int) -> bool:\n        d = [int(x) for x in str(n)]\n        summ = sum(d)\n        p = 1\n        for x in d:\n            p *= x\n        return n % (summ + p) == 0",
    "input": "checkDivisibility(n=99)",
    "output": "True",
    "correct_condition": "checkDivisibility(n=99) == True",
    "contest_id": "weekly-contest-459",
    "contest_date": "2025-07-20T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 8,
      "coverage": null
    },
    "submission_id": 1704176134
  },
  {
    "id": "contest459_q3886_s0",
    "question_id": 3886,
    "function_name": "countTrapezoids",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nfrom collections import Counter\n\nclass Solution:\n    def countTrapezoids(self, pts: List[List[int]]) -> int:\n        mod = 10**9 + 7\n        cnt = Counter(y for z, y in pts)\n        t = [c * (c - 1) // 2 % mod for c in cnt.values() if c > 1]\n        s = sum(t) % mod\n        s2 = sum(x * x for x in t) % mod\n        return (s * s - s2) * ((mod + 1) // 2) % mod\n\n\n\n",
    "input": "countTrapezoids(pts=[[1,0],[2,0],[3,0],[2,2],[3,2]])",
    "output": "3",
    "correct_condition": "countTrapezoids(pts=[[1,0],[2,0],[3,0],[2,2],[3,2]]) == 3",
    "contest_id": "weekly-contest-459",
    "contest_date": "2025-07-20T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 213,
      "coverage": null
    },
    "submission_id": 1704193761
  },
  {
    "id": "contest459_q3886_s2",
    "question_id": 3886,
    "function_name": "countTrapezoids",
    "code": "class Solution:\n    def countTrapezoids(self, points: List[List[int]]) -> int:\n        MOD = 10 ** 9 + 7\n        counts = Counter(p[1] for p in points)\n        total = prev = 0\n\n        for count in counts.values():\n            if count < 2:\n                continue\n\n            curr = count * (count - 1) // 2\n            total = (total + prev * curr) % MOD\n            prev = (prev + curr) % MOD\n\n        return total",
    "input": "countTrapezoids(points=[[1,0],[2,0],[3,0],[2,2],[3,2]])",
    "output": "3",
    "correct_condition": "countTrapezoids(points=[[1,0],[2,0],[3,0],[2,2],[3,2]]) == 3",
    "contest_id": "weekly-contest-459",
    "contest_date": "2025-07-20T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 15,
      "coverage": null
    },
    "submission_id": 1704188310
  },
  {
    "id": "contest459_q3941_s0",
    "question_id": 3941,
    "function_name": "popcountDepth",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def popcountDepth(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        def d(x):\n            r = 0\n            while x != 1:\n                x = bin(x).count(\"1\")\n                r += 1\n            return r\n\n        n = len(nums)\n        v = [d(x) for x in nums]\n        m = 1\n        while m < n:\n            m <<= 1\n\n        t = [[0] * 6 for i in range(2 * m)]\n\n        for i in range(n):\n            t[m + i][v[i]] += 1\n\n        for i in range(m - 1, 0, -1):\n            for k in range(6):\n                t[i][k] = t[2 * i][k] + t[2 * i + 1][k]\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                l, r, k = q[1] + m, q[2] + m, q[3]\n                s = 0\n                while l <= r:\n                    if l & 1:\n                        s += t[l][k]\n                        l += 1\n                    if not (r & 1):\n                        s += t[r][k]\n                        r -= 1\n                    l >>= 1\n                    r >>= 1\n                ans.append(s)\n            else:\n                i, y = q[1], q[2]\n                l0 = d(y)\n                l1 = v[i]\n                if l0 != l1:\n                    p = m + i\n                    t[p][l1] -= 1\n                    t[p][l0] += 1\n                    p >>= 1\n                    while p:\n                        t[p][l1] -= 1\n                        t[p][l0] += 1\n                        p >>= 1\n                    v[i] = l0\n        return ans\n\n\n\n",
    "input": "popcountDepth(nums=[2,4], queries=[[1,0,1,1],[2,1,1],[1,0,1,0]])",
    "output": "[2, 1]",
    "correct_condition": "popcountDepth(nums=[2,4], queries=[[1,0,1,1],[2,1,1],[1,0,1,0]]) == [2, 1]",
    "contest_id": "weekly-contest-459",
    "contest_date": "2025-07-20T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 257,
      "coverage": null
    },
    "submission_id": 1704192458
  },
  {
    "id": "contest459_q3941_s2",
    "question_id": 3941,
    "function_name": "popcountDepth",
    "code": "class Solution:\n    def popcountDepth(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        limit = 6\n\n        \n        class FenwickTree:\n            def __init__(self, size):\n                self.tree = [0] * (size + 1)\n\n            def add(self, index, delta):\n                index += 1\n                while index < len(self.tree):\n                    self.tree[index] += delta\n                    index += index & -index\n\n            def prefix_sum(self, index):\n                index += 1\n                s = 0\n                while index > 0:\n                    s += self.tree[index]\n                    index -= index & -index\n                return s\n\n            def query(self, start, end):\n                if start > end:\n                    return 0\n                res = self.prefix_sum(end)\n                if start > 0:\n                    res -= self.prefix_sum(start - 1)\n                return res\n\n        fenwick_trees = [FenwickTree(n) for _ in range(limit)]\n            \n        cache = {1: 0}\n        def popcount(x):\n            count = 0\n            while x > 0:\n                x &= (x - 1)\n                count += 1\n            return count\n\n        def get_depth(x):\n            if x in cache:\n                return cache[x]\n            depth = 1 + get_depth(popcount(x))\n            cache[x] = depth\n            return depth\n\n        curr = [0] * n\n        for i, num in enumerate(nums):\n            depth = get_depth(num)\n            curr[i] = depth\n            if depth < limit:\n                fenwick_trees[depth].add(i, 1)\n\n        res = []\n        for q in queries:\n            t = q[0]\n            if t == 1:\n                _, l, r, k = q\n                if 0 <= k < limit:\n                    count = fenwick_trees[k].query(l, r)\n                    res.append(count)\n                else:\n                    res.append(0)\n\n            elif t == 2:\n                _, i, v = q\n                prev = curr[i]\n                if prev < limit:\n                    fenwick_trees[prev].add(i, -1)\n\n                nums[i] = v\n                ndepth = get_depth(v)\n                curr[i] = ndepth\n\n                if ndepth <limit:\n                    fenwick_trees[ndepth].add(i, 1)\n\n\n        return res\n                \n            ",
    "input": "popcountDepth(nums=[2,4], queries=[[1,0,1,1],[2,1,1],[1,0,1,0]])",
    "output": "[2, 1]",
    "correct_condition": "popcountDepth(nums=[2,4], queries=[[1,0,1,1],[2,1,1],[1,0,1,0]]) == [2, 1]",
    "contest_id": "weekly-contest-459",
    "contest_date": "2025-07-20T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 84,
      "coverage": null
    },
    "submission_id": 1704219704
  },
  {
    "id": "contest459_q3897_s0",
    "question_id": 3897,
    "function_name": "countTrapezoids",
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nfrom math import gcd\nfrom collections import defaultdict\n\nclass Solution:\n    def countTrapezoids(self, p: List[List[int]]) -> int:\n        n = len(p)\n        l, m = {}, defaultdict(list)\n        for i in range(n):\n            x1, y1 = p[i]\n            for j in range(i + 1, n):\n                x2, y2 = p[j]\n                dx0, dy0 = x2 - x1, y2 - y1\n                if dx0 == 0:\n                    s, a, b = (1, 0), 1, 0\n                elif dy0 == 0:\n                    s, a, b = (0, 1), 0, 1\n                else:\n                    g = gcd(dx0, dy0)\n                    dx, dy = dx0 // g, dy0 // g\n                    if dx < 0:\n                        dx, dy = -dx, -dy\n                    s, a, b = (dy, dx), dy, dx\n                c = a * x1 - b * y1\n                key = (s, c)\n                l[key] = l.get(key, 0) | (1 << i) | (1 << j)\n                m[(x1 + x2, y1 + y2)].append((i, j, dx0, dy0))\n\n        sm = defaultdict(list)\n        for (s, _), bits in l.items():\n            cnt = bits.bit_count()\n            if cnt > 1:\n                sm[s].append(cnt)\n\n        ans = 0\n        for vals in sm.values():\n            t = sum(k * (k - 1) // 2 for k in vals)\n            u = sum((k * (k - 1) // 2) ** 2 for k in vals)\n            ans += (t * t - u) // 2\n\n        res = 0\n        for lst in m.values():\n            ln = len(lst)\n            for a in range(ln):\n                i1, j1, dx1, dy1 = lst[a]\n                for b in range(a + 1, ln):\n                    i2, j2, dx2, dy2 = lst[b]\n                    if {i1, j1} & {i2, j2}:\n                        continue\n                    if dx1 * dy2 == dy1 * dx2:\n                        continue\n                    res += 1\n\n        return ans - res\n        ",
    "input": "countTrapezoids(p=[[-3,2],[3,0],[2,3],[3,2],[2,-3]])",
    "output": "2",
    "correct_condition": "countTrapezoids(p=[[-3,2],[3,0],[2,3],[3,2],[2,-3]]) == 2",
    "contest_id": "weekly-contest-459",
    "contest_date": "2025-07-20T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 254,
      "coverage": null
    },
    "submission_id": 1704200782
  },
  {
    "id": "contest459_q3897_s2",
    "question_id": 3897,
    "function_name": "countTrapezoids",
    "code": "class DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n    \n    def find(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n        \n    def union(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            self.parent[root_i] = root_j\n\nclass Solution:\n    def countTrapezoids(self, points: List[List[int]]) -> int:\n\n        def get_slope(p1, p2):\n            dx = p2[0] - p1[0]\n            dy = p2[1] - p1[1]\n            if dx == 0: return (1, 0)\n            if dy == 0: return (0, 1)\n            GCD = gcd(dy, dx)\n            dy //= GCD\n            dx //= GCD\n\n            if dx < 0:\n                dx = -dx\n                dy *= -1\n\n            return (dy, dx)\n            \n        n = len(points)\n        slopes = defaultdict(list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                s = get_slope(points[i], points[j])\n                slopes[s].append((i, j))\n\n        total = 0\n        for s in slopes:\n            pairs = slopes[s]\n            if len(pairs) < 2: continue\n            dsu = DSU(n)\n            x = set()\n            for i, j in pairs:\n                dsu.union(i, j)\n                x.add(i)\n                x.add(j)\n\n            comps = defaultdict(int)\n            for i in x:\n                root =dsu.find(i)\n                comps[root] += 1\n\n            if len(comps) < 2:\n                continue\n\n            segs = []\n            for root in comps:\n                size = comps[root]\n                if size >= 2:\n                    segs.append(size * (size - 1) // 2)\n\n            k = sum(segs)\n            summ = sum(x * x for x in segs)\n\n            total += (k ** 2 - summ) // 2\n\n        mm = defaultdict(list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                ms = (points[i][0] + points[j][0], points[i][1] + points[j][1])\n                mm[ms].append((i, j))\n\n        count = 0\n        for ms in mm:\n            pairs = mm[ms]\n            k = len(pairs)\n            if k < 2:\n                continue\n            groups = defaultdict(int)\n            for i, j in pairs:\n                s = get_slope(points[i], points[j])\n                groups[s] += 1\n\n            x = k * (k - 1) // 2\n            d = 0\n            for s in groups:\n                cnt = groups[s]\n                d += cnt * (cnt - 1) // 2\n            count += x - d\n\n        return total - count\n\n\n\n        ",
    "input": "countTrapezoids(points=[[-3,2],[3,0],[2,3],[3,2],[2,-3]])",
    "output": "2",
    "correct_condition": "countTrapezoids(points=[[-3,2],[3,0],[2,3],[3,2],[2,-3]]) == 2",
    "contest_id": "weekly-contest-459",
    "contest_date": "2025-07-20T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 100,
      "coverage": null
    },
    "submission_id": 1704207616
  },
  {
    "id": "contest460_q3766_s0",
    "question_id": 3766,
    "function_name": "maximumMedianSum",
    "code": "class Solution:\n    def maximumMedianSum(self, nums: list[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        cnt, idx = 0, n-2\n        for _ in range(n // 3):\n            cnt += nums[idx]\n            idx -= 2\n        return cnt",
    "input": "maximumMedianSum(nums=[2,1,3,2,1,3])",
    "output": "5",
    "correct_condition": "maximumMedianSum(nums=[2,1,3,2,1,3]) == 5",
    "contest_id": "weekly-contest-460",
    "contest_date": "2025-07-27T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 9,
      "coverage": null
    },
    "submission_id": 1712734488
  },
  {
    "id": "contest460_q3766_s1",
    "question_id": 3766,
    "function_name": "maximumMedianSum",
    "code": "class Solution:\n    def maximumMedianSum(self, nums: List[int]) -> int:\n        from heapq import heapify, heappop, heappush\n        s = sorted(nums)\n        l = len(s)\n        i = l // 3\n        res = 0\n        while i < l:\n            res += s[i]\n            i += 2\n        return res\n",
    "input": "maximumMedianSum(nums=[2,1,3,2,1,3])",
    "output": "5",
    "correct_condition": "maximumMedianSum(nums=[2,1,3,2,1,3]) == 5",
    "contest_id": "weekly-contest-460",
    "contest_date": "2025-07-27T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 11,
      "coverage": null
    },
    "submission_id": 1712777024
  },
  {
    "id": "contest460_q3766_s2",
    "question_id": 3766,
    "function_name": "maximumMedianSum",
    "code": "class Solution:\n    def maximumMedianSum(self, a: List[int]) -> int:\n        a.sort()\n        m = len(a) // 3\n        return sum(a[-2 - 2*i] for i in range(m))",
    "input": "maximumMedianSum(a=[2,1,3,2,1,3])",
    "output": "5",
    "correct_condition": "maximumMedianSum(a=[2,1,3,2,1,3]) == 5",
    "contest_id": "weekly-contest-460",
    "contest_date": "2025-07-27T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 5,
      "coverage": null
    },
    "submission_id": 1712744021
  },
  {
    "id": "contest460_q3948_s0",
    "question_id": 3948,
    "function_name": "numOfSubsequences",
    "code": "class Solution:\n    def numOfSubsequences(self, s: str) -> int:\n        n = len(s)\n        prefixL, prefixLC = [0]*(n + 1), [0]*(n + 1)\n        for i, ch in enumerate(s):\n            prefixL[i + 1] = prefixL[i] + (ch == 'L')\n            prefixLC[i + 1] = prefixLC[i] + (ch == 'C') * prefixL[i]\n        suffixT, suffixCT = [0] * (n + 1), [0] * (n + 1)\n        t, ct = 0, 0\n        for i in range(n - 1, -1, -1):\n            ch = s[i]\n            if ch == 'T':\n                t += 1\n            elif ch == 'C':\n                ct += t\n            suffixT[i] = t\n            suffixCT[i] = ct\n        l, lc = 0, 0\n        cnt = 0\n        for ch in s:\n            if ch == 'L':\n                l += 1\n            elif ch == 'C':\n                lc += l\n            elif ch == 'T':\n                cnt += lc\n        best = 0\n        for p in range(n + 1):\n            incL = suffixCT[p]\n            incC = prefixL[p] * suffixT[p]\n            incT = prefixLC[p]\n            best = max(best, incL)\n            best = max(best, incC)\n            best = max(best, incT)\n        \n        return cnt + best",
    "input": "numOfSubsequences(s=\"LMCT\")",
    "output": "2",
    "correct_condition": "numOfSubsequences(s=\"LMCT\") == 2",
    "contest_id": "weekly-contest-460",
    "contest_date": "2025-07-27T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 36,
      "coverage": null
    },
    "submission_id": 1712744585
  },
  {
    "id": "contest460_q3948_s1",
    "question_id": 3948,
    "function_name": "numOfSubsequences",
    "code": "class Solution:\n    def numOfSubsequences(self, s):\n        ln = len(s)\n        preL, sufT = [0] * (ln + 1), [0] * (ln + 1)\n        total, leftSum, rightSum, maxCombo = 0, 0, 0, 0\n        i, j, ch, temp = 0, 0, '', 0\n\n        while i < ln:\n            ch = s[i]\n            preL[i + 1] = preL[i] + (ch == 'L')\n            i += 1\n\n        j = ln - 1\n        while j >= 0:\n            sufT[j] = sufT[j + 1] + (s[j] == 'T')\n            j -= 1\n\n        for idx in range(ln):\n            ch = s[idx]\n            if ch == 'C':\n                total += preL[idx] * sufT[idx + 1]\n                rightSum += sufT[idx + 1]\n                leftSum += preL[idx]\n\n        i = 0\n        while i <= ln:\n            temp = preL[i] * sufT[i]\n            if temp > maxCombo:\n                maxCombo = temp\n            i += 1\n\n        return total + max(leftSum, rightSum, maxCombo)\n",
    "input": "numOfSubsequences(s=\"LMCT\")",
    "output": "2",
    "correct_condition": "numOfSubsequences(s=\"LMCT\") == 2",
    "contest_id": "weekly-contest-460",
    "contest_date": "2025-07-27T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 32,
      "coverage": null
    },
    "submission_id": 1712779968
  },
  {
    "id": "contest460_q3948_s2",
    "question_id": 3948,
    "function_name": "numOfSubsequences",
    "code": "class Solution:\n    def numOfSubsequences(self, s: str) -> int:\n        n=len(s)\n        pl=[0]*(n+1)\n        for i,ch in enumerate(s):\n            pl[i+1]=pl[i]+(ch=='L')\n        st=[0]*(n+1)\n        for i in range(n-1,-1,-1):\n            st[i]=st[i+1]+(s[i]=='T')\n        oc=bl=bt=0\n        for i,ch in enumerate(s):\n            if ch=='C':\n                oc+=pl[i]*st[i+1]; bl+=st[i+1]; bt+=pl[i]\n        mc=0\n        for i in range(n+1):\n            v=pl[i]*st[i]\n            if v>mc: mc=v\n        return oc+max(0,bl,bt,mc)",
    "input": "numOfSubsequences(s=\"LMCT\")",
    "output": "2",
    "correct_condition": "numOfSubsequences(s=\"LMCT\") == 2",
    "contest_id": "weekly-contest-460",
    "contest_date": "2025-07-27T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 18,
      "coverage": null
    },
    "submission_id": 1712740274
  },
  {
    "id": "contest460_q3933_s0",
    "question_id": 3933,
    "function_name": "minJumps",
    "code": "from collections import defaultdict, deque\n\nclass Solution:\n    def minJumps(self, nums: list[int]) -> int:\n        def factors(x):\n            res = []\n            while x > 1:\n                p = smallestPrimeFact[x]\n                res.append(p)\n                while x % p == 0:\n                    x //= p\n            return list(dict.fromkeys(res))\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        maxi = max(nums)\n        \n        smallestPrimeFact = list(range(maxi + 1))\n        \n        for i in range(2, int(maxi**0.5) + 1):\n            \n            if smallestPrimeFact[i] == i:\n                step = i\n                s = i **2\n                \n                for j in range(s, maxi + 1, step):\n                    \n                    if smallestPrimeFact[j] == j:\n                        smallestPrimeFact[j] = i\n        \n        mapPrime = defaultdict(list)\n        \n        for i, v in enumerate(nums):\n            \n            if v >= 2:\n                for p in factors(v):\n                    mapPrime[p].append(i)\n        \n        visited = [False] * n\n        used = set()\n        queue = deque([0])\n        visited[0] = True\n        cnt = 0\n        \n        while queue:\n            \n            for _ in range(len(queue)):\n                i = queue.popleft()\n                \n                if i == n - 1:\n                    return cnt\n                v = nums[i]\n                \n                if v >= 2 and smallestPrimeFact[v] == v and v not in used:\n                    for j in mapPrime.get(v, []):\n                        if not visited[j]:\n                            visited[j] = True\n                            queue.append(j)\n                    used.add(v)\n                \n                if i + 1 < n and not visited[i + 1]:\n                    visited[i + 1] = True\n                    queue.append(i + 1)\n                \n                if i - 1 >= 0 and not visited[i - 1]:\n                    visited[i - 1] = True\n                    queue.append(i - 1)\n            \n            cnt += 1\n        return -1",
    "input": "minJumps(nums=[1,2,4,6])",
    "output": "2",
    "correct_condition": "minJumps(nums=[1,2,4,6]) == 2",
    "contest_id": "weekly-contest-460",
    "contest_date": "2025-07-27T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 71,
      "coverage": null
    },
    "submission_id": 1712757211
  },
  {
    "id": "contest460_q3933_s1",
    "question_id": 3933,
    "function_name": "minJumps",
    "code": "class Solution:\n    def minJumps(self, nums):\n\n        n = len(nums)\n        mx = max(nums)\n        sieve = [0] * (mx + 1)\n        factors_map = defaultdict(list)\n        q = deque()\n        visited = [0] * n\n        used_prime = set()\n        add_to_q = lambda idx, dist: q.append((idx, dist))\n\n        i, j = 2, 0\n        while i <= mx:\n            if sieve[i] == 0:\n                j = i\n                while j <= mx:\n                    if sieve[j] == 0:\n                        sieve[j] = i\n                    j += i\n            i += 1\n\n        # Map each prime factor to indices\n        for idx, val in enumerate(nums):\n            val_cp = val\n            unique_primes = set()\n            while val_cp > 1:\n                unique_primes.add(sieve[val_cp])\n                val_cp //= sieve[val_cp]\n            for p in unique_primes:\n                factors_map[p].append(idx)\n\n        # BFS time\n        q.append((0, 0))\n        visited[0] = 1\n        while q:\n            curr_idx, dist = q.popleft()\n            if curr_idx == n - 1:\n                return dist\n            for nxt in (curr_idx - 1, curr_idx + 1):\n                if 0 <= nxt < n and not visited[nxt]:\n                    visited[nxt] = 1\n                    add_to_q(nxt, dist + 1)\n            curr_val = nums[curr_idx]\n            if curr_val > 1 and sieve[curr_val] == curr_val and curr_val not in used_prime:\n                for linked_idx in factors_map[curr_val]:\n                    if not visited[linked_idx]:\n                        visited[linked_idx] = 1\n                        add_to_q(linked_idx, dist + 1)\n                used_prime.add(curr_val)\n        return -1\n",
    "input": "minJumps(nums=[1,2,4,6])",
    "output": "2",
    "correct_condition": "minJumps(nums=[1,2,4,6]) == 2",
    "contest_id": "weekly-contest-460",
    "contest_date": "2025-07-27T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 51,
      "coverage": null
    },
    "submission_id": 1712780859
  },
  {
    "id": "contest460_q3933_s2",
    "question_id": 3933,
    "function_name": "minJumps",
    "code": "class Solution:\n    def minJumps(self, a: List[int]) -> int:\n        n=len(a)\n        if n<2: return 0\n        M=max(a)\n        spf=list(range(M+1))\n        for i in range(2,int(M**0.5)+1):\n            if spf[i]==i:\n                for j in range(i*i,M+1,i):\n                    if spf[j]==j: spf[j]=i\n        mp={}\n        for i,v in enumerate(a):\n            x=v; st=set()\n            while x>1:\n                p=spf[x]; st.add(p)\n                while x%p==0: x//=p\n            for p in st: mp.setdefault(p,[]).append(i)\n        \n        ds=[-1]*n; ds[0]=0\n        dq=deque([0])\n        while dq:\n            i=dq.popleft(); d=ds[i]\n            if i==n-1: return d\n            for j in (i-1,i+1):\n                if 0<=j<n and ds[j]<0:\n                    ds[j]=d+1; dq.append(j)\n            v=a[i]\n            if v>1 and spf[v]==v and v in mp:\n                for j in mp[v]:\n                    if ds[j]<0:\n                        ds[j]=d+1; dq.append(j)\n                del mp[v]\n                \n        return -1",
    "input": "minJumps(a=[1,2,4,6])",
    "output": "2",
    "correct_condition": "minJumps(a=[1,2,4,6]) == 2",
    "contest_id": "weekly-contest-460",
    "contest_date": "2025-07-27T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 34,
      "coverage": null
    },
    "submission_id": 1712748830
  },
  {
    "id": "contest460_q3882_s0",
    "question_id": 3882,
    "function_name": "maximizeXorAndXor",
    "code": "class Solution:\n    def maximizeXorAndXor(self, nums: list[int]) -> int:\n        def best(s, m):\n            b = [0] * nbBits\n            while s:\n                t = s & -s\n                i = (t.bit_length() - 1)\n                x = nums[i] & m\n                while x:\n                    k = x.bit_length() - 1\n                    if b[k]:\n                        x ^= b[k]\n                    else:\n                        b[k] = x\n                        break\n                s ^= t\n            res = 0\n            for k in range(nbBits - 1, -1, -1):\n                if b[k] and (res ^ b[k]) > res:\n                    res ^= b[k]\n            return res \n         \n            \n        n = len(nums)\n        XORtot = 0\n        for v in nums:\n            XORtot ^= v\n        nbBits = max(XORtot, max(nums, default=0)).bit_length() or 1\n        bitmask = (1 << nbBits) - 1\n        N = 1 << n\n\n        xr, ad = [0] * N, [0] * N\n        ad[0] = bitmask\n        for m in range(1, N):\n            b = m & -m\n            i = (b.bit_length() - 1)\n            pm = m ^ b\n            xr[m] = xr[pm] ^ nums[i]\n            ad[m] = ad[pm] & nums[i]\n\n        ans = 0\n        for mB in range(N):\n            andB = 0 if mB == 0 else ad[mB]\n            XORAC = XORtot ^ xr[mB]\n            M = bitmask ^ XORAC\n            complB = (N - 1) ^ mB\n            ans = max(ans, andB + XORAC + 2 * best(complB, M)) \n        return ans",
    "input": "maximizeXorAndXor(nums=[2,3])",
    "output": "5",
    "correct_condition": "maximizeXorAndXor(nums=[2,3]) == 5",
    "contest_id": "weekly-contest-460",
    "contest_date": "2025-07-27T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 48,
      "coverage": null
    },
    "submission_id": 1712779651
  },
  {
    "id": "contest460_q3882_s1",
    "question_id": 3882,
    "function_name": "maximizeXorAndXor",
    "code": "class Solution:\n    def maximizeXorAndXor(self, a: List[int]) -> int:\n        from itertools import combinations as cmb\n        n = len(a)\n        full_mask = (1 << 31) - 1\n        max_res = -sys.maxsize\n        i = j = k = p = q = u = v = x = y = z = 0\n        arr = []\n        tmp = []\n        mask = []\n        comb = []\n        used = set()\n        base = []\n\n        def fx(vec):\n            base.clear()\n            z = 0\n            for val in vec:\n                for b in base:\n                    val = min(val, val ^ b)\n                if val: base.append(val)\n            base.sort(reverse=True)\n            for b in base: z = max(z, z ^ b)\n            return z\n\n        for k in range(min(4, n) + 1):\n            for comb in cmb(range(n), k):\n                q = 0 if not comb else a[comb[0]]\n                for i in comb[1:]: q &= a[i]\n                used = set(comb)\n                x = 0\n                tmp.clear()\n                for j in range(n):\n                    if j not in used:\n                        x ^= a[j]\n                        tmp.append(a[j])\n                mask = [(v & ((~x) & full_mask)) for v in tmp]\n                y = fx(mask) if mask else 0\n                max_res = max(max_res, q + x + 2 * y)\n        return max_res\n",
    "input": "maximizeXorAndXor(a=[2,3])",
    "output": "5",
    "correct_condition": "maximizeXorAndXor(a=[2,3]) == 5",
    "contest_id": "weekly-contest-460",
    "contest_date": "2025-07-27T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 40,
      "coverage": null
    },
    "submission_id": 1712781596
  },
  {
    "id": "contest460_q3882_s2",
    "question_id": 3882,
    "function_name": "maximizeXorAndXor",
    "code": "class Solution:\n    def maximizeXorAndXor(self, a: List[int]) -> int:\n        n=len(a)\n        f,sz=(1<<n)-1,1<<n\n        r,o,d,x=0,[0]*sz,[0]*sz,[0]*sz\n        for m in range(1,sz):\n            l=m&-m;i=l.bit_length()-1;p=m^l\n            o[m]=o[p]|a[i]\n            d[m]=a[i] if p==0 else d[p]&a[i]\n            x[m]=x[p]^a[i]\n        for m in range(sz):\n            rm=f^m\n            ub=d[m]+2*o[rm]-x[rm]\n            if ub<=r:continue\n            best_x=0\n            s=rm\n            while True:\n                v=x[s]+x[rm^s]\n                if v>best_x:best_x=v\n                if s==0:break\n                s=(s-1)&rm\n            v=d[m]+best_x\n            if v>r:r=v\n        return r",
    "input": "maximizeXorAndXor(a=[2,3])",
    "output": "5",
    "correct_condition": "maximizeXorAndXor(a=[2,3]) == 5",
    "contest_id": "weekly-contest-460",
    "contest_date": "2025-07-27T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 24,
      "coverage": null
    },
    "submission_id": 1712774072
  },
  {
    "id": "contest461_q3952_s0",
    "question_id": 3952,
    "function_name": "isTrionic",
    "code": "class Solution:\n    def isTrionic(self, a: list[int]) -> bool:\n        n = len(a)\n        if n < 3:\n            return False\n        p = 0\n        f1 = f2 = f3 = False\n        for i in range(1, n):\n            u, v = a[i - 1], a[i]\n            if v == u:\n                return False\n            if p == 0:\n                if v > u:\n                    f1 = True\n                else:\n                    if not f1:\n                        return False\n                    p = 1\n                    f2 = True\n            elif p == 1:\n                if v < u:\n                    f2 = True\n                else:\n                    if not f2:\n                        return False\n                    p = 2\n                    f3 = True\n            else:\n                if v > u:\n                    f3 = True\n                else:\n                    return False\n        return p == 2 and f1 and f2 and f3",
    "input": "isTrionic(a=[1,3,5,4,2,6])",
    "output": "True",
    "correct_condition": "isTrionic(a=[1,3,5,4,2,6]) == True",
    "contest_id": "weekly-contest-461",
    "contest_date": "2025-08-03T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 33,
      "coverage": null
    },
    "submission_id": 1721337202
  },
  {
    "id": "contest461_q3952_s1",
    "question_id": 3952,
    "function_name": "isTrionic",
    "code": "class Solution:\n    def isTrionic(self, nums: List[int]) -> bool:\n        n = len(nums)\n        for p in range(1, n - 1):\n            for q in range(p + 1, n - 1):\n                inc1 = all(nums[i] < nums[i + 1] for i in range(p))\n                dec = all(nums[i] > nums[i + 1] for i in range(p, q))\n                inc2 = all(nums[i] < nums[i + 1] for i in range(q, n - 1))\n                if inc1 and dec and inc2:\n                    return True\n        return False",
    "input": "isTrionic(nums=[1,3,5,4,2,6])",
    "output": "True",
    "correct_condition": "isTrionic(nums=[1,3,5,4,2,6]) == True",
    "contest_id": "weekly-contest-461",
    "contest_date": "2025-08-03T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 11,
      "coverage": null
    },
    "submission_id": 1721313297
  },
  {
    "id": "contest461_q3952_s2",
    "question_id": 3952,
    "function_name": "isTrionic",
    "code": "class Solution:\n    def isTrionic(self, nums: List[int]) -> bool:\n        prev = -1\n        for i in range(1, len(nums)):\n            a = nums[i-1]\n            b = nums[i]\n            if a == b:\n                return False\n            if a > b:\n                if i == 1:\n                    return False\n                if prev != -1 and prev != i-1:\n                    return False\n                prev = i\n        return prev != -1 and prev < len(nums) - 1",
    "input": "isTrionic(nums=[1,3,5,4,2,6])",
    "output": "True",
    "correct_condition": "isTrionic(nums=[1,3,5,4,2,6]) == True",
    "contest_id": "weekly-contest-461",
    "contest_date": "2025-08-03T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 15,
      "coverage": null
    },
    "submission_id": 1721315243
  },
  {
    "id": "contest461_q3954_s0",
    "question_id": 3954,
    "function_name": "maxBalancedShipments",
    "code": "class Solution:\n    def maxBalancedShipments(self, w: List[int]) -> int:\n        n, a, b = len(w), 0, w[0]\n        for i in range(1, n):\n            if w[i] > b: b = w[i]\n            if w[i] < b:\n                a += 1\n                if i + 1 < n: b = w[i + 1]\n        return a",
    "input": "maxBalancedShipments(w=[2,5,1,4,3])",
    "output": "2",
    "correct_condition": "maxBalancedShipments(w=[2,5,1,4,3]) == 2",
    "contest_id": "weekly-contest-461",
    "contest_date": "2025-08-03T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 9,
      "coverage": null
    },
    "submission_id": 1721336841
  },
  {
    "id": "contest461_q3954_s1",
    "question_id": 3954,
    "function_name": "maxBalancedShipments",
    "code": "class Solution:\n    def maxBalancedShipments(self, weight: List[int]) -> int:\n        n = len(weight)\n        count = 0\n        i = 0\n        \n        while i < n - 1:\n            currMax = weight[i]\n            found = False\n            for j in range(i + 1, n):\n                if weight[j] > currMax:\n                    currMax = weight[j]\n                if weight[j] < currMax:\n                    count += 1\n                    i = j + 1\n                    found = True\n                    break\n            if not found:\n                break\n        \n        return count",
    "input": "maxBalancedShipments(weight=[2,5,1,4,3])",
    "output": "2",
    "correct_condition": "maxBalancedShipments(weight=[2,5,1,4,3]) == 2",
    "contest_id": "weekly-contest-461",
    "contest_date": "2025-08-03T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 21,
      "coverage": null
    },
    "submission_id": 1721315412
  },
  {
    "id": "contest461_q3954_s2",
    "question_id": 3954,
    "function_name": "maxBalancedShipments",
    "code": "class Solution:\n    def maxBalancedShipments(self, weight: List[int]) -> int:\n        ans = 0\n        high = 0\n        for x in weight:\n            if x < high:\n                ans += 1\n                high = 0\n            else:\n                high = max(high, x)\n        return ans",
    "input": "maxBalancedShipments(weight=[2,5,1,4,3])",
    "output": "2",
    "correct_condition": "maxBalancedShipments(weight=[2,5,1,4,3]) == 2",
    "contest_id": "weekly-contest-461",
    "contest_date": "2025-08-03T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 11,
      "coverage": null
    },
    "submission_id": 1721317298
  },
  {
    "id": "contest461_q3944_s0",
    "question_id": 3944,
    "function_name": "minTime",
    "code": "class Solution:\n    def minTime(self, s: str, o: List[int], k: int) -> int:\n        n = len(s)\n        l, r, a = 0, n - 1, -1\n        if n * (n + 1) // 2 < k:\n            return -1\n\n        def f(t):\n            b, v, p = sorted(o[:t+1]), 0, -1\n            for i in b:\n                v += (i - p) * (n - i)\n                p = i\n            return v\n\n        while l <= r:\n            m = (l + r) // 2\n            if f(m) >= k:\n                a = m\n                r = m - 1\n            else:\n                l = m + 1\n        return a\n",
    "input": "minTime(s=\"abc\", o=[1,0,2], k=2)",
    "output": "0",
    "correct_condition": "minTime(s=\"abc\", o=[1,0,2], k=2) == 0",
    "contest_id": "weekly-contest-461",
    "contest_date": "2025-08-03T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 22,
      "coverage": null
    },
    "submission_id": 1721336485
  },
  {
    "id": "contest461_q3944_s1",
    "question_id": 3944,
    "function_name": "minTime",
    "code": "class Solution:\n    def minTime(self, s: str, order: List[int], k: int) -> int:\n        n = len(s)\n        totalSub = n * (n + 1) // 2\n        sList = list(s)\n        segments = [(0, n - 1)]\n        freeCount = totalSub\n\n        def findSegment(pos):\n            i = bisect.bisect_right(segments, (pos, float('inf'))) - 1\n            if i >= 0:\n                start, end = segments[i]\n                if start <= pos <= end:\n                    return i, (start, end)\n            return None, None\n\n        for t, pos in enumerate(order):\n            i, seg = findSegment(pos)\n            if seg is None:\n                continue\n            start, end = seg\n            segments.pop(i)\n            segLen = end - start + 1\n            leftLen = pos - start\n            rightLen = end - pos\n            oldSub = segLen * (segLen + 1) // 2\n            newSub = 0\n            if leftLen > 0:\n                newSub += leftLen * (leftLen + 1) // 2\n            if rightLen > 0:\n                newSub += rightLen * (rightLen + 1) // 2\n            freeCount = freeCount - oldSub + newSub\n            if leftLen > 0:\n                bisect.insort(segments, (start, pos - 1))\n            if rightLen > 0:\n                bisect.insort(segments, (pos + 1, end))\n            sList[pos] = '*'\n            valid = totalSub - freeCount\n            if valid >= k:\n                return t\n        return -1",
    "input": "minTime(s=\"abc\", order=[1,0,2], k=2)",
    "output": "0",
    "correct_condition": "minTime(s=\"abc\", order=[1,0,2], k=2) == 0",
    "contest_id": "weekly-contest-461",
    "contest_date": "2025-08-03T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 41,
      "coverage": null
    },
    "submission_id": 1721317504
  },
  {
    "id": "contest461_q3956_s0",
    "question_id": 3956,
    "function_name": "maxSumTrionic",
    "code": "class Solution:\n    def maxSumTrionic(self, a: List[int]) -> int:\n        n = len(a)\n        pre = [0] * (n + 1)\n        inc = [1] * n\n        dec = [1] * n\n        inc2 = [1] * n\n        p = [0] * (n + 2)\n        lg = p[:]\n        m = len(p).bit_length()\n        mn = [[0] * (n + 1) for _ in range(m)]\n        mx = [[0] * (n + 1) for _ in range(m)]\n        inf = sys.maxsize\n        ninf = -inf\n\n        for i in range(n):\n            pre[i + 1] = pre[i] + a[i]\n        for i in range(1, n):\n            if a[i - 1] < a[i]:\n                inc[i] = inc[i - 1] + 1\n            if a[i - 1] > a[i]:\n                dec[i] = dec[i - 1] + 1\n        for i in range(n - 2, -1, -1):\n            if a[i] < a[i + 1]:\n                inc2[i] = inc2[i + 1] + 1\n        for i in range(2, n + 2):\n            p[i] = p[i >> 1] + 1\n        for i in range(n + 1):\n            mn[0][i] = mx[0][i] = pre[i]\n\n        j = 1\n        while (1 << j) <= n + 1:\n            h = 1 << (j - 1)\n            lim = (n + 1) - (1 << j) + 1\n            for i in range(lim):\n                mn[j][i] = min(mn[j - 1][i], mn[j - 1][i + h])\n                mx[j][i] = max(mx[j - 1][i], mx[j - 1][i + h])\n            j += 1\n\n        def qmn(l, r):\n            if l > r: return inf\n            k = p[r - l + 1]\n            return min(mn[k][l], mn[k][r - (1 << k) + 1])\n\n        def qmx(l, r):\n            if l > r: return ninf\n            k = p[r - l + 1]\n            return max(mx[k][l], mx[k][r - (1 << k) + 1])\n\n        res = ninf\n        for i in range(1, n - 1):\n            if dec[i] >= 2 and inc2[i] >= 2:\n                l = i - dec[i] + 1\n                lv = inf\n                for j in range(l, i):\n                    if inc[j] >= 2:\n                        lo = j - inc[j] + 1\n                        hi = j - 1\n                        lv = min(lv, qmn(lo, hi))\n                if lv == inf: continue\n                rv = qmx(i + 2, i + inc2[i])\n                if rv != ninf:\n                    res = max(res, rv - lv)\n        return res\n",
    "input": "maxSumTrionic(a=[0,-2,-1,-3,0,2,-1])",
    "output": "-4",
    "correct_condition": "maxSumTrionic(a=[0,-2,-1,-3,0,2,-1]) == -4",
    "contest_id": "weekly-contest-461",
    "contest_date": "2025-08-03T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 64,
      "coverage": null
    },
    "submission_id": 1721337543
  },
  {
    "id": "contest461_q3956_s1",
    "question_id": 3956,
    "function_name": "maxSumTrionic",
    "code": "class Solution:\n    def maxSumTrionic(self, nums: List[int]) -> int:\n        n = len(nums)\n        negInf = -10**30\n        pre = [0] * n\n        pre[0] = nums[0]\n        for i in range(1, n):\n            pre[i] = pre[i-1] + nums[i]\n        incEnd = [negInf] * n\n        hasInc = [False] * n\n        for i in range(1, n):\n            if nums[i-1] < nums[i]:\n                cur = nums[i-1] + nums[i]\n                if hasInc[i-1]:\n                    ext = incEnd[i-1] + nums[i]\n                    if ext > cur:\n                        cur = ext\n                incEnd[i] = cur\n                hasInc[i] = True\n        incStart = [negInf] * n\n        hasIncStart = [False] * n\n        for i in range(n-2, -1, -1):\n            if nums[i] < nums[i+1]:\n                cur = nums[i] + nums[i+1]\n                if hasIncStart[i+1]:\n                    ext = incStart[i+1] + nums[i]\n                    if ext > cur:\n                        cur = ext\n                incStart[i] = cur\n                hasIncStart[i] = True\n        ans = negInf\n        runStart = 0\n        def process(s, e):\n            nonlocal ans\n            if e - s + 1 < 2:\n                return\n            bestT = negInf\n            for q in range(s+1, e+1):\n                p = q - 1\n                if hasInc[p]:\n                    prevSum = pre[p-1] if p-1 >= 0 else 0\n                    t = incEnd[p] - nums[p] - prevSum\n                    if t > bestT:\n                        bestT = t\n                if hasIncStart[q] and bestT > negInf:\n                    cand = bestT + pre[q] + incStart[q] - nums[q]\n                    if cand > ans:\n                        ans = cand\n        for i in range(1, n+1):\n            if i < n and nums[i-1] > nums[i]:\n                continue\n            process(runStart, i-1)\n            runStart = i\n        return ans",
    "input": "maxSumTrionic(nums=[0,-2,-1,-3,0,2,-1])",
    "output": "-4",
    "correct_condition": "maxSumTrionic(nums=[0,-2,-1,-3,0,2,-1]) == -4",
    "contest_id": "weekly-contest-461",
    "contest_date": "2025-08-03T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 54,
      "coverage": null
    },
    "submission_id": 1721333751
  },
  {
    "id": "contest461_q3956_s2",
    "question_id": 3956,
    "function_name": "maxSumTrionic",
    "code": "class Solution:\n    def maxSumTrionic(self, nums: List[int]) -> int:\n        best1 = best2 = best3 = -inf\n        ans = -inf\n        for i in range(1, len(nums)):\n            a = nums[i-1]\n            b = nums[i]\n            if a == b:\n                best1 = best2 = best3 = -inf\n            elif a < b:\n                best3 = max(best2 + b, best3 + b)\n                best2 = -inf\n                best1 = max(best1, a + b, best1 + b)\n            else:\n                best3 = -inf\n                best2 = max(best2 + b, best1 + b)\n                best1 = -inf\n            # print(nums[:i+1], best1, best2, best3)\n            ans = max(best3, ans)\n        return ans",
    "input": "maxSumTrionic(nums=[0,-2,-1,-3,0,2,-1])",
    "output": "-4",
    "correct_condition": "maxSumTrionic(nums=[0,-2,-1,-3,0,2,-1]) == -4",
    "contest_id": "weekly-contest-461",
    "contest_date": "2025-08-03T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 20,
      "coverage": null
    },
    "submission_id": 1721357504
  },
  {
    "id": "contest462_q3973_s0",
    "question_id": 3973,
    "function_name": "reverseSubmatrix",
    "code": "class Solution:\n    def reverseSubmatrix(self, g: List[List[int]], a: int, b: int, s: int) -> List[List[int]]:\n        r, c, k = a, b, s\n        tmp = [g[r + i][c:c + k] for i in range(k)]\n        for i, v in enumerate(reversed(tmp)):\n            g[r + i][c:c + k] = v\n        return g\n",
    "input": "reverseSubmatrix(g=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], a=1, b=0, s=3)",
    "output": "[[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
    "correct_condition": "reverseSubmatrix(g=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], a=1, b=0, s=3) == [[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
    "contest_id": "weekly-contest-462",
    "contest_date": "2025-08-10T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 7,
      "coverage": null
    },
    "submission_id": 1729547666
  },
  {
    "id": "contest462_q3973_s1",
    "question_id": 3973,
    "function_name": "reverseSubmatrix",
    "code": "class Solution:\n    def reverseSubmatrix(self, grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:\n        for i in range(k//2):\n            for j in range(y,y+k):\n                grid[x+i][j],grid[x+k-1-i][j] = grid[x+k-1-i][j],grid[x+i][j]\n        return grid",
    "input": "reverseSubmatrix(grid=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], x=1, y=0, k=3)",
    "output": "[[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
    "correct_condition": "reverseSubmatrix(grid=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], x=1, y=0, k=3) == [[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
    "contest_id": "weekly-contest-462",
    "contest_date": "2025-08-10T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 6,
      "coverage": null
    },
    "submission_id": 1729527513
  },
  {
    "id": "contest462_q3973_s2",
    "question_id": 3973,
    "function_name": "reverseSubmatrix",
    "code": "class Solution:\n    def reverseSubmatrix(self, grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:\n        for i in range(k // 2):\n            m = x + i\n            n = x + k - 1 - i\n            grid[m][y:y + k], grid[n][y:y + k] = grid[n][y:y + k], grid[m][y:y + k]\n        return grid",
    "input": "reverseSubmatrix(grid=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], x=1, y=0, k=3)",
    "output": "[[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
    "correct_condition": "reverseSubmatrix(grid=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], x=1, y=0, k=3) == [[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
    "contest_id": "weekly-contest-462",
    "contest_date": "2025-08-10T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 7,
      "coverage": null
    },
    "submission_id": 1729527363
  },
  {
    "id": "contest462_q3950_s0",
    "question_id": 3950,
    "function_name": "sortPermutation",
    "code": "class Solution:\n    def sortPermutation(self, a: List[int]) -> int:\n        n = len(a)\n        inf = sys.maxsize\n        neg_inf = -sys.maxsize\n        srt = all(a[i] == i for i in range(n))\n        if srt:\n            return 0\n        k = (1 << (max(a).bit_length())) - 1\n        f = True\n        for i, v in enumerate(a):\n            if v != i:\n                if f:\n                    k = v\n                    f = False\n                else:\n                    k &= v\n        return k\n",
    "input": "sortPermutation(a=[0,3,2,1])",
    "output": "1",
    "correct_condition": "sortPermutation(a=[0,3,2,1]) == 1",
    "contest_id": "weekly-contest-462",
    "contest_date": "2025-08-10T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 18,
      "coverage": null
    },
    "submission_id": 1729548141
  },
  {
    "id": "contest462_q3950_s1",
    "question_id": 3950,
    "function_name": "sortPermutation",
    "code": "class Solution:\n    def sortPermutation(self, nums: List[int]) -> int:\n        return max(0,reduce(and_,(n for i,n in enumerate(nums) if i != n),-1))",
    "input": "sortPermutation(nums=[0,3,2,1])",
    "output": "1",
    "correct_condition": "sortPermutation(nums=[0,3,2,1]) == 1",
    "contest_id": "weekly-contest-462",
    "contest_date": "2025-08-10T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 3,
      "coverage": null
    },
    "submission_id": 1729530821
  },
  {
    "id": "contest462_q3950_s2",
    "question_id": 3950,
    "function_name": "sortPermutation",
    "code": "class Solution:\n    def sortPermutation(self, nums: List[int]) -> int:\n        n = len(nums)\n        if all(i == v for i, v in enumerate(nums)):\n            return 0\n\n        arr = [0] * n\n        for i, j in enumerate(nums):\n            arr[j] = i\n        # print(arr)\n        ans = (1 << (n - 1).bit_length()) - 1\n        # print(ans)\n\n        for j in range(n):\n            if arr[j] != j:\n                ans &= j\n\n        return ans",
    "input": "sortPermutation(nums=[0,3,2,1])",
    "output": "1",
    "correct_condition": "sortPermutation(nums=[0,3,2,1]) == 1",
    "contest_id": "weekly-contest-462",
    "contest_date": "2025-08-10T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 18,
      "coverage": null
    },
    "submission_id": 1729535476
  },
  {
    "id": "contest462_q3959_s0",
    "question_id": 3959,
    "function_name": "maxTotal",
    "code": "class Solution:\n    def maxTotal(self, val: List[int], lim: List[int]) -> int:\n        g, c, t, q = defaultdict(list), 0, 0, deque()\n        for v, l in zip(val, lim):\n            heapq.heappush(g[l], -v)\n        for l in sorted(g):\n            tk, h = 0, g[l]\n            while h and c < l:\n                if q and q[0][0] == c:\n                    c -= q[0][1]\n                    q.popleft()\n                c += 1\n                tk += 1\n                t += -heapq.heappop(h)\n            if c == l:\n                c = 0\n            elif tk > 0:\n                q.append((l, tk))\n        return t\n",
    "input": "maxTotal(val=[3,5,8], lim=[2,1,3])",
    "output": "16",
    "correct_condition": "maxTotal(val=[3,5,8], lim=[2,1,3]) == 16",
    "contest_id": "weekly-contest-462",
    "contest_date": "2025-08-10T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 19,
      "coverage": null
    },
    "submission_id": 1729549267
  },
  {
    "id": "contest462_q3959_s1",
    "question_id": 3959,
    "function_name": "maxTotal",
    "code": "class Solution:\n    def maxTotal(self, value: List[int], limit: List[int]) -> int:\n        d = defaultdict(list)\n        for v,l in zip(value,limit):\n            heappush(d[l],v)\n            if len(d[l]) > l:\n                heappop(d[l])\n        return sum(map(sum,d.values()))",
    "input": "maxTotal(value=[3,5,8], limit=[2,1,3])",
    "output": "16",
    "correct_condition": "maxTotal(value=[3,5,8], limit=[2,1,3]) == 16",
    "contest_id": "weekly-contest-462",
    "contest_date": "2025-08-10T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 8,
      "coverage": null
    },
    "submission_id": 1729555230
  },
  {
    "id": "contest462_q3959_s2",
    "question_id": 3959,
    "function_name": "maxTotal",
    "code": "class Solution:\n    def maxTotal(self, value: List[int], limit: List[int]) -> int:\n        n = len(value)\n\n        b = [[] for _ in range(n + 2)]\n        for v, d in zip(value, limit):\n            heapq.heappush(b[d], -v)\n\n        z = t = r = c = 0\n\n        g = []\n        for d in range(1, n + 1):\n            if b[d]:\n                heapq.heappush(g, (d, b[d][0]))\n\n        _count = [0] * (n + 2)\n\n        ans = 0\n        while True:\n            d = c + 1\n            if z < d <= n and b[d]:\n                v = -heapq.heappop(b[d])\n                ans += v\n                t += 1\n                _count[d] += 1\n                # print(f\" adding value {v} fr limit {d}, total {ans}, t={t}, r={r}, c={c}\")\n                if b[d]:\n                    heapq.heappush(g, (d, b[d][0]))\n            else:\n                while g and (\n                    g[0][0] <= z or not b[g[0][0]] or g[0][1] != b[g[0][0]][0]\n                ):\n                    heapq.heappop(g)\n\n                if not g:\n                    break\n\n                q, p = heapq.heappop(g)\n                v = -heapq.heappop(b[q])\n                # print(f\"pop val {v} for limit {q},  total {ans}, t={t}, r={r}, c={c}\")\n\n                ans += v\n                t += 1\n                _count[q] += 1\n                # print(f\"pop value {v} for limit {q}, total {ans}, t={t},  r={r} , c={c}\")\n                if b[q]:\n                    heapq.heappush(g, (q, b[q][0]))\n\n            x = c + 1\n            if x > z:\n                for _r in range(z + 1, x + 1):\n                    r += _count[_r]\n                z = x\n                # print(f\"z={z}, r={r}, t={t}, c={c}, ans={ans}\")\n            c = t - r\n\n        return ans\n",
    "input": "maxTotal(value=[3,5,8], limit=[2,1,3])",
    "output": "16",
    "correct_condition": "maxTotal(value=[3,5,8], limit=[2,1,3]) == 16",
    "contest_id": "weekly-contest-462",
    "contest_date": "2025-08-10T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 57,
      "coverage": null
    },
    "submission_id": 1729582070
  },
  {
    "id": "contest462_q3951_s0",
    "question_id": 3951,
    "function_name": "specialPalindrome",
    "code": "class Solution:\n    def specialPalindrome(self, n: int) -> int:\n        def gsp(mx=16):\n            sp, dg = set(), list(range(1, 10))\n            for r in range(1, len(dg) + 1):\n                for cb in combinations(dg, r):\n                    tl = sum(cb)\n                    if tl > mx:\n                        continue\n                    hf, ct, ok = [], None, True\n                    for d in cb:\n                        c = d\n                        if c % 2:\n                            if ct is None:\n                                ct = str(d)\n                            else:\n                                ok = False\n                                break\n                        hf += [str(d)] * (c // 2)\n                    if not ok:\n                        continue\n                    for pm in set(permutations(hf)):\n                        h = ''.join(pm)\n                        p = h + ct + h[::-1] if ct else h + h[::-1]\n                        sp.add(int(p))\n            return sorted(sp)\n\n        Solution._c = gsp()\n        i = bisect_right(Solution._c, n)\n        return Solution._c[i] if i < len(Solution._c) else -1\n",
    "input": "specialPalindrome(n=2)",
    "output": "22",
    "correct_condition": "specialPalindrome(n=2) == 22",
    "contest_id": "weekly-contest-462",
    "contest_date": "2025-08-10T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 30,
      "coverage": null
    },
    "submission_id": 1729552431
  },
  {
    "id": "contest462_q3951_s1",
    "question_id": 3951,
    "function_name": "specialPalindrome",
    "code": "lim = 16\np = []\nfor r in range(1,10):\n    for digits in combinations(range(1,10),r):\n        if (odd := sum(d%2 for d in digits)) < 2 and sum(digits) <= lim:\n            if odd:\n                for d in digits:\n                    if d%2:\n                        odd = d\n            for perm in permutations(chain.from_iterable([d]*(d//2) for d in digits)):\n                n = 0\n                for d in perm:\n                    n *= 10\n                    n += d\n                if odd:\n                    n *= 10\n                    n += odd\n                for d in reversed(perm):\n                    n *= 10\n                    n += d\n                p.append(n)\np.sort()\n\nclass Solution:\n    def specialPalindrome(self, n: int) -> int:\n        return p[bisect_right(p,n)]",
    "input": "specialPalindrome(n=2)",
    "output": "22",
    "correct_condition": "specialPalindrome(n=2) == 22",
    "contest_id": "weekly-contest-462",
    "contest_date": "2025-08-10T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 26,
      "coverage": null
    },
    "submission_id": 1729564937
  },
  {
    "id": "contest463_q3980_s0",
    "question_id": 3980,
    "function_name": "maxProfit",
    "code": "class Solution:\n    def maxProfit(self, p: List[int], s: List[int], k: int) -> int:\n        n=len(p); h=k//2\n        pp=[0]*(n+1); pc=[0]*(n+1)\n        t=0\n        for i in range(n):\n            pp[i+1]=pp[i]+p[i]\n            v=s[i]*p[i]\n            pc[i+1]=pc[i]+v\n            t+=v\n        b=-inf; e=n-k; i=0\n        while i<=e:\n            d=(pp[i+k]-pp[i+h])-(pc[i+k]-pc[i])\n            if b<d: b=d\n            i+=1\n        if b>0: t+=b\n        return t",
    "input": "maxProfit(p=[4,2,8], s=[-1,0,1], k=2)",
    "output": "10",
    "correct_condition": "maxProfit(p=[4,2,8], s=[-1,0,1], k=2) == 10",
    "contest_id": "weekly-contest-463",
    "contest_date": "2025-08-17T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 17,
      "coverage": null
    },
    "submission_id": 1737962979
  },
  {
    "id": "contest463_q3980_s1",
    "question_id": 3980,
    "function_name": "maxProfit",
    "code": "class Solution:\n    def maxProfit(self, a: List[int], b: List[int], k: int) -> int:\n        n = len(a)\n        h = k // 2\n        x = sum(i * j for i, j in zip(a, b))\n        y = sum(b[i] * a[i] for i in range(k))\n        z = sum(a[i] for i in range(h, k))\n        m = z - y\n        for i in range(1, n - k + 1):\n            o = i - 1\n            j = i + k - 1\n            y += b[j] * a[j] - b[o] * a[o]\n            z += a[j] - a[o + h]\n            if z - y > m:\n                m = z - y\n        return x if m < 0 else x + m\n",
    "input": "maxProfit(a=[4,2,8], b=[-1,0,1], k=2)",
    "output": "10",
    "correct_condition": "maxProfit(a=[4,2,8], b=[-1,0,1], k=2) == 10",
    "contest_id": "weekly-contest-463",
    "contest_date": "2025-08-17T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 16,
      "coverage": null
    },
    "submission_id": 1737964304
  },
  {
    "id": "contest463_q3980_s2",
    "question_id": 3980,
    "function_name": "maxProfit",
    "code": "class Solution:\n    def maxProfit(self, prices: List[int], strategy: List[int], k: int) -> int:\n        n = len(prices)\n        base = sum(prices[i] * strategy[i] for i in range(n))\n        half = k // 2\n        prefP = [0] * (n + 1)\n        prefSP = [0] * (n + 1)\n        for i in range(n):\n            prefP[i + 1] = prefP[i] + prices[i]\n            prefSP[i + 1] = prefSP[i] + prices[i] * strategy[i]\n        max_delta = 0\n        for l in range(n - k + 1):\n            sumP = prefP[l + k] - prefP[l + half]\n            sumSP = prefSP[l + k] - prefSP[l]\n            delta = sumP - sumSP\n            if delta > max_delta:\n                max_delta = delta\n        return base + max_delta",
    "input": "maxProfit(prices=[4,2,8], strategy=[-1,0,1], k=2)",
    "output": "10",
    "correct_condition": "maxProfit(prices=[4,2,8], strategy=[-1,0,1], k=2) == 10",
    "contest_id": "weekly-contest-463",
    "contest_date": "2025-08-17T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 18,
      "coverage": null
    },
    "submission_id": 1737969042
  },
  {
    "id": "contest463_q3974_s0",
    "question_id": 3974,
    "function_name": "xorAfterQueries",
    "code": "class Solution:\n    def xorAfterQueries(self, a: List[int], q: List[List[int]]) -> int:\n        M=1000000007\n        for l,r,k,v in q:\n            i=l\n            while i<=r:\n                a[i]=(a[i]*v)%M\n                i+=k\n        x=0\n        for y in a:\n            x^=y\n        return x",
    "input": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]])",
    "output": "4",
    "correct_condition": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]]) == 4",
    "contest_id": "weekly-contest-463",
    "contest_date": "2025-08-17T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 12,
      "coverage": null
    },
    "submission_id": 1737954104
  },
  {
    "id": "contest463_q3974_s1",
    "question_id": 3974,
    "function_name": "xorAfterQueries",
    "code": "class Solution:\n    def xorAfterQueries(self, a: List[int], q: List[List[int]]) -> int:\n        m = 10**9 + 7\n        neg_inf = -sys.maxsize\n        pos_inf = sys.maxsize\n        t = (a, q)\n        for l, r, k, v in q:\n            i = l\n            while i <= r:\n                a[i] = (a[i] * v) % m\n                i += k\n        ans = 0\n        for x in a:\n            ans ^= x\n        return ans\n",
    "input": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]])",
    "output": "4",
    "correct_condition": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]]) == 4",
    "contest_id": "weekly-contest-463",
    "contest_date": "2025-08-17T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 15,
      "coverage": null
    },
    "submission_id": 1737964557
  },
  {
    "id": "contest463_q3974_s2",
    "question_id": 3974,
    "function_name": "xorAfterQueries",
    "code": "class Solution:\n    def xorAfterQueries(self, nums: List[int], queries: List[List[int]]) -> int:\n        mod = 10**9 + 7\n        for l, r, k, v in queries:\n            for i in range(l,r + 1, k):\n                nums[i] = (nums[i] * v) % mod\n        ans = 0\n        for x in nums:\n            ans ^= x\n        return ans\n        ",
    "input": "xorAfterQueries(nums=[1,1,1], queries=[[0,2,1,4]])",
    "output": "4",
    "correct_condition": "xorAfterQueries(nums=[1,1,1], queries=[[0,2,1,4]]) == 4",
    "contest_id": "weekly-contest-463",
    "contest_date": "2025-08-17T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 11,
      "coverage": null
    },
    "submission_id": 1737955530
  },
  {
    "id": "contest463_q3966_s0",
    "question_id": 3966,
    "function_name": "minArraySum",
    "code": "class Solution:\n    def minArraySum(self, a: List[int], k: int) -> int:\n        t=0\n        for x in a: t+=x\n        b=[-inf]*k\n        b[0]=0\n        d=0\n        p=0\n        for x in a:\n            p+=x\n            r=p%k\n            v=b[r]+p\n            if d<v: d=v\n            w=d-p\n            if b[r]<w: b[r]=w\n        return t-d",
    "input": "minArraySum(a=[1,1,1], k=2)",
    "output": "1",
    "correct_condition": "minArraySum(a=[1,1,1], k=2) == 1",
    "contest_id": "weekly-contest-463",
    "contest_date": "2025-08-17T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 16,
      "coverage": null
    },
    "submission_id": 1737955459
  },
  {
    "id": "contest463_q3966_s1",
    "question_id": 3966,
    "function_name": "minArraySum",
    "code": "class Solution:\n    def minArraySum(self, a: List[int], k: int) -> int:\n        n = len(a)\n        bm = [-sys.maxsize] * k\n        bm[0] = 0\n        ps = 0\n        dp = 0\n        for x in a:\n            ps += x\n            r = ps % k\n            c = bm[r] + ps\n            dp = max(dp, c)\n            bm[r] = max(bm[r], dp - ps)\n        return ps - dp\n",
    "input": "minArraySum(a=[1,1,1], k=2)",
    "output": "1",
    "correct_condition": "minArraySum(a=[1,1,1], k=2) == 1",
    "contest_id": "weekly-contest-463",
    "contest_date": "2025-08-17T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 14,
      "coverage": null
    },
    "submission_id": 1737964961
  },
  {
    "id": "contest463_q3966_s2",
    "question_id": 3966,
    "function_name": "minArraySum",
    "code": "class Solution:\n    def minArraySum(self, nums: List[int], k: int) -> int:\n        s = 0\n        dp = 0\n        best = {0: 0}\n        total = 0\n        for x in nums:\n            total += x\n            s += x\n            r = s%k\n            dp = max(dp, best.get(r, float(\"-inf\")) + s)\n            v = dp -s\n            if best.get(r, float(\"-inf\")) < v:\n                best[r] = v\n        return total - dp\n        ",
    "input": "minArraySum(nums=[1,1,1], k=2)",
    "output": "1",
    "correct_condition": "minArraySum(nums=[1,1,1], k=2) == 1",
    "contest_id": "weekly-contest-463",
    "contest_date": "2025-08-17T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 16,
      "coverage": null
    },
    "submission_id": 1737958114
  },
  {
    "id": "contest463_q3975_s0",
    "question_id": 3975,
    "function_name": "xorAfterQueries",
    "code": "class Solution:\n    def xorAfterQueries(self, a: List[int], q: List[List[int]]) -> int:\n        M=1000000007\n        n=len(a)\n        b=int(n**0.5)+1\n        d={}; inv={}\n        for l,r,k,v in q:\n            if k>=b:\n                i=l\n                while i<=r:\n                    a[i]=(a[i]*v)%M; i+=k\n            else:\n                c=l%k\n                key=(k,c)\n                if key not in d:d[key]={}\n                tl=(l-c)//k; tr=(r-c)//k\n                e=d[key]; u=inv.get(v)\n                if u is None:\n                    u=pow(v,M-2,M); inv[v]=u\n                e[tl]=(e.get(tl,1)*v)%M\n                x=tr+1\n                e[x]=(e.get(x,1)*u)%M\n        for (k,c),e in d.items():\n            if c>=n: continue\n            L=(n-1-c)//k+1\n            cur=1\n            for t in range(L):\n                cur=(cur*e.get(t,1))%M\n                i=c+t*k\n                a[i]=(a[i]*cur)%M\n        x=0\n        for v in a: x^=v\n        return x",
    "input": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]])",
    "output": "4",
    "correct_condition": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]]) == 4",
    "contest_id": "weekly-contest-463",
    "contest_date": "2025-08-17T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 33,
      "coverage": null
    },
    "submission_id": 1737960542
  },
  {
    "id": "contest463_q3975_s1",
    "question_id": 3975,
    "function_name": "xorAfterQueries",
    "code": "class Solution:\n    def xorAfterQueries(self, a: List[int], q: List[List[int]]) -> int:\n        m = 10**9 + 7\n        n = len(a)\n        g = defaultdict(list)\n        for l, r, k, v in q:\n            g[(k, l % k)].append((l, r, v))\n        b = a[:]\n        inv = {}\n        for (k, r), t in g.items():\n            if r >= n: \n                continue\n            d = [1] * (((n - 1 - r) // k) + 2)\n            for l, rr, v in t:\n                L, R = (l - r) // k, (rr - r) // k\n                d[L] = d[L] * v % m\n                if R + 1 < len(d) - 1:\n                    if v not in inv: \n                        inv[v] = pow(v, m - 2, m)\n                    d[R + 1] = d[R + 1] * inv[v] % m\n            c = 1\n            for i in range(len(d) - 1):\n                c = c * d[i] % m\n                b[r + i * k] = b[r + i * k] * c % m\n        ans = 0\n        for x in b: \n            ans ^= x\n        return ans\n",
    "input": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]])",
    "output": "4",
    "correct_condition": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]]) == 4",
    "contest_id": "weekly-contest-463",
    "contest_date": "2025-08-17T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 28,
      "coverage": null
    },
    "submission_id": 1737964920
  },
  {
    "id": "contest463_q3975_s2",
    "question_id": 3975,
    "function_name": "xorAfterQueries",
    "code": "class Solution:\n    def xorAfterQueries(self, nums: List[int], queries: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        B = math.isqrt(n) + 1\n        events_by_k = {}\n        large = []\n        for l, r, k, v in queries:\n            if k <= B:\n                d = events_by_k.get(k)\n                if d is None:\n                    d = {}\n                    events_by_k[k] = d\n                res = l % k\n                ev = d.get(res)\n                if ev is None:\n                    ev = {}\n                    d[res] = ev\n                s = (l - res) // k\n                e = (r - res) // k\n                ev[s] = ev.get(s, 1) * v % MOD\n                inv = pow(v, MOD - 2, MOD)\n                ev[e + 1] = ev.get(e + 1, 1) * inv % MOD\n            else:\n                large.append((l, r, k, v))\n        for k, d in events_by_k.items():\n            for res, ev in d.items():\n                curr = 1\n                t = 0\n                i = res\n                while i < n:\n                    m = ev.get(t)\n                    if m is not None:\n                        curr = (curr * m) % MOD\n                    if curr != 1:\n                        nums[i] = (nums[i] * curr) % MOD\n                    i += k\n                    t += 1\n        for l, r, k, v in large:\n            i = l\n            while i <= r:\n                nums[i] = (nums[i] * v) % MOD\n                i += k\n        ans = 0\n        for x in nums:\n            ans ^= x\n        return ans",
    "input": "xorAfterQueries(nums=[1,1,1], queries=[[0,2,1,4]])",
    "output": "4",
    "correct_condition": "xorAfterQueries(nums=[1,1,1], queries=[[0,2,1,4]]) == 4",
    "contest_id": "weekly-contest-463",
    "contest_date": "2025-08-17T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 47,
      "coverage": null
    },
    "submission_id": 1737961863
  },
  {
    "id": "contest464_q3995_s0",
    "question_id": 3995,
    "function_name": "gcdOfOddEvenSums",
    "code": "class Solution:\n    def gcdOfOddEvenSums(self, n: int) -> int:\n        return n",
    "input": "gcdOfOddEvenSums(n=4)",
    "output": "4",
    "correct_condition": "gcdOfOddEvenSums(n=4) == 4",
    "contest_id": "weekly-contest-464",
    "contest_date": "2025-08-24T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 3,
      "coverage": null
    },
    "submission_id": 1745988923
  },
  {
    "id": "contest464_q3995_s1",
    "question_id": 3995,
    "function_name": "gcdOfOddEvenSums",
    "code": "class Solution:\n    def gcdOfOddEvenSums(self, n: int) -> int:\n        return n",
    "input": "gcdOfOddEvenSums(n=4)",
    "output": "4",
    "correct_condition": "gcdOfOddEvenSums(n=4) == 4",
    "contest_id": "weekly-contest-464",
    "contest_date": "2025-08-24T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 3,
      "coverage": null
    },
    "submission_id": 1745987230
  },
  {
    "id": "contest464_q3995_s2",
    "question_id": 3995,
    "function_name": "gcdOfOddEvenSums",
    "code": "class Solution:\n    def gcdOfOddEvenSums(self, n: int) -> int:\n        seven = n*(n+1)\n        sodd = 2*n * (2*n +  1) // 2 - seven\n        return gcd(seven, sodd)",
    "input": "gcdOfOddEvenSums(n=4)",
    "output": "4",
    "correct_condition": "gcdOfOddEvenSums(n=4) == 4",
    "contest_id": "weekly-contest-464",
    "contest_date": "2025-08-24T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 5,
      "coverage": null
    },
    "submission_id": 1745987423
  },
  {
    "id": "contest464_q3979_s0",
    "question_id": 3979,
    "function_name": "partitionArray",
    "code": "class Solution:\n    def partitionArray(self, a: List[int], k: int) -> bool:\n        n=len(a)\n        if n%k!=0: return False\n\n        m=n//k\n        d=defaultdict(int)\n        for x in a: d[x]+=1\n\n        mx=0\n        for v in d.values():\n            mx=v if v>mx else mx\n\n        return True if mx<=m else False",
    "input": "partitionArray(a=[1,2,3,4], k=2)",
    "output": "True",
    "correct_condition": "partitionArray(a=[1,2,3,4], k=2) == True",
    "contest_id": "weekly-contest-464",
    "contest_date": "2025-08-24T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 14,
      "coverage": null
    },
    "submission_id": 1745992498
  },
  {
    "id": "contest464_q3979_s1",
    "question_id": 3979,
    "function_name": "partitionArray",
    "code": "from collections import Counter\n\nclass Solution:\n    def partitionArray(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        if n % k != 0:\n            return False\n\n        groups = n // k\n        freq = Counter(nums)\n\n        return all(count <= groups for count in freq.values())",
    "input": "partitionArray(nums=[1,2,3,4], k=2)",
    "output": "True",
    "correct_condition": "partitionArray(nums=[1,2,3,4], k=2) == True",
    "contest_id": "weekly-contest-464",
    "contest_date": "2025-08-24T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 12,
      "coverage": null
    },
    "submission_id": 1745988949
  },
  {
    "id": "contest464_q3979_s2",
    "question_id": 3979,
    "function_name": "partitionArray",
    "code": "fmin = lambda x,y: x if x<y else y\nclass Solution:\n    def partitionArray(self, A: List[int], K: int) -> bool:\n        N = len(A)\n        if N % K != 0: return False\n        G = N // K\n        for v in Counter(A).values():\n            if v > G: return False\n        return True\n        ",
    "input": "partitionArray(A=[1,2,3,4], K=2)",
    "output": "True",
    "correct_condition": "partitionArray(A=[1,2,3,4], K=2) == True",
    "contest_id": "weekly-contest-464",
    "contest_date": "2025-08-24T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 10,
      "coverage": null
    },
    "submission_id": 1746020390
  },
  {
    "id": "contest464_q3981_s0",
    "question_id": 3981,
    "function_name": "maxValue",
    "code": "class Solution:\n    def maxValue(self, a: List[int]) -> List[int]:\n        n=len(a)\n        if n==0: return []\n        if n==1: return [a[0]]\n        p=[0]*n\n        p[0]=a[0]\n        for i in range(1,n):\n            t=p[i-1]\n            p[i]=t if t>=a[i] else a[i]\n        s=[0]*n\n        s[-1]=a[-1]\n        for i in range(n-2,-1,-1):\n            t=s[i+1]\n            s[i]=t if t<=a[i] else a[i]\n        r=[0]*n\n        st=0\n        for i in range(n-1):\n            if p[i]<=s[i+1]:\n                m=p[i]\n                for j in range(st,i+1):\n                    r[j]=m\n                st=i+1\n        m=p[-1]\n        for j in range(st,n):\n            r[j]=m\n        return r",
    "input": "maxValue(a=[2,1,3])",
    "output": "[2, 2, 3]",
    "correct_condition": "maxValue(a=[2,1,3]) == [2, 2, 3]",
    "contest_id": "weekly-contest-464",
    "contest_date": "2025-08-24T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 27,
      "coverage": null
    },
    "submission_id": 1746005677
  },
  {
    "id": "contest464_q3981_s1",
    "question_id": 3981,
    "function_name": "maxValue",
    "code": "class Solution:\n    def maxValue(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        if n == 0:\n            return []\n\n        pref = [0] * n\n        smin = [0] * n\n\n        cur = float(\"-inf\")\n        for i in range(n):\n            cur = max(cur, nums[i])\n            pref[i] = cur\n\n        cur = float(\"inf\")\n        for i in range(n - 1, -1, -1):\n            cur = min(cur, nums[i])\n            smin[i] = cur\n\n        ans = [0] * n\n        start = 0\n        for i in range(n - 1):\n            if pref[i] <= smin[i + 1]:\n                segMax = pref[i]\n                for j in range(start, i + 1):\n                    ans[j] = segMax\n                start = i + 1\n\n        segMax = pref[n - 1]\n        for j in range(start, n):\n            ans[j] = segMax\n\n        return ans",
    "input": "maxValue(nums=[2,1,3])",
    "output": "[2, 2, 3]",
    "correct_condition": "maxValue(nums=[2,1,3]) == [2, 2, 3]",
    "contest_id": "weekly-contest-464",
    "contest_date": "2025-08-24T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 33,
      "coverage": null
    },
    "submission_id": 1746011963
  },
  {
    "id": "contest464_q3981_s2",
    "question_id": 3981,
    "function_name": "maxValue",
    "code": "fmin = lambda x,y: x if x<y else y\nfmax = lambda x,y: x if x>y else y\n\nclass Solution:\n    def maxValue(self, A: List[int]) -> List[int]:\n        N = len(A)\n        S = A[:]\n        m = A[-1]\n        for i in range(N-2,-1,-1):\n            m = fmin(m, A[i])\n            S[i] = m\n\n        anchor = 0\n        ans = [0] * N\n        cur = NINF = float('-inf')\n        for i in range(N - 1):\n            x = A[i]\n            cur = fmax(cur, x)\n            if cur <= S[i+1]:\n                for j in range(anchor, i + 1):\n                    ans[j] = cur\n                anchor = i + 1\n                cur = NINF\n\n        cur = fmax(cur, A[-1])\n        for j in range(anchor, N):\n            ans[j] = cur\n        return ans\n            ",
    "input": "maxValue(A=[2,1,3])",
    "output": "[2, 2, 3]",
    "correct_condition": "maxValue(A=[2,1,3]) == [2, 2, 3]",
    "contest_id": "weekly-contest-464",
    "contest_date": "2025-08-24T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 29,
      "coverage": null
    },
    "submission_id": 1745999661
  },
  {
    "id": "contest464_q3982_s0",
    "question_id": 3982,
    "function_name": "maxWalls",
    "code": "class Solution:\n    def maxWalls(self, r: List[int], d: List[int], w: List[int]) -> int:\n        def c(L,R):\n            if L>R:\n                return 0\n            return bisect_right(w,R)-bisect_left(w,L)\n\n        if not w: return 0\n        z=sorted(zip(r,d))\n        r=[p for p,_ in z]\n        d=[q for _,q in z]\n\n        w=sorted(w)\n        n=len(r)\n        cl,cr=[0]*n,[0]*n\n        Ls,Rs=[(0, -1)]*n,[(0, -1)]*n\n        Ls[0]=(r[0]-d[0], r[0])\n        cl[0]=c(Ls[0][0],Ls[0][1])\n        for i in range(1,n):\n            L=max(r[i]-d[i], r[i-1]+1)\n            U=r[i]\n            Ls[i]=(L,U)\n            cl[i]=c(L,U)\n\n        for i in range(n-1):\n            L=r[i]\n            U=min(r[i]+d[i], r[i+1]-1)\n            Rs[i]=(L,U)\n            cr[i]=c(L,U)\n\n        Rs[n-1]=(r[n-1], r[n-1]+d[n-1])\n        cr[n-1]=c(Rs[n-1][0],Rs[n-1][1])\n        cu=[0]*(n-1)\n        for i in range(n-1):\n            aL,aU=Rs[i]\n            bL,bU=Ls[i+1]\n            if aL>aU and bL>bU: cu[i]=0\n            elif aL>aU: cu[i]=cl[i+1]\n            elif bL>bU: cu[i]=cr[i]\n            else:\n                s=aL if aL>bL else bL\n                t=aU if aU<bU else bU\n                ov=c(s,t) if s<=t else 0\n                cu[i]=cr[i]+cl[i+1]-ov\n\n        dl,dr=cl[0],0\n        for i in range(n-1):\n            nl=dr+cu[i] if dr+cu[i]>dl+cl[i+1] else dl+cl[i+1]\n            nr=dr+cr[i] if dr+cr[i]>dl else dl\n            dl,nr=nl,nr\n            dr=nr\n\n        res=dr+cr[n-1] if dr+cr[n-1]>dl else dl\n        return res",
    "input": "maxWalls(r=[4], d=[3], w=[1,10])",
    "output": "1",
    "correct_condition": "maxWalls(r=[4], d=[3], w=[1,10]) == 1",
    "contest_id": "weekly-contest-464",
    "contest_date": "2025-08-24T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 54,
      "coverage": null
    },
    "submission_id": 1746019664
  },
  {
    "id": "contest464_q3982_s1",
    "question_id": 3982,
    "function_name": "maxWalls",
    "code": "import bisect\n\nclass Solution:\n    def maxWalls(self, robots: List[int], distance: List[int], walls: List[int]) -> int:\n        n = len(robots)\n        if n == 0:\n            return 0\n\n        rd = sorted(zip(robots, distance))\n\n        walls.sort()\n        wallset = set(walls)\n        base = 0\n\n        for p, _ in rd:\n            if p in wallset:\n                base += 1\n                wallset.remove(p)\n\n        rem = sorted(list(wallset))\n\n        def count(a, b):\n            if a > b:\n                return 0\n\n            l = bisect.bisect_left(rem, a)\n            r = bisect.bisect_right(rem, b)\n            return r - l\n\n        L = [0] * n\n        R = [0] * n\n        O = [0] * (n - 1)\n\n        for i in range(n):\n            p, d = rd[i]\n            prev = rd[i - 1][0] if i > 0 else float(\"-inf\")\n            L[i] = count(max(p - d, prev + 1), p - 1)\n            nxt = rd[i + 1][0] if  i < n - 1 else float(\"inf\")\n            R[i] = count(p + 1, min(p + d, nxt - 1))\n\n        for i in range(n - 1):\n            pi, di = rd[i]\n            pj, dj = rd[i + 1]\n            a = pi + 1\n            b = min(pi + di, pj - 1)\n            c = max(pj - dj, pi + 1)\n            d = pj - 1\n            O[i] = count(max(a, c), min(b, d))\n\n        dp = [[0, 0] for _ in range(n)]\n        dp[0][0] = L[0]\n\n        for i in range(1, n):\n            dp[i][0] = max(dp[i - 1][0] + L[i], dp[i - 1][1] + R[i-1] + L[i] - O[i-1])\n            dp[i][1] = max(dp[i - 1][0], dp[i - 1][1] + R[i - 1])\n        return base + max(dp[n - 1][0], dp[n - 1][1] + R[n - 1])",
    "input": "maxWalls(robots=[4], distance=[3], walls=[1,10])",
    "output": "1",
    "correct_condition": "maxWalls(robots=[4], distance=[3], walls=[1,10]) == 1",
    "contest_id": "weekly-contest-464",
    "contest_date": "2025-08-24T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 56,
      "coverage": null
    },
    "submission_id": 1746026591
  },
  {
    "id": "contest464_q3982_s2",
    "question_id": 3982,
    "function_name": "maxWalls",
    "code": "class Solution:\n    def maxWalls(self, robots: List[int], distance: List[int], walls: List[int]) -> int:\n        info = sorted(zip(robots, distance))\n        N = len(info)\n        locs = [x for x,d in info]\n        \n        walls.sort()\n\n        def count(L, R):\n            if L > R: return 0\n            return bisect_right(walls, R) - bisect_left(walls, L)\n\n\n        ans = 0\n        for k in set(locs):\n            ans += count(k, k)\n\n        avail = 0\n        used = count(locs[0] - info[0][1], locs[0] - 1)\n        for i in range(N - 1):\n            l,dl = info[i]\n            r,dr = info[i + 1]\n\n            l1, r1 = l+1, min(l+dl, r-1)\n            l2, r2 = max(r-dr, l+1), r-1\n            c1 = count(l1, r1)\n            c2 = count(l2, r2)\n            c3 = count(max(l1, l2), min(r1, r2))\n            avail, used = max(avail, avail+c1, used), max(avail+c2, avail+c1+c2-c3, used+c2)\n\n        l,dl = info[-1]\n        used = max(used, avail + count(l+1, l+dl))\n        ans += used\n        return ans",
    "input": "maxWalls(robots=[4], distance=[3], walls=[1,10])",
    "output": "1",
    "correct_condition": "maxWalls(robots=[4], distance=[3], walls=[1,10]) == 1",
    "contest_id": "weekly-contest-464",
    "contest_date": "2025-08-24T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 34,
      "coverage": null
    },
    "submission_id": 1746028614
  },
  {
    "id": "contest465_q4008_s0",
    "question_id": 4008,
    "function_name": "recoverOrder",
    "code": "class Solution:\n    def recoverOrder(self, order: List[int], friends: List[int]) -> List[int]:\n        p = {v:i for i,v in enumerate(order)}\n        return sorted(friends, key=lambda x: p[x])",
    "input": "recoverOrder(order=[3,1,2,5,4], friends=[1,3,4])",
    "output": "[3, 1, 4]",
    "correct_condition": "recoverOrder(order=[3,1,2,5,4], friends=[1,3,4]) == [3, 1, 4]",
    "contest_id": "weekly-contest-465",
    "contest_date": "2025-08-31T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 4,
      "coverage": null
    },
    "submission_id": 1754171804
  },
  {
    "id": "contest465_q4008_s1",
    "question_id": 4008,
    "function_name": "recoverOrder",
    "code": "class Solution:\n    def recoverOrder(self, order: List[int], friends: List[int]) -> List[int]:\n        f = set(friends)\n        ans = []\n        for o in order:\n            if o in f:\n               ans.append(o) \n        return ans",
    "input": "recoverOrder(order=[3,1,2,5,4], friends=[1,3,4])",
    "output": "[3, 1, 4]",
    "correct_condition": "recoverOrder(order=[3,1,2,5,4], friends=[1,3,4]) == [3, 1, 4]",
    "contest_id": "weekly-contest-465",
    "contest_date": "2025-08-31T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 8,
      "coverage": null
    },
    "submission_id": 1754170161
  },
  {
    "id": "contest465_q4008_s2",
    "question_id": 4008,
    "function_name": "recoverOrder",
    "code": "class Solution:\n    def recoverOrder(self, a: List[int], b: List[int]) -> List[int]:\n        s = set(b)\n        r = []\n        for x in a:\n            if x in s:\n                r.append(x)\n        return r\n",
    "input": "recoverOrder(a=[3,1,2,5,4], b=[1,3,4])",
    "output": "[3, 1, 4]",
    "correct_condition": "recoverOrder(a=[3,1,2,5,4], b=[1,3,4]) == [3, 1, 4]",
    "contest_id": "weekly-contest-465",
    "contest_date": "2025-08-31T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 8,
      "coverage": null
    },
    "submission_id": 1754196326
  },
  {
    "id": "contest465_q3947_s0",
    "question_id": 3947,
    "function_name": "minDifference",
    "code": "class Solution:\n    def minDifference(self, n: int, k: int) -> List[int]:\n        def f(m, s, t, c):\n            nonlocal b, a\n            if t == 1:\n                if m >= s:\n                    r = c + [m]\n                    d = max(r) - min(r)\n                    if b is None or d < b:\n                        b = d\n                        a = r[:]\n                return\n            u = int(m**0.5)\n            for d in range(s, u + 1):\n                if m % d == 0:\n                    f(m // d, d, t - 1, c + [d])\n\n        b = a = None\n        f(n, 1, k, [])\n        return sorted(a)",
    "input": "minDifference(n=100, k=2)",
    "output": "[10, 10]",
    "correct_condition": "minDifference(n=100, k=2) == [10, 10]",
    "contest_id": "weekly-contest-465",
    "contest_date": "2025-08-31T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 20,
      "coverage": null
    },
    "submission_id": 1754178362
  },
  {
    "id": "contest465_q3947_s1",
    "question_id": 3947,
    "function_name": "minDifference",
    "code": "class Solution(object):\n    def minDifference(self, n, k):\n        def divisors(x):\n            root = int(math.isqrt(x))\n            front, rear = [], []\n            for d1 in range(1, root + 1):\n                if x % d1 == 0:\n                    front.append(d1)\n                    d2 = x // d1\n                    if d1 != d2:\n                        rear.append(d2)\n            return front + rear[::-1]\n\n        \n        best = None\n        limit = None\n\n        def dfs(depth, prev, rem, chosen):\n            nonlocal best, limit\n\n        \n            if limit == 0:\n                return\n\n            if depth == k:\n                if rem == 1:\n                    cmin, cmax = min(chosen), max(chosen)\n                    climit = cmax - cmin\n                    if best is None or climit < limit:\n                        best = chosen.copy()\n                        limit = climit\n                return\n\n            \n            if depth == k - 1:\n                f = rem\n                if f >= prev:\n                    chosen.append(f)\n                    dfs(depth + 1, f, 1, chosen)\n                    chosen.pop()\n                return\n\n            \n            for f in divisors(rem):\n                if f < prev:\n                    continue\n                if rem % f == 0:\n                    chosen.append(f)\n                    dfs(depth + 1, f, rem // f, chosen)\n                    chosen.pop()\n\n        dfs(0, 1, n, [])\n        return best\n",
    "input": "minDifference(n=100, k=2)",
    "output": "[10, 10]",
    "correct_condition": "minDifference(n=100, k=2) == [10, 10]",
    "contest_id": "weekly-contest-465",
    "contest_date": "2025-08-31T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 53,
      "coverage": null
    },
    "submission_id": 1754190607
  },
  {
    "id": "contest465_q3947_s2",
    "question_id": 3947,
    "function_name": "minDifference",
    "code": "class Solution:\n    def minDifference(self, n: int, k: int) -> List[int]:\n        def factors(x: int) -> List[int]:\n            s = set(reduce(list.__add__, ([i, x // i] for i in range(1, int(x ** 0.5) + 1) if x % i == 0)))\n            return sorted(s)\n\n        f = factors(n)\n\n        @cache\n        def dfs(rr: int, rem_k: int, prev: int):\n            if rem_k == 1:\n                if rr >= prev:\n                    return 0, (rr,)\n                return None\n            best = None\n            for d in f:\n                if d < prev or rr % d:\n                    continue\n                nxt = dfs(rr // d, rem_k - 1, d)\n                if not nxt:\n                    continue\n                s, tup = nxt\n                cand = (d,) + tup\n                sc = max(cand) - min(cand)\n                if not best or sc < best[0]:\n                    best = (sc, cand)\n                    if sc == 0:\n                        break\n            return best\n        _, ans = dfs(n, k, 1)\n        return list(ans)\n",
    "input": "minDifference(n=100, k=2)",
    "output": "[10, 10]",
    "correct_condition": "minDifference(n=100, k=2) == [10, 10]",
    "contest_id": "weekly-contest-465",
    "contest_date": "2025-08-31T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 31,
      "coverage": null
    },
    "submission_id": 1754190490
  },
  {
    "id": "contest465_q3915_s0",
    "question_id": 3915,
    "function_name": "maxProduct",
    "code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        def bits(x):\n            r=[]\n            while x:\n                l=x& -x\n                r.append(l.bit_length()-1)\n                x-=l\n            return r\n\n        a=sorted(nums,reverse=True)\n        n=len(a)\n        if n<2: return 0\n\n        S=[0]*31\n        B=[None]*n\n        for i,v in enumerate(a):\n            b=bits(v); B[i]=b\n            for t in b: S[t] |= (1<<i)\n\n        am=(1<<n)-1\n        m=0; tt=a[0]\n        for i,v in enumerate(a):\n            if v*tt<=m: break\n            conf=0\n            for t in B[i]: conf |= S[t]\n            allow=am^conf\n            if allow:\n                j=(allow & -allow).bit_length()-1\n                p=v*a[j]\n                if p>m: m=p\n\n        return m",
    "input": "maxProduct(nums=[1,2,3,4,5,6,7])",
    "output": "12",
    "correct_condition": "maxProduct(nums=[1,2,3,4,5,6,7]) == 12",
    "contest_id": "weekly-contest-465",
    "contest_date": "2025-08-31T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 33,
      "coverage": null
    },
    "submission_id": 1754186379
  },
  {
    "id": "contest465_q3915_s1",
    "question_id": 3915,
    "function_name": "maxProduct",
    "code": "class Solution:\n    def maxProduct(self, a: List[int]) -> int:\n        n = 1 << (len(bin(max(a))) - 2)\n        y, z = [0] * n, [0] * n\n        for x in a:\n            if x > y[x]: y[x], z[x] = x, y[x]\n            elif x > z[x]: z[x] = x\n        h = 1\n        while h < n:\n            d = h << 1\n            for c in range(0, n, d):\n                r = c + h\n                for m in range(r, r + h):\n                    q = m - h\n                    u, v = y[m], z[m]\n                    t = y[q]\n                    if t > u: u, v = t, u\n                    elif t > v: v = t\n                    t = z[q]\n                    if t > u: u, v = t, u\n                    elif t > v: v = t\n                    y[m], z[m] = u, v\n            h <<= 1\n        return max(x * y[(n - 1) ^ x] for x in a)\n",
    "input": "maxProduct(a=[1,2,3,4,5,6,7])",
    "output": "12",
    "correct_condition": "maxProduct(a=[1,2,3,4,5,6,7]) == 12",
    "contest_id": "weekly-contest-465",
    "contest_date": "2025-08-31T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 24,
      "coverage": null
    },
    "submission_id": 1754208972
  },
  {
    "id": "contest465_q3915_s2",
    "question_id": 3915,
    "function_name": "maxProduct",
    "code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        n=len(nums)\n        mx=max(nums)\n        b=0\n        while(1<<b)<=mx:b+=1\n        if b==0:b=1\n        sz=1<<b\n        fm=sz-1\n        v1=[0]*sz;i1=[-1]*sz\n        v2=[0]*sz;i2=[-1]*sz\n        def ins(m:int,v:int,i:int):\n            if i==-1:return\n            if i1[m]==i:\n                if v>v1[m]:v1[m]=v\n                return\n            if v>v1[m]:\n                v2[m],i2[m]=v1[m],i1[m]\n                v1[m],i1[m]=v,i\n            elif i!=i1[m]and v>v2[m]:\n                v2[m],i2[m]=v,i\n        for i,x in enumerate(nums):ins(x,x,i)\n        for bit in range(b):\n            bm=1<<bit\n            for m in range(sz):\n                if m&bm:\n                    o=m^bm\n                    if i1[o]!=-1:ins(m,v1[o],i1[o])\n                    if i2[o]!=-1:ins(m,v2[o],i2[o])\n        ans=0\n        for i,x in enumerate(nums):\n            cm=fm^x;p=0\n            if i1[cm]!=-1 and i1[cm]!=i:p=v1[cm]\n            elif i2[cm]!=-1 and i2[cm]!=i:p=v2[cm]\n            if p>0:ans=max(ans,x*p)\n        return ans",
    "input": "maxProduct(nums=[1,2,3,4,5,6,7])",
    "output": "12",
    "correct_condition": "maxProduct(nums=[1,2,3,4,5,6,7]) == 12",
    "contest_id": "weekly-contest-465",
    "contest_date": "2025-08-31T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 36,
      "coverage": null
    },
    "submission_id": 1754221876
  },
  {
    "id": "contest465_q3989_s0",
    "question_id": 3989,
    "function_name": "totalBeauty",
    "code": "MOD=10**9+7\n\nclass Solution:\n    def totalBeauty(self, nums: List[int]) -> int:\n        def add(i,x):\n            while i<=n:\n                if bit[i]==0: touched.append(i)\n                bit[i]+=x\n                if bit[i]>=MOD: bit[i]-=MOD\n                i+=i&-i\n\n        def sumq(i):\n            s=0\n            while i>0:\n                s+=bit[i]\n                if s>=MOD: s-=MOD\n                i-=i&-i\n            return s\n\n        n=len(nums)\n        mx=max(nums)\n        pos=[[] for _ in range(mx+1)]\n        for i,v in enumerate(nums,1):\n            pos[v].append(i)\n        phi=list(range(mx+1))\n        for p in range(2,mx+1):\n            if phi[p]==p:\n                for k in range(p,mx+1,p):\n                    phi[k]=phi[k]//p*(p-1)\n        bit=[0]*(n+2)\n        touched=[]\n\n        res=0\n        for d in range(1,mx+1):\n            tot=0\n            for m in range(d,mx+1,d):\n                pl=pos[m]\n                if not pl: continue\n                tmp=[]\n                for idx in pl:\n                    s=sumq(idx-1)\n                    v=s+1\n                    if v>=MOD: v-=MOD\n                    tmp.append((idx,v))\n                    tot+=v\n                    if tot>=MOD: tot-=MOD\n                for idx,v in tmp:\n                    add(idx,v)\n            if tot:\n                res=(res+phi[d]*tot)%MOD\n            for p in touched: bit[p]=0\n            touched.clear()\n        return res%MOD",
    "input": "totalBeauty(nums=[1,2,3])",
    "output": "10",
    "correct_condition": "totalBeauty(nums=[1,2,3]) == 10",
    "contest_id": "weekly-contest-465",
    "contest_date": "2025-08-31T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 53,
      "coverage": null
    },
    "submission_id": 1754202539
  },
  {
    "id": "contest465_q3989_s1",
    "question_id": 3989,
    "function_name": "totalBeauty",
    "code": "MOD=10**9+7\nclass Solution:\n    def totalBeauty(self, nums: List[int]) -> int:\n        if not nums:return 0\n        mx=max(nums);seq=[[] for _ in range(mx+1)]\n        for x in nums:\n            r=int(math.isqrt(x))\n            for d in range(1,r+1):\n                if x%d==0:\n                    seq[d].append(x)\n                    od=x//d\n                    if od!=d:seq[od].append(x)\n        f=[0]*(mx+1)\n        for g in range(1,mx+1):\n            if not seq[g]:continue\n            vals=sorted(set(seq[g]));mp={v:i+1 for i,v in enumerate(vals)}\n            bit=[0]*(len(vals)+1);tg=0\n            def add(i,v):\n                while i<len(bit):bit[i]=(bit[i]+v)%MOD;i+=i&-i\n            def sm(i):\n                s=0\n                while i>0:s=(s+bit[i])%MOD;i-=i&-i\n                return s\n            for v in seq[g]:\n                i=mp[v];cur=(sm(i-1)+1)%MOD\n                add(i,cur);tg=(tg+cur)%MOD\n            f[g]=tg\n        h=[0]*(mx+1)\n        for g in range(mx,0,-1):\n            val=f[g]\n            for k in range(2*g,mx+1,g):val=(val-h[k])%MOD\n            h[g]=val\n        ans=0\n        for g in range(1,mx+1):\n            if h[g]:ans=(ans+g*h[g])%MOD\n        return ans",
    "input": "totalBeauty(nums=[1,2,3])",
    "output": "10",
    "correct_condition": "totalBeauty(nums=[1,2,3]) == 10",
    "contest_id": "weekly-contest-465",
    "contest_date": "2025-08-31T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 36,
      "coverage": null
    },
    "submission_id": 1754240103
  },
  {
    "id": "contest465_q3989_s2",
    "question_id": 3989,
    "function_name": "totalBeauty",
    "code": "from array import array\n\nMOD = 10**9 + 7\n\nN = 70000\n\nphi = list(range(N + 1))\nfor i in range(2, N + 1):\n    if phi[i] == i:\n        for j in range(i, N + 1, i):\n            phi[j] -= phi[j] // i\nspf = list(range(N + 1))\np = 2\nwhile p * p <= N:\n    if spf[p] == p:\n        step = p\n        start = p * p\n        for j in range(start, N + 1, step):\n            if spf[j] == j:\n                spf[j] = p\n    p += 1\n\n\n@cache\ndef divisors(x: int):\n    res = [1]\n    t = x\n    while t > 1:\n        p = spf[t]\n        e = 0\n        while t % p == 0:\n            t //= p\n            e += 1\n        cur = []\n        mul = 1\n        for _ in range(e):\n            mul *= p\n            for v in res:\n                cur.append(v * mul)\n        res += cur\n    return res\n\n\nclass BIT:\n    __slots__ = (\"n\", \"t\")\n\n    def __init__(self, n: int):\n        self.n = n\n        self.t = array(\"I\", [0]) * (n + 1)\n\n    def add(self, i: int, delta: int):\n        t = self.t\n        n = self.n\n        while i <= n:\n            v = t[i] + delta\n            if v >= MOD:\n                v -= MOD\n            t[i] = v\n            i += i & -i\n\n    def sum(self, i: int) -> int:\n        s = 0\n        t = self.t\n        while i > 0:\n            s += t[i]\n            if s >= MOD:\n                s -= MOD\n            i -= i & -i\n        return s\n\nclass Solution:\n    def totalBeauty(self, nums: List[int]) -> int:\n        M = max(nums)\n        bits = {}\n        res = 0\n\n        for x in nums:\n            for m in divisors(x):\n                q = x // m\n                b = bits.get(m)\n                if b is None:\n                    b = BIT(M // m)\n                    bits[m] = b\n                cnt = 1 + b.sum(q - 1)\n                if cnt >= MOD:\n                    cnt -= MOD\n                b.add(q, cnt)\n                res = (res + phi[m] * cnt) % MOD\n\n        return res",
    "input": "totalBeauty(nums=[1,2,3])",
    "output": "10",
    "correct_condition": "totalBeauty(nums=[1,2,3]) == 10",
    "contest_id": "weekly-contest-465",
    "contest_date": "2025-08-31T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 90,
      "coverage": null
    },
    "submission_id": 1754216231
  },
  {
    "id": "contest466_q3998_s0",
    "question_id": 3998,
    "function_name": "minOperations",
    "code": "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        return 0 if len(set(nums))==1 else 1",
    "input": "minOperations(nums=[1,2])",
    "output": "1",
    "correct_condition": "minOperations(nums=[1,2]) == 1",
    "contest_id": "weekly-contest-466",
    "contest_date": "2025-09-07T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 3,
      "coverage": null
    },
    "submission_id": 1762056134
  },
  {
    "id": "contest466_q3998_s1",
    "question_id": 3998,
    "function_name": "minOperations",
    "code": "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        if all(x==nums[0] for x in nums):\n            return 0\n        return 1",
    "input": "minOperations(nums=[1,2])",
    "output": "1",
    "correct_condition": "minOperations(nums=[1,2]) == 1",
    "contest_id": "weekly-contest-466",
    "contest_date": "2025-09-07T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 5,
      "coverage": null
    },
    "submission_id": 1762056152
  },
  {
    "id": "contest466_q3998_s2",
    "question_id": 3998,
    "function_name": "minOperations",
    "code": "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        x = nums[0]\n        for v in nums[1:]:\n            if v != x:\n                return 1\n        return 0",
    "input": "minOperations(nums=[1,2])",
    "output": "1",
    "correct_condition": "minOperations(nums=[1,2]) == 1",
    "contest_id": "weekly-contest-466",
    "contest_date": "2025-09-07T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 7,
      "coverage": null
    },
    "submission_id": 1762065504
  },
  {
    "id": "contest466_q3999_s0",
    "question_id": 3999,
    "function_name": "minOperations",
    "code": "class Solution:\n    def minOperations(self, s: str) -> int:\n        m=26\n        for c in s:\n            if c!='a':\n                v=ord(c)-97\n                if v<m: m=v\n        return 0 if m==26 else 26-m",
    "input": "minOperations(s=\"yz\")",
    "output": "2",
    "correct_condition": "minOperations(s=\"yz\") == 2",
    "contest_id": "weekly-contest-466",
    "contest_date": "2025-09-07T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 8,
      "coverage": null
    },
    "submission_id": 1762062000
  },
  {
    "id": "contest466_q3999_s1",
    "question_id": 3999,
    "function_name": "minOperations",
    "code": "class Solution:\n    def minOperations(self, s: str) -> int:\n        t=s\n\n        min_no=26\n\n        for ch in t:\n            if ch!='a':\n                v=ord(ch)-97\n                if v < min_no:\n                    min_no=v\n        return 0 if min_no ==26 else 26-min_no\n        ",
    "input": "minOperations(s=\"yz\")",
    "output": "2",
    "correct_condition": "minOperations(s=\"yz\") == 2",
    "contest_id": "weekly-contest-466",
    "contest_date": "2025-09-07T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 13,
      "coverage": null
    },
    "submission_id": 1762061215
  },
  {
    "id": "contest466_q3999_s2",
    "question_id": 3999,
    "function_name": "minOperations",
    "code": "class Solution:\n    def minOperations(self, s: str) -> int:\n        m = 26\n        for ch in s:\n            if ch != 'a':\n                v = ord(ch) - 97\n                if v < m:\n                    m = v\n        return 0 if m == 26 else 26 - m",
    "input": "minOperations(s=\"yz\")",
    "output": "2",
    "correct_condition": "minOperations(s=\"yz\") == 2",
    "contest_id": "weekly-contest-466",
    "contest_date": "2025-09-07T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 9,
      "coverage": null
    },
    "submission_id": 1762067280
  },
  {
    "id": "contest466_q4000_s0",
    "question_id": 4000,
    "function_name": "bowlSubarrays",
    "code": "class Solution:\n    def bowlSubarrays(self, nums: List[int]) -> int:\n        n,s=len(nums),[]\n        c=0\n        for x in nums:\n            while s and s[-1] < x:\n                s.pop()\n                c+=1\n            if s:  c+=1\n            s.append(x)\n        return c-(n-1)\n",
    "input": "bowlSubarrays(nums=[2,5,3,1,4])",
    "output": "2",
    "correct_condition": "bowlSubarrays(nums=[2,5,3,1,4]) == 2",
    "contest_id": "weekly-contest-466",
    "contest_date": "2025-09-07T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 11,
      "coverage": null
    },
    "submission_id": 1762067679
  },
  {
    "id": "contest466_q4000_s1",
    "question_id": 4000,
    "function_name": "bowlSubarrays",
    "code": "class Solution:\n    def bowlSubarrays(self, nums: List[int]) -> int:\n        par=nums[:]\n\n\n        n=len(par)\n        pi=[-1]*n\n        ni=[-1]*n\n        st=[]\n\n        for i,x in enumerate(par):\n            while st and par[st[-1]]<x:\n                st.pop()\n            pi[i]=st[-1] if st else -1\n            st.append(i)\n\n        st=[]\n\n        for i in range(n-1,-1,-1):\n            x=par[i]\n            while st and par[st[-1]]<x:\n                st.pop()\n            ni[i]=st[-1] if st else n\n            st.append(i)\n\n        ans=0\n        for i in range(n):\n            if pi[i]!=-1 and i-pi[i]>=2:\n                ans+=1\n            if ni[i]!=n and ni[i]-i>=2:\n                ans+=1\n\n        return ans\n        ",
    "input": "bowlSubarrays(nums=[2,5,3,1,4])",
    "output": "2",
    "correct_condition": "bowlSubarrays(nums=[2,5,3,1,4]) == 2",
    "contest_id": "weekly-contest-466",
    "contest_date": "2025-09-07T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 34,
      "coverage": null
    },
    "submission_id": 1762067451
  },
  {
    "id": "contest466_q4000_s2",
    "question_id": 4000,
    "function_name": "bowlSubarrays",
    "code": "class Solution:\n    def bowlSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 3:\n            return 0\n        st = []\n        vis = 0\n        for x in nums:\n            while st and st[-1] < x:\n                st.pop()\n                vis += 1\n            if st:\n                vis += 1\n            st.append(x)\n        return vis - (n - 1)",
    "input": "bowlSubarrays(nums=[2,5,3,1,4])",
    "output": "2",
    "correct_condition": "bowlSubarrays(nums=[2,5,3,1,4]) == 2",
    "contest_id": "weekly-contest-466",
    "contest_date": "2025-09-07T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 15,
      "coverage": null
    },
    "submission_id": 1762074551
  },
  {
    "id": "contest466_q4023_s0",
    "question_id": 4023,
    "function_name": "countBinaryPalindromes",
    "code": "class Solution:\n    def countBinaryPalindromes(self, n: int) -> int:\n        if n==0:return 1\n        s=bin(n)[2:]\n        L,r=len(s),1\n        for l in range(1,L):\n            if l==1: r+=1\n            else:    r+=1<<(((l+1)//2)-1)\n\n        h=(L+1)//2\n        p,lo=int(s[:h],2),1<<(h-1)\n        if p>lo:\n            r+=p-lo\n\n        t=s[:h]+(s[:h][:-1][::-1] if L&1 else s[:h][::-1])\n        if t<=s:\n            r+=1\n        return r",
    "input": "countBinaryPalindromes(n=9)",
    "output": "6",
    "correct_condition": "countBinaryPalindromes(n=9) == 6",
    "contest_id": "weekly-contest-466",
    "contest_date": "2025-09-07T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 18,
      "coverage": null
    },
    "submission_id": 1762075360
  },
  {
    "id": "contest466_q4023_s1",
    "question_id": 4023,
    "function_name": "countBinaryPalindromes",
    "code": "class Solution:\n    def countBinaryPalindromes(self, n: int) -> int:\n        if n==0:\n            return 1\n\n        d=n\n\n        def rbits(x,k):\n            y=0\n            for _ in range(k):\n                y=(y<<1)|(x&1)\n                x>>=1\n            return y\n\n        def makepal(p,l,m):\n            if l%2==0:\n                return (p<<m) | rbits(p,m)\n            else:\n                return (p<<(m-1)) | rbits(p>>1,m-1)\n\n        l=d.bit_length()\n\n        total=1\n        for i in range(1,l):\n            m=(i+1)//2\n            total+=1<<(m-1)\n\n        m=(l+1)//2\n        p_low=1<<(m-1)\n        p0=d>>(l-m)\n        pal_p0=makepal(p0,l,m)\n        if pal_p0<=d:\n            total+=(p0-p_low+1)\n        else:\n            total+=(p0-p_low)\n\n        return total\n        ",
    "input": "countBinaryPalindromes(n=9)",
    "output": "6",
    "correct_condition": "countBinaryPalindromes(n=9) == 6",
    "contest_id": "weekly-contest-466",
    "contest_date": "2025-09-07T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 38,
      "coverage": null
    },
    "submission_id": 1762076544
  },
  {
    "id": "contest466_q4023_s2",
    "question_id": 4023,
    "function_name": "countBinaryPalindromes",
    "code": "class Solution:\n    def countBinaryPalindromes(self, n: int) -> int:\n        if n == 0:\n            return 1\n\n        s = bin(n)[2:]\n        L = len(s)\n    \n        # helpers\n        def rev(x, k):\n            y = 0\n            for _ in range(k):\n                y = (y << 1) | (x & 1)\n                x >>= 1\n            return y\n\n        def make_pal(L, p):\n            k = L // 2\n            if L % 2 == 0:\n                return (p << k) | rev(p, k)\n            else:\n                return (p << k) | rev(p >> 1, k)\n        \n        # count lengths < L\n        ans = 1\n        for l in range(1, L):\n            ans += 1 << ((l - 1) // 2)\n\n        # handle length L\n        p_len = (L + 1) // 2\n        p = int(s[:p_len], 2)\n        base = 1 << (p_len - 1)\n        if p > base:\n            ans += p - base\n        if make_pal(L, p) <= n:\n            ans += 1\n\n        return ans",
    "input": "countBinaryPalindromes(n=9)",
    "output": "6",
    "correct_condition": "countBinaryPalindromes(n=9) == 6",
    "contest_id": "weekly-contest-466",
    "contest_date": "2025-09-07T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 38,
      "coverage": null
    },
    "submission_id": 1762086648
  },
  {
    "id": "contest467_q4012_s0",
    "question_id": 4012,
    "function_name": "earliestTime",
    "code": "class Solution:\n    def earliestTime(self, tasks: List[List[int]]) -> int:\n        res = inf\n        for s, t in tasks:\n            res = min(res, s + t)\n        return res",
    "input": "earliestTime(tasks=[[1,6],[2,3]])",
    "output": "5",
    "correct_condition": "earliestTime(tasks=[[1,6],[2,3]]) == 5",
    "contest_id": "weekly-contest-467",
    "contest_date": "2025-09-14T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 6,
      "coverage": null
    },
    "submission_id": 1769944892
  },
  {
    "id": "contest467_q4012_s1",
    "question_id": 4012,
    "function_name": "earliestTime",
    "code": "class Solution:\n  def earliestTime(self, tasks: List[List[int]]) -> int:\n    return min(t[0] + t[1] for t in tasks)",
    "input": "earliestTime(tasks=[[1,6],[2,3]])",
    "output": "5",
    "correct_condition": "earliestTime(tasks=[[1,6],[2,3]]) == 5",
    "contest_id": "weekly-contest-467",
    "contest_date": "2025-09-14T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 3,
      "coverage": null
    },
    "submission_id": 1769946189
  },
  {
    "id": "contest467_q4012_s2",
    "question_id": 4012,
    "function_name": "earliestTime",
    "code": "class Solution:\n    def earliestTime(self, tasks: List[List[int]]) -> int:\n        return min([x+y for x,y in tasks])",
    "input": "earliestTime(tasks=[[1,6],[2,3]])",
    "output": "5",
    "correct_condition": "earliestTime(tasks=[[1,6],[2,3]]) == 5",
    "contest_id": "weekly-contest-467",
    "contest_date": "2025-09-14T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 3,
      "coverage": null
    },
    "submission_id": 1769945503
  },
  {
    "id": "contest467_q3997_s0",
    "question_id": 3997,
    "function_name": "maxKDistinct",
    "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        res = []\n        nums.sort(reverse=True)\n        seen = set()\n        taken = 0\n        for i, v in enumerate(nums):\n            if taken == k:\n                break\n            if v in seen:\n                continue\n            seen.add(v)\n            res.append(v)\n            taken += 1\n\n        return res\n            ",
    "input": "maxKDistinct(nums=[84,93,100,77,90], k=3)",
    "output": "[100, 93, 90]",
    "correct_condition": "maxKDistinct(nums=[84,93,100,77,90], k=3) == [100, 93, 90]",
    "contest_id": "weekly-contest-467",
    "contest_date": "2025-09-14T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 17,
      "coverage": null
    },
    "submission_id": 1769946197
  },
  {
    "id": "contest467_q3997_s1",
    "question_id": 3997,
    "function_name": "maxKDistinct",
    "code": "class Solution:\n  def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n    nums = list(set(nums))\n    nums.sort(key=lambda i: -i)\n    return nums[0: k]",
    "input": "maxKDistinct(nums=[84,93,100,77,90], k=3)",
    "output": "[100, 93, 90]",
    "correct_condition": "maxKDistinct(nums=[84,93,100,77,90], k=3) == [100, 93, 90]",
    "contest_id": "weekly-contest-467",
    "contest_date": "2025-09-14T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 5,
      "coverage": null
    },
    "submission_id": 1769954176
  },
  {
    "id": "contest467_q3997_s2",
    "question_id": 3997,
    "function_name": "maxKDistinct",
    "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        res = []\n        nums.sort()\n        while len(res) < k and nums:\n            x = nums.pop()\n            if not res or x != res[-1]:\n                res.append(x)\n        return sorted(res,reverse=True)",
    "input": "maxKDistinct(nums=[84,93,100,77,90], k=3)",
    "output": "[100, 93, 90]",
    "correct_condition": "maxKDistinct(nums=[84,93,100,77,90], k=3) == [100, 93, 90]",
    "contest_id": "weekly-contest-467",
    "contest_date": "2025-09-14T00:00:00.000",
    "difficulty": "easy",
    "metrics": {
      "loc": 9,
      "coverage": null
    },
    "submission_id": 1769949793
  },
  {
    "id": "contest467_q3873_s0",
    "question_id": 3873,
    "function_name": "subsequenceSumAfterCapping",
    "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        c = Counter(nums)\n        n = len(nums)\n        pf = [0] * (n+1)\n        pf[0] = 1\n        fullMask = (1 << (k+1)) - 1\n        # print(f'{fullMask=}')\n\n        for v in range(1, n + 1):\n            dp = pf[v-1]\n            count = c[v]\n\n            pp = 1\n            while count > 0:\n                take = min(pp, count)\n                dp = (dp | (dp << (v*take)) & fullMask) & fullMask\n                count -= take\n                pp <<= 1\n\n            pf[v] = dp\n\n        suff = [0] * (n + 2)\n        for v in range(n, 0, -1):\n            suff[v] = suff[v+1] + c[v]\n\n        res = [False]*n\n\n        for x in range(1, n + 1):\n            dp = pf[x-1]\n            nxt = suff[x]\n            big = min(nxt, k // x)\n            noFail = False\n            for j in range(big + 1):\n                tmp = k - (j * x)\n                if (dp >> tmp) & 1:\n                    noFail = True\n                    break\n            res[x-1] = noFail\n\n        return res",
    "input": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5)",
    "output": "[False, False, True, True]",
    "correct_condition": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5) == [False, False, True, True]",
    "contest_id": "weekly-contest-467",
    "contest_date": "2025-09-14T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 41,
      "coverage": null
    },
    "submission_id": 1769967201
  },
  {
    "id": "contest467_q3873_s1",
    "question_id": 3873,
    "function_name": "subsequenceSumAfterCapping",
    "code": "class Solution:\n  def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n    n = len(nums)\n    freq = [0] * (n + 1)\n    for a in nums:\n        if 1 <= a <= n:\n            freq[a] += 1\n\n    ans = [False] * n\n    dp = 1\n    mask = (1 << (k + 1)) - 1\n\n    cnt_le = 0\n    for x in range(1, n + 1):\n        for _ in range(freq[x]):\n            dp = (dp | (dp << x)) & mask\n        cnt_le += freq[x]\n\n        m_x = n - cnt_le\n\n        possible = False\n        max_j = min(m_x, k // x)\n        for j in range(max_j + 1):\n            s = k - j * x\n            if (dp >> s) & 1:  # sum s is achievable using values  x\n                possible = True\n                break\n        ans[x - 1] = possible\n\n    return ans",
    "input": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5)",
    "output": "[False, False, True, True]",
    "correct_condition": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5) == [False, False, True, True]",
    "contest_id": "weekly-contest-467",
    "contest_date": "2025-09-14T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 30,
      "coverage": null
    },
    "submission_id": 1769967950
  },
  {
    "id": "contest467_q3873_s2",
    "question_id": 3873,
    "function_name": "subsequenceSumAfterCapping",
    "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        K = k\n        nums.sort()\n        N = len(nums)\n        dp = [0]*(k+1)\n        j = 0\n        dp[0] = 1\n\n        Z = 1\n        res = []\n        for i in range(1,N+1):\n            while j < len(nums) and nums[j] < i:\n                Z |= (Z << nums[j])\n                j += 1\n            remaining_count = len(nums)-j\n            max_cap = i\n            ans = False\n            for g in range(K,-1,-i):\n                diff = k-g\n                if remaining_count*max_cap >= diff:\n                    if ((1<<g)&Z) > 0:\n                        ans = True\n                        break\n                else:\n                    break\n            res.append(ans)\n        return res\n            \n                    \n            \n\n        ",
    "input": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5)",
    "output": "[False, False, True, True]",
    "correct_condition": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5) == [False, False, True, True]",
    "contest_id": "weekly-contest-467",
    "contest_date": "2025-09-14T00:00:00.000",
    "difficulty": "medium",
    "metrics": {
      "loc": 33,
      "coverage": null
    },
    "submission_id": 1769965337
  },
  {
    "id": "contest467_q4027_s0",
    "question_id": 4027,
    "function_name": "countStableSubsequences",
    "code": "class Solution:\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        res = 0\n\n        @cache\n        def dp(i, pp, p):\n            if i == len(nums):\n                return 1\n            ifSkip = dp(i + 1, pp, p)\n            v = nums[i]\n            if v % 2 == pp == p:\n                return ifSkip\n            ifTake = dp(i + 1, p, v % 2)\n            return (ifSkip + ifTake) % MOD\n\n        res = dp(0, -1, -1)\n        dp.cache_clear()\n        return res - 1",
    "input": "countStableSubsequences(nums=[1,3,5])",
    "output": "6",
    "correct_condition": "countStableSubsequences(nums=[1,3,5]) == 6",
    "contest_id": "weekly-contest-467",
    "contest_date": "2025-09-14T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 19,
      "coverage": null
    },
    "submission_id": 1769952969
  },
  {
    "id": "contest467_q4027_s1",
    "question_id": 4027,
    "function_name": "countStableSubsequences",
    "code": "class Solution:\n  def countStableSubsequences(self, nums: List[int]) -> int:\n    MOD = 1_000_000_007\n    E1 = E2 = O1 = O2 = 0\n\n    for a in nums:\n        if a % 2 == 0:\n            newE1 = (E1 + O1 + O2 + 1) % MOD\n            newE2 = (E2 + E1) % MOD\n            E1, E2 = newE1, newE2\n        else:\n            newO1 = (O1 + E1 + E2 + 1) % MOD\n            newO2 = (O2 + O1) % MOD\n            O1, O2 = newO1, newO2\n    return (E1 + E2 + O1 + O2) % MOD",
    "input": "countStableSubsequences(nums=[1,3,5])",
    "output": "6",
    "correct_condition": "countStableSubsequences(nums=[1,3,5]) == 6",
    "contest_id": "weekly-contest-467",
    "contest_date": "2025-09-14T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 15,
      "coverage": null
    },
    "submission_id": 1769973511
  },
  {
    "id": "contest467_q4027_s2",
    "question_id": 4027,
    "function_name": "countStableSubsequences",
    "code": "class Solution:\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        modulo = 10**9 + 7\n\n        nums = [x%2 for x in nums]\n\n        @lru_cache(None)\n        def recur_fn(i,prev,count):\n            if i == len(nums):\n                return 0\n            else:\n                res = 0\n                if nums[i] == prev and count == 1:\n                    res += 1 + recur_fn(i+1,prev,count+1)\n                    if res >= modulo:\n                        res %= modulo\n                if nums[i] != prev:\n                    res += 1+ recur_fn(i+1,nums[i],1)\n                    if res >= modulo:\n                        res %= modulo\n                res += recur_fn(i+1,prev,count)\n                if res >= modulo:\n                    res %= modulo\n                return res \n\n        ans = 0\n        for i in range(len(nums)):\n            ans += 1 + recur_fn(i+1,nums[i],1)\n            #print('ans',ans)\n            if ans >= modulo:\n                ans %= modulo\n            \n        recur_fn.cache_clear()\n        return ans%modulo",
    "input": "countStableSubsequences(nums=[1,3,5])",
    "output": "6",
    "correct_condition": "countStableSubsequences(nums=[1,3,5]) == 6",
    "contest_id": "weekly-contest-467",
    "contest_date": "2025-09-14T00:00:00.000",
    "difficulty": "hard",
    "metrics": {
      "loc": 34,
      "coverage": null
    },
    "submission_id": 1769974365
  }
]