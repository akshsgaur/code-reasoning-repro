{
  "id": "contest431_q3702_s0",
  "question_id": 3702,
  "function_name": "maxLength",
  "code": "def maxLength(nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for l in range(n):\n            a = 1\n            b = 1\n            c = 0\n            for r in range(l, n):\n                a *= nums[r]\n                b = lcm(b, nums[r])\n                c = gcd(c, nums[r])\n                if a == b * c:\n                    ans = max(ans, r - l + 1)\n        return ans\n                \n        ",
  "input": "maxLength(nums=[1,2,1,2,1,1,1])",
  "output": "5",
  "correct_condition": "maxLength(nums=[1,2,1,2,1,1,1]) == 5",
  "contest_id": "weekly-contest-431",
  "contest_date": "2025-01-05T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 16,
    "coverage": null
  },
  "submission_id": 1497983046,
  "mutated_code": "def maxLength(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for l in range(n):\n        a = 1\n        b = 1\n        c = 0\n        for r in range(l, n):\n            a *= nums[r]\n            b = lcm(b, nums[r])\n            c = gcd(c, nums[r])\n            if a == b * c:\n                ans = max(ans, r - l - 1)\n    return ans",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest431_q3702_s1",
  "question_id": 3702,
  "function_name": "maxLength",
  "code": "def maxLength(nums: List[int]) -> int:\n        ans = 1\n        run = 1\n        for l in range(len(nums)):\n            for r in range(l, len(nums)):\n                a = nums[l:r+1]\n                prod = 1\n                g = nums[l]\n                lc = nums[l]\n                for v in a:\n                    g = gcd(g, v)\n                    lc = lcm(lc, v)\n                    prod *= v\n                if g * lc == prod:\n                    ans = max(ans, r - l + 1)\n        return ans",
  "input": "maxLength(nums=[1,2,1,2,1,1,1])",
  "output": "5",
  "correct_condition": "maxLength(nums=[1,2,1,2,1,1,1]) == 5",
  "contest_id": "weekly-contest-431",
  "contest_date": "2025-01-05T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 16,
    "coverage": null
  },
  "submission_id": 1497983616,
  "mutated_code": "def maxLength(nums: List[int]) -> int:\n    ans = 1\n    run = 1\n    for l in range(len(nums)):\n        for r in range(l, len(nums)):\n            a = nums[l:r + 1]\n            prod = 1\n            g = nums[l]\n            lc = nums[l]\n            for v in a:\n                g = gcd(g, v)\n                lc = lcm(lc, v)\n                prod *= v\n            if g // lc == prod:\n                ans = max(ans, r - l + 1)\n    return ans",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest431_q3634_s0",
  "question_id": 3634,
  "function_name": "calculateScore",
  "code": "def calculateScore(s: str) -> int:\n        g = [[] for _ in range(26)]\n        ans = 0\n        for i, x in enumerate(s):\n            x = ord(x) - 97\n            if g[25 - x]:\n                ans += i - g[25 - x].pop()\n            else:\n                g[x].append(i)\n        return ans\n        ",
  "input": "calculateScore(s=\"aczzx\")",
  "output": "5",
  "correct_condition": "calculateScore(s=\"aczzx\") == 5",
  "contest_id": "weekly-contest-431",
  "contest_date": "2025-01-05T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 11,
    "coverage": null
  },
  "submission_id": 1497985461,
  "mutated_code": "def calculateScore(s: str) -> int:\n    g = [[] for _ in range(26)]\n    ans = 0\n    for i, x in enumerate(s):\n        x = ord(x) - 97\n        if g[25 - x]:\n            ans += i + g[25 - x].pop()\n        else:\n            g[x].append(i)\n    return ans",
  "mutated_output": "7",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest431_q3634_s1",
  "question_id": 3634,
  "function_name": "calculateScore",
  "code": "def calculateScore(s: str) -> int:\n        def mir(c):\n            return chr(ord('a') + (25 - (ord(c) - ord('a'))))\n        seen = defaultdict(list)\n        ans = 0\n        for i in range(len(s)):\n            c1 = mir(s[i])\n            if seen[c1]:\n                ans += i - seen[c1][-1]\n                seen[c1].pop()\n            else: seen[s[i]].append(i)\n        return ans",
  "input": "calculateScore(s=\"aczzx\")",
  "output": "5",
  "correct_condition": "calculateScore(s=\"aczzx\") == 5",
  "contest_id": "weekly-contest-431",
  "contest_date": "2025-01-05T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 12,
    "coverage": null
  },
  "submission_id": 1497985549,
  "mutated_code": "def calculateScore(s: str) -> int:\n\n    def mir(c):\n        return chr(ord('a') - (25 - (ord(c) - ord('a'))))\n    seen = defaultdict(list)\n    ans = 0\n    for i in range(len(s)):\n        c1 = mir(s[i])\n        if seen[c1]:\n            ans += i - seen[c1][-1]\n            seen[c1].pop()\n        else:\n            seen[s[i]].append(i)\n    return ans",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest431_q3715_s0",
  "question_id": 3715,
  "function_name": "maximumCoins",
  "code": "def maximumCoins(coins: List[List[int]], k: int) -> int:\n        coins.sort()\n        n = len(coins)\n        def f(p):\n            ret = tot = 0\n            j = 0\n            for i in range(n):\n                while j < n and p[j][1] - p[i][0] + 1 <= k:\n                    tot += (p[j][1] - p[j][0] + 1) * p[j][2]\n                    j += 1\n                cur = tot\n                if j < n and p[j][0] - p[i][0] + 1 <= k:\n                    cur += (p[i][0] + k - p[j][0]) * p[j][2]\n                if cur > ret:\n                    ret = cur\n                if i == j:\n                    j += 1\n                else:\n                    tot -= (p[i][1] - p[i][0] + 1) * p[i][2]\n            return ret\n        ans = f(coins)\n        coins.reverse()\n        m = 10 ** 9 + 1\n        for it in coins:\n            it[0], it[1] = m - it[1], m - it[0]\n        ans = max(ans, f(coins))\n        return ans\n                    \n                ",
  "input": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4)",
  "output": "10",
  "correct_condition": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4) == 10",
  "contest_id": "weekly-contest-431",
  "contest_date": "2025-01-05T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 29,
    "coverage": null
  },
  "submission_id": 1498002559,
  "mutated_code": "def maximumCoins(coins: List[List[int]], k: int) -> int:\n    coins.sort()\n    n = len(coins)\n\n    def f(p):\n        ret = tot = 0\n        j = 0\n        for i in range(n):\n            while j < n and p[j][1] - p[i][0] - 1 <= k:\n                tot += (p[j][1] - p[j][0] + 1) * p[j][2]\n                j += 1\n            cur = tot\n            if j < n and p[j][0] - p[i][0] + 1 <= k:\n                cur += (p[i][0] + k - p[j][0]) * p[j][2]\n            if cur > ret:\n                ret = cur\n            if i == j:\n                j += 1\n            else:\n                tot -= (p[i][1] - p[i][0] + 1) * p[i][2]\n        return ret\n    ans = f(coins)\n    coins.reverse()\n    m = 10 ** 9 + 1\n    for it in coins:\n        it[0], it[1] = (m - it[1], m - it[0])\n    ans = max(ans, f(coins))\n    return ans",
  "mutated_output": "14",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest431_q3715_s1",
  "question_id": 3715,
  "function_name": "maximumCoins",
  "code": "def maximumCoins(coins: List[List[int]], k: int) -> int:\n        coins.sort()\n        ans = 0\n        for _ in range(2):\n            cnt = 0\n            r = 0\n            # print(coins)\n            for l in range(len(coins)):\n                while r+1 < len(coins) and coins[r][1]-coins[l][0]+1 <= k:\n                    cnt += (coins[r][1]-coins[r][0]+1 ) * coins[r][2]\n                    r += 1\n                add = min(coins[r][1]+1, coins[l][0] + k) - coins[r][0]\n                add = max(add, 0)\n                add *= coins[r][2]\n                # add = (k - ((0 if r == 0 else coins[r-1][1])-coins[l][0]+1)) * coins[r][2]\n                ans = max(ans, cnt + add)\n                # print(l, r, add / coins[r][2], cnt + add)\n                cnt -= (coins[l][1]-coins[l][0]+1 ) * coins[l][2]\n            for i in range(len(coins)):\n                coins[i][0] *= -1\n                coins[i][1] *= -1\n                coins[i][0], coins[i][1] = coins[i][1], coins[i][0]\n            coins.sort()\n        return ans",
  "input": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4)",
  "output": "10",
  "correct_condition": "maximumCoins(coins=[[8,10,1],[1,3,2],[5,6,4]], k=4) == 10",
  "contest_id": "weekly-contest-431",
  "contest_date": "2025-01-05T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 24,
    "coverage": null
  },
  "submission_id": 1498001804,
  "mutated_code": "def maximumCoins(coins: List[List[int]], k: int) -> int:\n    coins.sort()\n    ans = 0\n    for _ in range(2):\n        cnt = 0\n        r = 0\n        for l in range(len(coins)):\n            while r + 1 < len(coins) and coins[r][1] - coins[l][0] - 1 <= k:\n                cnt += (coins[r][1] - coins[r][0] + 1) * coins[r][2]\n                r += 1\n            add = min(coins[r][1] + 1, coins[l][0] + k) - coins[r][0]\n            add = max(add, 0)\n            add *= coins[r][2]\n            ans = max(ans, cnt + add)\n            cnt -= (coins[l][1] - coins[l][0] + 1) * coins[l][2]\n        for i in range(len(coins)):\n            coins[i][0] *= -1\n            coins[i][1] *= -1\n            coins[i][0], coins[i][1] = (coins[i][1], coins[i][0])\n        coins.sort()\n    return ans",
  "mutated_output": "14",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest431_q3562_s0",
  "question_id": 3562,
  "function_name": "maximumWeight",
  "code": "def maximumWeight(p: List[List[int]]) -> List[int]:\n        a = []\n        for i, it in enumerate(p):\n            it.append(i)\n            a += [it[0], it[1]]\n        mp = {x: i + 1 for i, x in enumerate(sorted(set(a)))}\n        p.sort(key=lambda it:it[1])\n        for it in p:\n            it[0] = mp[it[0]]\n            it[1] = mp[it[1]]\n        f = [[[0, []] for _ in range(5)]]\n        pr = 0\n        for it in p:\n            l, r, w, i = it\n            while pr < r:\n                f.append(f[pr][:])\n                pr += 1\n            for k in range(4):\n                v, b = f[l - 1][k]\n                b = b[::] + [i]\n                b.sort()\n                v -= w\n                f[r][k + 1] = min(f[r][k + 1], [v, b])\n        return f[-1][4][1]",
  "input": "maximumWeight(p=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]])",
  "output": "[2, 3]",
  "correct_condition": "maximumWeight(p=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]) == [2, 3]",
  "contest_id": "weekly-contest-431",
  "contest_date": "2025-01-05T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 24,
    "coverage": null
  },
  "submission_id": 1498025769,
  "mutated_code": "def maximumWeight(p: List[List[int]]) -> List[int]:\n    a = []\n    for i, it in enumerate(p):\n        it.append(i)\n        a += [it[0], it[1]]\n    mp = {x: i + 1 for i, x in enumerate(sorted(set(a)))}\n    p.sort(key=lambda it: it[1])\n    for it in p:\n        it[0] = mp[it[0]]\n        it[1] = mp[it[1]]\n    f = [[[0, []] for _ in range(5)]]\n    pr = 0\n    for it in p:\n        l, r, w, i = it\n        while pr < r:\n            f.append(f[pr][:])\n            pr += 1\n        for k in range(4):\n            v, b = f[l + 1][k]\n            b = b[:] + [i]\n            b.sort()\n            v -= w\n            f[r][k + 1] = min(f[r][k + 1], [v, b])\n    return f[-1][4][1]",
  "mutated_output": "[0, 0, 2, 3]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest431_q3562_s1",
  "question_id": 3562,
  "function_name": "maximumWeight",
  "code": "def maximumWeight(intervals: List[List[int]]) -> List[int]:\n        locations = set()\n        for l, r, w in intervals:\n            locations.add(l)\n            locations.add(r+1)\n        locations = sorted(list(locations))\n        to_idx = dict()\n        for i, x in enumerate(locations):\n            to_idx[x] = i\n        nxt = [[] for i in range(len(locations))]\n        for i, (l, r, w) in enumerate(intervals):\n            nxt[to_idx[l]].append((to_idx[r+1], w, i))\n        @cache\n        def dp(idx, left):\n            res = (10 ** 12, [])\n            if idx >= len(locations) or left == 0: return res\n            \n            res = min(res, dp(idx + 1, left))\n            for r, w, i in nxt[idx]:\n                (a, ls) = dp(r, left-1)\n                a -= w\n                ls1 = ls.copy()\n                ls1.append(i)\n                ls1.sort()\n                res = min(res, (a, ls1))\n            return res\n        w, ls = dp(0, 4)\n        return ls\n            ",
  "input": "maximumWeight(intervals=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]])",
  "output": "[2, 3]",
  "correct_condition": "maximumWeight(intervals=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]) == [2, 3]",
  "contest_id": "weekly-contest-431",
  "contest_date": "2025-01-05T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 29,
    "coverage": null
  },
  "submission_id": 1498015639,
  "mutated_code": "def maximumWeight(intervals: List[List[int]]) -> List[int]:\n    locations = set()\n    for l, r, w in intervals:\n        locations.add(l)\n        locations.add(r + 1)\n    locations = sorted(list(locations))\n    to_idx = dict()\n    for i, x in enumerate(locations):\n        to_idx[x] = i\n    nxt = [[] for i in range(len(locations))]\n    for i, (l, r, w) in enumerate(intervals):\n        nxt[to_idx[l]].append((to_idx[r + 1], w, i))\n\n    @cache\n    def dp(idx, left):\n        res = (10 ** 12, [])\n        if idx >= len(locations) or left != 0:\n            return res\n        res = min(res, dp(idx + 1, left))\n        for r, w, i in nxt[idx]:\n            a, ls = dp(r, left - 1)\n            a -= w\n            ls1 = ls.copy()\n            ls1.append(i)\n            ls1.sort()\n            res = min(res, (a, ls1))\n        return res\n    w, ls = dp(0, 4)\n    return ls",
  "mutated_output": "[]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest432_q3708_s0",
  "question_id": 3708,
  "function_name": "zigzagTraversal",
  "code": "def zigzagTraversal(grid: List[List[int]]) -> List[int]:\n        R, C = len(grid), len(grid[0])\n        ans = []\n        i, j = 0, 0\n\n        def connected(i, j, ii, jj):\n            return (i == ii and abs(j - jj) == 1) or (j == jj and abs(i - ii) == 1)\n\n        dir = 1\n        while 0 <= i < R and 0 <= j < C:\n            ans.append(grid[i][j])\n            ii = i\n            jj = j + 2 * dir\n            if 0 <= jj < C:\n                i, j = ii, jj\n            else:\n                ii = i + 1\n                jj = 0 if jj < 0 else C - 1\n                dir = -dir\n                if 0 <= ii < R and 0 <= jj < C:\n                    if connected(i, j, ii, jj):\n                        jj += dir\n                    i, j = ii, jj\n                else:\n                    break\n\n        return ans\n\n",
  "input": "zigzagTraversal(grid=[[1,2],[3,4]])",
  "output": "[1, 4]",
  "correct_condition": "zigzagTraversal(grid=[[1,2],[3,4]]) == [1, 4]",
  "contest_id": "weekly-contest-432",
  "contest_date": "2025-01-12T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 28,
    "coverage": null
  },
  "submission_id": 1505653842,
  "mutated_code": "def zigzagTraversal(grid: List[List[int]]) -> List[int]:\n    R, C = (len(grid), len(grid[0]))\n    ans = []\n    i, j = (0, 0)\n\n    def connected(i, j, ii, jj):\n        return i == ii and abs(j - jj) == 1 or (j == jj and abs(i - ii) == 1)\n    dir = 1\n    while 0 <= i < R and 0 <= j < C:\n        ans.append(grid[i][j])\n        ii = i\n        jj = j - 2 * dir\n        if 0 <= jj < C:\n            i, j = (ii, jj)\n        else:\n            ii = i + 1\n            jj = 0 if jj < 0 else C - 1\n            dir = -dir\n            if 0 <= ii < R and 0 <= jj < C:\n                if connected(i, j, ii, jj):\n                    jj += dir\n                i, j = (ii, jj)\n            else:\n                break\n    return ans",
  "mutated_output": "[1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest432_q3708_s1",
  "question_id": 3708,
  "function_name": "zigzagTraversal",
  "code": "def zigzagTraversal(grid: List[List[int]]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n\n        r = 1\n        i, j = 0, 0\n        res = []\n        \n        while i < m:\n            res.append(grid[i][j])\n            if r:\n                j += 2\n                if j >= n:\n                    i += 1\n                    j = n - 1 - (j - n)\n                    r = 1 - r\n            else:\n                j -= 2\n                if j < 0:\n                    i += 1\n                    j = 0 - j - 1\n                    r = 1 - r\n\n        return res",
  "input": "zigzagTraversal(grid=[[1,2],[3,4]])",
  "output": "[1, 4]",
  "correct_condition": "zigzagTraversal(grid=[[1,2],[3,4]]) == [1, 4]",
  "contest_id": "weekly-contest-432",
  "contest_date": "2025-01-12T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 23,
    "coverage": null
  },
  "submission_id": 1505650015,
  "mutated_code": "def zigzagTraversal(grid: List[List[int]]) -> List[int]:\n    m, n = (len(grid), len(grid[0]))\n    r = 1\n    i, j = (1, 0)\n    res = []\n    while i < m:\n        res.append(grid[i][j])\n        if r:\n            j += 2\n            if j >= n:\n                i += 1\n                j = n - 1 - (j - n)\n                r = 1 - r\n        else:\n            j -= 2\n            if j < 0:\n                i += 1\n                j = 0 - j - 1\n                r = 1 - r\n    return res",
  "mutated_output": "[3]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest432_q3708_s2",
  "question_id": 3708,
  "function_name": "zigzagTraversal",
  "code": "def zigzagTraversal(grid: List[List[int]]) -> List[int]:\n        ans = []\n        for i, row in enumerate(grid):\n            if i % 2:\n                ans += row[::-1]\n            else:\n                ans += row\n        return ans[::2]\n            \n        ",
  "input": "zigzagTraversal(grid=[[1,2],[3,4]])",
  "output": "[1, 4]",
  "correct_condition": "zigzagTraversal(grid=[[1,2],[3,4]]) == [1, 4]",
  "contest_id": "weekly-contest-432",
  "contest_date": "2025-01-12T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 10,
    "coverage": null
  },
  "submission_id": 1505643478,
  "mutated_code": "def zigzagTraversal(grid: List[List[int]]) -> List[int]:\n    ans = []\n    for i, row in enumerate(grid):\n        if i // 2:\n            ans += row[::-1]\n        else:\n            ans += row\n    return ans[::2]",
  "mutated_output": "[1, 3]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest432_q3677_s0",
  "question_id": 3677,
  "function_name": "maximumAmount",
  "code": "def maximumAmount(coins: List[List[int]]) -> int:\n        R, C = len(coins), len(coins[0])\n\n        @cache\n        def f(i, j, magic):\n            if (i, j) in ((R, C - 1), (R - 1, C)):\n                return 0\n            if i >= R or j >= C:\n                return -inf\n\n            value = coins[i][j] + max(f(i + 1, j, magic), f(i, j + 1, magic))\n            if magic > 0:\n                value = max(value, max(coins[i][j], 0) + max(f(i, j + 1, magic - 1), f(i + 1, j, magic - 1)))\n            return value\n\n        ans = f(0, 0, 2)\n        return ans\n\n",
  "input": "maximumAmount(coins=[[0,1,-1],[1,-2,3],[2,-3,4]])",
  "output": "8",
  "correct_condition": "maximumAmount(coins=[[0,1,-1],[1,-2,3],[2,-3,4]]) == 8",
  "contest_id": "weekly-contest-432",
  "contest_date": "2025-01-12T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 18,
    "coverage": null
  },
  "submission_id": 1505662274,
  "mutated_code": "def maximumAmount(coins: List[List[int]]) -> int:\n    R, C = (len(coins), len(coins[0]))\n\n    @cache\n    def f(i, j, magic):\n        if (i, j) in ((R, C - 1), (R - 1, C)):\n            return 0\n        if i >= R or j >= C:\n            return -inf\n        value = coins[i][j] - max(f(i + 1, j, magic), f(i, j + 1, magic))\n        if magic > 0:\n            value = max(value, max(coins[i][j], 0) + max(f(i, j + 1, magic - 1), f(i + 1, j, magic - 1)))\n        return value\n    ans = f(0, 0, 2)\n    return ans",
  "mutated_output": "10",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest432_q3677_s1",
  "question_id": 3677,
  "function_name": "maximumAmount",
  "code": "def maximumAmount(coins: List[List[int]]) -> int:\n        m, n = len(coins), len(coins[0])\n        \n        dp0 = [[float('-inf')] * n for _ in range(m)]\n        dp1 = [[float('-inf')] * n for _ in range(m)]\n        dp2 = [[float('-inf')] * n for _ in range(m)]\n\n        dp0[0][0] = coins[0][0]\n        if coins[0][0] < 0:\n            dp1[0][0] = 0\n\n        for i, r in enumerate(coins):\n            for j, num in enumerate(r):\n                if i > 0:\n                    dp0[i][j] = max(dp0[i][j], dp0[i-1][j] + coins[i][j])\n                    dp1[i][j] = max(dp1[i][j], dp1[i-1][j] + coins[i][j])\n                    dp2[i][j] = max(dp2[i][j], dp2[i-1][j] + coins[i][j])\n                    if coins[i][j] < 0:\n                        dp1[i][j] = max(dp1[i][j], dp0[i-1][j])\n                        dp2[i][j] = max(dp2[i][j], dp1[i-1][j])\n\n                if j > 0:\n                    dp0[i][j] = max(dp0[i][j], dp0[i][j-1] + coins[i][j])\n                    dp1[i][j] = max(dp1[i][j], dp1[i][j-1] + coins[i][j])\n                    dp2[i][j] = max(dp2[i][j], dp2[i][j-1] + coins[i][j])\n                    if coins[i][j] < 0:\n                        dp1[i][j] = max(dp1[i][j], dp0[i][j-1])\n                        dp2[i][j] = max(dp2[i][j], dp1[i][j-1])\n                        \n        return max(dp0[-1][-1], dp1[-1][-1], dp2[-1][-1])",
  "input": "maximumAmount(coins=[[0,1,-1],[1,-2,3],[2,-3,4]])",
  "output": "8",
  "correct_condition": "maximumAmount(coins=[[0,1,-1],[1,-2,3],[2,-3,4]]) == 8",
  "contest_id": "weekly-contest-432",
  "contest_date": "2025-01-12T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 30,
    "coverage": null
  },
  "submission_id": 1505663966,
  "mutated_code": "def maximumAmount(coins: List[List[int]]) -> int:\n    m, n = (len(coins), len(coins[0]))\n    dp0 = [[float('-inf')] * n for _ in range(m)]\n    dp1 = [[float('-inf')] * n for _ in range(m)]\n    dp2 = [[float('-inf')] * n for _ in range(m)]\n    dp0[0][0] = coins[0][0]\n    if coins[0][0] < 0:\n        dp1[0][0] = 0\n    for i, r in enumerate(coins):\n        for j, num in enumerate(r):\n            if i > 0:\n                dp0[i][j] = max(dp0[i][j], dp0[i - 1][j] - coins[i][j])\n                dp1[i][j] = max(dp1[i][j], dp1[i - 1][j] + coins[i][j])\n                dp2[i][j] = max(dp2[i][j], dp2[i - 1][j] + coins[i][j])\n                if coins[i][j] < 0:\n                    dp1[i][j] = max(dp1[i][j], dp0[i - 1][j])\n                    dp2[i][j] = max(dp2[i][j], dp1[i - 1][j])\n            if j > 0:\n                dp0[i][j] = max(dp0[i][j], dp0[i][j - 1] + coins[i][j])\n                dp1[i][j] = max(dp1[i][j], dp1[i][j - 1] + coins[i][j])\n                dp2[i][j] = max(dp2[i][j], dp2[i][j - 1] + coins[i][j])\n                if coins[i][j] < 0:\n                    dp1[i][j] = max(dp1[i][j], dp0[i][j - 1])\n                    dp2[i][j] = max(dp2[i][j], dp1[i][j - 1])\n    return max(dp0[-1][-1], dp1[-1][-1], dp2[-1][-1])",
  "mutated_output": "10",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest432_q3677_s2",
  "question_id": 3677,
  "function_name": "maximumAmount",
  "code": "def maximumAmount(g: List[List[int]]) -> int:\n        n = len(g)\n        m = len(g[0])\n        f = [[[-inf] * 3 for j in range(m)] for i in range(n)]\n        f[0][0][0] = g[0][0]\n        f[0][0][1] = f[0][0][2] = max(g[0][0], 0)\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    continue\n                x = g[i][j]\n                for k in range(3):\n                    if i > 0 and f[i - 1][j][k] + x > f[i][j][k]:\n                        f[i][j][k] = f[i - 1][j][k] + x\n                    if j > 0 and f[i][j - 1][k] + x > f[i][j][k]:\n                        f[i][j][k] = f[i][j - 1][k] + x\n                    if k and i > 0 and f[i - 1][j][k - 1] > f[i][j][k]:\n                        f[i][j][k] = f[i - 1][j][k - 1]\n                    if k and j > 0 and f[i][j - 1][k - 1] > f[i][j][k]:\n                        f[i][j][k] = f[i][j - 1][k - 1]\n        return max(f[-1][-1])\n        ",
  "input": "maximumAmount(g=[[0,1,-1],[1,-2,3],[2,-3,4]])",
  "output": "8",
  "correct_condition": "maximumAmount(g=[[0,1,-1],[1,-2,3],[2,-3,4]]) == 8",
  "contest_id": "weekly-contest-432",
  "contest_date": "2025-01-12T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 22,
    "coverage": null
  },
  "submission_id": 1505655943,
  "mutated_code": "def maximumAmount(g: List[List[int]]) -> int:\n    n = len(g)\n    m = len(g[0])\n    f = [[[-inf] * 3 for j in range(m)] for i in range(n)]\n    f[0][0][0] = g[0][0]\n    f[0][0][1] = f[0][0][2] = max(g[0][0], 0)\n    for i in range(n):\n        for j in range(m):\n            if i == 0 and j == 0:\n                continue\n            x = g[i][j]\n            for k in range(3):\n                if i > 0 and f[i - 1][j][k] + x > f[i][j][k]:\n                    f[i][j][k] = f[i - 1][j][k] - x\n                if j > 0 and f[i][j - 1][k] + x > f[i][j][k]:\n                    f[i][j][k] = f[i][j - 1][k] + x\n                if k and i > 0 and (f[i - 1][j][k - 1] > f[i][j][k]):\n                    f[i][j][k] = f[i - 1][j][k - 1]\n                if k and j > 0 and (f[i][j - 1][k - 1] > f[i][j][k]):\n                    f[i][j][k] = f[i][j - 1][k - 1]\n    return max(f[-1][-1])",
  "mutated_output": "10",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest432_q3720_s0",
  "question_id": 3720,
  "function_name": "minMaxWeight",
  "code": "def minMaxWeight(n: int, edges: List[List[int]], threshold: int) -> int:\n        G = [[] for _ in range(n)]\n        for u, v, w in edges:\n            G[v].append((u, w))\n\n        def dfs(u, visited, cap):\n            visited[u] = True\n            for v, w in G[u]:\n                if w <= cap and not visited[v]:\n                    dfs(v, visited, cap)\n\n        visited = [False] * n\n        dfs(0, visited, inf)\n        for i in range(n):\n            if not visited[i]:\n                return -1\n\n        L = 0\n        R = 1000000 + 20\n        while L + 1 < R:\n            mid = (L + R) // 2\n            visited = [False] * n\n            dfs(0, visited, mid)\n            ok = True\n            for i in range(n):\n                if not visited[i]:\n                    ok = False\n                    break\n            if ok:\n                R = mid\n            else:\n                L = mid\n\n        return R\n",
  "input": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2)",
  "output": "1",
  "correct_condition": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2) == 1",
  "contest_id": "weekly-contest-432",
  "contest_date": "2025-01-12T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 34,
    "coverage": null
  },
  "submission_id": 1505695158,
  "mutated_code": "def minMaxWeight(n: int, edges: List[List[int]], threshold: int) -> int:\n    G = [[] for _ in range(n)]\n    for u, v, w in edges:\n        G[v].append((u, w))\n\n    def dfs(u, visited, cap):\n        visited[u] = True\n        for v, w in G[u]:\n            if w < cap and (not visited[v]):\n                dfs(v, visited, cap)\n    visited = [False] * n\n    dfs(0, visited, inf)\n    for i in range(n):\n        if not visited[i]:\n            return -1\n    L = 0\n    R = 1000000 + 20\n    while L + 1 < R:\n        mid = (L + R) // 2\n        visited = [False] * n\n        dfs(0, visited, mid)\n        ok = True\n        for i in range(n):\n            if not visited[i]:\n                ok = False\n                break\n        if ok:\n            R = mid\n        else:\n            L = mid\n    return R",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest432_q3720_s1",
  "question_id": 3720,
  "function_name": "minMaxWeight",
  "code": "def minMaxWeight(n: int, edges: List[List[int]], threshold: int) -> int:\n        ws = set()\n        graph = {}\n        rev = {}\n        for u, v, w in edges:\n            ws.add(w)\n            \n            if u not in graph:\n                graph[u] = defaultdict(lambda: float('inf'))\n            if v not in rev:\n                rev[v] = defaultdict(lambda: float('inf'))\n\n            graph[u][v] = min(graph[u][v], w)\n            rev[v][u] = min(rev[v][u], w)\n\n        q = deque([0])\n        seen = set([0])\n        while q:\n            v = q.popleft()\n            if v in rev:\n                for u in rev[v]:\n                    if u not in seen:\n                        q.append(u)\n                        seen.add(u)\n                        \n        if len(seen) < n:\n            return -1\n\n        def can(x):\n            q = deque([0])\n            seen = set([0])\n            while q:\n                v = q.popleft()\n                if v in rev:\n                    for u in rev[v]:\n                        if rev[v][u] <= x and u not in seen:\n                            q.append(u)\n                            seen.add(u)\n            return len(seen) == n\n\n        l, r = min(ws), max(ws)\n        while l < r:\n            mid = (l + r) // 2\n            if can(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l",
  "input": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2)",
  "output": "1",
  "correct_condition": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2) == 1",
  "contest_id": "weekly-contest-432",
  "contest_date": "2025-01-12T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 48,
    "coverage": null
  },
  "submission_id": 1505688956,
  "mutated_code": "def minMaxWeight(n: int, edges: List[List[int]], threshold: int) -> int:\n    ws = set()\n    graph = {}\n    rev = {}\n    for u, v, w in edges:\n        ws.add(w)\n        if u not in graph:\n            graph[u] = defaultdict(lambda: float('inf'))\n        if v not in rev:\n            rev[v] = defaultdict(lambda: float('inf'))\n        graph[u][v] = min(graph[u][v], w)\n        rev[v][u] = min(rev[v][u], w)\n    q = deque([0])\n    seen = set([0])\n    while q:\n        v = q.popleft()\n        if v in rev:\n            for u in rev[v]:\n                if u not in seen:\n                    q.append(u)\n                    seen.add(u)\n    if len(seen) <= n:\n        return -1\n\n    def can(x):\n        q = deque([0])\n        seen = set([0])\n        while q:\n            v = q.popleft()\n            if v in rev:\n                for u in rev[v]:\n                    if rev[v][u] <= x and u not in seen:\n                        q.append(u)\n                        seen.add(u)\n        return len(seen) == n\n    l, r = (min(ws), max(ws))\n    while l < r:\n        mid = (l + r) // 2\n        if can(mid):\n            r = mid\n        else:\n            l = mid + 1\n    return l",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest432_q3720_s2",
  "question_id": 3720,
  "function_name": "minMaxWeight",
  "code": "def minMaxWeight(n: int, edges: List[List[int]], threshold: int) -> int:\n        g = [[] for _ in range(n)]\n        m = 1\n        for u, v, w in edges:\n            g[v].append((u, w))\n            if w > m:\n                m = w\n        def check(mid):\n            vis = [0] * n\n            vis[0] = 1\n            Q = deque([0])\n            while Q:\n                u = Q.popleft()\n                for v, w in g[u]:\n                    if w <= mid and not vis[v]:\n                        Q.append(v)\n                        vis[v] = 1\n            return sum(vis) == n\n                        \n        \n        lo, hi = 1, m + 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if check(mid):\n                hi = mid\n            else:\n                lo = mid + 1\n        return -1 if lo > m else lo",
  "input": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2)",
  "output": "1",
  "correct_condition": "minMaxWeight(n=5, edges=[[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold=2) == 1",
  "contest_id": "weekly-contest-432",
  "contest_date": "2025-01-12T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 28,
    "coverage": null
  },
  "submission_id": 1505677494,
  "mutated_code": "def minMaxWeight(n: int, edges: List[List[int]], threshold: int) -> int:\n    g = [[] for _ in range(n)]\n    m = 1\n    for u, v, w in edges:\n        g[v].append((u, w))\n        if w > m:\n            m = w\n\n    def check(mid):\n        vis = [0] * n\n        vis[0] = 1\n        Q = deque([0])\n        while Q:\n            u = Q.popleft()\n            for v, w in g[u]:\n                if w < mid and (not vis[v]):\n                    Q.append(v)\n                    vis[v] = 1\n        return sum(vis) == n\n    lo, hi = (1, m + 1)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if check(mid):\n            hi = mid\n        else:\n            lo = mid + 1\n    return -1 if lo > m else lo",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest432_q3674_s1",
  "question_id": 3674,
  "function_name": "countNonDecreasingSubarrays",
  "code": "def countNonDecreasingSubarrays(nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        j = n\n        total = 0\n        stack = deque()\n        res = 0\n        for i in range(n-1, -1, -1):\n            num = nums[i]\n            \n            inc = 0\n            while stack and nums[stack[-1]] <= nums[i]:\n                cur = stack.pop()\n                prev = stack[-1] if stack else j\n                inc += (nums[i] - nums[cur]) * (prev - cur)\n            total += inc\n\n            stack.append(i)\n\n            while total > k:\n                total -= nums[stack[0]] - nums[j-1]\n                j -= 1\n\n                if j == stack[0]:\n                    stack.popleft()\n\n            res += j - i\n        return res",
  "input": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7)",
  "output": "17",
  "correct_condition": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7) == 17",
  "contest_id": "weekly-contest-432",
  "contest_date": "2025-01-12T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 28,
    "coverage": null
  },
  "submission_id": 1505713317,
  "mutated_code": "def countNonDecreasingSubarrays(nums: List[int], k: int) -> int:\n    n = len(nums)\n    j = n\n    total = 0\n    stack = deque()\n    res = 0\n    for i in range(n - 1, -1, -1):\n        num = nums[i]\n        inc = 0\n        while stack and nums[stack[-1]] <= nums[i]:\n            cur = stack.pop()\n            prev = stack[-1] if stack else j\n            inc += (nums[i] - nums[cur]) // (prev - cur)\n        total += inc\n        stack.append(i)\n        while total > k:\n            total -= nums[stack[0]] - nums[j - 1]\n            j -= 1\n            if j == stack[0]:\n                stack.popleft()\n        res += j - i\n    return res",
  "mutated_output": "21",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest432_q3674_s2",
  "question_id": 3674,
  "function_name": "countNonDecreasingSubarrays",
  "code": "def countNonDecreasingSubarrays(nums: List[int], k: int) -> int:\n        ans = 0\n        n = len(nums)\n        nextlargestidx = [None] * n # strictly larger\n\n        st = []\n        for i in range(len(nums)):\n            while len(st) != 0 and nums[st[-1]] < nums[i]:\n                nextlargestidx[st[-1]] = i\n                st.pop()\n            st.append(i)\n\n        # print(nextlargestidx)\n        \n        start = 0 # inclusive\n        used = 0\n        waterline = 0\n        for i in range(len(nums)):\n            if waterline > nums[i]:\n                used += waterline - nums[i]\n            else:\n                waterline = nums[i]\n\n            while used > k:\n                # attempt to move start forward one\n                oldnext = nextlargestidx[start]\n                oldwaterline = nums[start]\n                \n                temp = start+1\n                while temp is not None and (oldnext is None or temp < oldnext) and (temp <= i):\n                    if oldnext is None or oldnext > i:\n                        waterline = nums[temp]\n                    basinend = n if nextlargestidx[temp] is None else nextlargestidx[temp]\n                    reducecount = min(i+1,basinend) - temp\n                    used -= reducecount * (oldwaterline - nums[temp])\n                    temp = nextlargestidx[temp]\n                \n                    \n                start += 1\n            # print(start, \"to\", i, \"using\", used, \"waterline\", waterline)\n            ans += (i-start+1)\n\n        return ans",
  "input": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7)",
  "output": "17",
  "correct_condition": "countNonDecreasingSubarrays(nums=[6,3,1,2,4,4], k=7) == 17",
  "contest_id": "weekly-contest-432",
  "contest_date": "2025-01-12T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 43,
    "coverage": null
  },
  "submission_id": 1505705811,
  "mutated_code": "def countNonDecreasingSubarrays(nums: List[int], k: int) -> int:\n    ans = 0\n    n = len(nums)\n    nextlargestidx = [None] * n\n    st = []\n    for i in range(len(nums)):\n        while len(st) != 0 and nums[st[-1]] < nums[i]:\n            nextlargestidx[st[-1]] = i\n            st.pop()\n        st.append(i)\n    start = 0\n    used = 0\n    waterline = 0\n    for i in range(len(nums)):\n        if waterline > nums[i]:\n            used += waterline - nums[i]\n        else:\n            waterline = nums[i]\n        while used > k:\n            oldnext = nextlargestidx[start]\n            oldwaterline = nums[start]\n            temp = start + 1\n            while temp is not None and (oldnext is None or temp < oldnext) and (temp <= i):\n                if oldnext is None or oldnext > i:\n                    waterline = nums[temp]\n                basinend = n if nextlargestidx[temp] is None else nextlargestidx[temp]\n                reducecount = min(i + 1, basinend) - temp\n                used -= reducecount * (oldwaterline - nums[temp])\n                temp = nextlargestidx[temp]\n            start += 1\n        ans += i - start - 1\n    return ans",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 7,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest433_q3731_s0",
  "question_id": 3731,
  "function_name": "subarraySum",
  "code": "def subarraySum(nums):\n        n=len(nums)\n        p=[0]*(n+1)\n        for i in range(n):\n            p[i+1]=p[i]+nums[i]\n        s1=0\n        s2=0\n        for i in range(n):\n            st=i-nums[i]\n            if st<0: st=0\n            s1+=p[i+1]\n            s2+=p[st]\n        return s1-s2",
  "input": "subarraySum(nums=[2,3,1])",
  "output": "11",
  "correct_condition": "subarraySum(nums=[2,3,1]) == 11",
  "contest_id": "weekly-contest-433",
  "contest_date": "2025-01-19T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 13,
    "coverage": null
  },
  "submission_id": 1513087537,
  "mutated_code": "def subarraySum(nums):\n    n = len(nums)\n    p = [0] * (n + 1)\n    for i in range(n):\n        p[i - 1] = p[i] + nums[i]\n    s1 = 0\n    s2 = 0\n    for i in range(n):\n        st = i - nums[i]\n        if st < 0:\n            st = 0\n        s1 += p[i + 1]\n        s2 += p[st]\n    return s1 - s2",
  "mutated_output": "-4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest433_q3731_s2",
  "question_id": 3731,
  "function_name": "subarraySum",
  "code": "def subarraySum(nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            start = max(0, i - nums[i])\n            s = 0\n            for j in range(start, i + 1):\n                s += nums[j]\n            ans += s\n        return ans",
  "input": "subarraySum(nums=[2,3,1])",
  "output": "11",
  "correct_condition": "subarraySum(nums=[2,3,1]) == 11",
  "contest_id": "weekly-contest-433",
  "contest_date": "2025-01-19T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 10,
    "coverage": null
  },
  "submission_id": 1513080952,
  "mutated_code": "def subarraySum(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        start = max(0, i + nums[i])\n        s = 0\n        for j in range(start, i + 1):\n            s += nums[j]\n        ans += s\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest433_q3714_s0",
  "question_id": 3714,
  "function_name": "minMaxSums",
  "code": "def minMaxSums(nums: List[int], k: int) -> int:\n        import sys\n        sys.setrecursionlimit(10**7)\n        M=10**9+7\n        n=len(nums)\n        f=[1]*(n+1)\n        invf=[1]*(n+1)\n        for i in range(1,n+1):\n            f[i]=(f[i-1]*i)%M\n        def p(b,e):\n            r=1\n            while e>0:\n                if e&1:\n                    r=(r*b)%M\n                b=(b*b)%M\n                e>>=1\n            return r\n        invf[n]=p(f[n],M-2)\n        for i in range(n-1,-1,-1):\n            invf[i]=(invf[i+1]*(i+1))%M\n        def C(a,b):\n            if b<0 or b>a:\n                return 0\n            return (f[a]*((invf[b]*invf[a-b])%M))%M\n        nums.sort()\n        ans=0\n        for i in range(n):\n            for s in range(1,k+1):\n                if s-1<=i:\n                    ans=(ans+nums[i]*C(i,s-1))%M\n        for i in range(n):\n            for s in range(1,k+1):\n                if s-1<=n-1-i:\n                    ans=(ans+nums[i]*C(n-1-i,s-1))%M\n        return ans%M\n",
  "input": "minMaxSums(nums=[1,2,3], k=2)",
  "output": "24",
  "correct_condition": "minMaxSums(nums=[1,2,3], k=2) == 24",
  "contest_id": "weekly-contest-433",
  "contest_date": "2025-01-19T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 35,
    "coverage": null
  },
  "submission_id": 1513088015,
  "mutated_code": "def minMaxSums(nums: List[int], k: int) -> int:\n    import sys\n    sys.setrecursionlimit(10 ** 7)\n    M = 10 ** 9 - 7\n    n = len(nums)\n    f = [1] * (n + 1)\n    invf = [1] * (n + 1)\n    for i in range(1, n + 1):\n        f[i] = f[i - 1] * i % M\n\n    def p(b, e):\n        r = 1\n        while e > 0:\n            if e & 1:\n                r = r * b % M\n            b = b * b % M\n            e >>= 1\n        return r\n    invf[n] = p(f[n], M - 2)\n    for i in range(n - 1, -1, -1):\n        invf[i] = invf[i + 1] * (i + 1) % M\n\n    def C(a, b):\n        if b < 0 or b > a:\n            return 0\n        return f[a] * (invf[b] * invf[a - b] % M) % M\n    nums.sort()\n    ans = 0\n    for i in range(n):\n        for s in range(1, k + 1):\n            if s - 1 <= i:\n                ans = (ans + nums[i] * C(i, s - 1)) % M\n    for i in range(n):\n        for s in range(1, k + 1):\n            if s - 1 <= n - 1 - i:\n                ans = (ans + nums[i] * C(n - 1 - i, s - 1)) % M\n    return ans % M",
  "mutated_output": "880765893",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest433_q3714_s2",
  "question_id": 3714,
  "function_name": "minMaxSums",
  "code": "def minMaxSums(nums: List[int], k: int) -> int:\n        MOD = 10**9+7\n        n = len(nums)\n        nums.sort()\n        fact = [1] * (n+1)\n        inv_fact = [1] * (n+1)\n        \n        for i in range(1,n+1):\n            fact[i] = fact[i-1] * i % MOD\n        inv_fact[n] = pow(fact[n], MOD-2, MOD)\n        \n        for i in range(n-1,-1,-1):\n            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n        \n        def comb(a,b):\n            if b < 0 or b > a: return 0\n            return fact[a] * inv_fact[b] % MOD * inv_fact[a-b] % MOD\n        partialC = [0] * n\n        for i in range(n):\n            m = min(i,k-1)\n            s = 0\n            for j in range(m+1):\n                s = (s + comb(i,j)) % MOD\n            partialC[i] = s\n        ans1 = 0\n        ans2 = 0\n        for i in range(n):\n            ans1 = (ans1 + nums[i] * partialC[i]) % MOD\n            ans2 = (ans2 + nums[i] * partialC[n-1-i]) % MOD\n        return (ans1 + ans2) % MOD",
  "input": "minMaxSums(nums=[1,2,3], k=2)",
  "output": "24",
  "correct_condition": "minMaxSums(nums=[1,2,3], k=2) == 24",
  "contest_id": "weekly-contest-433",
  "contest_date": "2025-01-19T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 30,
    "coverage": null
  },
  "submission_id": 1513086962,
  "mutated_code": "def minMaxSums(nums: List[int], k: int) -> int:\n    MOD = 10 ** 9 - 7\n    n = len(nums)\n    nums.sort()\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\n    def comb(a, b):\n        if b < 0 or b > a:\n            return 0\n        return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD\n    partialC = [0] * n\n    for i in range(n):\n        m = min(i, k - 1)\n        s = 0\n        for j in range(m + 1):\n            s = (s + comb(i, j)) % MOD\n        partialC[i] = s\n    ans1 = 0\n    ans2 = 0\n    for i in range(n):\n        ans1 = (ans1 + nums[i] * partialC[i]) % MOD\n        ans2 = (ans2 + nums[i] * partialC[n - 1 - i]) % MOD\n    return (ans1 + ans2) % MOD",
  "mutated_output": "880765893",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest433_q3737_s0",
  "question_id": 3737,
  "function_name": "minCost",
  "code": "def minCost(n: int, cost: List[List[int]]) -> int:\n        s=[(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]\n        dp1=[cost[0][x[0]]+cost[n-1][x[1]] for x in s]\n        v=[[False]*6 for _ in range(6)]\n        for i in range(6):\n            for j in range(6):\n                v[i][j]=(s[i][0]!=s[j][0] and s[i][1]!=s[j][1])\n        for i in range(1,n//2):\n            dp2=[0]*6\n            for j in range(6):\n                mn=min(dp1[k] for k in range(6) if v[k][j])\n                dp2[j]=mn + cost[i][s[j][0]] + cost[n-1-i][s[j][1]]\n            dp1=dp2\n        return min(dp1)\n",
  "input": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]])",
  "output": "9",
  "correct_condition": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]]) == 9",
  "contest_id": "weekly-contest-433",
  "contest_date": "2025-01-19T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1513082546,
  "mutated_code": "def minCost(n: int, cost: List[List[int]]) -> int:\n    s = [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]\n    dp1 = [cost[0][x[0]] - cost[n - 1][x[1]] for x in s]\n    v = [[False] * 6 for _ in range(6)]\n    for i in range(6):\n        for j in range(6):\n            v[i][j] = s[i][0] != s[j][0] and s[i][1] != s[j][1]\n    for i in range(1, n // 2):\n        dp2 = [0] * 6\n        for j in range(6):\n            mn = min((dp1[k] for k in range(6) if v[k][j]))\n            dp2[j] = mn + cost[i][s[j][0]] + cost[n - 1 - i][s[j][1]]\n        dp1 = dp2\n    return min(dp1)",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest433_q3737_s2",
  "question_id": 3737,
  "function_name": "minCost",
  "code": "def minCost(n: int, cost: List[List[int]]) -> int:\n        dp = [[[float('inf')] * 3 for _ in range(3)] for __ in range(n//2+1)]\n        for cl in range(3):\n            for cr in range(3):\n                dp[0][cl][cr] = 0\n                \n        for nl in range(3):\n            for nr in range(3):\n                if nl != nr:\n                    for cl in range(3):\n                        for cr in range(3):\n                            v = dp[0][cl][cr] + cost[0][nl] + cost[n-1][nr]\n                            if v < dp[1][nl][nr]:\n                                dp[1][nl][nr] = v\n                                \n        for i in range(1, n//2):\n            for cl in range(3):\n                for cr in range(3):\n                    p = dp[i][cl][cr]\n                    if p == inf:\n                        continue\n                    for nl in range(3):\n                        for nr in range(3):\n                            if nl != nr and nl != cl and nr != cr:\n                                v = p + cost[i][nl] + cost[n-1-i][nr]\n                                if v < dp[i+1][nl][nr]:\n                                    dp[i+1][nl][nr] = v\n                                    \n        r = float('inf')\n        \n        for cl in range(3):\n            for cr in range(3):\n                if dp[n//2][cl][cr] < r:\n                    r = dp[n//2][cl][cr]\n        return r",
  "input": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]])",
  "output": "9",
  "correct_condition": "minCost(n=4, cost=[[3,5,7],[6,2,9],[4,8,1],[7,3,5]]) == 9",
  "contest_id": "weekly-contest-433",
  "contest_date": "2025-01-19T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 35,
    "coverage": null
  },
  "submission_id": 1513091870,
  "mutated_code": "def minCost(n: int, cost: List[List[int]]) -> int:\n    dp = [[[float('inf')] * 3 for _ in range(3)] for __ in range(n // 2 + 1)]\n    for cl in range(3):\n        for cr in range(3):\n            dp[0][cl][cr] = 0\n    for nl in range(3):\n        for nr in range(3):\n            if nl != nr:\n                for cl in range(3):\n                    for cr in range(3):\n                        v = dp[0][cl][cr] + cost[0][nl] - cost[n - 1][nr]\n                        if v < dp[1][nl][nr]:\n                            dp[1][nl][nr] = v\n    for i in range(1, n // 2):\n        for cl in range(3):\n            for cr in range(3):\n                p = dp[i][cl][cr]\n                if p == inf:\n                    continue\n                for nl in range(3):\n                    for nr in range(3):\n                        if nl != nr and nl != cl and (nr != cr):\n                            v = p + cost[i][nl] + cost[n - 1 - i][nr]\n                            if v < dp[i + 1][nl][nr]:\n                                dp[i + 1][nl][nr] = v\n    r = float('inf')\n    for cl in range(3):\n        for cr in range(3):\n            if dp[n // 2][cl][cr] < r:\n                r = dp[n // 2][cl][cr]\n    return r",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest433_q3725_s0",
  "question_id": 3725,
  "function_name": "minMaxSubarraySum",
  "code": "def minMaxSubarraySum(nums, k):\n        def p(L,R,M):\n            u=min(L,M-1)\n            if u<=0:return 0\n            if R>=M-1:return M*u - u*(u+1)//2\n            x=M-R\n            if x>u:return R*u\n            s=R*(x-1)\n            s+=M*(u-x+1)-((u*(u+1))//2-((x-1)*x)//2)\n            return s\n        def s(a,k,m):\n            n=len(a)\n            l=[0]*n\n            r=[0]*n\n            st=[]\n            for i in range(n):\n                while st and ((a[st[-1]]>a[i]) if m else (a[st[-1]]<a[i])):\n                    st.pop()\n                l[i]=i-st[-1] if st else i+1\n                st.append(i)\n            st=[]\n            for i in range(n-1,-1,-1):\n                while st and ((a[st[-1]]>=a[i]) if m else (a[st[-1]]<=a[i])):\n                    st.pop()\n                r[i]=st[-1]-i if st else n-i\n                st.append(i)\n            res=0\n            for i in range(n):\n                res+=a[i]*p(l[i],r[i],k+1)\n            return res\n        return s(nums,k,True)+s(nums,k,False)",
  "input": "minMaxSubarraySum(nums=[1,2,3], k=2)",
  "output": "20",
  "correct_condition": "minMaxSubarraySum(nums=[1,2,3], k=2) == 20",
  "contest_id": "weekly-contest-433",
  "contest_date": "2025-01-19T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 31,
    "coverage": null
  },
  "submission_id": 1513090643,
  "mutated_code": "def minMaxSubarraySum(nums, k):\n\n    def p(L, R, M):\n        u = min(L, M - 1)\n        if u <= 0:\n            return 0\n        if R >= M - 1:\n            return M * u + u * (u + 1) // 2\n        x = M - R\n        if x > u:\n            return R * u\n        s = R * (x - 1)\n        s += M * (u - x + 1) - (u * (u + 1) // 2 - (x - 1) * x // 2)\n        return s\n\n    def s(a, k, m):\n        n = len(a)\n        l = [0] * n\n        r = [0] * n\n        st = []\n        for i in range(n):\n            while st and (a[st[-1]] > a[i] if m else a[st[-1]] < a[i]):\n                st.pop()\n            l[i] = i - st[-1] if st else i + 1\n            st.append(i)\n        st = []\n        for i in range(n - 1, -1, -1):\n            while st and (a[st[-1]] >= a[i] if m else a[st[-1]] <= a[i]):\n                st.pop()\n            r[i] = st[-1] - i if st else n - i\n            st.append(i)\n        res = 0\n        for i in range(n):\n            res += a[i] * p(l[i], r[i], k + 1)\n        return res\n    return s(nums, k, True) + s(nums, k, False)",
  "mutated_output": "26",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest433_q3725_s2",
  "question_id": 3725,
  "function_name": "minMaxSubarraySum",
  "code": "def minMaxSubarraySum(nums: List[int], k: int) -> int:\n        n = len(nums)\n        lSmall = [-1]*n\n        rSmall = [n]*n\n        stack = []\n        for i in range(n):\n            while stack and nums[stack[-1]]>nums[i]:\n                stack.pop()\n            lSmall[i] = stack[-1] if stack else -1\n            stack.append(i)\n        stack.clear()\n        for i in range(n-1,-1,-1):\n            while stack and nums[stack[-1]]>=nums[i]:\n                stack.pop()\n            rSmall[i] = stack[-1] if stack else n\n            stack.append(i)\n        def countSub(L,R,k):\n            if L==0 or R==0:\n                return 0\n            m = k - 1\n            if (L - 1)+(R - 1) <= m:\n                return L*R\n            X = min(L,m+1)\n            x0 = max(0,m - (R-1))\n            s = 0\n            if x0>0:\n                t = min(x0,X)\n                s += t*R\n            if x0< X:\n                start = max(x0,0)\n                end = X\n                c = (end - start)\n                s += c*(m+1) - (start+end-1)*c//2\n            return s\n        totalMin = 0\n        for i in range(n):\n            L = i - lSmall[i]\n            R = rSmall[i] - i\n            totalMin += nums[i]*countSub(L,R,k)\n        lBig = [-1]*n\n        rBig = [n]*n\n        stack.clear()\n        for i in range(n):\n            while stack and nums[stack[-1]]<nums[i]:\n                stack.pop()\n            lBig[i] = stack[-1] if stack else -1\n            stack.append(i)\n        stack.clear()\n        for i in range(n-1,-1,-1):\n            while stack and nums[stack[-1]]<=nums[i]:\n                stack.pop()\n            rBig[i] = stack[-1] if stack else n\n            stack.append(i)\n        totalMax = 0\n        for i in range(n):\n            L = i - lBig[i]\n            R = rBig[i] - i\n            totalMax += nums[i]*countSub(L,R,k)\n        return totalMin + totalMax",
  "input": "minMaxSubarraySum(nums=[1,2,3], k=2)",
  "output": "20",
  "correct_condition": "minMaxSubarraySum(nums=[1,2,3], k=2) == 20",
  "contest_id": "weekly-contest-433",
  "contest_date": "2025-01-19T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 59,
    "coverage": null
  },
  "submission_id": 1513104348,
  "mutated_code": "def minMaxSubarraySum(nums: List[int], k: int) -> int:\n    n = len(nums)\n    lSmall = [-1] * n\n    rSmall = [n] * n\n    stack = []\n    for i in range(n):\n        while stack and nums[stack[-1]] > nums[i]:\n            stack.pop()\n        lSmall[i] = stack[-1] if stack else -1\n        stack.append(i)\n    stack.clear()\n    for i in range(n - 1, -1, -1):\n        while stack and nums[stack[-1]] >= nums[i]:\n            stack.pop()\n        rSmall[i] = stack[-1] if stack else n\n        stack.append(i)\n\n    def countSub(L, R, k):\n        if L == 0 or R == 0:\n            return 0\n        m = k + 1\n        if L - 1 + (R - 1) <= m:\n            return L * R\n        X = min(L, m + 1)\n        x0 = max(0, m - (R - 1))\n        s = 0\n        if x0 > 0:\n            t = min(x0, X)\n            s += t * R\n        if x0 < X:\n            start = max(x0, 0)\n            end = X\n            c = end - start\n            s += c * (m + 1) - (start + end - 1) * c // 2\n        return s\n    totalMin = 0\n    for i in range(n):\n        L = i - lSmall[i]\n        R = rSmall[i] - i\n        totalMin += nums[i] * countSub(L, R, k)\n    lBig = [-1] * n\n    rBig = [n] * n\n    stack.clear()\n    for i in range(n):\n        while stack and nums[stack[-1]] < nums[i]:\n            stack.pop()\n        lBig[i] = stack[-1] if stack else -1\n        stack.append(i)\n    stack.clear()\n    for i in range(n - 1, -1, -1):\n        while stack and nums[stack[-1]] <= nums[i]:\n            stack.pop()\n        rBig[i] = stack[-1] if stack else n\n        stack.append(i)\n    totalMax = 0\n    for i in range(n):\n        L = i - lBig[i]\n        R = rBig[i] - i\n        totalMax += nums[i] * countSub(L, R, k)\n    return totalMin + totalMax",
  "mutated_output": "24",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest434_q3704_s0",
  "question_id": 3704,
  "function_name": "countPartitions",
  "code": "def countPartitions(nums: List[int]) -> int:\n        S = sum(nums)\n        n = len(nums)\n        answer = 0 \n        S1 = 0 \n        for i in range(n-1):\n            S1+=nums[i]\n            S-=nums[i]\n            if (S-S1) % 2==0:\n                answer+=1\n        return answer\n        ",
  "input": "countPartitions(nums=[10,10,3,7,6])",
  "output": "4",
  "correct_condition": "countPartitions(nums=[10,10,3,7,6]) == 4",
  "contest_id": "weekly-contest-434",
  "contest_date": "2025-01-26T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 12,
    "coverage": null
  },
  "submission_id": 1520578515,
  "mutated_code": "def countPartitions(nums: List[int]) -> int:\n    S = sum(nums)\n    n = len(nums)\n    answer = 0\n    S1 = 0\n    for i in range(n - 1):\n        S1 += nums[i]\n        S -= nums[i]\n        if (S - S1) // 2 == 0:\n            answer += 1\n    return answer",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest434_q3704_s2",
  "question_id": 3704,
  "function_name": "countPartitions",
  "code": "def countPartitions(nums: List[int]) -> int:\n        total = sum(nums)\n        if total % 2 != 0:\n            return 0\n        return len(nums) - 1",
  "input": "countPartitions(nums=[10,10,3,7,6])",
  "output": "4",
  "correct_condition": "countPartitions(nums=[10,10,3,7,6]) == 4",
  "contest_id": "weekly-contest-434",
  "contest_date": "2025-01-26T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 5,
    "coverage": null
  },
  "submission_id": 1520580436,
  "mutated_code": "def countPartitions(nums: List[int]) -> int:\n    total = sum(nums)\n    if total // 2 != 0:\n        return 0\n    return len(nums) - 1",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest434_q3721_s0",
  "question_id": 3721,
  "function_name": "countMentions",
  "code": "def countMentions(numberOfUsers: int, events: List[List[str]]) -> List[int]:\n        m = numberOfUsers\n        n = len(events)\n        L = []\n        for event in events:\n            if event[0]=='MESSAGE':\n                t = int(event[1])\n                L.append([t, 2, event[2]])\n            else:\n                t = int(event[1])\n                L.append([t, 0, event[2]])\n                L.append([t+60, 1, event[2]])\n        d = {}\n        for t, x, R in L:\n            if t not in d:\n                d[t] = [[], [], []]\n            d[t][x].append(R)\n        users = set(range(m))\n        answer = [0 for i in range(m)]\n        for t in sorted(d):\n            for user in d[t][1]:\n                users.add(int(user))\n            for user in d[t][0]:\n                user = int(user)\n                if user in users:\n                    users.remove(user)\n            for x in d[t][2]:\n                if x=='ALL':\n                    for i in range(m):\n                        answer[i]+=1\n                elif x=='HERE':\n                    for i in users:\n                        answer[i]+=1\n                else:\n                    x = x.split()\n                    for i in x:\n                        answer[int(i[2:])]+=1\n        return answer",
  "input": "countMentions(numberOfUsers=2, events=[[\"MESSAGE\",\"10\",\"id1 id0\"],[\"OFFLINE\",\"11\",\"0\"],[\"MESSAGE\",\"71\",\"HERE\"]])",
  "output": "[2, 2]",
  "correct_condition": "countMentions(numberOfUsers=2, events=[[\"MESSAGE\",\"10\",\"id1 id0\"],[\"OFFLINE\",\"11\",\"0\"],[\"MESSAGE\",\"71\",\"HERE\"]]) == [2, 2]",
  "contest_id": "weekly-contest-434",
  "contest_date": "2025-01-26T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 38,
    "coverage": null
  },
  "submission_id": 1520610644,
  "mutated_code": "def countMentions(numberOfUsers: int, events: List[List[str]]) -> List[int]:\n    m = numberOfUsers\n    n = len(events)\n    L = []\n    for event in events:\n        if event[0] == 'MESSAGE':\n            t = int(event[1])\n            L.append([t, 2, event[2]])\n        else:\n            t = int(event[1])\n            L.append([t, 0, event[2]])\n            L.append([t - 60, 1, event[2]])\n    d = {}\n    for t, x, R in L:\n        if t not in d:\n            d[t] = [[], [], []]\n        d[t][x].append(R)\n    users = set(range(m))\n    answer = [0 for i in range(m)]\n    for t in sorted(d):\n        for user in d[t][1]:\n            users.add(int(user))\n        for user in d[t][0]:\n            user = int(user)\n            if user in users:\n                users.remove(user)\n        for x in d[t][2]:\n            if x == 'ALL':\n                for i in range(m):\n                    answer[i] += 1\n            elif x == 'HERE':\n                for i in users:\n                    answer[i] += 1\n            else:\n                x = x.split()\n                for i in x:\n                    answer[int(i[2:])] += 1\n    return answer",
  "mutated_output": "[1, 2]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest434_q3721_s2",
  "question_id": 3721,
  "function_name": "countMentions",
  "code": "def countMentions(numberOfUsers: int, events: List[List[str]]) -> List[int]:\n        mentions = [0] * numberOfUsers\n        offline_until = [0] * numberOfUsers\n\n        def sort_events(events: List[List[str]]) -> List[List[str]]:\n          \n            def sort_key(event):\n                ts = int(event[1])\n                event_type_priority = 0 if event[0] == 'OFFLINE' else 1\n                return (ts, event_type_priority)\n\n            return sorted(events, key=sort_key)\n\n        def handle_offline_event(user_id: int, ts: int):\n          \n            offline_until[user_id] = ts + 60\n\n        def handle_message_event(ts: int, payload: str):\n          \n            tokens = payload.split()\n            for token in tokens:\n                if token == 'ALL':\n                    # Mention all users (including offline)\n                    for user in range(numberOfUsers):\n                        mentions[user] += 1\n                elif token == 'HERE':\n                   \n                    for user in range(numberOfUsers):\n                        if offline_until[user] <= ts:\n                            mentions[user] += 1\n                else:  \n                    user = int(token[2:])\n                    mentions[user] += 1\n\n        def process_events(events: List[List[str]]):\n          \n            for event in events:\n                event_type, ts_str, payload = event\n                ts = int(ts_str)\n\n                if event_type == 'OFFLINE':\n                    handle_offline_event(int(payload), ts)\n                elif event_type == 'MESSAGE':\n                    handle_message_event(ts, payload)\n\n        # Sort events and process them\n        sorted_events = sort_events(events)\n        process_events(sorted_events)\n\n        return mentions\n",
  "input": "countMentions(numberOfUsers=2, events=[[\"MESSAGE\",\"10\",\"id1 id0\"],[\"OFFLINE\",\"11\",\"0\"],[\"MESSAGE\",\"71\",\"HERE\"]])",
  "output": "[2, 2]",
  "correct_condition": "countMentions(numberOfUsers=2, events=[[\"MESSAGE\",\"10\",\"id1 id0\"],[\"OFFLINE\",\"11\",\"0\"],[\"MESSAGE\",\"71\",\"HERE\"]]) == [2, 2]",
  "contest_id": "weekly-contest-434",
  "contest_date": "2025-01-26T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 50,
    "coverage": null
  },
  "submission_id": 1520595169,
  "mutated_code": "def countMentions(numberOfUsers: int, events: List[List[str]]) -> List[int]:\n    mentions = [0] * numberOfUsers\n    offline_until = [0] * numberOfUsers\n\n    def sort_events(events: List[List[str]]) -> List[List[str]]:\n\n        def sort_key(event):\n            ts = int(event[1])\n            event_type_priority = 0 if event[0] == 'OFFLINE' else 1\n            return (ts, event_type_priority)\n        return sorted(events, key=sort_key)\n\n    def handle_offline_event(user_id: int, ts: int):\n        offline_until[user_id] = ts + 60\n\n    def handle_message_event(ts: int, payload: str):\n        tokens = payload.split()\n        for token in tokens:\n            if token != 'ALL':\n                for user in range(numberOfUsers):\n                    mentions[user] += 1\n            elif token == 'HERE':\n                for user in range(numberOfUsers):\n                    if offline_until[user] <= ts:\n                        mentions[user] += 1\n            else:\n                user = int(token[2:])\n                mentions[user] += 1\n\n    def process_events(events: List[List[str]]):\n        for event in events:\n            event_type, ts_str, payload = event\n            ts = int(ts_str)\n            if event_type == 'OFFLINE':\n                handle_offline_event(int(payload), ts)\n            elif event_type == 'MESSAGE':\n                handle_message_event(ts, payload)\n    sorted_events = sort_events(events)\n    process_events(sorted_events)\n    return mentions",
  "mutated_output": "[3, 3]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest434_q3751_s0",
  "question_id": 3751,
  "function_name": "maxFrequency",
  "code": "def maxFrequency(nums: List[int], k: int) -> int:\n        n = len(nums)\n        k_count = 0 \n        for x in nums:\n            if x==k:\n                k_count+=1\n        answer = k_count\n        for x in range(1, 51):\n            curr_k = 0 \n            my_min = 0\n            x_count = 0 \n            for i in range(n):\n                if nums[i]==x:\n                    x_count+=1 \n                if nums[i]==k:\n                    curr_k+=1\n                my_min = min(my_min, x_count-curr_k)\n                answer = max(answer, x_count-my_min+k_count-curr_k)\n                #best you can do \n                #is [k-count best-freq]+rema\n                #x-freq - \n        return answer\n        \n        ",
  "input": "maxFrequency(nums=[1,2,3,4,5,6], k=1)",
  "output": "2",
  "correct_condition": "maxFrequency(nums=[1,2,3,4,5,6], k=1) == 2",
  "contest_id": "weekly-contest-434",
  "contest_date": "2025-01-26T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 24,
    "coverage": null
  },
  "submission_id": 1520594425,
  "mutated_code": "def maxFrequency(nums: List[int], k: int) -> int:\n    n = len(nums)\n    k_count = 0\n    for x in nums:\n        if x == k:\n            k_count += 1\n    answer = k_count\n    for x in range(1, 51):\n        curr_k = 0\n        my_min = 0\n        x_count = 0\n        for i in range(n):\n            if nums[i] == x:\n                x_count += 1\n            if nums[i] == k:\n                curr_k += 1\n            my_min = min(my_min, x_count + curr_k)\n            answer = max(answer, x_count - my_min + k_count - curr_k)\n    return answer",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest434_q3751_s2",
  "question_id": 3751,
  "function_name": "maxFrequency",
  "code": "def maxFrequency(nums: List[int], k: int) -> int:\n        import sys\n\n        def count_k_occurrences(nums: List[int], k: int) -> int:\n          \n            return sum(1 for x in nums if x == k)\n\n        def build_array(nums: List[int], k: int, v: int) -> List[int]:\n        \n            return [1 if x == v else -1 if x == k else 0 for x in nums]\n\n        def find_max_subarray_sum(arr: List[int]) -> int:\n          \n            current_sum = 0\n            max_sum = -sys.maxsize\n            for val in arr:\n                current_sum = max(val, current_sum + val)\n                max_sum = max(max_sum, current_sum)\n            return max_sum\n\n        def calculate_best_gain(nums: List[int], k: int, n: int) -> int:\n         \n            best_gain = 0\n            for v in range(1, 51):\n                if v == k:\n                    continue\n                arr = build_array(nums, k, v)\n                max_sum = find_max_subarray_sum(arr)\n                if max_sum > best_gain:\n                    best_gain = max_sum\n            return best_gain\n\n        n = len(nums)\n        base_k = count_k_occurrences(nums, k)\n\n        if base_k == n:\n            return n\n\n        best_gain = calculate_best_gain(nums, k, n)\n        return base_k + max(0, best_gain)\n",
  "input": "maxFrequency(nums=[1,2,3,4,5,6], k=1)",
  "output": "2",
  "correct_condition": "maxFrequency(nums=[1,2,3,4,5,6], k=1) == 2",
  "contest_id": "weekly-contest-434",
  "contest_date": "2025-01-26T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 40,
    "coverage": null
  },
  "submission_id": 1520602804,
  "mutated_code": "def maxFrequency(nums: List[int], k: int) -> int:\n    import sys\n\n    def count_k_occurrences(nums: List[int], k: int) -> int:\n        return sum((1 for x in nums if x == k))\n\n    def build_array(nums: List[int], k: int, v: int) -> List[int]:\n        return [1 if x == v else -1 if x == k else 0 for x in nums]\n\n    def find_max_subarray_sum(arr: List[int]) -> int:\n        current_sum = 0\n        max_sum = -sys.maxsize\n        for val in arr:\n            current_sum = max(val, current_sum + val)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    def calculate_best_gain(nums: List[int], k: int, n: int) -> int:\n        best_gain = 0\n        for v in range(1, 51):\n            if v == k:\n                continue\n            arr = build_array(nums, k, v)\n            max_sum = find_max_subarray_sum(arr)\n            if max_sum > best_gain:\n                best_gain = max_sum\n        return best_gain\n    n = len(nums)\n    base_k = count_k_occurrences(nums, k)\n    if base_k == n:\n        return n\n    best_gain = calculate_best_gain(nums, k, n)\n    return base_k - max(0, best_gain)",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest435_q3753_s0",
  "question_id": 3753,
  "function_name": "maxDifference",
  "code": "def maxDifference(s: str) -> int:\n        freq = Counter(s)\n        odd = [c for c in freq.values() if c % 2]\n        even = [c for c in freq.values() if c % 2 == 0]\n        return max(odd) - min(even) if odd and even else -1",
  "input": "maxDifference(s=\"aaaaabbc\")",
  "output": "3",
  "correct_condition": "maxDifference(s=\"aaaaabbc\") == 3",
  "contest_id": "weekly-contest-435",
  "contest_date": "2025-02-02T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 5,
    "coverage": null
  },
  "submission_id": 1528081228,
  "mutated_code": "def maxDifference(s: str) -> int:\n    freq = Counter(s)\n    odd = [c for c in freq.values() if c % 2]\n    even = [c for c in freq.values() if c // 2 == 0]\n    return max(odd) - min(even) if odd and even else -1",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest435_q3753_s1",
  "question_id": 3753,
  "function_name": "maxDifference",
  "code": "def maxDifference(s: str) -> int:\n        count = [0] * 26\n        for c in s:\n            count[ord(c) - ord('a')] += 1\n        odd = -1\n        even = float('inf')\n        for x in count:\n            if x:\n                if x % 2 == 0:\n                    even = min(even, x)\n                else:\n                    odd = max(odd, x)\n        return odd - even\n\n",
  "input": "maxDifference(s=\"aaaaabbc\")",
  "output": "3",
  "correct_condition": "maxDifference(s=\"aaaaabbc\") == 3",
  "contest_id": "weekly-contest-435",
  "contest_date": "2025-02-02T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1528102981,
  "mutated_code": "def maxDifference(s: str) -> int:\n    count = [0] * 26\n    for c in s:\n        count[ord(c) - ord('a')] += 1\n    odd = -1\n    even = float('inf')\n    for x in count:\n        if x:\n            if x // 2 == 0:\n                even = min(even, x)\n            else:\n                odd = max(odd, x)\n    return odd - even",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest435_q3754_s0",
  "question_id": 3754,
  "function_name": "maxDistance",
  "code": "def maxDistance(s: str, k: int) -> int:\n        res = 0\n        e = w = n = s_count = 0\n        for i, ch in enumerate(s, 1):\n            if ch == 'E': e += 1\n            elif ch == 'W': w += 1\n            elif ch == 'N': n += 1\n            else: s_count += 1\n            bx = abs(e - w)\n            hx = min(e, w)\n            by = abs(n - s_count)\n            hy = min(n, s_count)\n            cur = bx + by + 2 * min(k, hx + hy)\n            if cur > i: cur = i\n            if cur > res: res = cur\n        return res",
  "input": "maxDistance(s=\"NWSE\", k=1)",
  "output": "3",
  "correct_condition": "maxDistance(s=\"NWSE\", k=1) == 3",
  "contest_id": "weekly-contest-435",
  "contest_date": "2025-02-02T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 16,
    "coverage": null
  },
  "submission_id": 1528089568,
  "mutated_code": "def maxDistance(s: str, k: int) -> int:\n    res = 0\n    e = w = n = s_count = 0\n    for i, ch in enumerate(s, 1):\n        if ch == 'E':\n            e += 1\n        elif ch == 'W':\n            w += 1\n        elif ch == 'N':\n            n += 1\n        else:\n            s_count += 1\n        bx = abs(e + w)\n        hx = min(e, w)\n        by = abs(n - s_count)\n        hy = min(n, s_count)\n        cur = bx + by + 2 * min(k, hx + hy)\n        if cur > i:\n            cur = i\n        if cur > res:\n            res = cur\n    return res",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest435_q3754_s1",
  "question_id": 3754,
  "function_name": "maxDistance",
  "code": "def maxDistance(s: str, k: int) -> int:\n        n, a, c = len(s), 0, Counter()\n        \n        u = lambda x: c.update(x)\n        d = lambda x, y: abs(c[x] - c[y])\n        f = lambda x, y: min(c[x], c[y])\n        \n        for i, x in enumerate(s):\n            u(x)\n            dx, dy = d('E', 'W'), d('N', 'S')\n            fc = f('E', 'W') + f('N', 'S')\n            cand = min(dx + dy + 2 * min(k, fc), i + 1)\n            a = max(a, cand)\n        \n        return a\n",
  "input": "maxDistance(s=\"NWSE\", k=1)",
  "output": "3",
  "correct_condition": "maxDistance(s=\"NWSE\", k=1) == 3",
  "contest_id": "weekly-contest-435",
  "contest_date": "2025-02-02T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1528113622,
  "mutated_code": "def maxDistance(s: str, k: int) -> int:\n    n, a, c = (len(s), 0, Counter())\n    u = lambda x: c.update(x)\n    d = lambda x, y: abs(c[x] + c[y])\n    f = lambda x, y: min(c[x], c[y])\n    for i, x in enumerate(s):\n        u(x)\n        dx, dy = (d('E', 'W'), d('N', 'S'))\n        fc = f('E', 'W') + f('N', 'S')\n        cand = min(dx + dy + 2 * min(k, fc), i + 1)\n        a = max(a, cand)\n    return a",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest435_q3697_s0",
  "question_id": 3697,
  "function_name": "minimumIncrements",
  "code": "def minimumIncrements(nums: List[int], target: List[int]) -> int:\n        m = len(target)\n        full = (1 << m) - 1\n        subs = []\n        for s in range(1, 1 << m):\n            lcm_val = 1\n            for i in range(m):\n                if s >> i & 1:\n                    lcm_val = lcm_val * target[i] // gcd(lcm_val, target[i])\n            subs.append((s, lcm_val))\n        INF = 10**19\n        dp = [INF] * (1 << m)\n        dp[0] = 0\n        for a in nums:\n            ndp = dp[:]\n            for mask in range(1 << m):\n                if dp[mask] == INF:\n                    continue\n                for s, l in subs:\n                    nm = mask | s\n                    cost = (l - (a % l)) % l\n                    ndp[nm] = min(ndp[nm], dp[mask] + cost)\n            dp = ndp\n        return dp[full]",
  "input": "minimumIncrements(nums=[1,2,3], target=[4])",
  "output": "1",
  "correct_condition": "minimumIncrements(nums=[1,2,3], target=[4]) == 1",
  "contest_id": "weekly-contest-435",
  "contest_date": "2025-02-02T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 24,
    "coverage": null
  },
  "submission_id": 1528091022,
  "mutated_code": "def minimumIncrements(nums: List[int], target: List[int]) -> int:\n    m = len(target)\n    full = (1 << m) - 1\n    subs = []\n    for s in range(1, 1 << m):\n        lcm_val = 1\n        for i in range(m):\n            if s >> i & 1:\n                lcm_val = lcm_val * target[i] // gcd(lcm_val, target[i])\n        subs.append((s, lcm_val))\n    INF = 10 ** 19\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for a in nums:\n        ndp = dp[:]\n        for mask in range(1 << m):\n            if dp[mask] == INF:\n                continue\n            for s, l in subs:\n                nm = mask | s\n                cost = (l - a % l) // l\n                ndp[nm] = min(ndp[nm], dp[mask] + cost)\n        dp = ndp\n    return dp[full]",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 4,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest435_q3761_s0",
  "question_id": 3761,
  "function_name": "maxDifference",
  "code": "def maxDifference(s: str, k: int) -> int:\n        INF = 10**9\n        n = len(s)\n        ans = -10**9\n        for x in range(5):\n            for y in range(5):\n                if x == y:\n                    continue\n                N = n + 1\n                D = [0] * N\n                PX = [0] * N\n                PY = [0] * N\n                CNT = [0] * N\n                sx = str(x)\n                sy = str(y)\n                for i in range(n):\n                    D[i+1] = D[i] + (1 if s[i] == sx else 0) - (1 if s[i] == sy else 0)\n                    PX[i+1] = (PX[i] + (1 if s[i] == sx else 0)) & 1\n                    PY[i+1] = (PY[i] + (1 if s[i] == sy else 0)) & 1\n                    CNT[i+1] = CNT[i] + (1 if s[i] == sy else 0)\n                mp = {(0,0): [], (0,1): [], (1,0): [], (1,1): []}\n                cum = {(0,0): [], (0,1): [], (1,0): [], (1,1): []}\n                key0 = (PX[0], PY[0])\n                mp[key0].append((CNT[0], D[0]))\n                cum[key0].append(D[0])\n                best = -10**9\n                p = 1\n                for r in range(k, N):\n                    while p <= r - k:\n                        key = (PX[p], PY[p])\n                        mp[key].append((CNT[p], D[p]))\n                        if cum[key]:\n                            cum[key].append(min(cum[key][-1], D[p]))\n                        else:\n                            cum[key].append(D[p])\n                        p += 1\n                    keyq = (1 - PX[r], PY[r])\n                    arr = mp[keyq]\n                    if not arr:\n                        continue\n                    pos = bisect_left(arr, (CNT[r], -10**9))\n                    if pos:\n                        cand = D[r] - cum[keyq][pos-1]\n                        if cand > best:\n                            best = cand\n                if best > ans:\n                    ans = best\n        return ans\n\n",
  "input": "maxDifference(s=\"12233\", k=4)",
  "output": "-1",
  "correct_condition": "maxDifference(s=\"12233\", k=4) == -1",
  "contest_id": "weekly-contest-435",
  "contest_date": "2025-02-02T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 49,
    "coverage": null
  },
  "submission_id": 1528104807,
  "mutated_code": "def maxDifference(s: str, k: int) -> int:\n    INF = 10 ** 9\n    n = len(s)\n    ans = -10 ** 9\n    for x in range(5):\n        for y in range(5):\n            if x == y:\n                continue\n            N = n + 1\n            D = [0] * N\n            PX = [0] * N\n            PY = [0] * N\n            CNT = [0] * N\n            sx = str(x)\n            sy = str(y)\n            for i in range(n):\n                D[i - 1] = D[i] + (1 if s[i] == sx else 0) - (1 if s[i] == sy else 0)\n                PX[i + 1] = PX[i] + (1 if s[i] == sx else 0) & 1\n                PY[i + 1] = PY[i] + (1 if s[i] == sy else 0) & 1\n                CNT[i + 1] = CNT[i] + (1 if s[i] == sy else 0)\n            mp = {(0, 0): [], (0, 1): [], (1, 0): [], (1, 1): []}\n            cum = {(0, 0): [], (0, 1): [], (1, 0): [], (1, 1): []}\n            key0 = (PX[0], PY[0])\n            mp[key0].append((CNT[0], D[0]))\n            cum[key0].append(D[0])\n            best = -10 ** 9\n            p = 1\n            for r in range(k, N):\n                while p <= r - k:\n                    key = (PX[p], PY[p])\n                    mp[key].append((CNT[p], D[p]))\n                    if cum[key]:\n                        cum[key].append(min(cum[key][-1], D[p]))\n                    else:\n                        cum[key].append(D[p])\n                    p += 1\n                keyq = (1 - PX[r], PY[r])\n                arr = mp[keyq]\n                if not arr:\n                    continue\n                pos = bisect_left(arr, (CNT[r], -10 ** 9))\n                if pos:\n                    cand = D[r] - cum[keyq][pos - 1]\n                    if cand > best:\n                        best = cand\n            if best > ans:\n                ans = best\n    return ans",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 5,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3748_s0",
  "question_id": 3748,
  "function_name": "sortMatrix",
  "code": "def sortMatrix(grid: List[List[int]]) -> List[List[int]]:\n        n = len(grid)\n        x = 0\n        y = n - 1\n        while True:\n            pos = []\n            cur = 0\n            while x + cur < n and y + cur < n:\n                pos.append(grid[x + cur][y + cur])\n                cur += 1\n            cur = 0\n            if y > 0:\n                pos.sort()\n            else:\n                pos.sort(reverse=True)\n            while x + cur < n and y + cur < n:\n                grid[x + cur][y + cur] = pos[cur]\n                cur += 1\n            \n\n\n            if y > 0:\n                y -= 1\n            elif x < n - 1:\n                x += 1\n            else:\n                break\n        return grid\n        ",
  "input": "sortMatrix(grid=[[1,7,3],[9,8,2],[4,5,6]])",
  "output": "[[8, 2, 3], [9, 6, 7], [4, 5, 1]]",
  "correct_condition": "sortMatrix(grid=[[1,7,3],[9,8,2],[4,5,6]]) == [[8, 2, 3], [9, 6, 7], [4, 5, 1]]",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 29,
    "coverage": null
  },
  "submission_id": 1536399828,
  "mutated_code": "def sortMatrix(grid: List[List[int]]) -> List[List[int]]:\n    n = len(grid)\n    x = 0\n    y = n - 1\n    while True:\n        pos = []\n        cur = 0\n        while x + cur < n and y + cur < n:\n            pos.append(grid[x - cur][y + cur])\n            cur += 1\n        cur = 0\n        if y > 0:\n            pos.sort()\n        else:\n            pos.sort(reverse=True)\n        while x + cur < n and y + cur < n:\n            grid[x + cur][y + cur] = pos[cur]\n            cur += 1\n        if y > 0:\n            y -= 1\n        elif x < n - 1:\n            x += 1\n        else:\n            break\n    return grid",
  "mutated_output": "[[7, 6, 3], [9, 5, 7], [4, 6, 1]]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3748_s1",
  "question_id": 3748,
  "function_name": "sortMatrix",
  "code": "def sortMatrix(grid: List[List[int]]) -> List[List[int]]:\n        graph = collections.defaultdict(list)\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                graph[i-j].append(grid[i][j])\n        \n        for key in graph:\n            if key >= 0:\n                graph[key].sort()\n            else:\n                graph[key].sort(reverse=True)\n                \n        #print(graph)\n        \n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                grid[i][j] = graph[i-j].pop()\n        return grid",
  "input": "sortMatrix(grid=[[1,7,3],[9,8,2],[4,5,6]])",
  "output": "[[8, 2, 3], [9, 6, 7], [4, 5, 1]]",
  "correct_condition": "sortMatrix(grid=[[1,7,3],[9,8,2],[4,5,6]]) == [[8, 2, 3], [9, 6, 7], [4, 5, 1]]",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 20,
    "coverage": null
  },
  "submission_id": 1536396372,
  "mutated_code": "def sortMatrix(grid: List[List[int]]) -> List[List[int]]:\n    graph = collections.defaultdict(list)\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            graph[i - j].append(grid[i][j])\n    for key in graph:\n        if key > 0:\n            graph[key].sort()\n        else:\n            graph[key].sort(reverse=True)\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            grid[i][j] = graph[i - j].pop()\n    return grid",
  "mutated_output": "[[1, 2, 3], [9, 6, 7], [4, 5, 8]]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3748_s2",
  "question_id": 3748,
  "function_name": "sortMatrix",
  "code": "def sortMatrix(grid: List[List[int]]) -> List[List[int]]:\n        n = len(grid)\n        c = defaultdict(list)\n        for i in range(n):\n            for j in range(n):\n                c[i - j].append(grid[i][j])\n        for k in c.keys():\n            if k >= 0:\n                c[k].sort()\n            else:\n                c[k].sort(reverse=True)\n        \n        for i in range(n):\n            for j in range(n):\n                f = i - j\n                grid[i][j] = c[f][-1]\n                c[f].pop()\n        \n        return grid",
  "input": "sortMatrix(grid=[[1,7,3],[9,8,2],[4,5,6]])",
  "output": "[[8, 2, 3], [9, 6, 7], [4, 5, 1]]",
  "correct_condition": "sortMatrix(grid=[[1,7,3],[9,8,2],[4,5,6]]) == [[8, 2, 3], [9, 6, 7], [4, 5, 1]]",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 19,
    "coverage": null
  },
  "submission_id": 1536461192,
  "mutated_code": "def sortMatrix(grid: List[List[int]]) -> List[List[int]]:\n    n = len(grid)\n    c = defaultdict(list)\n    for i in range(n):\n        for j in range(n):\n            c[i - j].append(grid[i][j])\n    for k in c.keys():\n        if k > 0:\n            c[k].sort()\n        else:\n            c[k].sort(reverse=True)\n    for i in range(n):\n        for j in range(n):\n            f = i - j\n            grid[i][j] = c[f][-1]\n            c[f].pop()\n    return grid",
  "mutated_output": "[[1, 2, 3], [9, 6, 7], [4, 5, 8]]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3760_s0",
  "question_id": 3760,
  "function_name": "assignElements",
  "code": "def assignElements(groups: List[int], elements: List[int]) -> List[int]:\n        s = set()\n        dic = defaultdict(int)\n        for i, e in enumerate(elements):\n            if e in s:\n                continue\n            t = 1\n            while e * t <= 100000:\n                if e * t not in dic:\n                    dic[e * t] = i\n                t += 1\n            s.add(e)\n        res = []\n        for g in groups:\n            if g in dic:\n                res.append(dic[g])\n            else:\n                res.append(-1)\n        return res\n\n        \n        \n        ",
  "input": "assignElements(groups=[8,4,3,2,4], elements=[4,2])",
  "output": "[0, 0, -1, 1, 0]",
  "correct_condition": "assignElements(groups=[8,4,3,2,4], elements=[4,2]) == [0, 0, -1, 1, 0]",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 23,
    "coverage": null
  },
  "submission_id": 1536410003,
  "mutated_code": "def assignElements(groups: List[int], elements: List[int]) -> List[int]:\n    s = set()\n    dic = defaultdict(int)\n    for i, e in enumerate(elements):\n        if e in s:\n            continue\n        t = 1\n        while e * t <= 100000:\n            if e // t not in dic:\n                dic[e * t] = i\n            t += 1\n        s.add(e)\n    res = []\n    for g in groups:\n        if g in dic:\n            res.append(dic[g])\n        else:\n            res.append(-1)\n    return res",
  "mutated_output": "[1, 1, -1, 1, 1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3760_s1",
  "question_id": 3760,
  "function_name": "assignElements",
  "code": "def assignElements(groups: List[int], elements: List[int]) -> List[int]:\n        res = [-1]*len(groups)\n        \n        max_value = max(groups)\n        \n        \n        mapper = collections.defaultdict(list)\n        \n        for i,x in enumerate(groups):\n            mapper[x].append(i)\n        \n        seen = set()\n        for j in range(len(elements)):\n            if elements[j] in seen:\n                continue\n            seen.add(elements[j])\n            curr = elements[j]\n            increment = elements[j]\n            while curr <= max_value:\n                if curr in mapper:\n                    while mapper[curr]:\n                        res[mapper[curr].pop()] = j\n                curr += increment\n        return res",
  "input": "assignElements(groups=[8,4,3,2,4], elements=[4,2])",
  "output": "[0, 0, -1, 1, 0]",
  "correct_condition": "assignElements(groups=[8,4,3,2,4], elements=[4,2]) == [0, 0, -1, 1, 0]",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 24,
    "coverage": null
  },
  "submission_id": 1536400600,
  "mutated_code": "def assignElements(groups: List[int], elements: List[int]) -> List[int]:\n    res = [-1] * len(groups)\n    max_value = max(groups)\n    mapper = collections.defaultdict(list)\n    for i, x in enumerate(groups):\n        mapper[x].append(i)\n    seen = set()\n    for j in range(len(elements)):\n        if elements[j] in seen:\n            continue\n        seen.add(elements[j])\n        curr = elements[j]\n        increment = elements[j]\n        while curr < max_value:\n            if curr in mapper:\n                while mapper[curr]:\n                    res[mapper[curr].pop()] = j\n            curr += increment\n    return res",
  "mutated_output": "[-1, 0, -1, 1, 0]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3760_s2",
  "question_id": 3760,
  "function_name": "assignElements",
  "code": "def assignElements(groups: List[int], elements: List[int]) -> List[int]:\n        seen = set()\n        T = max(groups)\n        pre = [-1] * (T + 1)\n        for u, e in enumerate(elements):\n            if e in seen:\n                continue\n            seen.add(e)\n            i = e\n            while i <= T:\n                if pre[i] == -1:\n                    pre[i] = u\n                i += e\n        \n        ans = list()\n        for o in groups:\n            ans.append(pre[o])\n        return ans",
  "input": "assignElements(groups=[8,4,3,2,4], elements=[4,2])",
  "output": "[0, 0, -1, 1, 0]",
  "correct_condition": "assignElements(groups=[8,4,3,2,4], elements=[4,2]) == [0, 0, -1, 1, 0]",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 18,
    "coverage": null
  },
  "submission_id": 1536457071,
  "mutated_code": "def assignElements(groups: List[int], elements: List[int]) -> List[int]:\n    seen = set()\n    T = max(groups)\n    pre = [-1] * (T + 1)\n    for u, e in enumerate(elements):\n        if e in seen:\n            continue\n        seen.add(e)\n        i = e\n        while i < T:\n            if pre[i] == -1:\n                pre[i] = u\n            i += e\n    ans = list()\n    for o in groups:\n        ans.append(pre[o])\n    return ans",
  "mutated_output": "[-1, 0, -1, 1, 0]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3696_s0",
  "question_id": 3696,
  "function_name": "countSubstrings",
  "code": "def countSubstrings(s: str) -> int:\n        n = len(s)\n        res = 0\n        \n        mod3 = [1, 0, 0]\n        sum3 = 0\n    \n        mod9 = [1] + [0] * 8\n        sum9 = 0\n    \n        mod7 = [1] + [0] * 6\n        sum7 = 0\n        \n        pow5 = 1\n    \n        for i, c in enumerate(s):\n            d = int(c)\n            sum3 = (sum3 + d) % 3\n            sum9 = (sum9 + d) % 9\n            sum7 = (sum7 * 10 + d) % 7\n            R = (sum7 * pow5) % 7\n    \n            if c in '125':\n                res += (i + 1)\n            elif c in '36':\n                res += mod3[sum3]\n            elif c == '9':\n                res += mod9[sum9]\n            elif c == '4':\n                if i == 0:\n                    res += 1\n                else:\n                    v = int(s[i - 1]) * 10 + d\n                    if v % 4 == 0:\n                        res += (i + 1)\n                    else:\n                        res += 1\n            elif c == '8':\n                if i == 0:\n                    res += 1\n                elif i == 1:\n                    v = int(s[i - 1]) * 10 + d\n                    if v % 8 == 0:\n                        res += 2\n                    else:\n                        res += 1\n                else:\n                    v1 = int(s[i - 1]) * 10 + d\n                    v2 = int(s[i - 2]) * 100 + int(s[i - 1]) * 10 + d\n                    add_two = 1 if v1 % 8 == 0 else 0\n                    add_three = (i - 1) if v2 % 8 == 0 else 0\n                    res += 1 + add_two + add_three\n    \n            if c == '7':\n                res += mod7[R]\n    \n            mod3[sum3] += 1\n            mod9[sum9] += 1\n            mod7[R] += 1\n    \n            pow5 = (pow5 * 5) % 7\n            # print(res)\n    \n        return res",
  "input": "countSubstrings(s=\"12936\")",
  "output": "11",
  "correct_condition": "countSubstrings(s=\"12936\") == 11",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 64,
    "coverage": null
  },
  "submission_id": 1536442634,
  "mutated_code": "def countSubstrings(s: str) -> int:\n    n = len(s)\n    res = 0\n    mod3 = [1, 0, 0]\n    sum3 = 0\n    mod9 = [1] + [0] * 8\n    sum9 = 0\n    mod7 = [1] + [0] * 6\n    sum7 = 0\n    pow5 = 1\n    for i, c in enumerate(s):\n        d = int(c)\n        sum3 = (sum3 + d) % 3\n        sum9 = (sum9 + d) // 9\n        sum7 = (sum7 * 10 + d) % 7\n        R = sum7 * pow5 % 7\n        if c in '125':\n            res += i + 1\n        elif c in '36':\n            res += mod3[sum3]\n        elif c == '9':\n            res += mod9[sum9]\n        elif c == '4':\n            if i == 0:\n                res += 1\n            else:\n                v = int(s[i - 1]) * 10 + d\n                if v % 4 == 0:\n                    res += i + 1\n                else:\n                    res += 1\n        elif c == '8':\n            if i == 0:\n                res += 1\n            elif i == 1:\n                v = int(s[i - 1]) * 10 + d\n                if v % 8 == 0:\n                    res += 2\n                else:\n                    res += 1\n            else:\n                v1 = int(s[i - 1]) * 10 + d\n                v2 = int(s[i - 2]) * 100 + int(s[i - 1]) * 10 + d\n                add_two = 1 if v1 % 8 == 0 else 0\n                add_three = i - 1 if v2 % 8 == 0 else 0\n                res += 1 + add_two + add_three\n        if c == '7':\n            res += mod7[R]\n        mod3[sum3] += 1\n        mod9[sum9] += 1\n        mod7[R] += 1\n        pow5 = pow5 * 5 % 7\n    return res",
  "mutated_output": "10",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 6,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3696_s1",
  "question_id": 3696,
  "function_name": "countSubstrings",
  "code": "def countSubstrings(s: str) -> int:\n        debug = False\n        ans = 0\n\n        hash_table_3 = collections.defaultdict(int)\n        hash_table_3[0] += 1\n        hash_table_9 = collections.defaultdict(int)\n        hash_table_9[0] += 1\n\n        digit_sum_3 = 0\n        digit_sum_9 = 0\n\n        for i,char in enumerate(s):\n            digit_sum_3 += int(char)\n            digit_sum_3 = digit_sum_3%3\n\n\n            digit_sum_9 += int(char)\n            digit_sum_9 = digit_sum_9%9\n\n\n            if char == \"1\":\n                ans += (i+1)\n            elif char == \"2\":\n                ans += (i+1)\n            elif char == \"3\":\n                ans += hash_table_3[digit_sum_3]\n            elif char == \"4\":\n                if i == 0:\n                    ans += 1\n                else:\n                    Z = int(s[i-1])*10 + int(s[i])\n                    if Z%4 == 0:\n                        ans += (i+1)\n                    else:\n                        ans += 1\n            elif char == \"5\":\n                ans += (i+1)\n\n            elif char == \"6\":\n                ans += hash_table_3[digit_sum_3]\n            elif char == \"8\":\n                ans += 1\n\n                if i-1 >= 0:\n                    Z = int(s[i-1])*10 + int(s[i])\n                    if Z%8 == 0:\n                        ans += 1\n                if i-2 >= 0:\n                    Z = int(s[i-2])*100 + int(s[i-1])*10 + int(s[i])\n                    if Z%8 == 0:\n                        ans += (i-2+1)\n            elif char == \"9\":\n                ans += hash_table_9[digit_sum_9]\n            #print(ans,digit_sum_9,hash_table_9,'3_data',digit_sum_3,hash_table_3)\n\n            hash_table_3[digit_sum_3] += 1\n            hash_table_9[digit_sum_9] += 1\n\n        curr_sums = [0]*10\n        curr_sums[0] = 1\n\n        curr = 0\n        #ans = 0\n        for i in range(len(s)):\n            curr = (10*curr + int(s[i]))%7\n            new_curr_sums = [0]*10\n            for j in range(len(curr_sums)):\n                new_curr_sums[(j*10)%7] += curr_sums[j]\n            curr_sums = list(new_curr_sums)\n\n            if s[i] == \"7\":\n                ans += curr_sums[curr]\n            curr_sums[curr] += 1\n\n        return ans\n                ",
  "input": "countSubstrings(s=\"12936\")",
  "output": "11",
  "correct_condition": "countSubstrings(s=\"12936\") == 11",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 77,
    "coverage": null
  },
  "submission_id": 1536459645,
  "mutated_code": "def countSubstrings(s: str) -> int:\n    debug = False\n    ans = 0\n    hash_table_3 = collections.defaultdict(int)\n    hash_table_3[0] += 1\n    hash_table_9 = collections.defaultdict(int)\n    hash_table_9[0] += 1\n    digit_sum_3 = 0\n    digit_sum_9 = 0\n    for i, char in enumerate(s):\n        digit_sum_3 += int(char)\n        digit_sum_3 = digit_sum_3 // 3\n        digit_sum_9 += int(char)\n        digit_sum_9 = digit_sum_9 % 9\n        if char == '1':\n            ans += i + 1\n        elif char == '2':\n            ans += i + 1\n        elif char == '3':\n            ans += hash_table_3[digit_sum_3]\n        elif char == '4':\n            if i == 0:\n                ans += 1\n            else:\n                Z = int(s[i - 1]) * 10 + int(s[i])\n                if Z % 4 == 0:\n                    ans += i + 1\n                else:\n                    ans += 1\n        elif char == '5':\n            ans += i + 1\n        elif char == '6':\n            ans += hash_table_3[digit_sum_3]\n        elif char == '8':\n            ans += 1\n            if i - 1 >= 0:\n                Z = int(s[i - 1]) * 10 + int(s[i])\n                if Z % 8 == 0:\n                    ans += 1\n            if i - 2 >= 0:\n                Z = int(s[i - 2]) * 100 + int(s[i - 1]) * 10 + int(s[i])\n                if Z % 8 == 0:\n                    ans += i - 2 + 1\n        elif char == '9':\n            ans += hash_table_9[digit_sum_9]\n        hash_table_3[digit_sum_3] += 1\n        hash_table_9[digit_sum_9] += 1\n    curr_sums = [0] * 10\n    curr_sums[0] = 1\n    curr = 0\n    for i in range(len(s)):\n        curr = (10 * curr + int(s[i])) % 7\n        new_curr_sums = [0] * 10\n        for j in range(len(curr_sums)):\n            new_curr_sums[j * 10 % 7] += curr_sums[j]\n        curr_sums = list(new_curr_sums)\n        if s[i] == '7':\n            ans += curr_sums[curr]\n        curr_sums[curr] += 1\n    return ans",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3696_s2",
  "question_id": 3696,
  "function_name": "countSubstrings",
  "code": "def countSubstrings(s: str) -> int:\n        ans = 0\n        dp = [[0] * i for i in range(10)]\n        for i in range(1, 10):\n            dp[i][0] = 1\n        for c in s:\n            num = int(c)\n            newdp = [[0] * i for i in range(10)]\n            for i in range(1, 10):\n                for j in range(i):\n                    newdp[i][(j * 10 + num) % i] += dp[i][j]\n            if num != 0:\n                ans += newdp[num][0]\n            for i in range(1, 10):\n                newdp[i][0] += 1\n            dp = newdp\n        return ans\n        ",
  "input": "countSubstrings(s=\"12936\")",
  "output": "11",
  "correct_condition": "countSubstrings(s=\"12936\") == 11",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 18,
    "coverage": null
  },
  "submission_id": 1536441757,
  "mutated_code": "def countSubstrings(s: str) -> int:\n    ans = 0\n    dp = [[0] * i for i in range(10)]\n    for i in range(1, 10):\n        dp[i][0] = 1\n    for c in s:\n        num = int(c)\n        newdp = [[0] * i for i in range(10)]\n        for i in range(1, 10):\n            for j in range(i):\n                newdp[i][(j // 10 + num) % i] += dp[i][j]\n        if num != 0:\n            ans += newdp[num][0]\n        for i in range(1, 10):\n            newdp[i][0] += 1\n        dp = newdp\n    return ans",
  "mutated_output": "15",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 4,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3762_s0",
  "question_id": 3762,
  "function_name": "maxScore",
  "code": "def maxScore(points: List[int], m: int) -> int:\n        n = len(points)\n\n        def check(threshold):\n            needs = [0] * n\n            for i in range(n):\n                if threshold == 0:\n                    needs[i] = 0\n                else:\n                    needs[i] = (threshold - 1) // points[i] + 1\n            # print(threshold)\n            # print(needs)\n\n            count = 0\n            for i in range(n):\n                if needs[i] <= 0:\n                    if i != n - 1:\n                        count += 1\n                else:\n                    count += 2 * needs[i] - 1\n                    if i != n - 1:\n                        needs[i + 1] -= (needs[i] - 1)\n            \n            return count <= m\n    \n        left = 0\n        right = m * min(points)\n        while left < right:\n            mid = right - (right - left) // 2\n            if check(mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left\n\n    ",
  "input": "maxScore(points=[2,4], m=3)",
  "output": "4",
  "correct_condition": "maxScore(points=[2,4], m=3) == 4",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 36,
    "coverage": null
  },
  "submission_id": 1536475077,
  "mutated_code": "def maxScore(points: List[int], m: int) -> int:\n    n = len(points)\n\n    def check(threshold):\n        needs = [0] * n\n        for i in range(n):\n            if threshold == 0:\n                needs[i] = 0\n            else:\n                needs[i] = (threshold - 1) // points[i] - 1\n        count = 0\n        for i in range(n):\n            if needs[i] <= 0:\n                if i != n - 1:\n                    count += 1\n            else:\n                count += 2 * needs[i] - 1\n                if i != n - 1:\n                    needs[i + 1] -= needs[i] - 1\n        return count <= m\n    left = 0\n    right = m * min(points)\n    while left < right:\n        mid = right - (right - left) // 2\n        if check(mid):\n            left = mid\n        else:\n            right = mid - 1\n    return left",
  "mutated_output": "6",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3762_s1",
  "question_id": 3762,
  "function_name": "maxScore",
  "code": "def maxScore(points: List[int], m: int) -> int:\n        l = 1\n        r = 10**15\n        \n        \n        def check(target):\n            used = 0\n            \n            forward_count = 0\n            for i in range(len(points)):\n                needed = target-forward_count #-points[i]\n                if needed > 0 or i+1 < len(points):\n                    used += 1\n                    needed = target-forward_count -points[i]\n                \n                if needed > 0:\n                    G = (needed + points[i] - 1)//points[i]\n                    if i+1 < len(points):\n                        forward_count = G*points[i+1]\n                    else:\n                        forward_count = 0\n                    used += (G*2)\n                else:\n                    forward_count = 0\n                if used > m:\n                    return False\n               \n            return used <= m\n                \n            \n            \n        \n        best_ans = 0\n        while l <= r:\n            mid = l + (r-l)//2\n            #print(mid,check(mid))\n            if check(mid):\n                best_ans = mid\n                l = mid+1\n            else:\n                r = mid-1\n        return best_ans",
  "input": "maxScore(points=[2,4], m=3)",
  "output": "4",
  "correct_condition": "maxScore(points=[2,4], m=3) == 4",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 42,
    "coverage": null
  },
  "submission_id": 1536483553,
  "mutated_code": "def maxScore(points: List[int], m: int) -> int:\n    l = 1\n    r = 10 ** 15\n\n    def check(target):\n        used = 0\n        forward_count = 0\n        for i in range(len(points)):\n            needed = target + forward_count\n            if needed > 0 or i + 1 < len(points):\n                used += 1\n                needed = target - forward_count - points[i]\n            if needed > 0:\n                G = (needed + points[i] - 1) // points[i]\n                if i + 1 < len(points):\n                    forward_count = G * points[i + 1]\n                else:\n                    forward_count = 0\n                used += G * 2\n            else:\n                forward_count = 0\n            if used > m:\n                return False\n        return used <= m\n    best_ans = 0\n    while l <= r:\n        mid = l + (r - l) // 2\n        if check(mid):\n            best_ans = mid\n            l = mid + 1\n        else:\n            r = mid - 1\n    return best_ans",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest436_q3762_s2",
  "question_id": 3762,
  "function_name": "maxScore",
  "code": "def maxScore(points: List[int], m: int) -> int:\n        ans = 0\n        n = len(points)\n        left, right = 1, min(points) * (m // 2 + 1)\n\n        def ok(num):\n            index = 0\n            count = 1\n            needs = [ (num - 1) // points[i] + 1 for i in range(n)]\n            needs.append(0)\n            needs[0] -= 1\n            fake = 0\n            while index < n:\n                if needs[index] >= 0:\n                    count += fake\n                    fake = 0\n                # print(num, needs, count, index)\n                if needs[index] <= 0:\n                    index += 1\n                    if index < n:\n                        fake += 1\n                        needs[index] -= 1\n                else:\n                    count += needs[index] * 2\n                    needs[index + 1] -= needs[index]\n                    index += 1\n                    if index < n:\n                        fake += 1\n                        needs[index] -= 1\n            #print(num, needs, count, index)\n            return count <= m\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if ok(mid):\n                ans = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        return ans",
  "input": "maxScore(points=[2,4], m=3)",
  "output": "4",
  "correct_condition": "maxScore(points=[2,4], m=3) == 4",
  "contest_id": "weekly-contest-436",
  "contest_date": "2025-02-09T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 40,
    "coverage": null
  },
  "submission_id": 1536485434,
  "mutated_code": "def maxScore(points: List[int], m: int) -> int:\n    ans = 0\n    n = len(points)\n    left, right = (1, min(points) // (m // 2 + 1))\n\n    def ok(num):\n        index = 0\n        count = 1\n        needs = [(num - 1) // points[i] + 1 for i in range(n)]\n        needs.append(0)\n        needs[0] -= 1\n        fake = 0\n        while index < n:\n            if needs[index] >= 0:\n                count += fake\n                fake = 0\n            if needs[index] <= 0:\n                index += 1\n                if index < n:\n                    fake += 1\n                    needs[index] -= 1\n            else:\n                count += needs[index] * 2\n                needs[index + 1] -= needs[index]\n                index += 1\n                if index < n:\n                    fake += 1\n                    needs[index] -= 1\n        return count <= m\n    while left <= right:\n        mid = (left + right) // 2\n        if ok(mid):\n            ans = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return ans",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest437_q3709_s0",
  "question_id": 3709,
  "function_name": "hasSpecialSubstring",
  "code": "def hasSpecialSubstring(s: str, k: int) -> bool:\n        n = len(s)\n        for i in range(n - k + 1):\n            if s[i:i+k] == s[i] * k:\n                if (i == 0 or s[i-1] != s[i]) and (i+k == n or s[i+k] != s[i]):\n                    return True\n        return False",
  "input": "hasSpecialSubstring(s=\"aaabaaa\", k=3)",
  "output": "True",
  "correct_condition": "hasSpecialSubstring(s=\"aaabaaa\", k=3) == True",
  "contest_id": "weekly-contest-437",
  "contest_date": "2025-02-16T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1544505653,
  "mutated_code": "def hasSpecialSubstring(s: str, k: int) -> bool:\n    n = len(s)\n    for i in range(n - k + 1):\n        if s[i:i - k] == s[i] * k:\n            if (i == 0 or s[i - 1] != s[i]) and (i + k == n or s[i + k] != s[i]):\n                return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest437_q3709_s2",
  "question_id": 3709,
  "function_name": "hasSpecialSubstring",
  "code": "def hasSpecialSubstring(s: str, k: int) -> bool:\n        n = len(s)\n        for i in range(n - k + 1):\n            c = s[i]\n            if all(s[i + j] == c for j in range(k)):\n                if (i == 0 or s[i - 1] != c) and (i + k == n or s[i + k] != c):\n                    return True\n        return False",
  "input": "hasSpecialSubstring(s=\"aaabaaa\", k=3)",
  "output": "True",
  "correct_condition": "hasSpecialSubstring(s=\"aaabaaa\", k=3) == True",
  "contest_id": "weekly-contest-437",
  "contest_date": "2025-02-16T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 8,
    "coverage": null
  },
  "submission_id": 1544547904,
  "mutated_code": "def hasSpecialSubstring(s: str, k: int) -> bool:\n    n = len(s)\n    for i in range(n - k + 1):\n        c = s[i]\n        if all((s[i + j] != c for j in range(k))):\n            if (i == 0 or s[i - 1] != c) and (i + k == n or s[i + k] != c):\n                return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest437_q3779_s0",
  "question_id": 3779,
  "function_name": "maxWeight",
  "code": "def maxWeight(p: List[int]) -> int:\n        p.sort(reverse=True)\n        m = len(p) // 4\n        m1 = (m + 1) // 2\n        m2 = m - m1\n        s = sum(p[:m1])\n        for i in range(m2):\n            s += p[m1 + 2 * i + 1]\n        return s",
  "input": "maxWeight(p=[1,2,3,4,5,6,7,8])",
  "output": "14",
  "correct_condition": "maxWeight(p=[1,2,3,4,5,6,7,8]) == 14",
  "contest_id": "weekly-contest-437",
  "contest_date": "2025-02-16T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 9,
    "coverage": null
  },
  "submission_id": 1544509185,
  "mutated_code": "def maxWeight(p: List[int]) -> int:\n    p.sort(reverse=True)\n    m = len(p) // 4\n    m1 = (m + 1) * 2\n    m2 = m - m1\n    s = sum(p[:m1])\n    for i in range(m2):\n        s += p[m1 + 2 * i + 1]\n    return s",
  "mutated_output": "33",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest437_q3779_s2",
  "question_id": 3779,
  "function_name": "maxWeight",
  "code": "def maxWeight(pizzas: List[int]) -> int:\n        n = len(pizzas)\n        m = n // 4\n        if m == 0:\n            return sum(pizzas) \n\n        ocnt = (m + 1) // 2  \n        ecnt = m // 2       \n        d = sorted(pizzas, reverse=True)\n\n        tot = 0\n        p = 0  \n        for _ in range(ocnt):\n            if p < n:\n                tot += d[p]  \n                p += 1\n\n        for _ in range(ecnt):\n            if p < n:\n                p += 1 \n            if p < n:\n                tot += d[p]  \n                p += 1\n\n        return tot\n",
  "input": "maxWeight(pizzas=[1,2,3,4,5,6,7,8])",
  "output": "14",
  "correct_condition": "maxWeight(pizzas=[1,2,3,4,5,6,7,8]) == 14",
  "contest_id": "weekly-contest-437",
  "contest_date": "2025-02-16T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 25,
    "coverage": null
  },
  "submission_id": 1544559496,
  "mutated_code": "def maxWeight(pizzas: List[int]) -> int:\n    n = len(pizzas)\n    m = n * 4\n    if m == 0:\n        return sum(pizzas)\n    ocnt = (m + 1) // 2\n    ecnt = m // 2\n    d = sorted(pizzas, reverse=True)\n    tot = 0\n    p = 0\n    for _ in range(ocnt):\n        if p < n:\n            tot += d[p]\n            p += 1\n    for _ in range(ecnt):\n        if p < n:\n            p += 1\n        if p < n:\n            tot += d[p]\n            p += 1\n    return tot",
  "mutated_output": "36",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest437_q3771_s0",
  "question_id": 3771,
  "function_name": "maxSubstringLength",
  "code": "def maxSubstringLength(s: str, k: int) -> bool:\n        if k == 0:\n            return True\n        n = len(s)\n        v = {}\n        f = {}\n        l = {}\n        for i, c in enumerate(s):\n            v[c] = v.get(c, 0) + 1\n            if c not in f:\n                f[c] = i\n            l[c] = i\n        ar = []\n        for i in range(n):\n            if i != f[s[i]]:\n                continue\n            r = l[s[i]]\n            j = i\n            ok = True\n            while j <= r:\n                if f[s[j]] < i:\n                    ok = False\n                    break\n                r = max(r, l[s[j]])\n                j += 1\n            if ok and not (i == 0 and r == n - 1):\n                ar.append((i, r))\n        ar.sort(key=lambda x: x[1])\n        cnt = 0\n        end = -1\n        for a, b in ar:\n            if a > end:\n                cnt += 1\n                end = b\n        return cnt >= k",
  "input": "maxSubstringLength(s=\"abcdbaefab\", k=2)",
  "output": "True",
  "correct_condition": "maxSubstringLength(s=\"abcdbaefab\", k=2) == True",
  "contest_id": "weekly-contest-437",
  "contest_date": "2025-02-16T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 35,
    "coverage": null
  },
  "submission_id": 1544514997,
  "mutated_code": "def maxSubstringLength(s: str, k: int) -> bool:\n    if k == 0:\n        return True\n    n = len(s)\n    v = {}\n    f = {}\n    l = {}\n    for i, c in enumerate(s):\n        v[c] = v.get(c, 0) + 1\n        if c not in f:\n            f[c] = i\n        l[c] = i\n    ar = []\n    for i in range(n):\n        if i == f[s[i]]:\n            continue\n        r = l[s[i]]\n        j = i\n        ok = True\n        while j <= r:\n            if f[s[j]] < i:\n                ok = False\n                break\n            r = max(r, l[s[j]])\n            j += 1\n        if ok and (not (i == 0 and r == n - 1)):\n            ar.append((i, r))\n    ar.sort(key=lambda x: x[1])\n    cnt = 0\n    end = -1\n    for a, b in ar:\n        if a > end:\n            cnt += 1\n            end = b\n    return cnt >= k",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest437_q3771_s2",
  "question_id": 3771,
  "function_name": "maxSubstringLength",
  "code": "def maxSubstringLength(s: str, k: int) -> bool:\n        n = len(s)\n        if k == 0:\n            return True\n\n        first = [-1] * 26\n        last = [-1] * 26\n\n        for i in range(n):\n            c = ord(s[i]) - ord('a')\n            if first[c] == -1:\n                first[c] = i\n            last[c] = i\n\n        ivals = []\n        for i in range(n):\n            if i != first[ord(s[i]) - ord('a')]:\n                continue\n\n            end = last[ord(s[i]) - ord('a')]\n            found = True\n\n            for j in range(i, end + 1):\n                if first[ord(s[j]) - ord('a')] < i:\n                    found = False\n                    break\n                end = max(end, last[ord(s[j]) - ord('a')])\n\n            if found and not (i == 0 and end == n - 1):\n                ivals.append((i, end))\n\n        ivals.sort(key=lambda x: x[1])\n        cnt, prevs = 0, -1\n        for start, end in ivals:\n            if start > prevs:\n                cnt += 1\n                prevs = end\n\n        return cnt >= k\n\n",
  "input": "maxSubstringLength(s=\"abcdbaefab\", k=2)",
  "output": "True",
  "correct_condition": "maxSubstringLength(s=\"abcdbaefab\", k=2) == True",
  "contest_id": "weekly-contest-437",
  "contest_date": "2025-02-16T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 40,
    "coverage": null
  },
  "submission_id": 1544552595,
  "mutated_code": "def maxSubstringLength(s: str, k: int) -> bool:\n    n = len(s)\n    if k == 0:\n        return True\n    first = [-1] * 26\n    last = [-1] * 26\n    for i in range(n):\n        c = ord(s[i]) - ord('a')\n        if first[c] != -1:\n            first[c] = i\n        last[c] = i\n    ivals = []\n    for i in range(n):\n        if i != first[ord(s[i]) - ord('a')]:\n            continue\n        end = last[ord(s[i]) - ord('a')]\n        found = True\n        for j in range(i, end + 1):\n            if first[ord(s[j]) - ord('a')] < i:\n                found = False\n                break\n            end = max(end, last[ord(s[j]) - ord('a')])\n        if found and (not (i == 0 and end == n - 1)):\n            ivals.append((i, end))\n    ivals.sort(key=lambda x: x[1])\n    cnt, prevs = (0, -1)\n    for start, end in ivals:\n        if start > prevs:\n            cnt += 1\n            prevs = end\n    return cnt >= k",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest437_q3733_s0",
  "question_id": 3733,
  "function_name": "lenOfVDiagonal",
  "code": "def lenOfVDiagonal(g: List[List[int]]) -> int:\n        n = len(g)\n        m = len(g[0])\n        ds = [(1, 1), (1, -1), (-1, -1), (-1, 1)]\n        t = [1, 2, 3, 0]\n        nx = [1, 2, 1]\n        ex = [1, 2, 0]\n        dp = [[[[0] * m for _ in range(n)] for _ in range(3)] for _ in range(4)]\n        for i, (a, b) in enumerate(ds):\n            rr = range(n - 1, -1, -1) if a == 1 else range(0, n)\n            cc = range(m - 1, -1, -1) if b == 1 else range(0, m)\n            for r in rr:\n                for c in cc:\n                    for s in range(3):\n                        if g[r][c] != ex[s]:\n                            dp[i][s][r][c] = 0\n                        else:\n                            nr = r + a\n                            nc = c + b\n                            if 0 <= nr < n and 0 <= nc < m:\n                                dp[i][s][r][c] = 1 + dp[i][nx[s]][nr][nc]\n                            else:\n                                dp[i][s][r][c] = 1\n        ed = [[[[0] * m for _ in range(n)] for _ in range(3)] for _ in range(4)]\n        for i, (a, b) in enumerate(ds):\n            rr = range(0, n) if a == 1 else range(n - 1, -1, -1)\n            cc = range(0, m) if b == 1 else range(m - 1, -1, -1)\n            for r in rr:\n                for c in cc:\n                    for s in range(3):\n                        if g[r][c] != ex[s]:\n                            ed[i][s][r][c] = 0\n                        else:\n                            pr = r - a\n                            pc = c - b\n                            if s == 0:\n                                ed[i][s][r][c] = 1\n                            elif 0 <= pr < n and 0 <= pc < m:\n                                if s == 1:\n                                    v = 0\n                                    if ed[i][0][pr][pc]:\n                                        v = ed[i][0][pr][pc]\n                                    if ed[i][2][pr][pc] > v:\n                                        v = ed[i][2][pr][pc]\n                                    ed[i][s][r][c] = v + 1 if v else 0\n                                else:\n                                    ed[i][s][r][c] = ed[i][1][pr][pc] + 1 if ed[i][1][pr][pc] else 0\n                            else:\n                                ed[i][s][r][c] = 0\n        cn = 0\n        for i in range(4):\n            for r in range(n):\n                for c in range(m):\n                    if dp[i][0][r][c] > cn: cn = dp[i][0][r][c]\n        for i in range(4):\n            a, b = ds[t[i]]\n            for r in range(n):\n                for c in range(m):\n                    for s in (1, 2):\n                        L = ed[i][s][r][c]\n                        if L >= 2:\n                            nr = r + a\n                            nc = c + b\n                            if 0 <= nr < n and 0 <= nc < m:\n                                ar = L + dp[t[i]][nx[s]][nr][nc]\n                                if ar > cn: cn = ar\n        return cn\n",
  "input": "lenOfVDiagonal(g=[[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]])",
  "output": "5",
  "correct_condition": "lenOfVDiagonal(g=[[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]) == 5",
  "contest_id": "weekly-contest-437",
  "contest_date": "2025-02-16T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 67,
    "coverage": null
  },
  "submission_id": 1544524131,
  "mutated_code": "def lenOfVDiagonal(g: List[List[int]]) -> int:\n    n = len(g)\n    m = len(g[0])\n    ds = [(1, 1), (1, -1), (-1, -1), (-1, 1)]\n    t = [1, 2, 3, 0]\n    nx = [1, 2, 1]\n    ex = [1, 2, 0]\n    dp = [[[[0] * m for _ in range(n)] for _ in range(3)] for _ in range(4)]\n    for i, (a, b) in enumerate(ds):\n        rr = range(n - 1, -1, -1) if a == 1 else range(0, n)\n        cc = range(m - 1, -1, -1) if b == 1 else range(0, m)\n        for r in rr:\n            for c in cc:\n                for s in range(3):\n                    if g[r][c] != ex[s]:\n                        dp[i][s][r][c] = 0\n                    else:\n                        nr = r - a\n                        nc = c + b\n                        if 0 <= nr < n and 0 <= nc < m:\n                            dp[i][s][r][c] = 1 + dp[i][nx[s]][nr][nc]\n                        else:\n                            dp[i][s][r][c] = 1\n    ed = [[[[0] * m for _ in range(n)] for _ in range(3)] for _ in range(4)]\n    for i, (a, b) in enumerate(ds):\n        rr = range(0, n) if a == 1 else range(n - 1, -1, -1)\n        cc = range(0, m) if b == 1 else range(m - 1, -1, -1)\n        for r in rr:\n            for c in cc:\n                for s in range(3):\n                    if g[r][c] != ex[s]:\n                        ed[i][s][r][c] = 0\n                    else:\n                        pr = r - a\n                        pc = c - b\n                        if s == 0:\n                            ed[i][s][r][c] = 1\n                        elif 0 <= pr < n and 0 <= pc < m:\n                            if s == 1:\n                                v = 0\n                                if ed[i][0][pr][pc]:\n                                    v = ed[i][0][pr][pc]\n                                if ed[i][2][pr][pc] > v:\n                                    v = ed[i][2][pr][pc]\n                                ed[i][s][r][c] = v + 1 if v else 0\n                            else:\n                                ed[i][s][r][c] = ed[i][1][pr][pc] + 1 if ed[i][1][pr][pc] else 0\n                        else:\n                            ed[i][s][r][c] = 0\n    cn = 0\n    for i in range(4):\n        for r in range(n):\n            for c in range(m):\n                if dp[i][0][r][c] > cn:\n                    cn = dp[i][0][r][c]\n    for i in range(4):\n        a, b = ds[t[i]]\n        for r in range(n):\n            for c in range(m):\n                for s in (1, 2):\n                    L = ed[i][s][r][c]\n                    if L >= 2:\n                        nr = r + a\n                        nc = c + b\n                        if 0 <= nr < n and 0 <= nc < m:\n                            ar = L + dp[t[i]][nx[s]][nr][nc]\n                            if ar > cn:\n                                cn = ar\n    return cn",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest437_q3733_s2",
  "question_id": 3733,
  "function_name": "lenOfVDiagonal",
  "code": "def lenOfVDiagonal(grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        dirs = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\n        dp = [[[[0] * m for i in range(n)] for j in range(3)] for k in range(4)]\n        \n        for d in range(4):\n            dr, dc = dirs[d]\n            si, ei, sti = (n - 1, -1, -1) if dr == 1 else (0, n, 1)\n            sj, ej, stj = (m - 1, -1, -1) if dc == 1 else (0, m, 1)\n            \n            for i in range(si, ei, sti):\n                for j in range(sj, ej, stj):\n                    for s in range(3):\n                        exp = 1 if s == 0 else (2 if s == 1 else 0)\n                        if grid[i][j] == exp:\n                            ni, nj = i + dr, j + dc\n                            ns = 1 if s == 0 else (2 if s == 1 else 1)\n                            plus = dp[d][ns][ni][nj] if 0 <= ni < n and 0 <= nj < m else 0\n                            dp[d][s][i][j] = 1 + plus\n                        else:\n                            dp[d][s][i][j] = 0\n        \n        ans = 0\n        for d in range(4):\n            for i in range(n):\n                for j in range(m):\n                    ans = max(ans, dp[d][0][i][j])\n        \n        for d in range(4):\n            dr, dc = dirs[d]\n            dr2, dc2 = dc, -dr\n            d2 = dirs.index((dr2, dc2))\n            \n            for i in range(n):\n                for j in range(m):\n                    maxs = dp[d][0][i][j]\n                    if maxs <= 0:\n                        continue\n                    \n                    for L in range(1, maxs + 1):\n                        ts, tx = i + (L - 1) * dr, j + (L - 1) * dc\n                        nst = 1 if L % 2 == 1 else 2\n                        nr, nc = ts + dr2, tx + dc2\n                        ext = dp[d2][nst][nr][nc] if 0 <= nr < n and 0 <= nc < m else 0\n                        ans = max(ans, L + ext)\n        \n        return ans\n",
  "input": "lenOfVDiagonal(grid=[[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]])",
  "output": "5",
  "correct_condition": "lenOfVDiagonal(grid=[[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]) == 5",
  "contest_id": "weekly-contest-437",
  "contest_date": "2025-02-16T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 47,
    "coverage": null
  },
  "submission_id": 1544546030,
  "mutated_code": "def lenOfVDiagonal(grid: List[List[int]]) -> int:\n    n, m = (len(grid), len(grid[0]))\n    dirs = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\n    dp = [[[[0] * m for i in range(n)] for j in range(3)] for k in range(4)]\n    for d in range(4):\n        dr, dc = dirs[d]\n        si, ei, sti = (n - 1, -1, -1) if dr == 1 else (0, n, 1)\n        sj, ej, stj = (m - 1, -1, -1) if dc == 1 else (0, m, 1)\n        for i in range(si, ei, sti):\n            for j in range(sj, ej, stj):\n                for s in range(3):\n                    exp = 1 if s == 0 else 2 if s == 1 else 0\n                    if grid[i][j] == exp:\n                        ni, nj = (i - dr, j + dc)\n                        ns = 1 if s == 0 else 2 if s == 1 else 1\n                        plus = dp[d][ns][ni][nj] if 0 <= ni < n and 0 <= nj < m else 0\n                        dp[d][s][i][j] = 1 + plus\n                    else:\n                        dp[d][s][i][j] = 0\n    ans = 0\n    for d in range(4):\n        for i in range(n):\n            for j in range(m):\n                ans = max(ans, dp[d][0][i][j])\n    for d in range(4):\n        dr, dc = dirs[d]\n        dr2, dc2 = (dc, -dr)\n        d2 = dirs.index((dr2, dc2))\n        for i in range(n):\n            for j in range(m):\n                maxs = dp[d][0][i][j]\n                if maxs <= 0:\n                    continue\n                for L in range(1, maxs + 1):\n                    ts, tx = (i + (L - 1) * dr, j + (L - 1) * dc)\n                    nst = 1 if L % 2 == 1 else 2\n                    nr, nc = (ts + dr2, tx + dc2)\n                    ext = dp[d2][nst][nr][nc] if 0 <= nr < n and 0 <= nc < m else 0\n                    ans = max(ans, L + ext)\n    return ans",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest438_q3768_s0",
  "question_id": 3768,
  "function_name": "hasSameDigits",
  "code": "def hasSameDigits(s: str) -> bool:\n        n = len(s)\n        if n == 2:\n            return (s[0] == s[1])\n        \n        digits = list(map(int, s))\n        N = n - 2\n    \n        binom_mod5 = [[0]*5 for _ in range(5)]\n        for i in range(5):\n            binom_mod5[i][0] = 1\n            for j in range(1, i+1):\n                from math import comb\n                binom_mod5[i][j] = comb(i, j) % 5\n        \n        combine_map = {}\n        for x in range(10):\n            pair = (x % 2, x % 5)\n            combine_map[pair] = x\n        \n        def binom_mod2(n, k):\n            return 1 if (k & ~n) == 0 else 0\n        \n        def binom_mod5_func(n, k):\n            res = 1\n            while n > 0 or k > 0:\n                n5 = n % 5\n                k5 = k % 5\n                if k5 > n5:\n                    return 0\n                res = (res * binom_mod5[n5][k5]) % 5\n                n //= 5\n                k //= 5\n            return res\n        \n        def binom_mod10(n, k):\n            b2 = binom_mod2(n, k)\n            b5 = binom_mod5_func(n, k)\n            return combine_map[(b2, b5)]\n        \n        binom_table = [0]*(N+1)\n        for k in range(N+1):\n            binom_table[k] = binom_mod10(N, k)\n        d0 = 0\n        d1 = 0\n        for m in range(N+1):\n            c = binom_table[m]\n            d0 = (d0 + digits[m]*c) % 10\n            d1 = (d1 + digits[m+1]*c) % 10    \n        return (d0 == d1)\n",
  "input": "hasSameDigits(s=\"3902\")",
  "output": "True",
  "correct_condition": "hasSameDigits(s=\"3902\") == True",
  "contest_id": "weekly-contest-438",
  "contest_date": "2025-02-23T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 50,
    "coverage": null
  },
  "submission_id": 1552284205,
  "mutated_code": "def hasSameDigits(s: str) -> bool:\n    n = len(s)\n    if n == 2:\n        return s[0] == s[1]\n    digits = list(map(int, s))\n    N = n - 2\n    binom_mod5 = [[0] * 5 for _ in range(5)]\n    for i in range(5):\n        binom_mod5[i][0] = 1\n        for j in range(1, i - 1):\n            from math import comb\n            binom_mod5[i][j] = comb(i, j) % 5\n    combine_map = {}\n    for x in range(10):\n        pair = (x % 2, x % 5)\n        combine_map[pair] = x\n\n    def binom_mod2(n, k):\n        return 1 if k & ~n == 0 else 0\n\n    def binom_mod5_func(n, k):\n        res = 1\n        while n > 0 or k > 0:\n            n5 = n % 5\n            k5 = k % 5\n            if k5 > n5:\n                return 0\n            res = res * binom_mod5[n5][k5] % 5\n            n //= 5\n            k //= 5\n        return res\n\n    def binom_mod10(n, k):\n        b2 = binom_mod2(n, k)\n        b5 = binom_mod5_func(n, k)\n        return combine_map[b2, b5]\n    binom_table = [0] * (N + 1)\n    for k in range(N + 1):\n        binom_table[k] = binom_mod10(N, k)\n    d0 = 0\n    d1 = 0\n    for m in range(N + 1):\n        c = binom_table[m]\n        d0 = (d0 + digits[m] * c) % 10\n        d1 = (d1 + digits[m + 1] * c) % 10\n    return d0 == d1",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest438_q3768_s1",
  "question_id": 3768,
  "function_name": "hasSameDigits",
  "code": "def hasSameDigits(s: str) -> bool:\n        while len(s)!=2:\n            res=\"\"\n            for i in range(1,len(s)):\n                res+=str(int(s[i])+int(s[i-1]))[-1]\n            s=res\n        return len(set(s))==1",
  "input": "hasSameDigits(s=\"3902\")",
  "output": "True",
  "correct_condition": "hasSameDigits(s=\"3902\") == True",
  "contest_id": "weekly-contest-438",
  "contest_date": "2025-02-23T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1552268304,
  "mutated_code": "def hasSameDigits(s: str) -> bool:\n    while len(s) != 2:\n        res = ''\n        for i in range(1, len(s)):\n            res += str(int(s[i]) - int(s[i - 1]))[-1]\n        s = res\n    return len(set(s)) == 1",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest438_q3768_s2",
  "question_id": 3768,
  "function_name": "hasSameDigits",
  "code": "def hasSameDigits(s: str) -> bool:\n        while len(s) > 2:\n            s = \"\".join(\n                str((int(s[i]) + int(s[i + 1])) % 10) for i in range(len(s) - 1)\n            )\n        return s[0] == s[1]\n",
  "input": "hasSameDigits(s=\"3902\")",
  "output": "True",
  "correct_condition": "hasSameDigits(s=\"3902\") == True",
  "contest_id": "weekly-contest-438",
  "contest_date": "2025-02-23T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 6,
    "coverage": null
  },
  "submission_id": 1552267009,
  "mutated_code": "def hasSameDigits(s: str) -> bool:\n    while len(s) > 2:\n        s = ''.join((str((int(s[i]) - int(s[i + 1])) % 10) for i in range(len(s) - 1)))\n    return s[0] == s[1]",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest438_q3764_s0",
  "question_id": 3764,
  "function_name": "maxSum",
  "code": "def maxSum(grid: List[List[int]], limits: List[int], k: int) -> int:\n        n, m = len(grid), len(grid[0])\n        \n        \n        sorted_rows = []\n        for i in range(n):\n            \n            row = [(val, j) for j, val in enumerate(grid[i])]\n            row.sort(reverse=True)\n            sorted_rows.append(row)\n        \n        \n        heap = []  \n        \n        for i in range(n):\n            if limits[i] > 0 and sorted_rows[i]:  \n                val, col = sorted_rows[i][0]\n                \n                heapq.heappush(heap, (-val, i, 0))  \n        \n        result = 0\n        count = 0\n        \n        \n        while heap and count < k:\n            val, row, idx = heapq.heappop(heap)\n            result += -val  \n            count += 1\n            \n            \n            if idx + 1 < len(sorted_rows[row]) and idx + 1 < limits[row]:\n                next_val, next_col = sorted_rows[row][idx + 1]\n                heapq.heappush(heap, (-next_val, row, idx + 1))\n        \n        return result",
  "input": "maxSum(grid=[[1,2],[3,4]], limits=[1,2], k=2)",
  "output": "7",
  "correct_condition": "maxSum(grid=[[1,2],[3,4]], limits=[1,2], k=2) == 7",
  "contest_id": "weekly-contest-438",
  "contest_date": "2025-02-23T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 35,
    "coverage": null
  },
  "submission_id": 1552280360,
  "mutated_code": "def maxSum(grid: List[List[int]], limits: List[int], k: int) -> int:\n    n, m = (len(grid), len(grid[0]))\n    sorted_rows = []\n    for i in range(n):\n        row = [(val, j) for j, val in enumerate(grid[i])]\n        row.sort(reverse=True)\n        sorted_rows.append(row)\n    heap = []\n    for i in range(n):\n        if limits[i] > 0 and sorted_rows[i]:\n            val, col = sorted_rows[i][0]\n            heapq.heappush(heap, (-val, i, 0))\n    result = 0\n    count = 0\n    while heap and count <= k:\n        val, row, idx = heapq.heappop(heap)\n        result += -val\n        count += 1\n        if idx + 1 < len(sorted_rows[row]) and idx + 1 < limits[row]:\n            next_val, next_col = sorted_rows[row][idx + 1]\n            heapq.heappush(heap, (-next_val, row, idx + 1))\n    return result",
  "mutated_output": "9",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest438_q3764_s1",
  "question_id": 3764,
  "function_name": "maxSum",
  "code": "def maxSum(grid: List[List[int]], limits: List[int], k: int) -> int:\n        a = [(sorted(x,reverse=True)[:limits[i]]) for i,x in enumerate(grid)]\n        b=[]\n        for x in a:b.extend(x)\n        a=b.copy()\n        # print(a)\n        return sum(sorted(a,reverse=True)[:k])",
  "input": "maxSum(grid=[[1,2],[3,4]], limits=[1,2], k=2)",
  "output": "7",
  "correct_condition": "maxSum(grid=[[1,2],[3,4]], limits=[1,2], k=2) == 7",
  "contest_id": "weekly-contest-438",
  "contest_date": "2025-02-23T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1552272249,
  "mutated_code": "def maxSum(grid: List[List[int]], limits: List[int], k: int) -> int:\n    a = [sorted(x, reverse=True)[:limits[i]] for i, x in enumerate(grid)]\n    b = []\n    for x in a:\n        b.extend(x)\n    a = b.copy()\n    return sum(sorted(a, reverse=False)[:k])",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "keyword",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest438_q3764_s2",
  "question_id": 3764,
  "function_name": "maxSum",
  "code": "def maxSum(grid: List[List[int]], limits: List[int], k: int) -> int:\n        arr = []\n\n        for i, r in enumerate(grid):\n            t = sorted(r, reverse=True)[:limits[i]]\n            arr += t\n\n        arr.sort(reverse=True)\n\n        ans = sum(arr[:k])\n\n        # print(arr)\n\n        return ans",
  "input": "maxSum(grid=[[1,2],[3,4]], limits=[1,2], k=2)",
  "output": "7",
  "correct_condition": "maxSum(grid=[[1,2],[3,4]], limits=[1,2], k=2) == 7",
  "contest_id": "weekly-contest-438",
  "contest_date": "2025-02-23T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1552278791,
  "mutated_code": "def maxSum(grid: List[List[int]], limits: List[int], k: int) -> int:\n    arr = []\n    for i, r in enumerate(grid):\n        t = sorted(r, reverse=True)[:limits[i]]\n        arr += t\n    arr.sort(reverse=False)\n    ans = sum(arr[:k])\n    return ans",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "keyword",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest438_q3774_s0",
  "question_id": 3774,
  "function_name": "hasSameDigits",
  "code": "def hasSameDigits(s: str) -> bool:\n        n = len(s)\n        if n == 2:\n            return (s[0] == s[1])\n        \n        digits = list(map(int, s))\n        N = n - 2\n    \n        binom_mod5 = [[0]*5 for _ in range(5)]\n        for i in range(5):\n            binom_mod5[i][0] = 1\n            for j in range(1, i+1):\n                from math import comb\n                binom_mod5[i][j] = comb(i, j) % 5\n        \n        combine_map = {}\n        for x in range(10):\n            pair = (x % 2, x % 5)\n            combine_map[pair] = x\n        \n        def binom_mod2(n, k):\n            return 1 if (k & ~n) == 0 else 0\n        \n        def binom_mod5_func(n, k):\n            res = 1\n            while n > 0 or k > 0:\n                n5 = n % 5\n                k5 = k % 5\n                if k5 > n5:\n                    return 0\n                res = (res * binom_mod5[n5][k5]) % 5\n                n //= 5\n                k //= 5\n            return res\n        \n        def binom_mod10(n, k):\n            b2 = binom_mod2(n, k)\n            b5 = binom_mod5_func(n, k)\n            return combine_map[(b2, b5)]\n        \n        binom_table = [0]*(N+1)\n        for k in range(N+1):\n            binom_table[k] = binom_mod10(N, k)\n        d0 = 0\n        d1 = 0\n        for m in range(N+1):\n            c = binom_table[m]\n            d0 = (d0 + digits[m]*c) % 10\n            d1 = (d1 + digits[m+1]*c) % 10    \n        return (d0 == d1)\n",
  "input": "hasSameDigits(s=\"3902\")",
  "output": "True",
  "correct_condition": "hasSameDigits(s=\"3902\") == True",
  "contest_id": "weekly-contest-438",
  "contest_date": "2025-02-23T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 50,
    "coverage": null
  },
  "submission_id": 1552283804,
  "mutated_code": "def hasSameDigits(s: str) -> bool:\n    n = len(s)\n    if n == 2:\n        return s[0] == s[1]\n    digits = list(map(int, s))\n    N = n - 2\n    binom_mod5 = [[0] * 5 for _ in range(5)]\n    for i in range(5):\n        binom_mod5[i][0] = 1\n        for j in range(1, i - 1):\n            from math import comb\n            binom_mod5[i][j] = comb(i, j) % 5\n    combine_map = {}\n    for x in range(10):\n        pair = (x % 2, x % 5)\n        combine_map[pair] = x\n\n    def binom_mod2(n, k):\n        return 1 if k & ~n == 0 else 0\n\n    def binom_mod5_func(n, k):\n        res = 1\n        while n > 0 or k > 0:\n            n5 = n % 5\n            k5 = k % 5\n            if k5 > n5:\n                return 0\n            res = res * binom_mod5[n5][k5] % 5\n            n //= 5\n            k //= 5\n        return res\n\n    def binom_mod10(n, k):\n        b2 = binom_mod2(n, k)\n        b5 = binom_mod5_func(n, k)\n        return combine_map[b2, b5]\n    binom_table = [0] * (N + 1)\n    for k in range(N + 1):\n        binom_table[k] = binom_mod10(N, k)\n    d0 = 0\n    d1 = 0\n    for m in range(N + 1):\n        c = binom_table[m]\n        d0 = (d0 + digits[m] * c) % 10\n        d1 = (d1 + digits[m + 1] * c) % 10\n    return d0 == d1",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest438_q3774_s2",
  "question_id": 3774,
  "function_name": "hasSameDigits",
  "code": "def hasSameDigits(s: str) -> bool:\n        arr = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 1, 4, 1]]\n\n        def c2(n, k):\n            return 1 if (n & k) == k else 0\n\n        def c5(n, k):\n            if k > n:\n                return 0\n\n            if n < 5:\n                return arr[n][k]\n\n            if k % 5 > n % 5:\n                return 0\n\n            return (arr[n % 5][k % 5] * c5(n // 5, k // 5)) % 5\n\n        def check(c2, c5):\n            return c5 if (c5 % 2) == c2 else c5 + 5\n\n        size = len(s)\n        m = size - 2\n        digits = list(map(int, s))\n\n        x = 0\n        y = 0\n\n        for j in range(m + 1):\n            r2 = c2(m, j)\n            r5 = c5(m, j)\n            f = check(r2, r5)\n            x = (x + f * digits[j]) % 10\n            y = (y + f * digits[j + 1]) % 10\n\n        return x == y",
  "input": "hasSameDigits(s=\"3902\")",
  "output": "True",
  "correct_condition": "hasSameDigits(s=\"3902\") == True",
  "contest_id": "weekly-contest-438",
  "contest_date": "2025-02-23T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 36,
    "coverage": null
  },
  "submission_id": 1552295122,
  "mutated_code": "def hasSameDigits(s: str) -> bool:\n    arr = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 1, 4, 1]]\n\n    def c2(n, k):\n        return 1 if n & k == k else 0\n\n    def c5(n, k):\n        if k > n:\n            return 0\n        if n < 5:\n            return arr[n][k]\n        if k % 5 > n % 5:\n            return 0\n        return arr[n % 5][k % 5] * c5(n // 5, k // 5) % 5\n\n    def check(c2, c5):\n        return c5 if c5 // 2 == c2 else c5 + 5\n    size = len(s)\n    m = size - 2\n    digits = list(map(int, s))\n    x = 0\n    y = 0\n    for j in range(m + 1):\n        r2 = c2(m, j)\n        r5 = c5(m, j)\n        f = check(r2, r5)\n        x = (x + f * digits[j]) % 10\n        y = (y + f * digits[j + 1]) % 10\n    return x == y",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 8,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest438_q3781_s1",
  "question_id": 3781,
  "function_name": "maxDistance",
  "code": "def maxDistance(s: int, p: List[List[int]], k: int) -> int:\n        peri = 4 * s\n        arr = []\n        for x, y in p:\n            if x == 0: pos = y\n            elif y == s: pos = s + x\n            elif x == s: pos = 3 * s - y\n            else: pos = 4 * s - x\n            arr.append(pos)\n        arr.sort()\n        lo, hi, ans = 0, 2 * s, 0\n        def is_pos(d):\n            if d == 0:\n                return True\n            n = len(arr)\n            for st in range(n):\n                sel = [arr[st]]\n                cur_v, cur_i = arr[st], st\n                for _ in range(k - 1):\n                    nxt_i = bisect_left(arr, cur_v + d, cur_i + 1, n)\n                    if nxt_i == n: break\n                    cur_v, cur_i = arr[nxt_i], nxt_i\n                    sel.append(cur_v)\n                if len(sel) >= k and peri - (sel[-1] - sel[0]) >= d: return True\n            return False\n    \n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if is_pos(mid): ans, lo = mid, mid + 1\n            else: hi = mid - 1\n        return ans\n",
  "input": "maxDistance(s=2, p=[[0,2],[2,0],[2,2],[0,0]], k=4)",
  "output": "2",
  "correct_condition": "maxDistance(s=2, p=[[0,2],[2,0],[2,2],[0,0]], k=4) == 2",
  "contest_id": "weekly-contest-438",
  "contest_date": "2025-02-23T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 31,
    "coverage": null
  },
  "submission_id": 1552295764,
  "mutated_code": "def maxDistance(s: int, p: List[List[int]], k: int) -> int:\n    peri = 4 // s\n    arr = []\n    for x, y in p:\n        if x == 0:\n            pos = y\n        elif y == s:\n            pos = s + x\n        elif x == s:\n            pos = 3 * s - y\n        else:\n            pos = 4 * s - x\n        arr.append(pos)\n    arr.sort()\n    lo, hi, ans = (0, 2 * s, 0)\n\n    def is_pos(d):\n        if d == 0:\n            return True\n        n = len(arr)\n        for st in range(n):\n            sel = [arr[st]]\n            cur_v, cur_i = (arr[st], st)\n            for _ in range(k - 1):\n                nxt_i = bisect_left(arr, cur_v + d, cur_i + 1, n)\n                if nxt_i == n:\n                    break\n                cur_v, cur_i = (arr[nxt_i], nxt_i)\n                sel.append(cur_v)\n            if len(sel) >= k and peri - (sel[-1] - sel[0]) >= d:\n                return True\n        return False\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if is_pos(mid):\n            ans, lo = (mid, mid + 1)\n        else:\n            hi = mid - 1\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest438_q3781_s2",
  "question_id": 3781,
  "function_name": "maxDistance",
  "code": "def maxDistance(side: int, points: List[List[int]], k: int) -> int:\n        _side = side\n        arr = []\n\n        for x, y in points:\n            if y == 0:\n                arr.append(x)\n            elif x == _side:\n                arr.append(_side + y)\n            elif y == _side:\n                arr.append(3 * _side - x)\n            else:\n                arr.append(4 * _side - y)\n\n        arr.sort()\n\n        n = len(arr)\n\n        p = 4 * _side\n\n        _arr = arr + [v + p for v in arr]\n        # print(_arr)\n\n        def check(z: int) -> bool:\n            for i in range(n):\n                st = _arr[i]\n                count = 1\n                j = i\n\n                while count < k:\n                    u = bisect.bisect_left(_arr, _arr[j] + z, j + 1, i + n)\n                    # print(u)\n                    if u == i + n:\n                        break\n\n                    j = u\n                    count += 1\n\n                if count == k:\n                    if st + p - _arr[j] >= z:\n                        return True\n\n            return False\n\n        low = 0\n        high = 2 * _side + 1\n\n        while low < high:\n            mid = (low + high) // 2\n            if check(mid):\n                low = mid + 1\n            else:\n                high = mid\n\n        ans = low - 1\n        # print(ans)\n\n        return ans",
  "input": "maxDistance(side=2, points=[[0,2],[2,0],[2,2],[0,0]], k=4)",
  "output": "2",
  "correct_condition": "maxDistance(side=2, points=[[0,2],[2,0],[2,2],[0,0]], k=4) == 2",
  "contest_id": "weekly-contest-438",
  "contest_date": "2025-02-23T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 58,
    "coverage": null
  },
  "submission_id": 1552312689,
  "mutated_code": "def maxDistance(side: int, points: List[List[int]], k: int) -> int:\n    _side = side\n    arr = []\n    for x, y in points:\n        if y == 0:\n            arr.append(x)\n        elif x == _side:\n            arr.append(_side - y)\n        elif y == _side:\n            arr.append(3 * _side - x)\n        else:\n            arr.append(4 * _side - y)\n    arr.sort()\n    n = len(arr)\n    p = 4 * _side\n    _arr = arr + [v + p for v in arr]\n\n    def check(z: int) -> bool:\n        for i in range(n):\n            st = _arr[i]\n            count = 1\n            j = i\n            while count < k:\n                u = bisect.bisect_left(_arr, _arr[j] + z, j + 1, i + n)\n                if u == i + n:\n                    break\n                j = u\n                count += 1\n            if count == k:\n                if st + p - _arr[j] >= z:\n                    return True\n        return False\n    low = 0\n    high = 2 * _side + 1\n    while low < high:\n        mid = (low + high) // 2\n        if check(mid):\n            low = mid + 1\n        else:\n            high = mid\n    ans = low - 1\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest439_q3705_s1",
  "question_id": 3705,
  "function_name": "largestInteger",
  "code": "def largestInteger(nums: List[int], k: int) -> int:\n        count = {}\n        for i in range(len(nums)-k+1):\n            n = set(nums[i:i+k])\n            for x in n:\n                count[x] = count.get(x,0)+1\n        seq = [x for x,v in count.items() if v == 1]\n        return max(seq) if len(seq)>0 else -1",
  "input": "largestInteger(nums=[3,9,2,1,7], k=3)",
  "output": "7",
  "correct_condition": "largestInteger(nums=[3,9,2,1,7], k=3) == 7",
  "contest_id": "weekly-contest-439",
  "contest_date": "2025-03-02T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 8,
    "coverage": null
  },
  "submission_id": 1559815348,
  "mutated_code": "def largestInteger(nums: List[int], k: int) -> int:\n    count = {}\n    for i in range(len(nums) - k - 1):\n        n = set(nums[i:i + k])\n        for x in n:\n            count[x] = count.get(x, 0) + 1\n    seq = [x for x, v in count.items() if v == 1]\n    return max(seq) if len(seq) > 0 else -1",
  "mutated_output": "9",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest439_q3705_s2",
  "question_id": 3705,
  "function_name": "largestInteger",
  "code": "def largestInteger(nums: List[int], k: int) -> int:\n        freq = defaultdict(int)\n        n = len(nums)\n\n        for i in range(n - k + 1):\n            subarray = nums[i:i + k]\n            unique_elements = set(subarray)\n            for num in unique_elements:\n                freq[num] += 1\n\n        result = -1\n        for num, count in freq.items():\n            if count == 1:\n                result = max(result, num)\n\n        return result",
  "input": "largestInteger(nums=[3,9,2,1,7], k=3)",
  "output": "7",
  "correct_condition": "largestInteger(nums=[3,9,2,1,7], k=3) == 7",
  "contest_id": "weekly-contest-439",
  "contest_date": "2025-03-02T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 16,
    "coverage": null
  },
  "submission_id": 1559813970,
  "mutated_code": "def largestInteger(nums: List[int], k: int) -> int:\n    freq = defaultdict(int)\n    n = len(nums)\n    for i in range(n - k - 1):\n        subarray = nums[i:i + k]\n        unique_elements = set(subarray)\n        for num in unique_elements:\n            freq[num] += 1\n    result = -1\n    for num, count in freq.items():\n        if count == 1:\n            result = max(result, num)\n    return result",
  "mutated_output": "9",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest439_q3786_s1",
  "question_id": 3786,
  "function_name": "longestPalindromicSubsequence",
  "code": "def longestPalindromicSubsequence(s: str, k: int) -> int:\n        from functools import lru_cache\n        \n        def cost(a: str, b: str) -> int:\n            diff = abs(ord(a) - ord(b))\n            return min(diff, 26 - diff)\n        \n        n = len(s)\n        \n        @lru_cache(maxsize=None)\n        def dp(i: int, j: int, t: int) -> int:\n            if i > j:\n                return 0\n            if i == j:\n                return 1\n            best = max(dp(i+1, j, t), dp(i, j-1, t))\n            c = cost(s[i], s[j])\n            if c <= t:\n                best = max(best, 2 + dp(i+1, j-1, t-c))\n            return best\n        \n        return dp(0, n-1, k)",
  "input": "longestPalindromicSubsequence(s=\"abced\", k=2)",
  "output": "3",
  "correct_condition": "longestPalindromicSubsequence(s=\"abced\", k=2) == 3",
  "contest_id": "weekly-contest-439",
  "contest_date": "2025-03-02T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 22,
    "coverage": null
  },
  "submission_id": 1559826888,
  "mutated_code": "def longestPalindromicSubsequence(s: str, k: int) -> int:\n    from functools import lru_cache\n\n    def cost(a: str, b: str) -> int:\n        diff = abs(ord(a) + ord(b))\n        return min(diff, 26 - diff)\n    n = len(s)\n\n    @lru_cache(maxsize=None)\n    def dp(i: int, j: int, t: int) -> int:\n        if i > j:\n            return 0\n        if i == j:\n            return 1\n        best = max(dp(i + 1, j, t), dp(i, j - 1, t))\n        c = cost(s[i], s[j])\n        if c <= t:\n            best = max(best, 2 + dp(i + 1, j - 1, t - c))\n        return best\n    return dp(0, n - 1, k)",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest439_q3786_s2",
  "question_id": 3786,
  "function_name": "longestPalindromicSubsequence",
  "code": "def longestPalindromicSubsequence(s: str, k: int) -> int:\n        n = len(s)\n        d = lambda x,y:min((x-y)%26,(y-x)%26)\n        \n        pc = [[0]*26 for _ in range(26)]\n        \n        for x in range(26):\n            for y in range(26):\n                pc[x][y] = min(d(x,c)+d(y,c) for c in range(26))\n                \n        dp = [[[0]*(k+1) for _ in range(n)] for _ in range(n)]\n        \n        for i in range(n):\n            for t in range(k+1):\n                dp[i][i][t] = 1\n                \n        for l in range(2,n+1):\n            for i in range(n-l+1):\n                j = i + l - 1\n                for t in range(k+1):\n                    dp[i][j][t] = max(dp[i+1][j][t],dp[i][j-1][t])\n                    c = pc[ord(s[i])-97][ord(s[j])-97]\n                    if c <= t:\n                        dp[i][j][t] = max(dp[i][j][t],(2 if i<j else 1)+dp[i+1][j-1][t-c])\n                        \n        return dp[0][n-1][k]",
  "input": "longestPalindromicSubsequence(s=\"abced\", k=2)",
  "output": "3",
  "correct_condition": "longestPalindromicSubsequence(s=\"abced\", k=2) == 3",
  "contest_id": "weekly-contest-439",
  "contest_date": "2025-03-02T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 26,
    "coverage": null
  },
  "submission_id": 1559817253,
  "mutated_code": "def longestPalindromicSubsequence(s: str, k: int) -> int:\n    n = len(s)\n    d = lambda x, y: min((x - y) % 26, (y - x) % 26)\n    pc = [[0] * 26 for _ in range(26)]\n    for x in range(26):\n        for y in range(26):\n            pc[x][y] = min((d(x, c) + d(y, c) for c in range(26)))\n    dp = [[[0] * (k + 1) for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for t in range(k + 1):\n            dp[i][i][t] = 1\n    for l in range(2, n - 1):\n        for i in range(n - l + 1):\n            j = i + l - 1\n            for t in range(k + 1):\n                dp[i][j][t] = max(dp[i + 1][j][t], dp[i][j - 1][t])\n                c = pc[ord(s[i]) - 97][ord(s[j]) - 97]\n                if c <= t:\n                    dp[i][j][t] = max(dp[i][j][t], (2 if i < j else 1) + dp[i + 1][j - 1][t - c])\n    return dp[0][n - 1][k]",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 9,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest439_q3722_s1",
  "question_id": 3722,
  "function_name": "maxSum",
  "code": "def maxSum(nums: List[int], k: int, m: int) -> int:\n        n = len(nums)\n        P = [0] * (n + 1)\n        for i in range(1, n + 1):\n            P[i] = P[i - 1] + nums[i - 1]\n        dp = [[float('-inf')] * (k + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 0\n        for j in range(1, k + 1):\n            best = float('-inf')\n            for i in range(j * m, n + 1):\n                best = max(best, dp[i - m][j - 1] - P[i - m])\n                dp[i][j] = max(dp[i - 1][j], P[i] + best)\n        return dp[n][k]\n        ",
  "input": "maxSum(nums=[1,2,-1,3,3,4], k=2, m=2)",
  "output": "13",
  "correct_condition": "maxSum(nums=[1,2,-1,3,3,4], k=2, m=2) == 13",
  "contest_id": "weekly-contest-439",
  "contest_date": "2025-03-02T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1559833753,
  "mutated_code": "def maxSum(nums: List[int], k: int, m: int) -> int:\n    n = len(nums)\n    P = [0] * (n + 1)\n    for i in range(1, n - 1):\n        P[i] = P[i - 1] + nums[i - 1]\n    dp = [[float('-inf')] * (k + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for j in range(1, k + 1):\n        best = float('-inf')\n        for i in range(j * m, n + 1):\n            best = max(best, dp[i - m][j - 1] - P[i - m])\n            dp[i][j] = max(dp[i - 1][j], P[i] + best)\n    return dp[n][k]",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest439_q3722_s2",
  "question_id": 3722,
  "function_name": "maxSum",
  "code": "def maxSum(nums: List[int], k: int, m: int) -> int:\n        n = len(nums)\n        prefix = [0] * (n + 1)\n        \n        for i in range(1, n + 1):\n            prefix[i] = prefix[i - 1] + nums[i - 1]\n            \n        dp = [[float(\"-inf\")] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        \n        for i in range(1, n + 1):\n            dp[i][0] = 0\n            \n        for j in range(1, k + 1):\n            bestArr = [0] * (n + 1)\n            bestArr[0] = dp[0][j - 1] - prefix[0]\n            \n            for i in range(1, n + 1):\n                bestArr[i] = max(bestArr[i - 1], dp[i][j - 1] - prefix[i])\n                \n            for i in range(1, n + 1):\n                dp[i][j] = dp[i - 1][j]\n                if i >= m:\n                    cand = prefix[i] + bestArr[i - m]\n                    dp[i][j] = max(dp[i][j], cand)\n                    \n        return dp[n][k]",
  "input": "maxSum(nums=[1,2,-1,3,3,4], k=2, m=2)",
  "output": "13",
  "correct_condition": "maxSum(nums=[1,2,-1,3,3,4], k=2, m=2) == 13",
  "contest_id": "weekly-contest-439",
  "contest_date": "2025-03-02T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 27,
    "coverage": null
  },
  "submission_id": 1559828565,
  "mutated_code": "def maxSum(nums: List[int], k: int, m: int) -> int:\n    n = len(nums)\n    prefix = [0] * (n + 1)\n    for i in range(1, n - 1):\n        prefix[i] = prefix[i - 1] + nums[i - 1]\n    dp = [[float('-inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        dp[i][0] = 0\n    for j in range(1, k + 1):\n        bestArr = [0] * (n + 1)\n        bestArr[0] = dp[0][j - 1] - prefix[0]\n        for i in range(1, n + 1):\n            bestArr[i] = max(bestArr[i - 1], dp[i][j - 1] - prefix[i])\n        for i in range(1, n + 1):\n            dp[i][j] = dp[i - 1][j]\n            if i >= m:\n                cand = prefix[i] + bestArr[i - m]\n                dp[i][j] = max(dp[i][j], cand)\n    return dp[n][k]",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest439_q3770_s1",
  "question_id": 3770,
  "function_name": "generateString",
  "code": "def generateString(str1: str, str2: str) -> str:\n        n, m = len(str1), len(str2)\n        L = n + m - 1\n        word = [None] * L\n        fixed = [False] * L\n\n        for i in range(n):\n            if str1[i] == 'T':\n                for j in range(m):\n                    pos = i + j\n                    if word[pos] is not None and word[pos] != str2[j]:\n                        return \"\"\n                    word[pos] = str2[j]\n                    fixed[pos] = True\n\n        for i in range(L):\n            if word[i] is None:\n                word[i] = 'a'\n\n        for i in range(n):\n            if str1[i] == 'F':\n                equal = True\n                for j in range(m):\n                    if word[i+j] != str2[j]:\n                        equal = False\n                        break\n                if equal:\n                    modified = False\n                    for pos in range(i + m - 1, i - 1, -1):\n                        if not fixed[pos]:\n                            word[pos] = 'b'\n                            modified = True\n                            break\n                    if not modified:\n                        return \"\"\n        return \"\".join(word)",
  "input": "generateString(str1=\"TFTF\", str2=\"ab\")",
  "output": "'ababa'",
  "correct_condition": "generateString(str1=\"TFTF\", str2=\"ab\") == 'ababa'",
  "contest_id": "weekly-contest-439",
  "contest_date": "2025-03-02T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 36,
    "coverage": null
  },
  "submission_id": 1559842202,
  "mutated_code": "def generateString(str1: str, str2: str) -> str:\n    n, m = (len(str1), len(str2))\n    L = n + m + 1\n    word = [None] * L\n    fixed = [False] * L\n    for i in range(n):\n        if str1[i] == 'T':\n            for j in range(m):\n                pos = i + j\n                if word[pos] is not None and word[pos] != str2[j]:\n                    return ''\n                word[pos] = str2[j]\n                fixed[pos] = True\n    for i in range(L):\n        if word[i] is None:\n            word[i] = 'a'\n    for i in range(n):\n        if str1[i] == 'F':\n            equal = True\n            for j in range(m):\n                if word[i + j] != str2[j]:\n                    equal = False\n                    break\n            if equal:\n                modified = False\n                for pos in range(i + m - 1, i - 1, -1):\n                    if not fixed[pos]:\n                        word[pos] = 'b'\n                        modified = True\n                        break\n                if not modified:\n                    return ''\n    return ''.join(word)",
  "mutated_output": "'ababaaa'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest439_q3770_s2",
  "question_id": 3770,
  "function_name": "generateString",
  "code": "def generateString(str1: str, str2: str) -> str:\n        n, m = len(str1), len(str2)\n        L = n + m - 1\n        res = [None] * L\n        free = [True] * L\n        \n        for i in range(n):\n            if str1[i] == 'T':\n                for j in range(m):\n                    pos = i + j\n                    c = str2[j]\n                    if res[pos] is None:\n                        res[pos] = c\n                        free[pos] = False\n                    elif res[pos] != c:\n                        return \"\"\n                        \n        for i in range(L):\n            if res[i] is None:\n                res[i] = 'a'\n                \n        for i in range(n):\n            if str1[i] == 'F':\n                eq = True\n                \n                for j in range(m):\n                    if res[i+j] != str2[j]:\n                        eq = False\n                        break\n                        \n                if eq:\n                    cand = -1\n                    for j in range(m):\n                        pos = i + j\n                        if free[pos]:\n                            cand = pos\n                    if cand == -1:\n                        return \"\"\n                    res[cand] = 'b'\n                    free[cand] = False\n                    \n        return \"\".join(res)",
  "input": "generateString(str1=\"TFTF\", str2=\"ab\")",
  "output": "'ababa'",
  "correct_condition": "generateString(str1=\"TFTF\", str2=\"ab\") == 'ababa'",
  "contest_id": "weekly-contest-439",
  "contest_date": "2025-03-02T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 42,
    "coverage": null
  },
  "submission_id": 1559848310,
  "mutated_code": "def generateString(str1: str, str2: str) -> str:\n    n, m = (len(str1), len(str2))\n    L = n + m + 1\n    res = [None] * L\n    free = [True] * L\n    for i in range(n):\n        if str1[i] == 'T':\n            for j in range(m):\n                pos = i + j\n                c = str2[j]\n                if res[pos] is None:\n                    res[pos] = c\n                    free[pos] = False\n                elif res[pos] != c:\n                    return ''\n    for i in range(L):\n        if res[i] is None:\n            res[i] = 'a'\n    for i in range(n):\n        if str1[i] == 'F':\n            eq = True\n            for j in range(m):\n                if res[i + j] != str2[j]:\n                    eq = False\n                    break\n            if eq:\n                cand = -1\n                for j in range(m):\n                    pos = i + j\n                    if free[pos]:\n                        cand = pos\n                if cand == -1:\n                    return ''\n                res[cand] = 'b'\n                free[cand] = False\n    return ''.join(res)",
  "mutated_output": "'ababaaa'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest440_q3790_s0",
  "question_id": 3790,
  "function_name": "numOfUnplacedFruits",
  "code": "def numOfUnplacedFruits(f: List[int], b: List[int]) -> int:\n        n = len(f)\n        u = [0]*n\n        c = 0\n        for x in f:\n            p = 0\n            for i in range(n):\n                if not u[i] and b[i] >= x:\n                    u[i] = 1\n                    p = 1\n                    break\n            if not p:\n                c += 1\n        return c\n",
  "input": "numOfUnplacedFruits(f=[4,2,5], b=[3,5,4])",
  "output": "1",
  "correct_condition": "numOfUnplacedFruits(f=[4,2,5], b=[3,5,4]) == 1",
  "contest_id": "weekly-contest-440",
  "contest_date": "2025-03-09T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1567562189,
  "mutated_code": "def numOfUnplacedFruits(f: List[int], b: List[int]) -> int:\n    n = len(f)\n    u = [0] * n\n    c = 0\n    for x in f:\n        p = 0\n        for i in range(n):\n            if not u[i] or b[i] >= x:\n                u[i] = 1\n                p = 1\n                break\n        if not p:\n            c += 1\n    return c",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "logical",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest440_q3790_s1",
  "question_id": 3790,
  "function_name": "numOfUnplacedFruits",
  "code": "def numOfUnplacedFruits(fruits: List[int], baskets: List[int]) -> int:\n        n = len(fruits)\n        \n        usedBaskets = [False] * n\n        placedFruits = [False] * n\n        \n        for i in range(n):\n            fruitQty = fruits[i]\n            \n            leftmostBasket = -1\n            for j in range(n):\n                if not usedBaskets[j] and baskets[j] >= fruitQty:\n                    leftmostBasket = j\n                    break\n            \n            if leftmostBasket != -1:\n                placedFruits[i] = True\n                usedBaskets[leftmostBasket] = True\n        \n        unplacedCount = sum(1 for placed in placedFruits if not placed)\n        return unplacedCount",
  "input": "numOfUnplacedFruits(fruits=[4,2,5], baskets=[3,5,4])",
  "output": "1",
  "correct_condition": "numOfUnplacedFruits(fruits=[4,2,5], baskets=[3,5,4]) == 1",
  "contest_id": "weekly-contest-440",
  "contest_date": "2025-03-09T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 21,
    "coverage": null
  },
  "submission_id": 1567552337,
  "mutated_code": "def numOfUnplacedFruits(fruits: List[int], baskets: List[int]) -> int:\n    n = len(fruits)\n    usedBaskets = [False] * n\n    placedFruits = [False] * n\n    for i in range(n):\n        fruitQty = fruits[i]\n        leftmostBasket = -1\n        for j in range(n):\n            if not usedBaskets[j] and baskets[j] >= fruitQty:\n                leftmostBasket = j\n                break\n        if leftmostBasket == -1:\n            placedFruits[i] = True\n            usedBaskets[leftmostBasket] = True\n    unplacedCount = sum((1 for placed in placedFruits if not placed))\n    return unplacedCount",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest440_q3790_s2",
  "question_id": 3790,
  "function_name": "numOfUnplacedFruits",
  "code": "def numOfUnplacedFruits(a: List[int], b: List[int]) -> int:\n        n = len(a)\n        m = 1 << ((n - 1).bit_length())\n        \n        t = [-1] * (2 * m)\n        for i in range(n):\n            t[m + i] = b[i]\n            \n        for i in range(m - 1, 0, -1):\n            t[i] = max(t[2 * i], t[2 * i + 1])\n        def u(i, v):\n            i += m\n            t[i] = v\n            i //= 2\n            while i:\n                t[i] = max(t[2 * i], t[2 * i + 1])\n                i //= 2\n        def q(x):\n            if t[1] < x:\n                return -1\n            i = 1\n            while i < m:\n                i = 2 * i if t[2 * i] >= x else 2 * i + 1\n            return i - m if i - m < n else -1\n        ans = 0\n        for x in a:\n            i = q(x)\n            if i == -1:\n                ans += 1\n            else:\n                u(i, -1)\n        return ans",
  "input": "numOfUnplacedFruits(a=[4,2,5], b=[3,5,4])",
  "output": "1",
  "correct_condition": "numOfUnplacedFruits(a=[4,2,5], b=[3,5,4]) == 1",
  "contest_id": "weekly-contest-440",
  "contest_date": "2025-03-09T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 32,
    "coverage": null
  },
  "submission_id": 1567581598,
  "mutated_code": "def numOfUnplacedFruits(a: List[int], b: List[int]) -> int:\n    n = len(a)\n    m = 1 << (n - 1).bit_length()\n    t = [-1] * (2 * m)\n    for i in range(n):\n        t[m - i] = b[i]\n    for i in range(m - 1, 0, -1):\n        t[i] = max(t[2 * i], t[2 * i + 1])\n\n    def u(i, v):\n        i += m\n        t[i] = v\n        i //= 2\n        while i:\n            t[i] = max(t[2 * i], t[2 * i + 1])\n            i //= 2\n\n    def q(x):\n        if t[1] < x:\n            return -1\n        i = 1\n        while i < m:\n            i = 2 * i if t[2 * i] >= x else 2 * i + 1\n        return i - m if i - m < n else -1\n    ans = 0\n    for x in a:\n        i = q(x)\n        if i == -1:\n            ans += 1\n        else:\n            u(i, -1)\n    return ans",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest440_q3759_s0",
  "question_id": 3759,
  "function_name": "findMaxSum",
  "code": "def findMaxSum(a: List[int], b: List[int], k: int) -> List[int]:\n        import heapq\n        n=len(a)\n        L=[(a[i],b[i],i) for i in range(n)]\n        L.sort(key=lambda x:x[0])\n        r=[0]*n\n        h=[]\n        s=0\n        i=0\n        while i<n:\n            v=L[i][0]\n            j=i\n            while j<n and L[j][0]==v:\n                r[L[j][2]]=s\n                j+=1\n            for p in range(i,j):\n                y=L[p][1]\n                if len(h)<k:\n                    heapq.heappush(h,y)\n                    s+=y\n                elif y>h[0]:\n                    t=heapq.heapreplace(h,y)\n                    s+=y-t\n            i=j\n        return r\n",
  "input": "findMaxSum(a=[4,2,1,5,3], b=[10,20,30,40,50], k=2)",
  "output": "[80, 30, 0, 80, 50]",
  "correct_condition": "findMaxSum(a=[4,2,1,5,3], b=[10,20,30,40,50], k=2) == [80, 30, 0, 80, 50]",
  "contest_id": "weekly-contest-440",
  "contest_date": "2025-03-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 25,
    "coverage": null
  },
  "submission_id": 1567561194,
  "mutated_code": "def findMaxSum(a: List[int], b: List[int], k: int) -> List[int]:\n    import heapq\n    n = len(a)\n    L = [(a[i], b[i], i) for i in range(n)]\n    L.sort(key=lambda x: x[0])\n    r = [0] * n\n    h = []\n    s = 0\n    i = 0\n    while i < n:\n        v = L[i][0]\n        j = i\n        while j < n and L[j][0] == v:\n            r[L[j][2]] = s\n            j += 1\n        for p in range(i, j):\n            y = L[p][1]\n            if len(h) < k:\n                heapq.heappush(h, y)\n                s += y\n            elif y > h[0]:\n                t = heapq.heapreplace(h, y)\n                s += y + t\n        i = j\n    return r",
  "mutated_output": "[120, 30, 0, 120, 50]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest440_q3759_s1",
  "question_id": 3759,
  "function_name": "findMaxSum",
  "code": "def findMaxSum(nums1, nums2, k):\n        n = len(nums1)\n        pairArr = []\n        i = 0\n        while i < n:\n            pairArr.append((nums1[i], nums2[i], i))\n            i += 1\n        pairArr.sort(key=lambda x: x[0])\n        ans = [0] * n\n        heap = []\n        currentSum = 0\n        i = 0\n        while i < n:\n            j = i\n            while j < n and pairArr[j][0] == pairArr[i][0]:\n                j += 1\n            p = i\n            while p < j:\n                origIdx = pairArr[p][2]\n                ans[origIdx] = currentSum\n                p += 1\n            p = i\n            while p < j:\n                val = pairArr[p][1]\n                heapq.heappush(heap, val)\n                currentSum += val\n                if len(heap) > k:\n                    rem = heapq.heappop(heap)\n                    currentSum -= rem\n                p += 1\n            i = j\n        return ans",
  "input": "findMaxSum(nums1=[4,2,1,5,3], nums2=[10,20,30,40,50], k=2)",
  "output": "[80, 30, 0, 80, 50]",
  "correct_condition": "findMaxSum(nums1=[4,2,1,5,3], nums2=[10,20,30,40,50], k=2) == [80, 30, 0, 80, 50]",
  "contest_id": "weekly-contest-440",
  "contest_date": "2025-03-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 32,
    "coverage": null
  },
  "submission_id": 1567558204,
  "mutated_code": "def findMaxSum(nums1, nums2, k):\n    n = len(nums1)\n    pairArr = []\n    i = 0\n    while i < n:\n        pairArr.append((nums1[i], nums2[i], i))\n        i += 1\n    pairArr.sort(key=lambda x: x[0])\n    ans = [0] * n\n    heap = []\n    currentSum = 0\n    i = 0\n    while i < n:\n        j = i\n        while j < n and pairArr[j][0] == pairArr[i][0]:\n            j += 1\n        p = i\n        while p < j:\n            origIdx = pairArr[p][2]\n            ans[origIdx] = currentSum\n            p += 1\n        p = i\n        while p < j:\n            val = pairArr[p][1]\n            heapq.heappush(heap, val)\n            currentSum += val\n            if len(heap) >= k:\n                rem = heapq.heappop(heap)\n                currentSum -= rem\n            p += 1\n        i = j\n    return ans",
  "mutated_output": "[50, 30, 0, 50, 30]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 6,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest440_q3759_s2",
  "question_id": 3759,
  "function_name": "findMaxSum",
  "code": "def findMaxSum(a: List[int], b: List[int], k: int) -> List[int]:\n        n = len(a)\n        P = sorted(zip(a, b, range(n)), key=lambda x: x[0])\n        R = [0] * n\n        h, s = [], 0\n        i = 0\n        while i < n:\n            j = i\n            while j < n and P[j][0] == P[i][0]:\n                R[P[j][2]] = s\n                j += 1\n            for _, y, _ in P[i:j]:\n                if len(h) < k:\n                    heapq.heappush(h, y)\n                    s += y\n                elif y > h[0]:\n                    s += y - h[0]\n                    heapq.heapreplace(h, y)\n            i = j\n        return R",
  "input": "findMaxSum(a=[4,2,1,5,3], b=[10,20,30,40,50], k=2)",
  "output": "[80, 30, 0, 80, 50]",
  "correct_condition": "findMaxSum(a=[4,2,1,5,3], b=[10,20,30,40,50], k=2) == [80, 30, 0, 80, 50]",
  "contest_id": "weekly-contest-440",
  "contest_date": "2025-03-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 20,
    "coverage": null
  },
  "submission_id": 1567577211,
  "mutated_code": "def findMaxSum(a: List[int], b: List[int], k: int) -> List[int]:\n    n = len(a)\n    P = sorted(zip(a, b, range(n)), key=lambda x: x[0])\n    R = [0] * n\n    h, s = ([], 0)\n    i = 0\n    while i < n:\n        j = i\n        while j < n and P[j][0] == P[i][0]:\n            R[P[j][2]] = s\n            j += 1\n        for _, y, _ in P[i:j]:\n            if len(h) < k:\n                heapq.heappush(h, y)\n                s += y\n            elif y > h[0]:\n                s += y + h[0]\n                heapq.heapreplace(h, y)\n        i = j\n    return R",
  "mutated_output": "[120, 30, 0, 120, 50]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest440_q3791_s0",
  "question_id": 3791,
  "function_name": "numOfUnplacedFruits",
  "code": "def numOfUnplacedFruits(f: List[int], b: List[int]) -> int:\n        n = len(b)\n        s = 1\n        while s < n: s *= 2\n        t = [0]*(2*s)\n        for i in range(n): t[s+i] = b[i]\n        for i in range(s-1, 0, -1): t[i] = max(t[2*i], t[2*i+1])\n        c = 0\n        for x in f:\n            if t[1] < x:\n                c += 1\n            else:\n                i = 1\n                while i < s:\n                    if t[2*i] >= x:\n                        i = 2*i\n                    else:\n                        i = 2*i+1\n                j = i - s\n                t[i] = -1\n                i //= 2\n                while i:\n                    t[i] = max(t[2*i], t[2*i+1])\n                    i //= 2\n        return c\n",
  "input": "numOfUnplacedFruits(f=[4,2,5], b=[3,5,4])",
  "output": "1",
  "correct_condition": "numOfUnplacedFruits(f=[4,2,5], b=[3,5,4]) == 1",
  "contest_id": "weekly-contest-440",
  "contest_date": "2025-03-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 25,
    "coverage": null
  },
  "submission_id": 1567552448,
  "mutated_code": "def numOfUnplacedFruits(f: List[int], b: List[int]) -> int:\n    n = len(b)\n    s = 1\n    while s < n:\n        s *= 2\n    t = [0] * (2 * s)\n    for i in range(n):\n        t[s - i] = b[i]\n    for i in range(s - 1, 0, -1):\n        t[i] = max(t[2 * i], t[2 * i + 1])\n    c = 0\n    for x in f:\n        if t[1] < x:\n            c += 1\n        else:\n            i = 1\n            while i < s:\n                if t[2 * i] >= x:\n                    i = 2 * i\n                else:\n                    i = 2 * i + 1\n            j = i - s\n            t[i] = -1\n            i //= 2\n            while i:\n                t[i] = max(t[2 * i], t[2 * i + 1])\n                i //= 2\n    return c",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest440_q3791_s1",
  "question_id": 3791,
  "function_name": "numOfUnplacedFruits",
  "code": "def numOfUnplacedFruits(fruits, baskets):\n        n = len(baskets)\n        treeSize = 1\n        while treeSize < n:\n            treeSize *= 2\n        tree = [0] * (2 * treeSize)\n        i = 0\n        while i < n:\n            tree[treeSize + i] = baskets[i]\n            i += 1\n        i = n\n        while i < treeSize:\n            tree[treeSize + i] = 0\n            i += 1\n        i = treeSize - 1\n        while i >= 1:\n            leftChild = tree[2 * i]\n            rightChild = tree[2 * i + 1]\n            if leftChild >= rightChild:\n                tree[i] = leftChild\n            else:\n                tree[i] = rightChild\n            i -= 1\n        def query(val):\n            if tree[1] < val:\n                return -1\n            idx = 1\n            while idx < treeSize:\n                leftIdx = 2 * idx\n                if tree[leftIdx] >= val:\n                    idx = leftIdx\n                else:\n                    idx = leftIdx + 1\n            return idx - treeSize\n        def update(pos, newVal):\n            idx = pos + treeSize\n            tree[idx] = newVal\n            idx //= 2\n            while idx >= 1:\n                leftVal = tree[2 * idx]\n                rightVal = tree[2 * idx + 1]\n                if leftVal >= rightVal:\n                    tree[idx] = leftVal\n                else:\n                    tree[idx] = rightVal\n                idx //= 2\n        unplaced = 0\n        i = 0\n        while i < len(fruits):\n            fVal = fruits[i]\n            pos = query(fVal)\n            if pos == -1:\n                unplaced += 1\n            else:\n                update(pos, 0)\n            i += 1\n        return unplaced",
  "input": "numOfUnplacedFruits(fruits=[4,2,5], baskets=[3,5,4])",
  "output": "1",
  "correct_condition": "numOfUnplacedFruits(fruits=[4,2,5], baskets=[3,5,4]) == 1",
  "contest_id": "weekly-contest-440",
  "contest_date": "2025-03-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 57,
    "coverage": null
  },
  "submission_id": 1567569757,
  "mutated_code": "def numOfUnplacedFruits(fruits, baskets):\n    n = len(baskets)\n    treeSize = 1\n    while treeSize < n:\n        treeSize *= 2\n    tree = [0] * (2 * treeSize)\n    i = 0\n    while i < n:\n        tree[treeSize - i] = baskets[i]\n        i += 1\n    i = n\n    while i < treeSize:\n        tree[treeSize + i] = 0\n        i += 1\n    i = treeSize - 1\n    while i >= 1:\n        leftChild = tree[2 * i]\n        rightChild = tree[2 * i + 1]\n        if leftChild >= rightChild:\n            tree[i] = leftChild\n        else:\n            tree[i] = rightChild\n        i -= 1\n\n    def query(val):\n        if tree[1] < val:\n            return -1\n        idx = 1\n        while idx < treeSize:\n            leftIdx = 2 * idx\n            if tree[leftIdx] >= val:\n                idx = leftIdx\n            else:\n                idx = leftIdx + 1\n        return idx - treeSize\n\n    def update(pos, newVal):\n        idx = pos + treeSize\n        tree[idx] = newVal\n        idx //= 2\n        while idx >= 1:\n            leftVal = tree[2 * idx]\n            rightVal = tree[2 * idx + 1]\n            if leftVal >= rightVal:\n                tree[idx] = leftVal\n            else:\n                tree[idx] = rightVal\n            idx //= 2\n    unplaced = 0\n    i = 0\n    while i < len(fruits):\n        fVal = fruits[i]\n        pos = query(fVal)\n        if pos == -1:\n            unplaced += 1\n        else:\n            update(pos, 0)\n        i += 1\n    return unplaced",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest440_q3791_s2",
  "question_id": 3791,
  "function_name": "numOfUnplacedFruits",
  "code": "def numOfUnplacedFruits(a: List[int], b: List[int]) -> int:\n        n = len(a)\n        m = 1 << ((n - 1).bit_length())\n        \n        t = [-1] * (2 * m)\n        for i in range(n):\n            t[m + i] = b[i]\n            \n        for i in range(m - 1, 0, -1):\n            t[i] = max(t[2 * i], t[2 * i + 1])\n        def u(i, v):\n            i += m\n            t[i] = v\n            i //= 2\n            while i:\n                t[i] = max(t[2 * i], t[2 * i + 1])\n                i //= 2\n        def q(x):\n            if t[1] < x:\n                return -1\n            i = 1\n            while i < m:\n                i = 2 * i if t[2 * i] >= x else 2 * i + 1\n            return i - m if i - m < n else -1\n        ans = 0\n        for x in a:\n            i = q(x)\n            if i == -1:\n                ans += 1\n            else:\n                u(i, -1)\n        return ans",
  "input": "numOfUnplacedFruits(a=[4,2,5], b=[3,5,4])",
  "output": "1",
  "correct_condition": "numOfUnplacedFruits(a=[4,2,5], b=[3,5,4]) == 1",
  "contest_id": "weekly-contest-440",
  "contest_date": "2025-03-09T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 32,
    "coverage": null
  },
  "submission_id": 1567582045,
  "mutated_code": "def numOfUnplacedFruits(a: List[int], b: List[int]) -> int:\n    n = len(a)\n    m = 1 << (n - 1).bit_length()\n    t = [-1] * (2 * m)\n    for i in range(n):\n        t[m - i] = b[i]\n    for i in range(m - 1, 0, -1):\n        t[i] = max(t[2 * i], t[2 * i + 1])\n\n    def u(i, v):\n        i += m\n        t[i] = v\n        i //= 2\n        while i:\n            t[i] = max(t[2 * i], t[2 * i + 1])\n            i //= 2\n\n    def q(x):\n        if t[1] < x:\n            return -1\n        i = 1\n        while i < m:\n            i = 2 * i if t[2 * i] >= x else 2 * i + 1\n        return i - m if i - m < n else -1\n    ans = 0\n    for x in a:\n        i = q(x)\n        if i == -1:\n            ans += 1\n        else:\n            u(i, -1)\n    return ans",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest440_q3789_s0",
  "question_id": 3789,
  "function_name": "maxSubarrays",
  "code": "def maxSubarrays(n: int, r: List[List[int]]) -> int:\n        for i in range(len(r)):\n            a, b = r[i]\n            if a > b:\n                r[i] = [b, a]\n        M = [[] for _ in range(n+1)]\n        for a, b in r:\n            M[a].append(b)\n        for i in range(1, n+1):\n            M[i].sort()\n        D = [None]*(n+2)\n        D[n+1] = (n+1, 0, n+1)\n        for i in range(n, 0, -1):\n            d = {}\n            for v in M[i]:\n                d[v] = d.get(v, 0) + 1\n            x0, c0, y0 = D[i+1]\n            if c0 > 0:\n                d[x0] = d.get(x0, 0) + c0\n            if c0 == 1:\n                if y0 != x0:\n                    d[y0] = d.get(y0, 0) + 1\n            U = sorted(d.keys()) if d else [n+1]\n            x = U[0]\n            c = d[x] if d else 0\n            y = U[1] if len(U) > 1 else n+1\n            D[i] = (x, c, y)\n        A = 0\n        for i in range(1, n+1):\n            A += D[i][0] - i\n        d2 = {}\n        for i in range(1, n+1):\n            x, c, y = D[i]\n            if x != n+1 and c == 1:\n                if x not in d2:\n                    d2[x] = ([], [])\n                d2[x][0].append(i)\n                d2[x][1].append(y - x)\n        import bisect\n        for k in d2:\n            L, S = d2[k]\n            for i in range(1, len(S)):\n                S[i] += S[i-1]\n        m = 0\n        for a, b in r:\n            if b in d2:\n                i = bisect.bisect_right(d2[b][0], a)\n            else:\n                i = 0\n            s = d2[b][1][i-1] if i else 0\n            if s > m:\n                m = s\n        return A + m\n",
  "input": "maxSubarrays(n=4, r=[[2,3],[1,4]])",
  "output": "9",
  "correct_condition": "maxSubarrays(n=4, r=[[2,3],[1,4]]) == 9",
  "contest_id": "weekly-contest-440",
  "contest_date": "2025-03-09T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 53,
    "coverage": null
  },
  "submission_id": 1567558598,
  "mutated_code": "def maxSubarrays(n: int, r: List[List[int]]) -> int:\n    for i in range(len(r)):\n        a, b = r[i]\n        if a > b:\n            r[i] = [b, a]\n    M = [[] for _ in range(n + 1)]\n    for a, b in r:\n        M[a].append(b)\n    for i in range(1, n + 1):\n        M[i].sort()\n    D = [None] * (n + 2)\n    D[n + 1] = (n + 1, 0, n + 1)\n    for i in range(n, 0, -1):\n        d = {}\n        for v in M[i]:\n            d[v] = d.get(v, 0) - 1\n        x0, c0, y0 = D[i + 1]\n        if c0 > 0:\n            d[x0] = d.get(x0, 0) + c0\n        if c0 == 1:\n            if y0 != x0:\n                d[y0] = d.get(y0, 0) + 1\n        U = sorted(d.keys()) if d else [n + 1]\n        x = U[0]\n        c = d[x] if d else 0\n        y = U[1] if len(U) > 1 else n + 1\n        D[i] = (x, c, y)\n    A = 0\n    for i in range(1, n + 1):\n        A += D[i][0] - i\n    d2 = {}\n    for i in range(1, n + 1):\n        x, c, y = D[i]\n        if x != n + 1 and c == 1:\n            if x not in d2:\n                d2[x] = ([], [])\n            d2[x][0].append(i)\n            d2[x][1].append(y - x)\n    import bisect\n    for k in d2:\n        L, S = d2[k]\n        for i in range(1, len(S)):\n            S[i] += S[i - 1]\n    m = 0\n    for a, b in r:\n        if b in d2:\n            i = bisect.bisect_right(d2[b][0], a)\n        else:\n            i = 0\n        s = d2[b][1][i - 1] if i else 0\n        if s > m:\n            m = s\n    return A + m",
  "mutated_output": "7",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 7,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest440_q3789_s1",
  "question_id": 3789,
  "function_name": "maxSubarrays",
  "code": "def maxSubarrays(n: int, conflictingPairs: List[List[int]]) -> int:\n        pairs = []\n        i = 0\n        \n        while i < len(conflictingPairs):\n            a = conflictingPairs[i][0]\n            b = conflictingPairs[i][1]\n            if a > b:\n                tmp = a\n                a = b\n                b = tmp\n            pairs.append((b, a, i))\n            i += 1\n            \n        pairs.sort(key=lambda x: (x[0], x[1]))\n        curMax = 0\n        curSec = 0\n        curCount = 0\n        curId = -1\n        pointer = 0\n        f0 = 0\n        delta = {}\n        r = 1\n        \n        while r <= n:\n            while pointer < len(pairs) and pairs[pointer][0] == r:\n                bVal = pairs[pointer][0]\n                aVal = pairs[pointer][1]\n                pairId = pairs[pointer][2]\n                if aVal > curMax:\n                    curSec = curMax\n                    curMax = aVal\n                    curCount = 1\n                    curId = pairId\n                elif aVal == curMax:\n                    curCount = curCount + 1\n                    curId = -1\n                else:\n                    if aVal > curSec:\n                        curSec = aVal\n                pointer = pointer + 1\n            f0 = f0 + (r - curMax)\n            if curMax > 0 and curCount == 1 and curId != -1:\n                if curId in delta:\n                    delta[curId] = delta[curId] + (curMax - curSec)\n                else:\n                    delta[curId] = (curMax - curSec)\n            r = r + 1\n        maxDelta = 0\n        \n        for key in delta:\n            if delta[key] > maxDelta:\n                maxDelta = delta[key]\n                \n        return f0 + maxDelta",
  "input": "maxSubarrays(n=4, conflictingPairs=[[2,3],[1,4]])",
  "output": "9",
  "correct_condition": "maxSubarrays(n=4, conflictingPairs=[[2,3],[1,4]]) == 9",
  "contest_id": "weekly-contest-440",
  "contest_date": "2025-03-09T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 55,
    "coverage": null
  },
  "submission_id": 1567583893,
  "mutated_code": "def maxSubarrays(n: int, conflictingPairs: List[List[int]]) -> int:\n    pairs = []\n    i = 0\n    while i < len(conflictingPairs):\n        a = conflictingPairs[i][0]\n        b = conflictingPairs[i][1]\n        if a > b:\n            tmp = a\n            a = b\n            b = tmp\n        pairs.append((b, a, i))\n        i += 1\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    curMax = 0\n    curSec = 0\n    curCount = 0\n    curId = -1\n    pointer = 0\n    f0 = 0\n    delta = {}\n    r = 1\n    while r <= n:\n        while pointer < len(pairs) and pairs[pointer][0] == r:\n            bVal = pairs[pointer][0]\n            aVal = pairs[pointer][1]\n            pairId = pairs[pointer][2]\n            if aVal > curMax:\n                curSec = curMax\n                curMax = aVal\n                curCount = 1\n                curId = pairId\n            elif aVal == curMax:\n                curCount = curCount + 1\n                curId = -1\n            elif aVal > curSec:\n                curSec = aVal\n            pointer = pointer + 1\n        f0 = f0 - (r - curMax)\n        if curMax > 0 and curCount == 1 and (curId != -1):\n            if curId in delta:\n                delta[curId] = delta[curId] + (curMax - curSec)\n            else:\n                delta[curId] = curMax - curSec\n        r = r + 1\n    maxDelta = 0\n    for key in delta:\n        if delta[key] > maxDelta:\n            maxDelta = delta[key]\n    return f0 + maxDelta",
  "mutated_output": "-3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest440_q3789_s2",
  "question_id": 3789,
  "function_name": "maxSubarrays",
  "code": "def maxSubarrays(n: int, cp: List[List[int]]) -> int:\n        NIL = 0\n        I = n + 1\n        p = ((a, b) if a < b else (b, a) for a, b in cp)\n        B = [[] for _ in range(n+1)]\n        for L, R in p:\n            B[L].append(R)\n        d = [None]*(n+2)\n        d[n+1] = (I, 0, I, NIL)\n        for i in range(n, 0, -1):\n            if B[i]:\n                lst = sorted(B[i])\n                f = lst[0]\n                cnt = lst.count(f)\n                s = min((x for x in lst if x > f), default=I)\n                x = (f, cnt, s, i)\n            else:\n                x = (I, 0, I, NIL)\n            y = d[i+1]\n            m = min(x[0], y[0])\n            cnt = 0\n            aid = NIL\n            if x[0] == m:\n                cnt += x[1]\n                if x[1] == 1:\n                    aid = x[3]\n            if y[0] == m:\n                cnt += y[1]\n                if y[1] == 1:\n                    aid = y[3] if aid == NIL else NIL\n            cur = []\n            if x[0] > m: cur.append(x[0])\n            if y[0] > m: cur.append(y[0])\n            if x[2] < I: cur.append(x[2])\n            if y[2] < I: cur.append(y[2])\n            sec = min(cur) if cur else I\n            d[i] = (m, cnt, sec, aid)\n        ans = 0\n        for i in range(1, n+1):\n            ans += (n - i + 1) if d[i][0] == I else (d[i][0] - i)\n        mp = defaultdict(int)\n        for i in range(1, n+1):\n            m, c, s, aid = d[i]\n            if m != I and c == 1 and aid != NIL:\n                sc = s if s != I else (n + 1)\n                mp[aid] += sc - m\n        mx = 0\n        if mp:\n            mx = max(mx, max(mp.values()))\n        return ans + mx",
  "input": "maxSubarrays(n=4, cp=[[2,3],[1,4]])",
  "output": "9",
  "correct_condition": "maxSubarrays(n=4, cp=[[2,3],[1,4]]) == 9",
  "contest_id": "weekly-contest-440",
  "contest_date": "2025-03-09T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 50,
    "coverage": null
  },
  "submission_id": 1567579889,
  "mutated_code": "def maxSubarrays(n: int, cp: List[List[int]]) -> int:\n    NIL = 0\n    I = n - 1\n    p = ((a, b) if a < b else (b, a) for a, b in cp)\n    B = [[] for _ in range(n + 1)]\n    for L, R in p:\n        B[L].append(R)\n    d = [None] * (n + 2)\n    d[n + 1] = (I, 0, I, NIL)\n    for i in range(n, 0, -1):\n        if B[i]:\n            lst = sorted(B[i])\n            f = lst[0]\n            cnt = lst.count(f)\n            s = min((x for x in lst if x > f), default=I)\n            x = (f, cnt, s, i)\n        else:\n            x = (I, 0, I, NIL)\n        y = d[i + 1]\n        m = min(x[0], y[0])\n        cnt = 0\n        aid = NIL\n        if x[0] == m:\n            cnt += x[1]\n            if x[1] == 1:\n                aid = x[3]\n        if y[0] == m:\n            cnt += y[1]\n            if y[1] == 1:\n                aid = y[3] if aid == NIL else NIL\n        cur = []\n        if x[0] > m:\n            cur.append(x[0])\n        if y[0] > m:\n            cur.append(y[0])\n        if x[2] < I:\n            cur.append(x[2])\n        if y[2] < I:\n            cur.append(y[2])\n        sec = min(cur) if cur else I\n        d[i] = (m, cnt, sec, aid)\n    ans = 0\n    for i in range(1, n + 1):\n        ans += n - i + 1 if d[i][0] == I else d[i][0] - i\n    mp = defaultdict(int)\n    for i in range(1, n + 1):\n        m, c, s, aid = d[i]\n        if m != I and c == 1 and (aid != NIL):\n            sc = s if s != I else n + 1\n            mp[aid] += sc - m\n    mx = 0\n    if mp:\n        mx = max(mx, max(mp.values()))\n    return ans + mx",
  "mutated_output": "10",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest441_q3788_s0",
  "question_id": 3788,
  "function_name": "maxSum",
  "code": "def maxSum(a: List[int]) -> int:\n        s = {x for x in a if x > 0}\n        return sum(s) if s else max(a)\n",
  "input": "maxSum(a=[1,2,3,4,5])",
  "output": "15",
  "correct_condition": "maxSum(a=[1,2,3,4,5]) == 15",
  "contest_id": "weekly-contest-441",
  "contest_date": "2025-03-16T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 3,
    "coverage": null
  },
  "submission_id": 1575094028,
  "mutated_code": "def maxSum(a: List[int]) -> int:\n    s = {x for x in a if x > 1}\n    return sum(s) if s else max(a)",
  "mutated_output": "14",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest441_q3788_s1",
  "question_id": 3788,
  "function_name": "maxSum",
  "code": "def maxSum(nums: List[int]) -> int:\n        positive_set = {num for num in nums if num > 0}\n        \n        if positive_set:\n            return sum(positive_set)\n        else:\n            return max(nums)",
  "input": "maxSum(nums=[1,2,3,4,5])",
  "output": "15",
  "correct_condition": "maxSum(nums=[1,2,3,4,5]) == 15",
  "contest_id": "weekly-contest-441",
  "contest_date": "2025-03-16T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1575079192,
  "mutated_code": "def maxSum(nums: List[int]) -> int:\n    positive_set = {num for num in nums if num > 1}\n    if positive_set:\n        return sum(positive_set)\n    else:\n        return max(nums)",
  "mutated_output": "14",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest441_q3788_s2",
  "question_id": 3788,
  "function_name": "maxSum",
  "code": "def maxSum(nums: List[int]) -> int:\n        positive_set = set()\n        total_sum = 0\n        for num in nums:\n            if num > 0 and num not in positive_set:\n                positive_set.add(num)\n                total_sum += num\n        if total_sum > 0:\n            return total_sum\n        return max(nums)",
  "input": "maxSum(nums=[1,2,3,4,5])",
  "output": "15",
  "correct_condition": "maxSum(nums=[1,2,3,4,5]) == 15",
  "contest_id": "weekly-contest-441",
  "contest_date": "2025-03-16T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 10,
    "coverage": null
  },
  "submission_id": 1575080067,
  "mutated_code": "def maxSum(nums: List[int]) -> int:\n    positive_set = set()\n    total_sum = 1\n    for num in nums:\n        if num > 0 and num not in positive_set:\n            positive_set.add(num)\n            total_sum += num\n    if total_sum > 0:\n        return total_sum\n    return max(nums)",
  "mutated_output": "16",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest441_q3750_s0",
  "question_id": 3750,
  "function_name": "solveQueries",
  "code": "def solveQueries(a: List[int], b: List[int]) -> List[int]:\n        n = len(a)\n        d = {}\n        for i, x in enumerate(a):\n            d.setdefault(x, []).append(i)\n        for x in d: d[x].sort()\n        r = []\n        import bisect\n        for i in b:\n            x = a[i]\n            L = d[x]\n            if len(L) == 1:\n                r.append(-1)\n                continue\n            p = bisect.bisect_left(L, i)\n            m = n\n            if p:\n                j = L[p - 1]\n                k = i - j if i >= j else j - i\n                m = min(m, k, n - k)\n            if p < len(L) - 1:\n                j = L[p + 1]\n                k = j - i if j >= i else i - j\n                m = min(m, k, n - k)\n            if p == 0:\n                j = L[-1]\n                k = i - j if i >= j else j - i\n                m = min(m, k, n - k)\n            if p == len(L) - 1:\n                j = L[0]\n                k = j - i if j >= i else i - j\n                m = min(m, k, n - k)\n            r.append(m)\n        return r\n",
  "input": "solveQueries(a=[1,3,1,4,1,3,2], b=[0,3,5])",
  "output": "[2, -1, 3]",
  "correct_condition": "solveQueries(a=[1,3,1,4,1,3,2], b=[0,3,5]) == [2, -1, 3]",
  "contest_id": "weekly-contest-441",
  "contest_date": "2025-03-16T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 34,
    "coverage": null
  },
  "submission_id": 1575092171,
  "mutated_code": "def solveQueries(a: List[int], b: List[int]) -> List[int]:\n    n = len(a)\n    d = {}\n    for i, x in enumerate(a):\n        d.setdefault(x, []).append(i)\n    for x in d:\n        d[x].sort()\n    r = []\n    import bisect\n    for i in b:\n        x = a[i]\n        L = d[x]\n        if len(L) == 1:\n            r.append(-1)\n            continue\n        p = bisect.bisect_left(L, i)\n        m = n\n        if p:\n            j = L[p - 1]\n            k = i + j if i >= j else j - i\n            m = min(m, k, n - k)\n        if p < len(L) - 1:\n            j = L[p + 1]\n            k = j - i if j >= i else i - j\n            m = min(m, k, n - k)\n        if p == 0:\n            j = L[-1]\n            k = i - j if i >= j else j - i\n            m = min(m, k, n - k)\n        if p == len(L) - 1:\n            j = L[0]\n            k = j - i if j >= i else i - j\n            m = min(m, k, n - k)\n        r.append(m)\n    return r",
  "mutated_output": "[2, -1, 1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest441_q3750_s1",
  "question_id": 3750,
  "function_name": "solveQueries",
  "code": "def solveQueries(nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        pos_map = defaultdict(list)\n        for idx, num in enumerate(nums):\n            pos_map[num].append(idx)\n        \n        result = []\n        for q in queries:\n            val = nums[q]\n            indices = pos_map[val]\n            if len(indices) == 1:\n                result.append(-1)\n                continue\n            \n            pos = bisect.bisect_left(indices, q)\n            \n            left_neighbor = indices[pos - 1]\n            right_neighbor = indices[(pos + 1) % len(indices)]\n            \n            def circular_distance(i, j):\n                diff = abs(i - j)\n                return min(diff, n - diff)\n            \n            d_left = circular_distance(q, left_neighbor)\n            d_right = circular_distance(q, right_neighbor)\n            answer = min(d_left, d_right)\n            \n            result.append(answer)\n        \n        return result",
  "input": "solveQueries(nums=[1,3,1,4,1,3,2], queries=[0,3,5])",
  "output": "[2, -1, 3]",
  "correct_condition": "solveQueries(nums=[1,3,1,4,1,3,2], queries=[0,3,5]) == [2, -1, 3]",
  "contest_id": "weekly-contest-441",
  "contest_date": "2025-03-16T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 30,
    "coverage": null
  },
  "submission_id": 1575081382,
  "mutated_code": "def solveQueries(nums: List[int], queries: List[int]) -> List[int]:\n    n = len(nums)\n    pos_map = defaultdict(list)\n    for idx, num in enumerate(nums):\n        pos_map[num].append(idx)\n    result = []\n    for q in queries:\n        val = nums[q]\n        indices = pos_map[val]\n        if len(indices) == 1:\n            result.append(-1)\n            continue\n        pos = bisect.bisect_left(indices, q)\n        left_neighbor = indices[pos - 1]\n        right_neighbor = indices[(pos + 1) // len(indices)]\n\n        def circular_distance(i, j):\n            diff = abs(i - j)\n            return min(diff, n - diff)\n        d_left = circular_distance(q, left_neighbor)\n        d_right = circular_distance(q, right_neighbor)\n        answer = min(d_left, d_right)\n        result.append(answer)\n    return result",
  "mutated_output": "[0, -1, 0]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest441_q3750_s2",
  "question_id": 3750,
  "function_name": "solveQueries",
  "code": "def solveQueries(nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        occurrences = {}\n        for index, value in enumerate(nums):\n            occurrences.setdefault(value, []).append(index)\n        for value in occurrences:\n            occurrences[value].sort()\n        answer = []\n        for query in queries:\n            value = nums[query]\n            occ = occurrences[value]\n            if len(occ) < 2:\n                answer.append(-1)\n            else:\n                pos = bisect.bisect_left(occ, query)\n                distances = []\n                if pos > 0:\n                    candidate = occ[pos - 1]\n                    diff = abs(query - candidate)\n                    distances.append(min(diff, n - diff))\n                if pos < len(occ) - 1:\n                    candidate = occ[pos + 1]\n                    diff = abs(query - candidate)\n                    distances.append(min(diff, n - diff))\n                if pos == 0:\n                    candidate = occ[-1]\n                    diff = abs(query - candidate)\n                    distances.append(min(diff, n - diff))\n                if pos == len(occ) - 1:\n                    candidate = occ[0]\n                    diff = abs(query - candidate)\n                    distances.append(min(diff, n - diff))\n                answer.append(min(distances))\n        return answer",
  "input": "solveQueries(nums=[1,3,1,4,1,3,2], queries=[0,3,5])",
  "output": "[2, -1, 3]",
  "correct_condition": "solveQueries(nums=[1,3,1,4,1,3,2], queries=[0,3,5]) == [2, -1, 3]",
  "contest_id": "weekly-contest-441",
  "contest_date": "2025-03-16T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 34,
    "coverage": null
  },
  "submission_id": 1575086006,
  "mutated_code": "def solveQueries(nums: List[int], queries: List[int]) -> List[int]:\n    n = len(nums)\n    occurrences = {}\n    for index, value in enumerate(nums):\n        occurrences.setdefault(value, []).append(index)\n    for value in occurrences:\n        occurrences[value].sort()\n    answer = []\n    for query in queries:\n        value = nums[query]\n        occ = occurrences[value]\n        if len(occ) < 2:\n            answer.append(-1)\n        else:\n            pos = bisect.bisect_left(occ, query)\n            distances = []\n            if pos > 0:\n                candidate = occ[pos - 1]\n                diff = abs(query + candidate)\n                distances.append(min(diff, n - diff))\n            if pos < len(occ) - 1:\n                candidate = occ[pos + 1]\n                diff = abs(query - candidate)\n                distances.append(min(diff, n - diff))\n            if pos == 0:\n                candidate = occ[-1]\n                diff = abs(query - candidate)\n                distances.append(min(diff, n - diff))\n            if pos == len(occ) - 1:\n                candidate = occ[0]\n                diff = abs(query - candidate)\n                distances.append(min(diff, n - diff))\n            answer.append(min(distances))\n    return answer",
  "mutated_output": "[2, -1, 1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest441_q3795_s0",
  "question_id": 3795,
  "function_name": "minZeroArray",
  "code": "def minZeroArray(nums: List[int], queries: List[List[int]]) -> int:\n        a = nums\n        n = len(a)\n        if all(x==0 for x in a):\n            return 0\n        d = [1]*n\n        for i, q in enumerate(queries):\n            x, y, z = q\n            for j in range(x, y+1):\n                d[j] |= d[j] << z\n            if all(d[j] & (1 << a[j]) for j in range(n)):\n                return i+1\n        return -1\n",
  "input": "minZeroArray(nums=[2,0,2], queries=[[0,2,1],[0,2,1],[1,1,3]])",
  "output": "2",
  "correct_condition": "minZeroArray(nums=[2,0,2], queries=[[0,2,1],[0,2,1],[1,1,3]]) == 2",
  "contest_id": "weekly-contest-441",
  "contest_date": "2025-03-16T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 13,
    "coverage": null
  },
  "submission_id": 1575088928,
  "mutated_code": "def minZeroArray(nums: List[int], queries: List[List[int]]) -> int:\n    a = nums\n    n = len(a)\n    if all((x == 0 for x in a)):\n        return 0\n    d = [1] * n\n    for i, q in enumerate(queries):\n        x, y, z = q\n        for j in range(x, y - 1):\n            d[j] |= d[j] << z\n        if all((d[j] & 1 << a[j] for j in range(n))):\n            return i + 1\n    return -1",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest441_q3795_s1",
  "question_id": 3795,
  "function_name": "minZeroArray",
  "code": "def minZeroArray(nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        total_queries = len(queries)\n        \n        def can_sum_to(vals: List[int], target: int) -> bool:\n            dp = [False] * (target + 1)\n            dp[0] = True\n            for v in vals:\n                for t in range(target, v - 1, -1):\n                    if dp[t - v]:\n                        dp[t] = True\n                if dp[target]:\n                    return True\n            return dp[target]\n        \n        for k in range(total_queries + 1):\n            possible_for_all = True\n            for i in range(n):\n                if nums[i] == 0:\n                    continue\n                available_vals = []\n                for j in range(k):\n                    l, r, val = queries[j]\n                    if l <= i <= r:\n                        available_vals.append(val)\n                if not can_sum_to(available_vals, nums[i]):\n                    possible_for_all = False\n                    break\n            \n            if possible_for_all:\n                return k\n        \n        return -1",
  "input": "minZeroArray(nums=[2,0,2], queries=[[0,2,1],[0,2,1],[1,1,3]])",
  "output": "2",
  "correct_condition": "minZeroArray(nums=[2,0,2], queries=[[0,2,1],[0,2,1],[1,1,3]]) == 2",
  "contest_id": "weekly-contest-441",
  "contest_date": "2025-03-16T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 33,
    "coverage": null
  },
  "submission_id": 1575088850,
  "mutated_code": "def minZeroArray(nums: List[int], queries: List[List[int]]) -> int:\n    n = len(nums)\n    total_queries = len(queries)\n\n    def can_sum_to(vals: List[int], target: int) -> bool:\n        dp = [False] * (target + 1)\n        dp[0] = True\n        for v in vals:\n            for t in range(target, v + 1, -1):\n                if dp[t - v]:\n                    dp[t] = True\n            if dp[target]:\n                return True\n        return dp[target]\n    for k in range(total_queries + 1):\n        possible_for_all = True\n        for i in range(n):\n            if nums[i] == 0:\n                continue\n            available_vals = []\n            for j in range(k):\n                l, r, val = queries[j]\n                if l <= i <= r:\n                    available_vals.append(val)\n            if not can_sum_to(available_vals, nums[i]):\n                possible_for_all = False\n                break\n        if possible_for_all:\n            return k\n    return -1",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest441_q3795_s2",
  "question_id": 3795,
  "function_name": "minZeroArray",
  "code": "def minZeroArray(nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        if all(num == 0 for num in nums):\n            return 0\n        def is_feasible(num_queries):\n            for index in range(n):\n                required = nums[index]\n                dp = 1\n                mask = (1 << (required + 1)) - 1\n                for i in range(num_queries):\n                    left_bound, right_bound, query_value = queries[i]\n                    if left_bound <= index <= right_bound:\n                        dp = dp | (dp << query_value)\n                        dp &= mask\n                if (dp >> required) & 1 == 0:\n                    return False\n            return True\n        low = 0\n        high = len(queries)\n        answer = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if is_feasible(mid):\n                answer = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        return answer\n                        \n",
  "input": "minZeroArray(nums=[2,0,2], queries=[[0,2,1],[0,2,1],[1,1,3]])",
  "output": "2",
  "correct_condition": "minZeroArray(nums=[2,0,2], queries=[[0,2,1],[0,2,1],[1,1,3]]) == 2",
  "contest_id": "weekly-contest-441",
  "contest_date": "2025-03-16T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 29,
    "coverage": null
  },
  "submission_id": 1575094269,
  "mutated_code": "def minZeroArray(nums: List[int], queries: List[List[int]]) -> int:\n    n = len(nums)\n    if all((num == 0 for num in nums)):\n        return 0\n\n    def is_feasible(num_queries):\n        for index in range(n):\n            required = nums[index]\n            dp = 1\n            mask = (1 << required + 1) + 1\n            for i in range(num_queries):\n                left_bound, right_bound, query_value = queries[i]\n                if left_bound <= index <= right_bound:\n                    dp = dp | dp << query_value\n                    dp &= mask\n            if dp >> required & 1 == 0:\n                return False\n        return True\n    low = 0\n    high = len(queries)\n    answer = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if is_feasible(mid):\n            answer = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    return answer",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest441_q3801_s0",
  "question_id": 3801,
  "function_name": "beautifulNumbers",
  "code": "def beautifulNumbers(l: int, r: int) -> int:\n        def g(x):\n            return list(map(int, str(x)))\n        from functools import lru_cache\n        def h(x):\n            d = g(x)\n            @lru_cache(maxsize=None)\n            def f(i, t, st):\n                if i == len(d): return 1 if st else 0\n                a = 0\n                m = d[i] if t else 9\n                for j in range(m + 1):\n                    nt = t and (j == m)\n                    if not st and j == 0:\n                        a += f(i + 1, nt, False)\n                    else:\n                        if j == 0: continue\n                        a += f(i + 1, nt, True)\n                return a\n            return f(0, True, False)\n        def k(x):\n            d = g(x)\n            @lru_cache(maxsize=None)\n            def f(i, t, st, s, p):\n                if i == len(d): return 1 if st and p % s == 0 else 0\n                a = 0\n                m = d[i] if t else 9\n                for j in range(m + 1):\n                    nt = t and (j == m)\n                    if not st and j == 0:\n                        a += f(i + 1, nt, False, s, p)\n                    else:\n                        if j == 0: continue\n                        a += f(i + 1, nt, True, s + j, p * j)\n                return a\n            return f(0, True, False, 0, 1)\n        def c(x):\n            if x <= 0: return 0\n            return x - h(x) + k(x)\n        return c(r) - c(l - 1)\n",
  "input": "beautifulNumbers(l=10, r=20)",
  "output": "2",
  "correct_condition": "beautifulNumbers(l=10, r=20) == 2",
  "contest_id": "weekly-contest-441",
  "contest_date": "2025-03-16T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 40,
    "coverage": null
  },
  "submission_id": 1575085194,
  "mutated_code": "def beautifulNumbers(l: int, r: int) -> int:\n\n    def g(x):\n        return list(map(int, str(x)))\n    from functools import lru_cache\n\n    def h(x):\n        d = g(x)\n\n        @lru_cache(maxsize=None)\n        def f(i, t, st):\n            if i == len(d):\n                return 1 if st else 0\n            a = 0\n            m = d[i] if t else 9\n            for j in range(m - 1):\n                nt = t and j == m\n                if not st and j == 0:\n                    a += f(i + 1, nt, False)\n                else:\n                    if j == 0:\n                        continue\n                    a += f(i + 1, nt, True)\n            return a\n        return f(0, True, False)\n\n    def k(x):\n        d = g(x)\n\n        @lru_cache(maxsize=None)\n        def f(i, t, st, s, p):\n            if i == len(d):\n                return 1 if st and p % s == 0 else 0\n            a = 0\n            m = d[i] if t else 9\n            for j in range(m + 1):\n                nt = t and j == m\n                if not st and j == 0:\n                    a += f(i + 1, nt, False, s, p)\n                else:\n                    if j == 0:\n                        continue\n                    a += f(i + 1, nt, True, s + j, p * j)\n            return a\n        return f(0, True, False, 0, 1)\n\n    def c(x):\n        if x <= 0:\n            return 0\n        return x - h(x) + k(x)\n    return c(r) - c(l - 1)",
  "mutated_output": "11",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest441_q3801_s1",
  "question_id": 3801,
  "function_name": "beautifulNumbers",
  "code": "def beautifulNumbers(l: int, r: int) -> int:\n        def countBeautiful(X: int) -> int:\n            if X <= 0:\n                return 0\n            \n            digits = list(map(int, str(X)))\n            n = len(digits)\n            \n            from functools import lru_cache\n            \n            @lru_cache(maxsize=None)\n            def dp(pos, tight, started, hasZero, curr_sum, curr_prod):\n                if pos == n:\n                    if not started:\n                        return 0\n                    if hasZero:\n                        return 1\n                    return 1 if curr_prod % curr_sum == 0 else 0\n                    \n                total = 0\n                upper_bound = digits[pos] if tight else 9\n                \n                for d in range(0, upper_bound + 1):\n                    ntight = tight and (d == upper_bound)\n                    \n                    if not started:\n                        if d == 0:\n                            total += dp(pos+1, ntight, False, False, 0, 1)\n                        else:\n                            total += dp(pos+1, ntight, True, False, d, d)\n                    else:\n                        if d == 0:\n                            total += dp(pos+1, ntight, True, True, curr_sum + d, 0)\n                        else:\n                            if hasZero:\n                                new_prod = 0\n                            else:\n                                new_prod = curr_prod * d\n                            total += dp(pos+1, ntight, True, hasZero, curr_sum + d, new_prod)\n                            \n                return total\n            \n            return dp(0, True, False, False, 0, 1)\n        \n        return countBeautiful(r) - countBeautiful(l - 1)",
  "input": "beautifulNumbers(l=10, r=20)",
  "output": "2",
  "correct_condition": "beautifulNumbers(l=10, r=20) == 2",
  "contest_id": "weekly-contest-441",
  "contest_date": "2025-03-16T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 45,
    "coverage": null
  },
  "submission_id": 1575096103,
  "mutated_code": "def beautifulNumbers(l: int, r: int) -> int:\n\n    def countBeautiful(X: int) -> int:\n        if X <= 0:\n            return 0\n        digits = list(map(int, str(X)))\n        n = len(digits)\n        from functools import lru_cache\n\n        @lru_cache(maxsize=None)\n        def dp(pos, tight, started, hasZero, curr_sum, curr_prod):\n            if pos == n:\n                if not started:\n                    return 0\n                if hasZero:\n                    return 1\n                return 1 if curr_prod // curr_sum == 0 else 0\n            total = 0\n            upper_bound = digits[pos] if tight else 9\n            for d in range(0, upper_bound + 1):\n                ntight = tight and d == upper_bound\n                if not started:\n                    if d == 0:\n                        total += dp(pos + 1, ntight, False, False, 0, 1)\n                    else:\n                        total += dp(pos + 1, ntight, True, False, d, d)\n                elif d == 0:\n                    total += dp(pos + 1, ntight, True, True, curr_sum + d, 0)\n                else:\n                    if hasZero:\n                        new_prod = 0\n                    else:\n                        new_prod = curr_prod * d\n                    total += dp(pos + 1, ntight, True, hasZero, curr_sum + d, new_prod)\n            return total\n        return dp(0, True, False, False, 0, 1)\n    return countBeautiful(r) - countBeautiful(l - 1)",
  "mutated_output": "11",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3817_s0",
  "question_id": 3817,
  "function_name": "maxContainers",
  "code": "def maxContainers(n: int, w: int, maxWeight: int) -> int:\n        return min(n*n, maxWeight//w)",
  "input": "maxContainers(n=2, w=3, maxWeight=15)",
  "output": "4",
  "correct_condition": "maxContainers(n=2, w=3, maxWeight=15) == 4",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 2,
    "coverage": null
  },
  "submission_id": 1582808446,
  "mutated_code": "def maxContainers(n: int, w: int, maxWeight: int) -> int:\n    return min(n // n, maxWeight // w)",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3817_s1",
  "question_id": 3817,
  "function_name": "maxContainers",
  "code": "def maxContainers(n: int, w: int, maxWeight: int) -> int:\n        return min(n * n, maxWeight // w)\n",
  "input": "maxContainers(n=2, w=3, maxWeight=15)",
  "output": "4",
  "correct_condition": "maxContainers(n=2, w=3, maxWeight=15) == 4",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 2,
    "coverage": null
  },
  "submission_id": 1582806336,
  "mutated_code": "def maxContainers(n: int, w: int, maxWeight: int) -> int:\n    return min(n // n, maxWeight // w)",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3817_s2",
  "question_id": 3817,
  "function_name": "maxContainers",
  "code": "def maxContainers(n: int, w: int, maxWeight: int) -> int:\n        return min(maxWeight // w, n * n)",
  "input": "maxContainers(n=2, w=3, maxWeight=15)",
  "output": "4",
  "correct_condition": "maxContainers(n=2, w=3, maxWeight=15) == 4",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 2,
    "coverage": null
  },
  "submission_id": 1582820286,
  "mutated_code": "def maxContainers(n: int, w: int, maxWeight: int) -> int:\n    return min(maxWeight // w, n // n)",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3809_s0",
  "question_id": 3809,
  "function_name": "numberOfComponents",
  "code": "def numberOfComponents(props, k):\n        n = len(props)\n        uf = list(range(n))\n        \n        def find(u):\n            if uf[u] != u:\n                uf[u] = find(uf[u])\n            return uf[u]\n        \n        def uni(u, v):\n            pu, pv = find(u), find(v)\n            m = pu if pu < pv else pv\n            uf[pu] = m\n            uf[pv] = m\n            \n        def inter(a, b, k):\n            if len(a) < k or len(b) < k:\n                return False\n            r = 0\n            i = j = 0\n            while i < len(a) and j < len(b) and r < k:\n                if a[i] == b[j]:\n                    r += 1\n                    i += 1\n                    j += 1\n                elif a[i] < b[j]:\n                    i += 1\n                else:\n                    j += 1\n            return r >= k\n        \n        for i in range(n):\n            props[i] = sorted(set(props[i]))\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if inter(props[i], props[j], k):\n                    uni(i, j)\n                    \n        res = sum(1 for i in range(n) if find(i) == i)\n        return res",
  "input": "numberOfComponents(props=[[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k=1)",
  "output": "3",
  "correct_condition": "numberOfComponents(props=[[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k=1) == 3",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 41,
    "coverage": null
  },
  "submission_id": 1582812387,
  "mutated_code": "def numberOfComponents(props, k):\n    n = len(props)\n    uf = list(range(n))\n\n    def find(u):\n        if uf[u] != u:\n            uf[u] = find(uf[u])\n        return uf[u]\n\n    def uni(u, v):\n        pu, pv = (find(u), find(v))\n        m = pu if pu < pv else pv\n        uf[pu] = m\n        uf[pv] = m\n\n    def inter(a, b, k):\n        if len(a) < k or len(b) <= k:\n            return False\n        r = 0\n        i = j = 0\n        while i < len(a) and j < len(b) and (r < k):\n            if a[i] == b[j]:\n                r += 1\n                i += 1\n                j += 1\n            elif a[i] < b[j]:\n                i += 1\n            else:\n                j += 1\n        return r >= k\n    for i in range(n):\n        props[i] = sorted(set(props[i]))\n    for i in range(n):\n        for j in range(i + 1, n):\n            if inter(props[i], props[j], k):\n                uni(i, j)\n    res = sum((1 for i in range(n) if find(i) == i))\n    return res",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3809_s1",
  "question_id": 3809,
  "function_name": "numberOfComponents",
  "code": "def numberOfComponents(properties: List[List[int]], k: int) -> int:\n        n = len(properties)\n        sets = [set(prop) for prop in properties]\n\n        graph = {i: [] for i in range(n)}\n        for i in range(n):\n            for j in range(i + 1, n):\n                if len(sets[i].intersection(sets[j])) >= k:\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        visited = set()\n\n        def dfs(node):\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                if curr not in visited:\n                    visited.add(curr)\n                    for neighbor in graph[curr]:\n                        if neighbor not in visited:\n                            stack.append(neighbor)\n\n        components = 0\n        for i in range(n):\n            if i not in visited:\n                dfs(i)\n                components += 1\n\n        return components",
  "input": "numberOfComponents(properties=[[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k=1)",
  "output": "3",
  "correct_condition": "numberOfComponents(properties=[[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k=1) == 3",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 30,
    "coverage": null
  },
  "submission_id": 1582811996,
  "mutated_code": "def numberOfComponents(properties: List[List[int]], k: int) -> int:\n    n = len(properties)\n    sets = [set(prop) for prop in properties]\n    graph = {i: [] for i in range(n)}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if len(sets[i].intersection(sets[j])) > k:\n                graph[i].append(j)\n                graph[j].append(i)\n    visited = set()\n\n    def dfs(node):\n        stack = [node]\n        while stack:\n            curr = stack.pop()\n            if curr not in visited:\n                visited.add(curr)\n                for neighbor in graph[curr]:\n                    if neighbor not in visited:\n                        stack.append(neighbor)\n    components = 0\n    for i in range(n):\n        if i not in visited:\n            dfs(i)\n            components += 1\n    return components",
  "mutated_output": "6",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3809_s2",
  "question_id": 3809,
  "function_name": "numberOfComponents",
  "code": "def numberOfComponents(properties: List[List[int]], k: int) -> int:\n        n = len(properties)\n        s = list(map(set, properties))\n        g = [[] for _ in range(n)]\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if len(s[i] & s[j]) < k:\n                    continue\n                g[i].append(j)\n                g[j].append(i)\n\n        seen = [False] * n\n\n        def dfs(i):\n            seen[i] = True\n            for j in g[i]:\n                if not seen[j]:\n                    dfs(j)\n\n        ans = 0\n        for i in range(n):\n            if seen[i]:\n                continue\n            dfs(i)\n            ans += 1\n\n        return ans\n",
  "input": "numberOfComponents(properties=[[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k=1)",
  "output": "3",
  "correct_condition": "numberOfComponents(properties=[[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k=1) == 3",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 28,
    "coverage": null
  },
  "submission_id": 1582816211,
  "mutated_code": "def numberOfComponents(properties: List[List[int]], k: int) -> int:\n    n = len(properties)\n    s = list(map(set, properties))\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if len(s[i] & s[j]) <= k:\n                continue\n            g[i].append(j)\n            g[j].append(i)\n    seen = [False] * n\n\n    def dfs(i):\n        seen[i] = True\n        for j in g[i]:\n            if not seen[j]:\n                dfs(j)\n    ans = 0\n    for i in range(n):\n        if seen[i]:\n            continue\n        dfs(i)\n        ans += 1\n    return ans",
  "mutated_output": "6",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3794_s0",
  "question_id": 3794,
  "function_name": "minTime",
  "code": "def minTime(s, m):\n        n = len(s)\n        f = [0] * n\n        for x in m:\n            nw = f[0]\n            for i in range(1, n):\n                nw = max(nw + s[i - 1] * x, f[i])\n            f[n - 1] = nw + s[n - 1] * x\n            for i in range(n - 2, -1, -1):\n                f[i] = f[i + 1] - s[i + 1] * x\n        return f[n - 1]",
  "input": "minTime(s=[1,5,2,4], m=[5,1,4,2])",
  "output": "110",
  "correct_condition": "minTime(s=[1,5,2,4], m=[5,1,4,2]) == 110",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 11,
    "coverage": null
  },
  "submission_id": 1582817620,
  "mutated_code": "def minTime(s, m):\n    n = len(s)\n    f = [0] * n\n    for x in m:\n        nw = f[0]\n        for i in range(1, n):\n            nw = max(nw - s[i - 1] * x, f[i])\n        f[n - 1] = nw + s[n - 1] * x\n        for i in range(n - 2, -1, -1):\n            f[i] = f[i + 1] - s[i + 1] * x\n    return f[n - 1]",
  "mutated_output": "48",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3794_s1",
  "question_id": 3794,
  "function_name": "minTime",
  "code": "def minTime(skill: List[int], mana: List[int]) -> int:\n        n, m = len(skill), len(mana)\n        ss = [0] * n\n        ss[0] = skill[0]\n        for i in range(1, n):\n            ss[i] = ss[i - 1] + skill[i]\n        S = 0\n        for j in range(1, m):\n            delay = skill[0] * mana[j - 1]\n            for i in range(1, n):\n                d = ss[i] * mana[j - 1] - ss[i - 1] * mana[j]\n                if d > delay:\n                    delay = d\n            S += delay\n        return S + ss[-1] * mana[-1]",
  "input": "minTime(skill=[1,5,2,4], mana=[5,1,4,2])",
  "output": "110",
  "correct_condition": "minTime(skill=[1,5,2,4], mana=[5,1,4,2]) == 110",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1582823640,
  "mutated_code": "def minTime(skill: List[int], mana: List[int]) -> int:\n    n, m = (len(skill), len(mana))\n    ss = [0] * n\n    ss[0] = skill[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] - skill[i]\n    S = 0\n    for j in range(1, m):\n        delay = skill[0] * mana[j - 1]\n        for i in range(1, n):\n            d = ss[i] * mana[j - 1] - ss[i - 1] * mana[j]\n            if d > delay:\n                delay = d\n        S += delay\n    return S + ss[-1] * mana[-1]",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3794_s2",
  "question_id": 3794,
  "function_name": "minTime",
  "code": "def minTime(skill: List[int], mana: List[int]) -> int:\n        n, m = len(skill), len(mana)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + skill[i - 1]\n        s = 0\n        for j in range(m - 1):\n            s += max(mana[j] * dp[i] - mana[j + 1] * dp[i - 1] for i in range(1, n + 1))\n        return mana[m - 1] * dp[n] + s",
  "input": "minTime(skill=[1,5,2,4], mana=[5,1,4,2])",
  "output": "110",
  "correct_condition": "minTime(skill=[1,5,2,4], mana=[5,1,4,2]) == 110",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 9,
    "coverage": null
  },
  "submission_id": 1582832026,
  "mutated_code": "def minTime(skill: List[int], mana: List[int]) -> int:\n    n, m = (len(skill), len(mana))\n    dp = [0] * (n + 1)\n    for i in range(1, n - 1):\n        dp[i] = dp[i - 1] + skill[i - 1]\n    s = 0\n    for j in range(m - 1):\n        s += max((mana[j] * dp[i] - mana[j + 1] * dp[i - 1] for i in range(1, n + 1)))\n    return mana[m - 1] * dp[n] + s",
  "mutated_output": "53",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3744_s1",
  "question_id": 3744,
  "function_name": "minOperations",
  "code": "def minOperations(queries: List[List[int]]) -> int:\n        p = [1] * 16\n        for i in range(1, 16):\n            p[i] = p[i - 1] * 4\n        ans = 0\n        for l, r in queries:\n            total = 0\n            for t in range(1, 16):\n                L = p[t - 1]\n                R = p[t] - 1\n                lo = l if l > L else L\n                hi = r if r < R else R\n                if lo <= hi:\n                    total += t * (hi - lo + 1)\n            tmax = 0\n            for t in range(1, 16):\n                if r <= p[t] - 1:\n                    tmax = t\n                    break\n            ops = (total + 1) // 2\n            if tmax > ops:\n                ops = tmax\n            ans += ops\n        return ans",
  "input": "minOperations(queries=[[1,2],[2,4]])",
  "output": "3",
  "correct_condition": "minOperations(queries=[[1,2],[2,4]]) == 3",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 24,
    "coverage": null
  },
  "submission_id": 1582831208,
  "mutated_code": "def minOperations(queries: List[List[int]]) -> int:\n    p = [1] * 16\n    for i in range(1, 16):\n        p[i] = p[i - 1] // 4\n    ans = 0\n    for l, r in queries:\n        total = 0\n        for t in range(1, 16):\n            L = p[t - 1]\n            R = p[t] - 1\n            lo = l if l > L else L\n            hi = r if r < R else R\n            if lo <= hi:\n                total += t * (hi - lo + 1)\n        tmax = 0\n        for t in range(1, 16):\n            if r <= p[t] - 1:\n                tmax = t\n                break\n        ops = (total + 1) // 2\n        if tmax > ops:\n            ops = tmax\n        ans += ops\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest442_q3744_s2",
  "question_id": 3744,
  "function_name": "minOperations",
  "code": "def minOperations(queries: List[List[int]]) -> int:\n        result = []\n        k = 1\n        while True:\n            low = 4 ** (k - 1)\n            high = 4 ** k - 1\n            if low > 10 ** 9:\n                break\n            result.append((low, high, k))\n            k += 1\n\n        # print(result)\n        ans = 0\n        for q in queries:\n            l = q[0]\n            r = q[1]\n            _sum = 0\n            for a, b, c in result:\n                if b >= l and a <= r:\n                    x = max(l, a)\n                    y = min(r, b)\n                    _sum += c * (y - x + 1)\n                    # print(f'x: {x}, y: {y}, c: {c}, _sum: {_sum}')\n            ans += (_sum + 1) // 2\n            # print(f'ans: {ans}')\n        # print(ans)\n        return ans",
  "input": "minOperations(queries=[[1,2],[2,4]])",
  "output": "3",
  "correct_condition": "minOperations(queries=[[1,2],[2,4]]) == 3",
  "contest_id": "weekly-contest-442",
  "contest_date": "2025-03-23T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 27,
    "coverage": null
  },
  "submission_id": 1582837946,
  "mutated_code": "def minOperations(queries: List[List[int]]) -> int:\n    result = []\n    k = 1\n    while True:\n        low = 4 ** (k + 1)\n        high = 4 ** k - 1\n        if low > 10 ** 9:\n            break\n        result.append((low, high, k))\n        k += 1\n    ans = 0\n    for q in queries:\n        l = q[0]\n        r = q[1]\n        _sum = 0\n        for a, b, c in result:\n            if b >= l and a <= r:\n                x = max(l, a)\n                y = min(r, b)\n                _sum += c * (y - x + 1)\n        ans += (_sum + 1) // 2\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest443_q3832_s0",
  "question_id": 3832,
  "function_name": "minCosts",
  "code": "def minCosts(a: List[int]) -> List[int]:\n        res = a\n        for i in range(1, len(res)):\n            res[i] = min(res[i], res[i - 1])\n        return res",
  "input": "minCosts(a=[5,3,4,1,3,2])",
  "output": "[5, 3, 3, 1, 1, 1]",
  "correct_condition": "minCosts(a=[5,3,4,1,3,2]) == [5, 3, 3, 1, 1, 1]",
  "contest_id": "weekly-contest-443",
  "contest_date": "2025-03-30T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 5,
    "coverage": null
  },
  "submission_id": 1590604607,
  "mutated_code": "def minCosts(a: List[int]) -> List[int]:\n    res = a\n    for i in range(1, len(res)):\n        res[i] = min(res[i], res[i - 0])\n    return res",
  "mutated_output": "[5, 3, 4, 1, 3, 2]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest443_q3832_s1",
  "question_id": 3832,
  "function_name": "minCosts",
  "code": "def minCosts(cost: List[int]) -> List[int]:\n        for i in range(1, len(cost)):\n            if cost[i] > cost[i-1]:\n                cost[i] = cost[i-1]\n        return cost",
  "input": "minCosts(cost=[5,3,4,1,3,2])",
  "output": "[5, 3, 3, 1, 1, 1]",
  "correct_condition": "minCosts(cost=[5,3,4,1,3,2]) == [5, 3, 3, 1, 1, 1]",
  "contest_id": "weekly-contest-443",
  "contest_date": "2025-03-30T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 5,
    "coverage": null
  },
  "submission_id": 1590616291,
  "mutated_code": "def minCosts(cost: List[int]) -> List[int]:\n    for i in range(1, len(cost)):\n        if cost[i] > cost[i - 1]:\n            cost[i] = cost[i + 1]\n    return cost",
  "mutated_output": "[5, 3, 1, 1, 2, 2]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest443_q3832_s2",
  "question_id": 3832,
  "function_name": "minCosts",
  "code": "def minCosts(cost: List[int]) -> List[int]:\n        prev = float(\"inf\")\n        ans = []\n        for i, c in enumerate(cost):\n            prev = min(prev, c)\n            ans.append(prev)\n        return ans",
  "input": "minCosts(cost=[5,3,4,1,3,2])",
  "output": "[5, 3, 3, 1, 1, 1]",
  "correct_condition": "minCosts(cost=[5,3,4,1,3,2]) == [5, 3, 3, 1, 1, 1]",
  "contest_id": "weekly-contest-443",
  "contest_date": "2025-03-30T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1590605154,
  "mutated_code": null,
  "mutated_output": null,
  "has_mutation": false,
  "mutation_info": null
}

{
  "id": "contest443_q3793_s0",
  "question_id": 3793,
  "function_name": "longestPalindrome",
  "code": "def longestPalindrome(s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        palS = [[False] * n for _ in range(n)]\n        for i in range(n):\n            palS[i][i] = True\n        for i in range(n - 1):\n            palS[i][i + 1] = (s[i] == s[i + 1])\n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                palS[i][j] = (s[i] == s[j] and palS[i + 1][j - 1])\n        left_pal = [0] * n\n        for i in range(n):\n            mx = 0\n            for j in range(i, n):\n                if palS[i][j]:\n                    cur = j - i + 1\n                    if cur > mx:\n                        mx = cur\n            left_pal[i] = mx\n        longest_s = max(left_pal) if n else 0\n\n        palT = [[False] * m for _ in range(m)]\n        for i in range(m):\n            palT[i][i] = True\n        for i in range(m - 1):\n            palT[i][i + 1] = (t[i] == t[i + 1])\n        for length in range(3, m + 1):\n            for i in range(m - length + 1):\n                j = i + length - 1\n                palT[i][j] = (t[i] == t[j] and palT[i + 1][j - 1])\n        right_pal = [0] * m\n        for j in range(m):\n            mx = 0\n            for i in range(j + 1):\n                if palT[i][j]:\n                    cur = j - i + 1\n                    if cur > mx:\n                        mx = cur\n            right_pal[j] = mx\n        longest_t = max(right_pal) if m else 0\n\n        best = max(longest_s, longest_t)\n        R = t[::-1]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == R[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    L = dp[i][j]\n                    extra1 = left_pal[i] if i < n else 0\n                    cand1 = 2 * L + extra1\n                    if cand1 > best:\n                        best = cand1\n                    p = m - j\n                    extra2 = right_pal[p - 1] if p > 0 else 0\n                    cand2 = 2 * L + extra2\n                    if cand2 > best:\n                        best = cand2\n                else:\n                    dp[i][j] = 0\n        return best",
  "input": "longestPalindrome(s=\"a\", t=\"a\")",
  "output": "2",
  "correct_condition": "longestPalindrome(s=\"a\", t=\"a\") == 2",
  "contest_id": "weekly-contest-443",
  "contest_date": "2025-03-30T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 62,
    "coverage": null
  },
  "submission_id": 1590627738,
  "mutated_code": "def longestPalindrome(s: str, t: str) -> int:\n    n, m = (len(s), len(t))\n    palS = [[False] * n for _ in range(n)]\n    for i in range(n):\n        palS[i][i] = True\n    for i in range(n - 1):\n        palS[i][i + 1] = s[i] == s[i + 1]\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            palS[i][j] = s[i] == s[j] and palS[i + 1][j - 1]\n    left_pal = [0] * n\n    for i in range(n):\n        mx = 0\n        for j in range(i, n):\n            if palS[i][j]:\n                cur = j - i + 1\n                if cur > mx:\n                    mx = cur\n        left_pal[i] = mx\n    longest_s = max(left_pal) if n else 0\n    palT = [[False] * m for _ in range(m)]\n    for i in range(m):\n        palT[i][i] = True\n    for i in range(m - 1):\n        palT[i][i + 1] = t[i] == t[i + 1]\n    for length in range(3, m + 1):\n        for i in range(m - length + 1):\n            j = i + length - 1\n            palT[i][j] = t[i] == t[j] and palT[i + 1][j - 1]\n    right_pal = [0] * m\n    for j in range(m):\n        mx = 0\n        for i in range(j + 1):\n            if palT[i][j]:\n                cur = j - i + 1\n                if cur > mx:\n                    mx = cur\n        right_pal[j] = mx\n    longest_t = max(right_pal) if m else 0\n    best = max(longest_s, longest_t)\n    R = t[::-1]\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n - 1):\n        for j in range(1, m + 1):\n            if s[i - 1] == R[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                L = dp[i][j]\n                extra1 = left_pal[i] if i < n else 0\n                cand1 = 2 * L + extra1\n                if cand1 > best:\n                    best = cand1\n                p = m - j\n                extra2 = right_pal[p - 1] if p > 0 else 0\n                cand2 = 2 * L + extra2\n                if cand2 > best:\n                    best = cand2\n            else:\n                dp[i][j] = 0\n    return best",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 32,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest443_q3793_s1",
  "question_id": 3793,
  "function_name": "longestPalindrome",
  "code": "def longestPalindrome(ss1: str, ss2: str) -> int:\n        def solve(s1, s2):\n            trie = {}\n            for i in range(len(s2)):\n                cur = trie\n                for j in range(i, len(s2)):\n                    c = s2[j]\n                    if c not in cur:\n                        cur[c] = {}\n                    cur = cur[c]\n            ans = 1\n            for midl in range(len(s1)):\n                for shift in [0, 1]:\n                    midr = midl + shift\n                    l = midl\n                    r = midr\n                    triestarted = False\n                    while l >= 0:\n                        if not triestarted:\n                            if r < len(s1) and s1[r] == s1[l]:\n                                ans = max(ans, r - l + 1)\n                                l -= 1\n                                r += 1\n                            else:\n                                triestarted = True\n                                cur = trie\n                        else:\n                            if s1[l] not in cur:\n                                break\n                            else:\n                                cur = cur[s1[l]]\n                                ans = max(ans, r - l + 1)\n                                l -= 1\n                                r += 1\n            return ans\n        return max(solve(ss1, ss2), solve(ss2[::-1], ss1[::-1]))\n                                \n",
  "input": "longestPalindrome(ss1=\"a\", ss2=\"a\")",
  "output": "2",
  "correct_condition": "longestPalindrome(ss1=\"a\", ss2=\"a\") == 2",
  "contest_id": "weekly-contest-443",
  "contest_date": "2025-03-30T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 37,
    "coverage": null
  },
  "submission_id": 1590624516,
  "mutated_code": "def longestPalindrome(ss1: str, ss2: str) -> int:\n\n    def solve(s1, s2):\n        trie = {}\n        for i in range(len(s2)):\n            cur = trie\n            for j in range(i, len(s2)):\n                c = s2[j]\n                if c not in cur:\n                    cur[c] = {}\n                cur = cur[c]\n        ans = 1\n        for midl in range(len(s1)):\n            for shift in [0, 1]:\n                midr = midl - shift\n                l = midl\n                r = midr\n                triestarted = False\n                while l >= 0:\n                    if not triestarted:\n                        if r < len(s1) and s1[r] == s1[l]:\n                            ans = max(ans, r - l + 1)\n                            l -= 1\n                            r += 1\n                        else:\n                            triestarted = True\n                            cur = trie\n                    elif s1[l] not in cur:\n                        break\n                    else:\n                        cur = cur[s1[l]]\n                        ans = max(ans, r - l + 1)\n                        l -= 1\n                        r += 1\n        return ans\n    return max(solve(ss1, ss2), solve(ss2[::-1], ss1[::-1]))",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest443_q3793_s2",
  "question_id": 3793,
  "function_name": "longestPalindrome",
  "code": "def longestPalindrome(s: str, t: str) -> int:\n        n, m = len(s), len(t)\n    \n        # --- Precompute palindromic substrings for s ---\n        # isPalS[i][j] = True if s[i:j+1] is a palindrome.\n        isPalS = [[False] * n for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i < 2 or isPalS[i+1][j-1]):\n                    isPalS[i][j] = True\n        # best_start[i] = length of longest palindrome starting exactly at index i in s.\n        best_start = [0] * n\n        for i in range(n):\n            max_len = 0\n            for j in range(i, n):\n                if isPalS[i][j]:\n                    length = j - i + 1\n                    if length > max_len:\n                        max_len = length\n            best_start[i] = max_len\n        \n        # --- Precompute palindromic substrings for t ---\n        # isPalT[i][j] = True if t[i:j+1] is a palindrome.\n        isPalT = [[False] * m for _ in range(m)]\n        for i in range(m-1, -1, -1):\n            for j in range(i, m):\n                if t[i] == t[j] and (j - i < 2 or isPalT[i+1][j-1]):\n                    isPalT[i][j] = True\n        # best_end[j] = length of longest palindrome ending exactly at index j in t.\n        best_end = [0] * m\n        for j in range(m):\n            max_len = 0\n            for i in range(0, j+1):\n                if isPalT[i][j]:\n                    length = j - i + 1\n                    if length > max_len:\n                        max_len = length\n            best_end[j] = max_len\n        \n        # --- Pure palindromes: those lying entirely in s or entirely in t ---\n        pure = 0\n        if n > 0:\n            pure = max(best_start)  # longest palindrome in s\n        if m > 0:\n            pure = max(pure, max(best_end))  # longest palindrome in t\n        \n        # --- DP for common substrings between s and reverse(t) ---\n        t_rev = t[::-1]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        best_cross = 0\n        \n        # dp[i][j]: longest common suffix of s[:i] and t_rev[:j].\n        # When dp[i][j] = L > 0, it means s[i-L:i] = t_rev[j-L:j],\n        # which corresponds to a substring X in s (ending at index i-1)\n        # and reverse(X) in t. In t, the occurrence of reverse(X) starts at pos = m - j.\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == t_rev[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    L = dp[i][j]\n                    # Case B: extend u in s (u = X + Y, where Y is a palindrome).\n                    # Here, X = s[i - L : i] and we can append Y = (longest palindrome starting at index i).\n                    ext_s = best_start[i] if i < n else 0\n                    candidate_B = 2 * L + ext_s\n                    # Case A: extend v in t (v = p + reverse(X), where p is a palindrome).\n                    # In t, the occurrence of reverse(X) starts at index pos = m - j.\n                    pos = m - j  \n                    ext_t = best_end[pos - 1] if pos > 0 else 0\n                    candidate_A = 2 * L + ext_t\n                    best_cross = max(best_cross, candidate_A, candidate_B)\n        \n        return max(pure, best_cross)",
  "input": "longestPalindrome(s=\"a\", t=\"a\")",
  "output": "2",
  "correct_condition": "longestPalindrome(s=\"a\", t=\"a\") == 2",
  "contest_id": "weekly-contest-443",
  "contest_date": "2025-03-30T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 72,
    "coverage": null
  },
  "submission_id": 1590642799,
  "mutated_code": "def longestPalindrome(s: str, t: str) -> int:\n    n, m = (len(s), len(t))\n    isPalS = [[False] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j] and (j - i < 2 or isPalS[i + 1][j - 1]):\n                isPalS[i][j] = True\n    best_start = [0] * n\n    for i in range(n):\n        max_len = 0\n        for j in range(i, n):\n            if isPalS[i][j]:\n                length = j - i + 1\n                if length > max_len:\n                    max_len = length\n        best_start[i] = max_len\n    isPalT = [[False] * m for _ in range(m)]\n    for i in range(m - 1, -1, -1):\n        for j in range(i, m):\n            if t[i] == t[j] and (j - i < 2 or isPalT[i + 1][j - 1]):\n                isPalT[i][j] = True\n    best_end = [0] * m\n    for j in range(m):\n        max_len = 0\n        for i in range(0, j + 1):\n            if isPalT[i][j]:\n                length = j - i + 1\n                if length > max_len:\n                    max_len = length\n        best_end[j] = max_len\n    pure = 0\n    if n > 0:\n        pure = max(best_start)\n    if m > 0:\n        pure = max(pure, max(best_end))\n    t_rev = t[::-1]\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    best_cross = 0\n    for i in range(1, n - 1):\n        for j in range(1, m + 1):\n            if s[i - 1] == t_rev[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                L = dp[i][j]\n                ext_s = best_start[i] if i < n else 0\n                candidate_B = 2 * L + ext_s\n                pos = m - j\n                ext_t = best_end[pos - 1] if pos > 0 else 0\n                candidate_A = 2 * L + ext_t\n                best_cross = max(best_cross, candidate_A, candidate_B)\n    return max(pure, best_cross)",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 20,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest443_q3808_s0",
  "question_id": 3808,
  "function_name": "longestPalindrome",
  "code": "def longestPalindrome(s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        palS = [[False] * n for _ in range(n)]\n        for i in range(n):\n            palS[i][i] = True\n        for i in range(n - 1):\n            palS[i][i + 1] = (s[i] == s[i + 1])\n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                palS[i][j] = (s[i] == s[j] and palS[i + 1][j - 1])\n        left_pal = [0] * n\n        for i in range(n):\n            mx = 0\n            for j in range(i, n):\n                if palS[i][j]:\n                    cur = j - i + 1\n                    if cur > mx:\n                        mx = cur\n            left_pal[i] = mx\n        longest_s = max(left_pal) if n else 0\n\n        palT = [[False] * m for _ in range(m)]\n        for i in range(m):\n            palT[i][i] = True\n        for i in range(m - 1):\n            palT[i][i + 1] = (t[i] == t[i + 1])\n        for length in range(3, m + 1):\n            for i in range(m - length + 1):\n                j = i + length - 1\n                palT[i][j] = (t[i] == t[j] and palT[i + 1][j - 1])\n        right_pal = [0] * m\n        for j in range(m):\n            mx = 0\n            for i in range(j + 1):\n                if palT[i][j]:\n                    cur = j - i + 1\n                    if cur > mx:\n                        mx = cur\n            right_pal[j] = mx\n        longest_t = max(right_pal) if m else 0\n\n        best = max(longest_s, longest_t)\n        R = t[::-1]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == R[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    L = dp[i][j]\n                    extra1 = left_pal[i] if i < n else 0\n                    cand1 = 2 * L + extra1\n                    if cand1 > best:\n                        best = cand1\n                    p = m - j\n                    extra2 = right_pal[p - 1] if p > 0 else 0\n                    cand2 = 2 * L + extra2\n                    if cand2 > best:\n                        best = cand2\n                else:\n                    dp[i][j] = 0\n        return best",
  "input": "longestPalindrome(s=\"a\", t=\"a\")",
  "output": "2",
  "correct_condition": "longestPalindrome(s=\"a\", t=\"a\") == 2",
  "contest_id": "weekly-contest-443",
  "contest_date": "2025-03-30T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 62,
    "coverage": null
  },
  "submission_id": 1590625901,
  "mutated_code": "def longestPalindrome(s: str, t: str) -> int:\n    n, m = (len(s), len(t))\n    palS = [[False] * n for _ in range(n)]\n    for i in range(n):\n        palS[i][i] = True\n    for i in range(n - 1):\n        palS[i][i + 1] = s[i] == s[i + 1]\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            palS[i][j] = s[i] == s[j] and palS[i + 1][j - 1]\n    left_pal = [0] * n\n    for i in range(n):\n        mx = 0\n        for j in range(i, n):\n            if palS[i][j]:\n                cur = j - i + 1\n                if cur > mx:\n                    mx = cur\n        left_pal[i] = mx\n    longest_s = max(left_pal) if n else 0\n    palT = [[False] * m for _ in range(m)]\n    for i in range(m):\n        palT[i][i] = True\n    for i in range(m - 1):\n        palT[i][i + 1] = t[i] == t[i + 1]\n    for length in range(3, m + 1):\n        for i in range(m - length + 1):\n            j = i + length - 1\n            palT[i][j] = t[i] == t[j] and palT[i + 1][j - 1]\n    right_pal = [0] * m\n    for j in range(m):\n        mx = 0\n        for i in range(j + 1):\n            if palT[i][j]:\n                cur = j - i + 1\n                if cur > mx:\n                    mx = cur\n        right_pal[j] = mx\n    longest_t = max(right_pal) if m else 0\n    best = max(longest_s, longest_t)\n    R = t[::-1]\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n - 1):\n        for j in range(1, m + 1):\n            if s[i - 1] == R[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                L = dp[i][j]\n                extra1 = left_pal[i] if i < n else 0\n                cand1 = 2 * L + extra1\n                if cand1 > best:\n                    best = cand1\n                p = m - j\n                extra2 = right_pal[p - 1] if p > 0 else 0\n                cand2 = 2 * L + extra2\n                if cand2 > best:\n                    best = cand2\n            else:\n                dp[i][j] = 0\n    return best",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 32,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest443_q3808_s1",
  "question_id": 3808,
  "function_name": "longestPalindrome",
  "code": "def longestPalindrome(ss1: str, ss2: str) -> int:\n        def solve(s1, s2):\n            trie = {}\n            for i in range(len(s2)):\n                cur = trie\n                for j in range(i, len(s2)):\n                    c = s2[j]\n                    if c not in cur:\n                        cur[c] = {}\n                    cur = cur[c]\n            ans = 1\n            for midl in range(len(s1)):\n                for shift in [0, 1]:\n                    midr = midl + shift\n                    l = midl\n                    r = midr\n                    triestarted = False\n                    while l >= 0:\n                        if not triestarted:\n                            if r < len(s1) and s1[r] == s1[l]:\n                                ans = max(ans, r - l + 1)\n                                l -= 1\n                                r += 1\n                            else:\n                                triestarted = True\n                                cur = trie\n                        else:\n                            if s1[l] not in cur:\n                                break\n                            else:\n                                cur = cur[s1[l]]\n                                ans = max(ans, r - l + 1)\n                                l -= 1\n                                r += 1\n            return ans\n        return max(solve(ss1, ss2), solve(ss2[::-1], ss1[::-1]))\n                                \n",
  "input": "longestPalindrome(ss1=\"a\", ss2=\"a\")",
  "output": "2",
  "correct_condition": "longestPalindrome(ss1=\"a\", ss2=\"a\") == 2",
  "contest_id": "weekly-contest-443",
  "contest_date": "2025-03-30T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 37,
    "coverage": null
  },
  "submission_id": 1590624215,
  "mutated_code": "def longestPalindrome(ss1: str, ss2: str) -> int:\n\n    def solve(s1, s2):\n        trie = {}\n        for i in range(len(s2)):\n            cur = trie\n            for j in range(i, len(s2)):\n                c = s2[j]\n                if c not in cur:\n                    cur[c] = {}\n                cur = cur[c]\n        ans = 1\n        for midl in range(len(s1)):\n            for shift in [0, 1]:\n                midr = midl - shift\n                l = midl\n                r = midr\n                triestarted = False\n                while l >= 0:\n                    if not triestarted:\n                        if r < len(s1) and s1[r] == s1[l]:\n                            ans = max(ans, r - l + 1)\n                            l -= 1\n                            r += 1\n                        else:\n                            triestarted = True\n                            cur = trie\n                    elif s1[l] not in cur:\n                        break\n                    else:\n                        cur = cur[s1[l]]\n                        ans = max(ans, r - l + 1)\n                        l -= 1\n                        r += 1\n        return ans\n    return max(solve(ss1, ss2), solve(ss2[::-1], ss1[::-1]))",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest443_q3808_s2",
  "question_id": 3808,
  "function_name": "longestPalindrome",
  "code": "def longestPalindrome(s: str, t: str) -> int:\n        n, m = len(s), len(t)\n    \n        # --- Precompute palindromic substrings for s ---\n        # isPalS[i][j] = True if s[i:j+1] is a palindrome.\n        isPalS = [[False] * n for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i < 2 or isPalS[i+1][j-1]):\n                    isPalS[i][j] = True\n        # best_start[i] = length of longest palindrome starting exactly at index i in s.\n        best_start = [0] * n\n        for i in range(n):\n            max_len = 0\n            for j in range(i, n):\n                if isPalS[i][j]:\n                    length = j - i + 1\n                    if length > max_len:\n                        max_len = length\n            best_start[i] = max_len\n        \n        # --- Precompute palindromic substrings for t ---\n        # isPalT[i][j] = True if t[i:j+1] is a palindrome.\n        isPalT = [[False] * m for _ in range(m)]\n        for i in range(m-1, -1, -1):\n            for j in range(i, m):\n                if t[i] == t[j] and (j - i < 2 or isPalT[i+1][j-1]):\n                    isPalT[i][j] = True\n        # best_end[j] = length of longest palindrome ending exactly at index j in t.\n        best_end = [0] * m\n        for j in range(m):\n            max_len = 0\n            for i in range(0, j+1):\n                if isPalT[i][j]:\n                    length = j - i + 1\n                    if length > max_len:\n                        max_len = length\n            best_end[j] = max_len\n        \n        # --- Pure palindromes: those lying entirely in s or entirely in t ---\n        pure = 0\n        if n > 0:\n            pure = max(best_start)  # longest palindrome in s\n        if m > 0:\n            pure = max(pure, max(best_end))  # longest palindrome in t\n        \n        # --- DP for common substrings between s and reverse(t) ---\n        t_rev = t[::-1]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        best_cross = 0\n        \n        # dp[i][j]: longest common suffix of s[:i] and t_rev[:j].\n        # When dp[i][j] = L > 0, it means s[i-L:i] = t_rev[j-L:j],\n        # which corresponds to a substring X in s (ending at index i-1)\n        # and reverse(X) in t. In t, the occurrence of reverse(X) starts at pos = m - j.\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == t_rev[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    L = dp[i][j]\n                    # Case B: extend u in s (u = X + Y, where Y is a palindrome).\n                    # Here, X = s[i - L : i] and we can append Y = (longest palindrome starting at index i).\n                    ext_s = best_start[i] if i < n else 0\n                    candidate_B = 2 * L + ext_s\n                    # Case A: extend v in t (v = p + reverse(X), where p is a palindrome).\n                    # In t, the occurrence of reverse(X) starts at index pos = m - j.\n                    pos = m - j  \n                    ext_t = best_end[pos - 1] if pos > 0 else 0\n                    candidate_A = 2 * L + ext_t\n                    best_cross = max(best_cross, candidate_A, candidate_B)\n        \n        return max(pure, best_cross)",
  "input": "longestPalindrome(s=\"a\", t=\"a\")",
  "output": "2",
  "correct_condition": "longestPalindrome(s=\"a\", t=\"a\") == 2",
  "contest_id": "weekly-contest-443",
  "contest_date": "2025-03-30T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 72,
    "coverage": null
  },
  "submission_id": 1590627076,
  "mutated_code": "def longestPalindrome(s: str, t: str) -> int:\n    n, m = (len(s), len(t))\n    isPalS = [[False] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j] and (j - i < 2 or isPalS[i + 1][j - 1]):\n                isPalS[i][j] = True\n    best_start = [0] * n\n    for i in range(n):\n        max_len = 0\n        for j in range(i, n):\n            if isPalS[i][j]:\n                length = j - i + 1\n                if length > max_len:\n                    max_len = length\n        best_start[i] = max_len\n    isPalT = [[False] * m for _ in range(m)]\n    for i in range(m - 1, -1, -1):\n        for j in range(i, m):\n            if t[i] == t[j] and (j - i < 2 or isPalT[i + 1][j - 1]):\n                isPalT[i][j] = True\n    best_end = [0] * m\n    for j in range(m):\n        max_len = 0\n        for i in range(0, j + 1):\n            if isPalT[i][j]:\n                length = j - i + 1\n                if length > max_len:\n                    max_len = length\n        best_end[j] = max_len\n    pure = 0\n    if n > 0:\n        pure = max(best_start)\n    if m > 0:\n        pure = max(pure, max(best_end))\n    t_rev = t[::-1]\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    best_cross = 0\n    for i in range(1, n - 1):\n        for j in range(1, m + 1):\n            if s[i - 1] == t_rev[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                L = dp[i][j]\n                ext_s = best_start[i] if i < n else 0\n                candidate_B = 2 * L + ext_s\n                pos = m - j\n                ext_t = best_end[pos - 1] if pos > 0 else 0\n                candidate_A = 2 * L + ext_t\n                best_cross = max(best_cross, candidate_A, candidate_B)\n    return max(pure, best_cross)",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 20,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest444_q3773_s0",
  "question_id": 3773,
  "function_name": "minimumPairRemoval",
  "code": "def minimumPairRemoval(nums: List[int]) -> int:\n        x = nums\n        o = 0\n        while True:\n            f = True\n            p = 0\n            while p < len(x) - 1:\n                if x[p] > x[p+1]:\n                    f = False\n                    break\n                p += 1\n\n            if f:\n                break\n\n            mi = -1 \n            ms = float('inf')\n            k = 0\n            s = len(x)\n            while k < s - 1:\n                cs = x[k] + x[k+1]\n                if cs < ms:\n                    ms = cs\n                    mi = k\n                k += 1\n\n            if mi != -1:\n                replacement_val = x[mi] + x[mi+1]\n                x[mi] = replacement_val\n                x.pop(mi + 1)\n                o += 1\n            else:\n                break\n\n        return o\n",
  "input": "minimumPairRemoval(nums=[5,2,3,1])",
  "output": "2",
  "correct_condition": "minimumPairRemoval(nums=[5,2,3,1]) == 2",
  "contest_id": "weekly-contest-444",
  "contest_date": "2025-04-06T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 35,
    "coverage": null
  },
  "submission_id": 1597996116,
  "mutated_code": "def minimumPairRemoval(nums: List[int]) -> int:\n    x = nums\n    o = 0\n    while True:\n        f = True\n        p = 0\n        while p < len(x) - 1:\n            if x[p] > x[p + 1]:\n                f = False\n                break\n            p += 1\n        if f:\n            break\n        mi = -1\n        ms = float('inf')\n        k = 0\n        s = len(x)\n        while k < s - 1:\n            cs = x[k] - x[k + 1]\n            if cs < ms:\n                ms = cs\n                mi = k\n            k += 1\n        if mi != -1:\n            replacement_val = x[mi] + x[mi + 1]\n            x[mi] = replacement_val\n            x.pop(mi + 1)\n            o += 1\n        else:\n            break\n    return o",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest444_q3773_s1",
  "question_id": 3773,
  "function_name": "minimumPairRemoval",
  "code": "def minimumPairRemoval(nums: List[int]) -> int:\n        cnt = 0;\n        while nums != sorted(nums):\n            min_sum = inf\n            cnt += 1\n            for i in range(len(nums) - 1):\n                min_sum = min(min_sum, nums[i] + nums[i + 1])\n            for i in range(len(nums) - 1):\n                if nums[i] + nums[i + 1] == min_sum:\n                    nums = nums[:i] + [min_sum] + nums[i+2:]\n                    break\n        return cnt\n        ",
  "input": "minimumPairRemoval(nums=[5,2,3,1])",
  "output": "2",
  "correct_condition": "minimumPairRemoval(nums=[5,2,3,1]) == 2",
  "contest_id": "weekly-contest-444",
  "contest_date": "2025-04-06T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 13,
    "coverage": null
  },
  "submission_id": 1597989422,
  "mutated_code": "def minimumPairRemoval(nums: List[int]) -> int:\n    cnt = 0\n    while nums == sorted(nums):\n        min_sum = inf\n        cnt += 1\n        for i in range(len(nums) - 1):\n            min_sum = min(min_sum, nums[i] + nums[i + 1])\n        for i in range(len(nums) - 1):\n            if nums[i] + nums[i + 1] == min_sum:\n                nums = nums[:i] + [min_sum] + nums[i + 2:]\n                break\n    return cnt",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest444_q3777_s0",
  "question_id": 3777,
  "function_name": "maxProduct",
  "code": "def maxProduct(a: List[int], b: int, c: int) -> int:\n        a = (a.copy(), b, c)\n        d = float('inf')\n        e = defaultdict(set)\n        \n        i = 0\n        while i < len(a[0]):\n            f = defaultdict(set)\n            g = a[0][i]\n            for h in e:\n                f[h] |= e[h]\n            \n            if g == 0:\n                f[(1, 0)].add(0)\n            else:\n                if g <= c:\n                    f[(1, g)].add(g)\n                else:\n                    f[(1, d)].add(g)\n            \n            j = list(e.keys())\n            k = 0\n            while k < len(j):\n                (l, m) = j[k]\n                for n in e[(l, m)]:\n                    o = 1 - l\n                    p = n + g if l == 0 else n - g\n                    if g == 0:\n                        q = 0\n                    else:\n                        if m == d:\n                            q = d\n                        else:\n                            r = m * g\n                            q = r if r <= c else d\n                    f[(o, q)].add(p)\n                k += 1\n            \n            e = f\n            i += 1\n        \n        s = -1\n        j = list(e.keys())\n        t = 0\n        while t < len(j):\n            (l, m) = j[t]\n            if m != d and b in e[(l, m)]:\n                s = max(s, m)\n            t += 1\n        \n        return s\n",
  "input": "maxProduct(a=[1,2,3], b=2, c=10)",
  "output": "6",
  "correct_condition": "maxProduct(a=[1,2,3], b=2, c=10) == 6",
  "contest_id": "weekly-contest-444",
  "contest_date": "2025-04-06T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 51,
    "coverage": null
  },
  "submission_id": 1598062192,
  "mutated_code": "def maxProduct(a: List[int], b: int, c: int) -> int:\n    a = (a.copy(), b, c)\n    d = float('inf')\n    e = defaultdict(set)\n    i = 0\n    while i < len(a[0]):\n        f = defaultdict(set)\n        g = a[0][i]\n        for h in e:\n            f[h] |= e[h]\n        if g == 0:\n            f[1, 0].add(0)\n        elif g <= c:\n            f[1, g].add(g)\n        else:\n            f[1, d].add(g)\n        j = list(e.keys())\n        k = 0\n        while k < len(j):\n            l, m = j[k]\n            for n in e[l, m]:\n                o = 1 + l\n                p = n + g if l == 0 else n - g\n                if g == 0:\n                    q = 0\n                elif m == d:\n                    q = d\n                else:\n                    r = m * g\n                    q = r if r <= c else d\n                f[o, q].add(p)\n            k += 1\n        e = f\n        i += 1\n    s = -1\n    j = list(e.keys())\n    t = 0\n    while t < len(j):\n        l, m = j[t]\n        if m != d and b in e[l, m]:\n            s = max(s, m)\n        t += 1\n    return s",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest444_q3777_s1",
  "question_id": 3777,
  "function_name": "maxProduct",
  "code": "def maxProduct(nums: List[int], k: int, limit: int) -> int:\n        dp = set([(0, 0, 1, True)])\n        for num in nums:\n            newdp = []\n            for s, f, p, flag in dp:\n                if f == 0:\n                    news = s + num\n                else:\n                    news = s - num\n                newf = 1 - f\n                newp = p * num\n                if newp > limit:\n                    newp = limit + 1\n                newdp.append((news, newf, newp, False))\n            for t in newdp:\n                dp.add(t)\n        ans = -1\n        # print(dp)\n        for s, f, p, flag in dp:\n            if flag == False and s == k and p <= limit:\n                ans = max(ans, p)\n        return ans",
  "input": "maxProduct(nums=[1,2,3], k=2, limit=10)",
  "output": "6",
  "correct_condition": "maxProduct(nums=[1,2,3], k=2, limit=10) == 6",
  "contest_id": "weekly-contest-444",
  "contest_date": "2025-04-06T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 22,
    "coverage": null
  },
  "submission_id": 1598041064,
  "mutated_code": "def maxProduct(nums: List[int], k: int, limit: int) -> int:\n    dp = set([(0, 0, 1, True)])\n    for num in nums:\n        newdp = []\n        for s, f, p, flag in dp:\n            if f == 0:\n                news = s - num\n            else:\n                news = s - num\n            newf = 1 - f\n            newp = p * num\n            if newp > limit:\n                newp = limit + 1\n            newdp.append((news, newf, newp, False))\n        for t in newdp:\n            dp.add(t)\n    ans = -1\n    for s, f, p, flag in dp:\n        if flag == False and s == k and (p <= limit):\n            ans = max(ans, p)\n    return ans",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest445_q3830_s0",
  "question_id": 3830,
  "function_name": "findClosest",
  "code": "def findClosest(x: int, y: int, z: int) -> int:\n        if abs(z-x) < abs(z-y):\n            return 1\n        elif abs(z-y) < abs(z-x):\n            return 2\n        return 0\n",
  "input": "findClosest(x=2, y=7, z=4)",
  "output": "1",
  "correct_condition": "findClosest(x=2, y=7, z=4) == 1",
  "contest_id": "weekly-contest-445",
  "contest_date": "2025-04-13T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 6,
    "coverage": null
  },
  "submission_id": 1605121226,
  "mutated_code": "def findClosest(x: int, y: int, z: int) -> int:\n    if abs(z + x) < abs(z - y):\n        return 1\n    elif abs(z - y) < abs(z - x):\n        return 2\n    return 0",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest445_q3830_s1",
  "question_id": 3830,
  "function_name": "findClosest",
  "code": "def findClosest(x: int, y: int, z: int) -> int:\n        if abs(z - y) == abs(z - x):\n            return 0\n        elif abs(z - y) < abs(z - x):\n            return 2\n        else:\n            return 1",
  "input": "findClosest(x=2, y=7, z=4)",
  "output": "1",
  "correct_condition": "findClosest(x=2, y=7, z=4) == 1",
  "contest_id": "weekly-contest-445",
  "contest_date": "2025-04-13T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1605117709,
  "mutated_code": "def findClosest(x: int, y: int, z: int) -> int:\n    if abs(z - y) == abs(z - x):\n        return 0\n    elif abs(z - y) < abs(z + x):\n        return 2\n    else:\n        return 1",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest445_q3830_s2",
  "question_id": 3830,
  "function_name": "findClosest",
  "code": "def findClosest(x: int, y: int, z: int) -> int:\n        d1, d2 = abs(x - z), abs(y - z)\n        return 1 if d1 < d2 else 2 if d2 < d1 else 0\n",
  "input": "findClosest(x=2, y=7, z=4)",
  "output": "1",
  "correct_condition": "findClosest(x=2, y=7, z=4) == 1",
  "contest_id": "weekly-contest-445",
  "contest_date": "2025-04-13T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 3,
    "coverage": null
  },
  "submission_id": 1605121176,
  "mutated_code": "def findClosest(x: int, y: int, z: int) -> int:\n    d1, d2 = (abs(x + z), abs(y - z))\n    return 1 if d1 < d2 else 2 if d2 < d1 else 0",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest445_q3812_s0",
  "question_id": 3812,
  "function_name": "smallestPalindrome",
  "code": "def smallestPalindrome(s: str) -> str:\n        freq = [0] * 26\n        for ch in s:\n            freq[ord(ch) - ord('a')] += 1\n    \n        center = \"\"\n        for i in range(26):\n            if freq[i] % 2 == 1:\n                center = chr(i + ord('a'))\n                freq[i] -= 1\n                break\n        \n        first_half = []\n        for i in range(26):\n            first_half.append(chr(i + ord('a')) * (freq[i] // 2))\n        \n        first_half_str = \"\".join(first_half)\n        result = first_half_str + center + first_half_str[::-1]\n        return result\n",
  "input": "smallestPalindrome(s=\"z\")",
  "output": "'z'",
  "correct_condition": "smallestPalindrome(s=\"z\") == 'z'",
  "contest_id": "weekly-contest-445",
  "contest_date": "2025-04-13T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 19,
    "coverage": null
  },
  "submission_id": 1605113299,
  "mutated_code": "def smallestPalindrome(s: str) -> str:\n    freq = [0] * 26\n    for ch in s:\n        freq[ord(ch) - ord('a')] += 1\n    center = ''\n    for i in range(26):\n        if freq[i] // 2 == 1:\n            center = chr(i + ord('a'))\n            freq[i] -= 1\n            break\n    first_half = []\n    for i in range(26):\n        first_half.append(chr(i + ord('a')) * (freq[i] // 2))\n    first_half_str = ''.join(first_half)\n    result = first_half_str + center + first_half_str[::-1]\n    return result",
  "mutated_output": "''",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest445_q3812_s1",
  "question_id": 3812,
  "function_name": "smallestPalindrome",
  "code": "def smallestPalindrome(s: str) -> str:\n        charCount = {}\n        for char in s:\n            charCount[char] = charCount.get(char, 0) + 1\n        \n        oddChar = None\n        for char, count in charCount.items():\n            if count % 2 == 1:\n                if oddChar is None or char < oddChar:\n                    oddChar = char\n        \n        leftHalf = []\n        for char in sorted(charCount.keys()):\n            if char == oddChar:\n                leftHalf.extend([char] * ((charCount[char] - 1) // 2))\n            else:\n                leftHalf.extend([char] * (charCount[char] // 2))\n        \n        middle = [oddChar] if oddChar is not None else []\n        \n        rightHalf = leftHalf.copy()\n        rightHalf.reverse()\n        \n        return ''.join(leftHalf + middle + rightHalf)",
  "input": "smallestPalindrome(s=\"z\")",
  "output": "'z'",
  "correct_condition": "smallestPalindrome(s=\"z\") == 'z'",
  "contest_id": "weekly-contest-445",
  "contest_date": "2025-04-13T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 24,
    "coverage": null
  },
  "submission_id": 1605120842,
  "mutated_code": "def smallestPalindrome(s: str) -> str:\n    charCount = {}\n    for char in s:\n        charCount[char] = charCount.get(char, 0) + 1\n    oddChar = None\n    for char, count in charCount.items():\n        if count // 2 == 1:\n            if oddChar is None or char < oddChar:\n                oddChar = char\n    leftHalf = []\n    for char in sorted(charCount.keys()):\n        if char == oddChar:\n            leftHalf.extend([char] * ((charCount[char] - 1) // 2))\n        else:\n            leftHalf.extend([char] * (charCount[char] // 2))\n    middle = [oddChar] if oddChar is not None else []\n    rightHalf = leftHalf.copy()\n    rightHalf.reverse()\n    return ''.join(leftHalf + middle + rightHalf)",
  "mutated_output": "''",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest445_q3812_s2",
  "question_id": 3812,
  "function_name": "smallestPalindrome",
  "code": "def smallestPalindrome(s: str) -> str:\n        c = Counter(s)\n        arr = []\n        mid = \"\"\n        for x in sorted(c):\n            n = c[x] // 2\n            arr.append(x * n)\n            if c[x] % 2:\n                mid = x\n        left = \"\".join(arr)\n        return left + mid + left[::-1]\n",
  "input": "smallestPalindrome(s=\"z\")",
  "output": "'z'",
  "correct_condition": "smallestPalindrome(s=\"z\") == 'z'",
  "contest_id": "weekly-contest-445",
  "contest_date": "2025-04-13T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 11,
    "coverage": null
  },
  "submission_id": 1605125714,
  "mutated_code": "def smallestPalindrome(s: str) -> str:\n    c = Counter(s)\n    arr = []\n    mid = ''\n    for x in sorted(c):\n        n = c[x] * 2\n        arr.append(x * n)\n        if c[x] % 2:\n            mid = x\n    left = ''.join(arr)\n    return left + mid + left[::-1]",
  "mutated_output": "'zzzzz'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest445_q3813_s0",
  "question_id": 3813,
  "function_name": "smallestPalindrome",
  "code": "def smallestPalindrome(s: str, k: int) -> str:\n        freq = [0] * 26\n        for ch in s:\n            freq[ord(ch) - ord('a')] += 1\n\n        half_counts = [count // 2 for count in freq]\n        L = sum(half_counts)\n        center = \"\"\n        for i in range(26):\n            if freq[i] % 2 == 1:\n                center = chr(i + ord('a'))\n                break\n        \n        def count_permutations(counts, cap_value):\n            total = sum(counts)\n            result = 1\n            rem = total\n            for m in counts:\n                if m > 0:\n                    result *= comb(rem, m)\n                    if result > cap_value:\n                        return cap_value\n                    rem -= m\n            return result\n\n        total_count = count_permutations(half_counts, k + 1)\n        if total_count < k:\n            return \"\"\n\n        first_half = []\n        for _ in range(L):\n            for letter in range(26):\n                if half_counts[letter] > 0:\n                    half_counts[letter] -= 1\n                    count_here = count_permutations(half_counts, k + 1)\n                    if count_here >= k:\n                        first_half.append(chr(letter + ord('a')))\n                        break\n                    else:\n                        k -= count_here\n                        half_counts[letter] += 1\n            else:\n                return \"\"\n        first_half_str = \"\".join(first_half)\n        return first_half_str + center + first_half_str[::-1]\n",
  "input": "smallestPalindrome(s=\"abba\", k=2)",
  "output": "'baab'",
  "correct_condition": "smallestPalindrome(s=\"abba\", k=2) == 'baab'",
  "contest_id": "weekly-contest-445",
  "contest_date": "2025-04-13T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 45,
    "coverage": null
  },
  "submission_id": 1605121925,
  "mutated_code": "def smallestPalindrome(s: str, k: int) -> str:\n    freq = [0] * 26\n    for ch in s:\n        freq[ord(ch) - ord('a')] += 1\n    half_counts = [count * 2 for count in freq]\n    L = sum(half_counts)\n    center = ''\n    for i in range(26):\n        if freq[i] % 2 == 1:\n            center = chr(i + ord('a'))\n            break\n\n    def count_permutations(counts, cap_value):\n        total = sum(counts)\n        result = 1\n        rem = total\n        for m in counts:\n            if m > 0:\n                result *= comb(rem, m)\n                if result > cap_value:\n                    return cap_value\n                rem -= m\n        return result\n    total_count = count_permutations(half_counts, k + 1)\n    if total_count < k:\n        return ''\n    first_half = []\n    for _ in range(L):\n        for letter in range(26):\n            if half_counts[letter] > 0:\n                half_counts[letter] -= 1\n                count_here = count_permutations(half_counts, k + 1)\n                if count_here >= k:\n                    first_half.append(chr(letter + ord('a')))\n                    break\n                else:\n                    k -= count_here\n                    half_counts[letter] += 1\n        else:\n            return ''\n    first_half_str = ''.join(first_half)\n    return first_half_str + center + first_half_str[::-1]",
  "mutated_output": "'aaababbbbbbabaaa'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest445_q3813_s1",
  "question_id": 3813,
  "function_name": "smallestPalindrome",
  "code": "def smallestPalindrome(s: str, k: int) -> str:\n        def getCount(countMap, total, limit):\n            ways = 1\n            for ch in sorted(countMap):\n                cnt = countMap[ch]\n                if cnt:\n                    ways *= math.comb(total, cnt)\n                    total -= cnt\n                    if ways > limit:\n                        return ways\n            return ways\n        countMap = Counter(s)\n        oddChar = \"\"\n        halfMap = {}\n        for ch in sorted(countMap.keys()):\n            if countMap[ch] % 2 != 0:\n                oddChar = ch\n            halfMap[ch] = countMap[ch] // 2\n        totalHalf = sum(halfMap.values())\n        totalWays = getCount(halfMap, totalHalf, k)\n        if totalWays < k:\n            return \"\"\n        leftHalf = []\n        for _ in range(totalHalf):\n            for ch in sorted(halfMap.keys()):\n                if halfMap[ch] > 0:\n                    halfMap[ch] -= 1\n                    ways = getCount(halfMap, totalHalf - len(leftHalf) - 1, k)\n                    if ways >= k:\n                        leftHalf.append(ch)\n                        break\n                    else:\n                        k -= ways\n                        halfMap[ch] += 1\n        return \"\".join(leftHalf) + oddChar + \"\".join(leftHalf[::-1])",
  "input": "smallestPalindrome(s=\"abba\", k=2)",
  "output": "'baab'",
  "correct_condition": "smallestPalindrome(s=\"abba\", k=2) == 'baab'",
  "contest_id": "weekly-contest-445",
  "contest_date": "2025-04-13T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 35,
    "coverage": null
  },
  "submission_id": 1605122324,
  "mutated_code": "def smallestPalindrome(s: str, k: int) -> str:\n\n    def getCount(countMap, total, limit):\n        ways = 1\n        for ch in sorted(countMap):\n            cnt = countMap[ch]\n            if cnt:\n                ways *= math.comb(total, cnt)\n                total -= cnt\n                if ways > limit:\n                    return ways\n        return ways\n    countMap = Counter(s)\n    oddChar = ''\n    halfMap = {}\n    for ch in sorted(countMap.keys()):\n        if countMap[ch] // 2 != 0:\n            oddChar = ch\n        halfMap[ch] = countMap[ch] // 2\n    totalHalf = sum(halfMap.values())\n    totalWays = getCount(halfMap, totalHalf, k)\n    if totalWays < k:\n        return ''\n    leftHalf = []\n    for _ in range(totalHalf):\n        for ch in sorted(halfMap.keys()):\n            if halfMap[ch] > 0:\n                halfMap[ch] -= 1\n                ways = getCount(halfMap, totalHalf - len(leftHalf) - 1, k)\n                if ways >= k:\n                    leftHalf.append(ch)\n                    break\n                else:\n                    k -= ways\n                    halfMap[ch] += 1\n    return ''.join(leftHalf) + oddChar + ''.join(leftHalf[::-1])",
  "mutated_output": "'babab'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest445_q3813_s2",
  "question_id": 3813,
  "function_name": "smallestPalindrome",
  "code": "def smallestPalindrome(s: str, k: int) -> str:\n        c = Counter(s)\n        mid = \"\"\n        h = {}\n        for x in sorted(c):\n            if c[x] % 2:\n                mid = x\n            h[x] = c[x] // 2\n\n        n = sum(h.values())\n        et = math.factorial(n)\n        # print(\"et\", et)\n\n        for v in h.values():\n            et //= math.factorial(v)\n        # print(\"et\", et)\n\n        if et < k:\n            ans = \"\"\n            return ans\n\n        arr = []\n        while n:\n            for x in sorted(h):\n                if h[x]:\n                    w = et * h[x] // n\n                    if k > w:\n                        k -= w\n                    else:\n                        arr.append(x)\n                        et = w\n                        h[x] -= 1\n                        n -= 1\n                        break\n        ans = \"\".join(arr) + mid + \"\".join(arr[::-1])\n        # print(\"arr\", arr)\n\n        return ans\n",
  "input": "smallestPalindrome(s=\"abba\", k=2)",
  "output": "'baab'",
  "correct_condition": "smallestPalindrome(s=\"abba\", k=2) == 'baab'",
  "contest_id": "weekly-contest-445",
  "contest_date": "2025-04-13T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 38,
    "coverage": null
  },
  "submission_id": 1605133535,
  "mutated_code": "def smallestPalindrome(s: str, k: int) -> str:\n    c = Counter(s)\n    mid = ''\n    h = {}\n    for x in sorted(c):\n        if c[x] // 2:\n            mid = x\n        h[x] = c[x] // 2\n    n = sum(h.values())\n    et = math.factorial(n)\n    for v in h.values():\n        et //= math.factorial(v)\n    if et < k:\n        ans = ''\n        return ans\n    arr = []\n    while n:\n        for x in sorted(h):\n            if h[x]:\n                w = et * h[x] // n\n                if k > w:\n                    k -= w\n                else:\n                    arr.append(x)\n                    et = w\n                    h[x] -= 1\n                    n -= 1\n                    break\n    ans = ''.join(arr) + mid + ''.join(arr[::-1])\n    return ans",
  "mutated_output": "'babab'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest446_q3732_s0",
  "question_id": 3732,
  "function_name": "calculateScore",
  "code": "def calculateScore(instructions: List[str], values: List[int]) -> int:\n        n = len(instructions)\n        v = set()\n        i = 0\n        s = 0\n\n        while 0 <= i < n:\n            if i in v:\n                break\n            v.add(i)\n            if instructions[i] == \"add\":\n                s += values[i]\n                i += 1\n            else:\n                i += values[i]\n\n        return s\n",
  "input": "calculateScore(instructions=[\"jump\",\"add\",\"add\",\"jump\",\"add\",\"jump\"], values=[2,1,3,1,-2,-3])",
  "output": "1",
  "correct_condition": "calculateScore(instructions=[\"jump\",\"add\",\"add\",\"jump\",\"add\",\"jump\"], values=[2,1,3,1,-2,-3]) == 1",
  "contest_id": "weekly-contest-446",
  "contest_date": "2025-04-20T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 17,
    "coverage": null
  },
  "submission_id": 1612012426,
  "mutated_code": "def calculateScore(instructions: List[str], values: List[int]) -> int:\n    n = len(instructions)\n    v = set()\n    i = 0\n    s = 0\n    while 0 < i < n:\n        if i in v:\n            break\n        v.add(i)\n        if instructions[i] == 'add':\n            s += values[i]\n            i += 1\n        else:\n            i += values[i]\n    return s",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest446_q3732_s1",
  "question_id": 3732,
  "function_name": "calculateScore",
  "code": "def calculateScore(instructions: List[str], values: List[int]) -> int:\n        n = len(instructions)\n        visited = [False] * n\n        i = 0\n        score = 0\n        while 0 <= i < n and not visited[i]:\n            visited[i] = True\n            if instructions[i] == \"add\":\n                score += values[i]\n                i += 1\n            else:\n                i += values[i]\n        return score",
  "input": "calculateScore(instructions=[\"jump\",\"add\",\"add\",\"jump\",\"add\",\"jump\"], values=[2,1,3,1,-2,-3])",
  "output": "1",
  "correct_condition": "calculateScore(instructions=[\"jump\",\"add\",\"add\",\"jump\",\"add\",\"jump\"], values=[2,1,3,1,-2,-3]) == 1",
  "contest_id": "weekly-contest-446",
  "contest_date": "2025-04-20T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 13,
    "coverage": null
  },
  "submission_id": 1612022105,
  "mutated_code": "def calculateScore(instructions: List[str], values: List[int]) -> int:\n    n = len(instructions)\n    visited = [False] * n\n    i = 0\n    score = 0\n    while 0 < i < n and (not visited[i]):\n        visited[i] = True\n        if instructions[i] == 'add':\n            score += values[i]\n            i += 1\n        else:\n            i += values[i]\n    return score",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest446_q3732_s2",
  "question_id": 3732,
  "function_name": "calculateScore",
  "code": "def calculateScore(instructions: List[str], values: List[int]) -> int:\n        n = len(instructions)\n        visited = set()\n        score = 0\n        i = 0\n        \n        while 0 <= i < n:\n            if i in visited:\n                break\n                \n            visited.add(i)\n            if instructions[i] == \"add\":\n                score += values[i]\n                i += 1\n            elif instructions[i] == \"jump\":\n                i = i + values[i]\n                \n        return score",
  "input": "calculateScore(instructions=[\"jump\",\"add\",\"add\",\"jump\",\"add\",\"jump\"], values=[2,1,3,1,-2,-3])",
  "output": "1",
  "correct_condition": "calculateScore(instructions=[\"jump\",\"add\",\"add\",\"jump\",\"add\",\"jump\"], values=[2,1,3,1,-2,-3]) == 1",
  "contest_id": "weekly-contest-446",
  "contest_date": "2025-04-20T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 18,
    "coverage": null
  },
  "submission_id": 1611993158,
  "mutated_code": "def calculateScore(instructions: List[str], values: List[int]) -> int:\n    n = len(instructions)\n    visited = set()\n    score = 0\n    i = 0\n    while 0 <= i < n:\n        if i in visited:\n            break\n        visited.add(i)\n        if instructions[i] == 'add':\n            score += values[i]\n            i += 1\n        elif instructions[i] == 'jump':\n            i = i - values[i]\n    return score",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest446_q3738_s0",
  "question_id": 3738,
  "function_name": "maximumPossibleSize",
  "code": "def maximumPossibleSize(nums: List[int]) -> int:\n        a = []\n        for b in nums:\n            a.append(b)\n            while len(a) >= 2 and a[-2] > a[-1]:\n                a.pop()\n        return len(a)\n",
  "input": "maximumPossibleSize(nums=[4,2,5,3,5])",
  "output": "3",
  "correct_condition": "maximumPossibleSize(nums=[4,2,5,3,5]) == 3",
  "contest_id": "weekly-contest-446",
  "contest_date": "2025-04-20T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1612012595,
  "mutated_code": "def maximumPossibleSize(nums: List[int]) -> int:\n    a = []\n    for b in nums:\n        a.append(b)\n        while len(a) > 2 and a[-2] > a[-1]:\n            a.pop()\n    return len(a)",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest446_q3738_s1",
  "question_id": 3738,
  "function_name": "maximumPossibleSize",
  "code": "def maximumPossibleSize(nums: List[int]) -> int:\n        res = 0\n        mx = float('-inf')\n        for el in nums:\n            if el >= mx:\n                mx = el\n                res += 1\n        return res",
  "input": "maximumPossibleSize(nums=[4,2,5,3,5])",
  "output": "3",
  "correct_condition": "maximumPossibleSize(nums=[4,2,5,3,5]) == 3",
  "contest_id": "weekly-contest-446",
  "contest_date": "2025-04-20T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 8,
    "coverage": null
  },
  "submission_id": 1612019160,
  "mutated_code": "def maximumPossibleSize(nums: List[int]) -> int:\n    res = 0\n    mx = float('-inf')\n    for el in nums:\n        if el > mx:\n            mx = el\n            res += 1\n    return res",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest446_q3738_s2",
  "question_id": 3738,
  "function_name": "maximumPossibleSize",
  "code": "def maximumPossibleSize(nums: List[int]) -> int:\n        stack = []\n        for currVal in nums:\n            stack.append(currVal)\n            while len(stack) > 1 and stack[-2] > stack[-1]:\n                lastVal = stack.pop()\n                prevVal = stack.pop()\n                stack.append(lastVal if lastVal > prevVal else prevVal)\n        return len(stack)",
  "input": "maximumPossibleSize(nums=[4,2,5,3,5])",
  "output": "3",
  "correct_condition": "maximumPossibleSize(nums=[4,2,5,3,5]) == 3",
  "contest_id": "weekly-contest-446",
  "contest_date": "2025-04-20T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 9,
    "coverage": null
  },
  "submission_id": 1612002603,
  "mutated_code": "def maximumPossibleSize(nums: List[int]) -> int:\n    stack = []\n    for currVal in nums:\n        stack.append(currVal)\n        while len(stack) > 1 and stack[-2] >= stack[-1]:\n            lastVal = stack.pop()\n            prevVal = stack.pop()\n            stack.append(lastVal if lastVal > prevVal else prevVal)\n    return len(stack)",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest446_q3831_s0",
  "question_id": 3831,
  "function_name": "resultArray",
  "code": "def resultArray(nums: List[int], k: int) -> List[int]:\n        res = [0] * k\n        prev = [0] * k\n\n        for n in nums:\n            m = n % k\n            cur = [0] * k\n            cur[m] += 1\n            for r in range(k):\n                if prev[r]:\n                    new_r = (r * m) % k\n                    cur[new_r] += prev[r]\n            for r in range(k):\n                res[r] += cur[r]\n            prev = cur\n\n        return res\n",
  "input": "resultArray(nums=[1,2,3,4,5], k=3)",
  "output": "[9, 2, 4]",
  "correct_condition": "resultArray(nums=[1,2,3,4,5], k=3) == [9, 2, 4]",
  "contest_id": "weekly-contest-446",
  "contest_date": "2025-04-20T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 17,
    "coverage": null
  },
  "submission_id": 1612012857,
  "mutated_code": "def resultArray(nums: List[int], k: int) -> List[int]:\n    res = [0] * k\n    prev = [0] * k\n    for n in nums:\n        m = n // k\n        cur = [0] * k\n        cur[m] += 1\n        for r in range(k):\n            if prev[r]:\n                new_r = r * m % k\n                cur[new_r] += prev[r]\n        for r in range(k):\n            res[r] += cur[r]\n        prev = cur\n    return res",
  "mutated_output": "[9, 6, 0]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest446_q3831_s1",
  "question_id": 3831,
  "function_name": "resultArray",
  "code": "def resultArray(nums: List[int], k: int) -> List[int]:\n        res = [0] * k\n        dp = [0] * k\n        for a in nums:\n            ndp = [0] * k\n            am = a % k\n            ndp[am] += 1\n            for r in range(k):\n                if dp[r]:\n                    ndp[(r * am) % k] += dp[r]\n            for r in range(k):\n                res[r] += ndp[r]\n            dp = ndp\n        return res",
  "input": "resultArray(nums=[1,2,3,4,5], k=3)",
  "output": "[9, 2, 4]",
  "correct_condition": "resultArray(nums=[1,2,3,4,5], k=3) == [9, 2, 4]",
  "contest_id": "weekly-contest-446",
  "contest_date": "2025-04-20T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1612015311,
  "mutated_code": "def resultArray(nums: List[int], k: int) -> List[int]:\n    res = [0] * k\n    dp = [0] * k\n    for a in nums:\n        ndp = [0] * k\n        am = a // k\n        ndp[am] += 1\n        for r in range(k):\n            if dp[r]:\n                ndp[r * am % k] += dp[r]\n        for r in range(k):\n            res[r] += ndp[r]\n        dp = ndp\n    return res",
  "mutated_output": "[9, 6, 0]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest446_q3831_s2",
  "question_id": 3831,
  "function_name": "resultArray",
  "code": "def resultArray(nums: List[int], k: int) -> List[int]:\n        result = [0] * k\n        curr = [0] * k\n        for num in nums:\n            m = num % k\n            newCurr = [0] * k\n            for r in range(k):\n                newCurr[(r * m) % k] += curr[r]\n            newCurr[m] += 1\n            curr = newCurr\n            for r in range(k):\n                result[r] += curr[r]\n        return result",
  "input": "resultArray(nums=[1,2,3,4,5], k=3)",
  "output": "[9, 2, 4]",
  "correct_condition": "resultArray(nums=[1,2,3,4,5], k=3) == [9, 2, 4]",
  "contest_id": "weekly-contest-446",
  "contest_date": "2025-04-20T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 13,
    "coverage": null
  },
  "submission_id": 1612005272,
  "mutated_code": "def resultArray(nums: List[int], k: int) -> List[int]:\n    result = [0] * k\n    curr = [0] * k\n    for num in nums:\n        m = num // k\n        newCurr = [0] * k\n        for r in range(k):\n            newCurr[r * m % k] += curr[r]\n        newCurr[m] += 1\n        curr = newCurr\n        for r in range(k):\n            result[r] += curr[r]\n    return result",
  "mutated_output": "[9, 6, 0]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest446_q3840_s0",
  "question_id": 3840,
  "function_name": "resultArray",
  "code": "def resultArray(nums: List[int], k: int, queries: List[List[int]]) -> List[int]:\n        def range_query(left, right):\n            left_prod, right_prod = 1, 1\n            left_counts = [0] * k\n            right_counts = [0] * k\n            l, r = left + seg_size, right + seg_size\n\n            while l < r:\n                if l & 1:\n                    merged = [0] * k\n                    for i in range(k):\n                        merged[i] += left_counts[i]\n                    for i in range(k):\n                        if tree_counts[l][i]:\n                            merged[(left_prod * i) % k] += tree_counts[l][i]\n                    left_prod = (left_prod * tree_product[l]) % k\n                    left_counts = merged\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    merged = [0] * k\n                    for i in range(k):\n                        merged[i] += tree_counts[r][i]\n                    for i in range(k):\n                        if right_counts[i]:\n                            merged[(tree_product[r] * i) % k] += right_counts[i]\n                    right_prod = (tree_product[r] * right_prod) % k\n                    right_counts = merged\n                l //= 2\n                r //= 2\n\n            total_product = (left_prod * right_prod) % k\n            result = [0] * k\n            for i in range(k):\n                result[i] += left_counts[i]\n            for i in range(k):\n                if right_counts[i]:\n                    result[(left_prod * i) % k] += right_counts[i]\n            return total_product, result\n        \n        original_state = (nums.copy(), k, [q[:] for q in queries])\n\n        n = len(nums)\n        seg_size = 1\n        while seg_size < n: \n            seg_size <<= 1\n\n        tree_product = [1] * (2 * seg_size)\n        tree_counts = [[0] * k for _ in range(2 * seg_size)]\n\n        for i in range(n):\n            mod_val = nums[i] % k\n            tree_product[seg_size + i] = mod_val\n            tree_counts[seg_size + i][mod_val] = 1\n\n        for i in range(seg_size - 1, 0, -1):\n            left_prod, right_prod = tree_product[2 * i], tree_product[2 * i + 1]\n            tree_product[i] = (left_prod * right_prod) % k\n            merged = [0] * k\n            for j in range(k):\n                merged[j] += tree_counts[2 * i][j]\n            for j in range(k):\n                if tree_counts[2 * i + 1][j]:\n                    new_mod = (left_prod * j) % k\n                    merged[new_mod] += tree_counts[2 * i + 1][j]\n            tree_counts[i] = merged\n            \n        \n\n        def update(index, value):\n            pos = seg_size + index\n            mod_val = value % k\n            tree_product[pos] = mod_val\n            tree_counts[pos] = [0] * k\n            tree_counts[pos][mod_val] = 1\n\n            pos //= 2\n            while pos:\n                left_prod, right_prod = tree_product[2 * pos], tree_product[2 * pos + 1]\n                tree_product[pos] = (left_prod * right_prod) % k\n                merged = [0] * k\n                for j in range(k):\n                    merged[j] += tree_counts[2 * pos][j]\n                for j in range(k):\n                    if tree_counts[2 * pos + 1][j]:\n                        new_mod = (left_prod * j) % k\n                        merged[new_mod] += tree_counts[2 * pos + 1][j]\n                tree_counts[pos] = merged\n                pos //= 2\n                \n        \n\n        answers = []\n        for idx, val, l, target_mod in queries:\n            update(idx, val)\n            _, mod_counts = range_query(l, n)\n            answers.append(mod_counts[target_mod])\n        return answers\n\n\n        ",
  "input": "resultArray(nums=[1,2,3,4,5], k=3, queries=[[2,2,0,2],[3,3,3,0],[0,1,0,1]])",
  "output": "[2, 2, 2]",
  "correct_condition": "resultArray(nums=[1,2,3,4,5], k=3, queries=[[2,2,0,2],[3,3,3,0],[0,1,0,1]]) == [2, 2, 2]",
  "contest_id": "weekly-contest-446",
  "contest_date": "2025-04-20T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 101,
    "coverage": null
  },
  "submission_id": 1612019119,
  "mutated_code": "def resultArray(nums: List[int], k: int, queries: List[List[int]]) -> List[int]:\n\n    def range_query(left, right):\n        left_prod, right_prod = (1, 1)\n        left_counts = [0] * k\n        right_counts = [0] * k\n        l, r = (left - seg_size, right + seg_size)\n        while l < r:\n            if l & 1:\n                merged = [0] * k\n                for i in range(k):\n                    merged[i] += left_counts[i]\n                for i in range(k):\n                    if tree_counts[l][i]:\n                        merged[left_prod * i % k] += tree_counts[l][i]\n                left_prod = left_prod * tree_product[l] % k\n                left_counts = merged\n                l += 1\n            if r & 1:\n                r -= 1\n                merged = [0] * k\n                for i in range(k):\n                    merged[i] += tree_counts[r][i]\n                for i in range(k):\n                    if right_counts[i]:\n                        merged[tree_product[r] * i % k] += right_counts[i]\n                right_prod = tree_product[r] * right_prod % k\n                right_counts = merged\n            l //= 2\n            r //= 2\n        total_product = left_prod * right_prod % k\n        result = [0] * k\n        for i in range(k):\n            result[i] += left_counts[i]\n        for i in range(k):\n            if right_counts[i]:\n                result[left_prod * i % k] += right_counts[i]\n        return (total_product, result)\n    original_state = (nums.copy(), k, [q[:] for q in queries])\n    n = len(nums)\n    seg_size = 1\n    while seg_size < n:\n        seg_size <<= 1\n    tree_product = [1] * (2 * seg_size)\n    tree_counts = [[0] * k for _ in range(2 * seg_size)]\n    for i in range(n):\n        mod_val = nums[i] % k\n        tree_product[seg_size + i] = mod_val\n        tree_counts[seg_size + i][mod_val] = 1\n    for i in range(seg_size - 1, 0, -1):\n        left_prod, right_prod = (tree_product[2 * i], tree_product[2 * i + 1])\n        tree_product[i] = left_prod * right_prod % k\n        merged = [0] * k\n        for j in range(k):\n            merged[j] += tree_counts[2 * i][j]\n        for j in range(k):\n            if tree_counts[2 * i + 1][j]:\n                new_mod = left_prod * j % k\n                merged[new_mod] += tree_counts[2 * i + 1][j]\n        tree_counts[i] = merged\n\n    def update(index, value):\n        pos = seg_size + index\n        mod_val = value % k\n        tree_product[pos] = mod_val\n        tree_counts[pos] = [0] * k\n        tree_counts[pos][mod_val] = 1\n        pos //= 2\n        while pos:\n            left_prod, right_prod = (tree_product[2 * pos], tree_product[2 * pos + 1])\n            tree_product[pos] = left_prod * right_prod % k\n            merged = [0] * k\n            for j in range(k):\n                merged[j] += tree_counts[2 * pos][j]\n            for j in range(k):\n                if tree_counts[2 * pos + 1][j]:\n                    new_mod = left_prod * j % k\n                    merged[new_mod] += tree_counts[2 * pos + 1][j]\n            tree_counts[pos] = merged\n            pos //= 2\n    answers = []\n    for idx, val, l, target_mod in queries:\n        update(idx, val)\n        _, mod_counts = range_query(l, n)\n        answers.append(mod_counts[target_mod])\n    return answers",
  "mutated_output": "[2, 6, 2]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest446_q3840_s2",
  "question_id": 3840,
  "function_name": "resultArray",
  "code": "def resultArray(nums: List[int], k: int, queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        tree = [None] * (4 * n)\n        \n        def merge(leftNode, rightNode):\n            leftProd, leftHist = leftNode\n            rightProd, rightHist = rightNode\n            totalProd = (leftProd * rightProd) % k\n            newHist = [0] * k\n            for v in range(k):\n                newHist[v] += leftHist[v]\n            for u in range(k):\n                v = (leftProd * u) % k\n                newHist[v] += rightHist[u]\n            return (totalProd, newHist)\n        \n        def build(node, l, r):\n            if l == r:\n                prod = nums[l] % k\n                hist = [0] * k\n                hist[prod] = 1\n                tree[node] = (prod, hist)\n            else:\n                m = (l + r) // 2\n                build(node*2, l, m)\n                build(node*2+1, m+1, r)\n                tree[node] = merge(tree[node*2], tree[node*2+1])\n        \n        def update(node, l, r, idx, val):\n            if l == r:\n                prod = val % k\n                hist = [0] * k\n                hist[prod] = 1\n                tree[node] = (prod, hist)\n            else:\n                m = (l + r) // 2\n                if idx <= m:\n                    update(node*2, l, m, idx, val)\n                else:\n                    update(node*2+1, m+1, r, idx, val)\n                tree[node] = merge(tree[node*2], tree[node*2+1])\n        \n        def query(node, l, r, ql, qr):\n            if ql > r or qr < l:\n                return (1, [0] * k)\n            if ql <= l and r <= qr:\n                return tree[node]\n            m = (l + r) // 2\n            leftRes = query(node*2, l, m, ql, qr)\n            rightRes = query(node*2+1, m+1, r, ql, qr)\n            return merge(leftRes, rightRes)\n        \n        build(1, 0, n-1)\n        result = []\n        for idx, val, start, x in queries:\n            update(1, 0, n-1, idx, val)\n            _, hist = query(1, 0, n-1, start, n-1)\n            result.append(hist[x])\n        return result",
  "input": "resultArray(nums=[1,2,3,4,5], k=3, queries=[[2,2,0,2],[3,3,3,0],[0,1,0,1]])",
  "output": "[2, 2, 2]",
  "correct_condition": "resultArray(nums=[1,2,3,4,5], k=3, queries=[[2,2,0,2],[3,3,3,0],[0,1,0,1]]) == [2, 2, 2]",
  "contest_id": "weekly-contest-446",
  "contest_date": "2025-04-20T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 59,
    "coverage": null
  },
  "submission_id": 1612023624,
  "mutated_code": "def resultArray(nums: List[int], k: int, queries: List[List[int]]) -> List[int]:\n    n = len(nums)\n    tree = [None] * (4 * n)\n\n    def merge(leftNode, rightNode):\n        leftProd, leftHist = leftNode\n        rightProd, rightHist = rightNode\n        totalProd = leftProd * rightProd // k\n        newHist = [0] * k\n        for v in range(k):\n            newHist[v] += leftHist[v]\n        for u in range(k):\n            v = leftProd * u % k\n            newHist[v] += rightHist[u]\n        return (totalProd, newHist)\n\n    def build(node, l, r):\n        if l == r:\n            prod = nums[l] % k\n            hist = [0] * k\n            hist[prod] = 1\n            tree[node] = (prod, hist)\n        else:\n            m = (l + r) // 2\n            build(node * 2, l, m)\n            build(node * 2 + 1, m + 1, r)\n            tree[node] = merge(tree[node * 2], tree[node * 2 + 1])\n\n    def update(node, l, r, idx, val):\n        if l == r:\n            prod = val % k\n            hist = [0] * k\n            hist[prod] = 1\n            tree[node] = (prod, hist)\n        else:\n            m = (l + r) // 2\n            if idx <= m:\n                update(node * 2, l, m, idx, val)\n            else:\n                update(node * 2 + 1, m + 1, r, idx, val)\n            tree[node] = merge(tree[node * 2], tree[node * 2 + 1])\n\n    def query(node, l, r, ql, qr):\n        if ql > r or qr < l:\n            return (1, [0] * k)\n        if ql <= l and r <= qr:\n            return tree[node]\n        m = (l + r) // 2\n        leftRes = query(node * 2, l, m, ql, qr)\n        rightRes = query(node * 2 + 1, m + 1, r, ql, qr)\n        return merge(leftRes, rightRes)\n    build(1, 0, n - 1)\n    result = []\n    for idx, val, start, x in queries:\n        update(1, 0, n - 1, idx, val)\n        _, hist = query(1, 0, n - 1, start, n - 1)\n        result.append(hist[x])\n    return result",
  "mutated_output": "[1, 2, 1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest447_q3819_s0",
  "question_id": 3819,
  "function_name": "countCoveredBuildings",
  "code": "def countCoveredBuildings(n: int, buildings: List[List[int]]) -> int:\n        rMin, rMax, cMin, cMax = {}, {}, {}, {}\n        for x, y in buildings:\n            if x in rMin:\n                rMin[x] = min(rMin[x], y)\n                rMax[x] = max(rMax[x], y)\n            else:\n                rMin[x] = y\n                rMax[x] = y\n            if y in cMin:\n                cMin[y] = min(cMin[y], x)\n                cMax[y] = max(cMax[y], x)\n            else:\n                cMin[y] = x\n                cMax[y] = x\n        cnt = 0\n        for x, y in buildings:\n            if y > rMin[x] and y < rMax[x] and x > cMin[y] and x < cMax[y]:\n                cnt += 1\n        return cnt",
  "input": "countCoveredBuildings(n=3, buildings=[[1,2],[2,2],[3,2],[2,1],[2,3]])",
  "output": "1",
  "correct_condition": "countCoveredBuildings(n=3, buildings=[[1,2],[2,2],[3,2],[2,1],[2,3]]) == 1",
  "contest_id": "weekly-contest-447",
  "contest_date": "2025-04-27T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 20,
    "coverage": null
  },
  "submission_id": 1618869457,
  "mutated_code": "def countCoveredBuildings(n: int, buildings: List[List[int]]) -> int:\n    rMin, rMax, cMin, cMax = ({}, {}, {}, {})\n    for x, y in buildings:\n        if x in rMin:\n            rMin[x] = min(rMin[x], y)\n            rMax[x] = max(rMax[x], y)\n        else:\n            rMin[x] = y\n            rMax[x] = y\n        if y in cMin:\n            cMin[y] = min(cMin[y], x)\n            cMax[y] = max(cMax[y], x)\n        else:\n            cMin[y] = x\n            cMax[y] = x\n    cnt = 0\n    for x, y in buildings:\n        if y > rMin[x] or y < rMax[x] or x > cMin[y] or (x < cMax[y]):\n            cnt += 1\n    return cnt",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "logical",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest447_q3819_s2",
  "question_id": 3819,
  "function_name": "countCoveredBuildings",
  "code": "def countCoveredBuildings(n: int, buildings: List[List[int]]) -> int:\n        rows = {}\n        cols = {}\n        for x, y in buildings:\n            rows.setdefault(x, []).append(y)\n            cols.setdefault(y, []).append(x)\n        for r in rows:\n            rows[r].sort()\n        for c in cols:\n            cols[c].sort()\n\n        covered = 0\n        for x, y in buildings:\n            ys = rows[x]\n            i = bisect.bisect_left(ys, y)\n            has_left  = (i > 0)\n            has_right = (i+1 < len(ys))\n\n            xs = cols[y]\n            j = bisect.bisect_left(xs, x)\n            has_up    = (j > 0)\n            has_down  = (j+1 < len(xs))\n\n            if has_left and has_right and has_up and has_down:\n                covered += 1\n\n        return covered",
  "input": "countCoveredBuildings(n=3, buildings=[[1,2],[2,2],[3,2],[2,1],[2,3]])",
  "output": "1",
  "correct_condition": "countCoveredBuildings(n=3, buildings=[[1,2],[2,2],[3,2],[2,1],[2,3]]) == 1",
  "contest_id": "weekly-contest-447",
  "contest_date": "2025-04-27T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 27,
    "coverage": null
  },
  "submission_id": 1618870819,
  "mutated_code": "def countCoveredBuildings(n: int, buildings: List[List[int]]) -> int:\n    rows = {}\n    cols = {}\n    for x, y in buildings:\n        rows.setdefault(x, []).append(y)\n        cols.setdefault(y, []).append(x)\n    for r in rows:\n        rows[r].sort()\n    for c in cols:\n        cols[c].sort()\n    covered = 0\n    for x, y in buildings:\n        ys = rows[x]\n        i = bisect.bisect_left(ys, y)\n        has_left = i > 0\n        has_right = i + 1 < len(ys)\n        xs = cols[y]\n        j = bisect.bisect_left(xs, x)\n        has_up = j > 0\n        has_down = j + 1 < len(xs)\n        if has_left or has_right or has_up or has_down:\n            covered += 1\n    return covered",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "logical",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest447_q3838_s0",
  "question_id": 3838,
  "function_name": "pathExistenceQueries",
  "code": "def pathExistenceQueries(n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[bool]:\n        comp = [0] * n\n        cid = 0\n        for i in range(1, n):\n            if nums[i] - nums[i - 1] <= maxDiff:\n                comp[i] = cid\n            else:\n                cid += 1\n                comp[i] = cid\n        res = []\n        for u, v in queries:\n            res.append(comp[u] == comp[v])\n        return res",
  "input": "pathExistenceQueries(n=2, nums=[1,3], maxDiff=1, queries=[[0,0],[0,1]])",
  "output": "[True, False]",
  "correct_condition": "pathExistenceQueries(n=2, nums=[1,3], maxDiff=1, queries=[[0,0],[0,1]]) == [True, False]",
  "contest_id": "weekly-contest-447",
  "contest_date": "2025-04-27T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 13,
    "coverage": null
  },
  "submission_id": 1618871052,
  "mutated_code": "def pathExistenceQueries(n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[bool]:\n    comp = [0] * n\n    cid = 0\n    for i in range(1, n):\n        if nums[i] - nums[i - 1] <= maxDiff:\n            comp[i] = cid\n        else:\n            cid += 1\n            comp[i] = cid\n    res = []\n    for u, v in queries:\n        res.append(comp[u] != comp[v])\n    return res",
  "mutated_output": "[False, True]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest447_q3838_s2",
  "question_id": 3838,
  "function_name": "pathExistenceQueries",
  "code": "def pathExistenceQueries(n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[bool]:\n        comp = [0] * n\n        cid = 0\n        for i in range(1, n):\n            if nums[i] - nums[i-1] > maxDiff:\n                cid += 1\n            comp[i] = cid\n\n        ans = []\n        for u, v in queries:\n            ans.append(comp[u] == comp[v])\n        return ans",
  "input": "pathExistenceQueries(n=2, nums=[1,3], maxDiff=1, queries=[[0,0],[0,1]])",
  "output": "[True, False]",
  "correct_condition": "pathExistenceQueries(n=2, nums=[1,3], maxDiff=1, queries=[[0,0],[0,1]]) == [True, False]",
  "contest_id": "weekly-contest-447",
  "contest_date": "2025-04-27T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 12,
    "coverage": null
  },
  "submission_id": 1618872111,
  "mutated_code": "def pathExistenceQueries(n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[bool]:\n    comp = [0] * n\n    cid = 0\n    for i in range(1, n):\n        if nums[i] - nums[i - 1] > maxDiff:\n            cid += 1\n        comp[i] = cid\n    ans = []\n    for u, v in queries:\n        ans.append(comp[u] != comp[v])\n    return ans",
  "mutated_output": "[False, True]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest447_q3841_s0",
  "question_id": 3841,
  "function_name": "concatenatedDivisibility",
  "code": "def concatenatedDivisibility(nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        p = [pow(10, len(str(x)), k) for x in nums]\n        order = sorted(range(n), key=lambda i: nums[i])\n        full = (1 << n) - 1\n        dp = {}\n        def rec(mask, rem):\n            if mask == full:\n                return [] if rem == 0 else None\n            key = (mask, rem)\n            if key in dp:\n                return dp[key]\n            for i in order:\n                if mask & (1 << i) == 0:\n                    nr = (rem * p[i] + nums[i]) % k\n                    res = rec(mask | (1 << i), nr)\n                    if res is not None:\n                        dp[key] = [nums[i]] + res\n                        return dp[key]\n            dp[key] = None\n            return None\n        ans = rec(0, 0)\n        return ans if ans is not None else []",
  "input": "concatenatedDivisibility(nums=[3,12,45], k=5)",
  "output": "[3, 12, 45]",
  "correct_condition": "concatenatedDivisibility(nums=[3,12,45], k=5) == [3, 12, 45]",
  "contest_id": "weekly-contest-447",
  "contest_date": "2025-04-27T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 23,
    "coverage": null
  },
  "submission_id": 1618873220,
  "mutated_code": "def concatenatedDivisibility(nums: List[int], k: int) -> List[int]:\n    n = len(nums)\n    p = [pow(10, len(str(x)), k) for x in nums]\n    order = sorted(range(n), key=lambda i: nums[i])\n    full = (1 << n) + 1\n    dp = {}\n\n    def rec(mask, rem):\n        if mask == full:\n            return [] if rem == 0 else None\n        key = (mask, rem)\n        if key in dp:\n            return dp[key]\n        for i in order:\n            if mask & 1 << i == 0:\n                nr = (rem * p[i] + nums[i]) % k\n                res = rec(mask | 1 << i, nr)\n                if res is not None:\n                    dp[key] = [nums[i]] + res\n                    return dp[key]\n        dp[key] = None\n        return None\n    ans = rec(0, 0)\n    return ans if ans is not None else []",
  "mutated_output": "[]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest447_q3841_s2",
  "question_id": 3841,
  "function_name": "concatenatedDivisibility",
  "code": "def concatenatedDivisibility(nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        FULL = (1<<n) - 1\n\n        L = [len(str(x)) for x in nums]\n        pow10L = [pow(10, L[i], k) for i in range(n)]\n\n        idxs = sorted(range(n), key=lambda i: nums[i])\n\n        dq = deque()\n        seen = set()\n\n        for i in idxs:\n            m = 1<<i\n            r = nums[i] % k\n            seq = [nums[i]]\n            state = (m, r)\n            dq.append((m, r, seq))\n            seen.add(state)\n\n        while dq:\n            mask, rem, seq = dq.popleft()\n            if mask == FULL and rem == 0:\n                return seq\n\n            for i in idxs:\n                bit = 1<<i\n                if mask & bit: \n                    continue\n                nm = mask | bit\n\n                nr = (rem * pow10L[i] + nums[i]) % k\n                st = (nm, nr)\n                if st in seen:\n                    continue\n                seen.add(st)\n                dq.append((nm, nr, seq + [nums[i]]))\n\n        return []  ",
  "input": "concatenatedDivisibility(nums=[3,12,45], k=5)",
  "output": "[3, 12, 45]",
  "correct_condition": "concatenatedDivisibility(nums=[3,12,45], k=5) == [3, 12, 45]",
  "contest_id": "weekly-contest-447",
  "contest_date": "2025-04-27T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 39,
    "coverage": null
  },
  "submission_id": 1618878091,
  "mutated_code": "def concatenatedDivisibility(nums: List[int], k: int) -> List[int]:\n    n = len(nums)\n    FULL = (1 << n) + 1\n    L = [len(str(x)) for x in nums]\n    pow10L = [pow(10, L[i], k) for i in range(n)]\n    idxs = sorted(range(n), key=lambda i: nums[i])\n    dq = deque()\n    seen = set()\n    for i in idxs:\n        m = 1 << i\n        r = nums[i] % k\n        seq = [nums[i]]\n        state = (m, r)\n        dq.append((m, r, seq))\n        seen.add(state)\n    while dq:\n        mask, rem, seq = dq.popleft()\n        if mask == FULL and rem == 0:\n            return seq\n        for i in idxs:\n            bit = 1 << i\n            if mask & bit:\n                continue\n            nm = mask | bit\n            nr = (rem * pow10L[i] + nums[i]) % k\n            st = (nm, nr)\n            if st in seen:\n                continue\n            seen.add(st)\n            dq.append((nm, nr, seq + [nums[i]]))\n    return []",
  "mutated_output": "[]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest447_q3852_s0",
  "question_id": 3852,
  "function_name": "pathExistenceQueries",
  "code": "def pathExistenceQueries(n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[int]:\n        arr = [(nums[i], i) for i in range(n)]\n        arr.sort(key=lambda x: x[0])\n        sv = [a for a, _ in arr]\n        si = [i for _, i in arr]\n        pos = [0] * n\n        for j in range(n):\n            pos[si[j]] = j\n        comp = [0] * n\n        for i in range(1, n):\n            comp[i] = comp[i - 1] + (1 if sv[i] - sv[i - 1] > maxDiff else 0)\n        r = [0] * n\n        j = 0\n        for i in range(n):\n            while j < n and sv[j] - sv[i] <= maxDiff:\n                j += 1\n            r[i] = j - 1\n        L = n.bit_length()\n        f = [r[:]]\n        for p in range(1, L):\n            fp = [0] * n\n            for i in range(n):\n                fp[i] = f[p - 1][f[p - 1][i]]\n            f.append(fp)\n        def jump(a, b):\n            if sv[b] - sv[a] <= maxDiff:\n                return 1\n            steps, cur = 0, a\n            for p in range(L - 1, -1, -1):\n                if f[p][cur] < b:\n                    cur = f[p][cur]\n                    steps += 1 << p\n            return steps + 1 if f[0][cur] >= b else -1\n        res = []\n        for u, v in queries:\n            if u == v:\n                res.append(0)\n                continue\n            a, b = pos[u], pos[v]\n            if a > b:\n                a, b = b, a\n            if comp[a] != comp[b]:\n                res.append(-1)\n            else:\n                res.append(jump(a, b))\n        return res",
  "input": "pathExistenceQueries(n=5, nums=[1,8,3,4,2], maxDiff=3, queries=[[0,3],[2,4]])",
  "output": "[1, 1]",
  "correct_condition": "pathExistenceQueries(n=5, nums=[1,8,3,4,2], maxDiff=3, queries=[[0,3],[2,4]]) == [1, 1]",
  "contest_id": "weekly-contest-447",
  "contest_date": "2025-04-27T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 46,
    "coverage": null
  },
  "submission_id": 1618879937,
  "mutated_code": "def pathExistenceQueries(n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[int]:\n    arr = [(nums[i], i) for i in range(n)]\n    arr.sort(key=lambda x: x[0])\n    sv = [a for a, _ in arr]\n    si = [i for _, i in arr]\n    pos = [0] * n\n    for j in range(n):\n        pos[si[j]] = j\n    comp = [0] * n\n    for i in range(1, n):\n        comp[i] = comp[i - 1] + (1 if sv[i] + sv[i - 1] > maxDiff else 0)\n    r = [0] * n\n    j = 0\n    for i in range(n):\n        while j < n and sv[j] - sv[i] <= maxDiff:\n            j += 1\n        r[i] = j - 1\n    L = n.bit_length()\n    f = [r[:]]\n    for p in range(1, L):\n        fp = [0] * n\n        for i in range(n):\n            fp[i] = f[p - 1][f[p - 1][i]]\n        f.append(fp)\n\n    def jump(a, b):\n        if sv[b] - sv[a] <= maxDiff:\n            return 1\n        steps, cur = (0, a)\n        for p in range(L - 1, -1, -1):\n            if f[p][cur] < b:\n                cur = f[p][cur]\n                steps += 1 << p\n        return steps + 1 if f[0][cur] >= b else -1\n    res = []\n    for u, v in queries:\n        if u == v:\n            res.append(0)\n            continue\n        a, b = (pos[u], pos[v])\n        if a > b:\n            a, b = (b, a)\n        if comp[a] != comp[b]:\n            res.append(-1)\n        else:\n            res.append(jump(a, b))\n    return res",
  "mutated_output": "[-1, -1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 4,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest447_q3852_s2",
  "question_id": 3852,
  "function_name": "pathExistenceQueries",
  "code": "def pathExistenceQueries(n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[int]:\n        pairs = sorted((val, idx) for idx, val in enumerate(nums))\n        values = [val for val, _ in pairs]\n        pos = [0] * n\n        for i, (_, idx) in enumerate(pairs):\n            pos[idx] = i\n        \n        comp = [0] * n\n        cid = 0\n        for i in range(1, n):\n            if values[i] - values[i-1] > maxDiff:\n                cid += 1\n            comp[i] = cid\n        \n        R = [0] * n\n        j = 0\n        for i in range(n):\n            while j + 1 < n and values[j+1] <= values[i] + maxDiff:\n                j += 1\n            R[i] = j\n        \n        LOG = math.ceil(math.log2(n)) + 1\n        nxt = [R]\n        for k in range(1, LOG):\n            prev = nxt[k-1]\n            curr = [0] * n\n            for i in range(n):\n                curr[i] = prev[prev[i]]\n            nxt.append(curr)\n        \n        def dist(pu, pv):\n            if pu == pv:\n                return 0\n            steps = 0\n            cur = pu\n            for k in range(LOG-1, -1, -1):\n                if nxt[k][cur] < pv:\n                    cur = nxt[k][cur]\n                    steps += 1 << k\n            \n            return steps + 1\n        \n        ans = []\n        for u, v in queries:\n            pu, pv = pos[u], pos[v]\n            if comp[pu] != comp[pv]:\n                ans.append(-1)\n            else:\n                if pu > pv:\n                    pu, pv = pv, pu\n                ans.append(dist(pu, pv))\n        return ans",
  "input": "pathExistenceQueries(n=5, nums=[1,8,3,4,2], maxDiff=3, queries=[[0,3],[2,4]])",
  "output": "[1, 1]",
  "correct_condition": "pathExistenceQueries(n=5, nums=[1,8,3,4,2], maxDiff=3, queries=[[0,3],[2,4]]) == [1, 1]",
  "contest_id": "weekly-contest-447",
  "contest_date": "2025-04-27T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 52,
    "coverage": null
  },
  "submission_id": 1618886059,
  "mutated_code": "def pathExistenceQueries(n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[int]:\n    pairs = sorted(((val, idx) for idx, val in enumerate(nums)))\n    values = [val for val, _ in pairs]\n    pos = [0] * n\n    for i, (_, idx) in enumerate(pairs):\n        pos[idx] = i\n    comp = [0] * n\n    cid = 0\n    for i in range(1, n):\n        if values[i] + values[i - 1] > maxDiff:\n            cid += 1\n        comp[i] = cid\n    R = [0] * n\n    j = 0\n    for i in range(n):\n        while j + 1 < n and values[j + 1] <= values[i] + maxDiff:\n            j += 1\n        R[i] = j\n    LOG = math.ceil(math.log2(n)) + 1\n    nxt = [R]\n    for k in range(1, LOG):\n        prev = nxt[k - 1]\n        curr = [0] * n\n        for i in range(n):\n            curr[i] = prev[prev[i]]\n        nxt.append(curr)\n\n    def dist(pu, pv):\n        if pu == pv:\n            return 0\n        steps = 0\n        cur = pu\n        for k in range(LOG - 1, -1, -1):\n            if nxt[k][cur] < pv:\n                cur = nxt[k][cur]\n                steps += 1 << k\n        return steps + 1\n    ans = []\n    for u, v in queries:\n        pu, pv = (pos[u], pos[v])\n        if comp[pu] != comp[pv]:\n            ans.append(-1)\n        else:\n            if pu > pv:\n                pu, pv = (pv, pu)\n            ans.append(dist(pu, pv))\n    return ans",
  "mutated_output": "[-1, -1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest448_q3859_s0",
  "question_id": 3859,
  "function_name": "maxProduct",
  "code": "def maxProduct(n: int) -> int:\n        l = []\n        while n:\n            l.append(n % 10)\n            n = n//10\n        l.sort()\n        return l[-1] * l[-2]",
  "input": "maxProduct(n=31)",
  "output": "3",
  "correct_condition": "maxProduct(n=31) == 3",
  "contest_id": "weekly-contest-448",
  "contest_date": "2025-05-04T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1624858658,
  "mutated_code": "def maxProduct(n: int) -> int:\n    l = []\n    while n:\n        l.append(n // 10)\n        n = n // 10\n    l.sort()\n    return l[-1] * l[-2]",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest448_q3859_s1",
  "question_id": 3859,
  "function_name": "maxProduct",
  "code": "def maxProduct(n: int) -> int:\n        s = str(n)\n        arr = sorted(int(_) for _ in s)\n        return arr[-1] * arr[-2]\n",
  "input": "maxProduct(n=31)",
  "output": "3",
  "correct_condition": "maxProduct(n=31) == 3",
  "contest_id": "weekly-contest-448",
  "contest_date": "2025-05-04T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 4,
    "coverage": null
  },
  "submission_id": 1624852966,
  "mutated_code": "def maxProduct(n: int) -> int:\n    s = str(n)\n    arr = sorted((int(_) for _ in s))\n    return arr[-2] * arr[-2]",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest448_q3859_s2",
  "question_id": 3859,
  "function_name": "maxProduct",
  "code": "def maxProduct(n: int) -> int:\n        d = sorted([int(x) for x in str(n)], reverse=True)\n        return d[0] * d[1]",
  "input": "maxProduct(n=31)",
  "output": "3",
  "correct_condition": "maxProduct(n=31) == 3",
  "contest_id": "weekly-contest-448",
  "contest_date": "2025-05-04T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 3,
    "coverage": null
  },
  "submission_id": 1624854518,
  "mutated_code": "def maxProduct(n: int) -> int:\n    d = sorted([int(x) for x in str(n)], reverse=True)\n    return d[-1] * d[1]",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest448_q3822_s0",
  "question_id": 3822,
  "function_name": "specialGrid",
  "code": "def specialGrid(N: int) -> List[List[int]]:\n        grid = [[0]]\n        for _ in range(N):\n            m = len(grid)\n            M = m * m\n            size = m * 2\n            new = [[0] * size for _ in range(size)]\n            for i in range(m):\n                for j in range(m):\n                    v = grid[i][j]\n                    new[i][j + m]     = v + 0 * M\n                    new[i + m][j + m] = v + 1 * M\n                    new[i + m][j]     = v + 2 * M\n                    new[i][j]         = v + 3 * M\n            grid = new\n        return grid",
  "input": "specialGrid(N=0)",
  "output": "[[0]]",
  "correct_condition": "specialGrid(N=0) == [[0]]",
  "contest_id": "weekly-contest-448",
  "contest_date": "2025-05-04T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 16,
    "coverage": null
  },
  "submission_id": 1624861294,
  "mutated_code": "def specialGrid(N: int) -> List[List[int]]:\n    grid = [[1]]\n    for _ in range(N):\n        m = len(grid)\n        M = m * m\n        size = m * 2\n        new = [[0] * size for _ in range(size)]\n        for i in range(m):\n            for j in range(m):\n                v = grid[i][j]\n                new[i][j + m] = v + 0 * M\n                new[i + m][j + m] = v + 1 * M\n                new[i + m][j] = v + 2 * M\n                new[i][j] = v + 3 * M\n        grid = new\n    return grid",
  "mutated_output": "[[1]]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest448_q3822_s2",
  "question_id": 3822,
  "function_name": "specialGrid",
  "code": "def specialGrid(n: int) -> List[List[int]]:\n        if n==0: return [[0]]\n        p=self.specialGrid(n-1)\n        d=len(p)\n        b=d*d\n        m=[[0]*(d*2) for _ in range(d*2)]\n        o=[0,b,2*b,3*b]\n        for i in range(d):\n            for j in range(d):\n                v=p[i][j]\n                m[i][j+d]=o[0]+v\n                m[i+d][j+d]=o[1]+v\n                m[i+d][j]=o[2]+v\n                m[i][j]=o[3]+v\n        return m\n",
  "input": "specialGrid(n=0)",
  "output": "[[0]]",
  "correct_condition": "specialGrid(n=0) == [[0]]",
  "contest_id": "weekly-contest-448",
  "contest_date": "2025-05-04T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1624857145,
  "mutated_code": "def specialGrid(n: int) -> List[List[int]]:\n    if n == 0:\n        return [[-1]]\n    p = self.specialGrid(n - 1)\n    d = len(p)\n    b = d * d\n    m = [[0] * (d * 2) for _ in range(d * 2)]\n    o = [0, b, 2 * b, 3 * b]\n    for i in range(d):\n        for j in range(d):\n            v = p[i][j]\n            m[i][j + d] = o[0] + v\n            m[i + d][j + d] = o[1] + v\n            m[i + d][j] = o[2] + v\n            m[i][j] = o[3] + v\n    return m",
  "mutated_output": "[[-1]]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest448_q3833_s0",
  "question_id": 3833,
  "function_name": "minTravelTime",
  "code": "def minTravelTime(l: int, n: int, k: int, position: List[int], time: List[int]) -> int:\n        P = position\n        T0 = time[:n-1]\n        prefix = [0] * n\n        prefix[0] = T0[0]\n        for i in range(1, n-1):\n            prefix[i] = prefix[i-1] + T0[i]\n        prefix[n-1] = prefix[n-2]\n        INF = 10**18\n        max_t = prefix[n-1]\n        dp = [[[INF] * (max_t + 1) for _ in range(k + 1)] for _ in range(n)]\n        dp[0][0][prefix[0]] = 0\n        for i in range(n):\n            for used in range(k + 1):\n                for t_val in range(max_t + 1):\n                    cost = dp[i][used][t_val]\n                    if cost == INF:\n                        continue\n                    for j in range(i+1, n):\n                        merges = j - i - 1\n                        new_used = used + merges\n                        if new_used > k:\n                            break\n                        dist = P[j] - P[i]\n                        new_cost = cost + t_val * dist\n                        new_t = prefix[j] - prefix[i]\n                        if new_cost < dp[j][new_used][new_t]:\n                            dp[j][new_used][new_t] = new_cost\n        return min(dp[n-1][k])\n\n\n\n\n\n\n\n",
  "input": "minTravelTime(l=10, n=4, k=1, position=[0,3,8,10], time=[5,8,3,6])",
  "output": "62",
  "correct_condition": "minTravelTime(l=10, n=4, k=1, position=[0,3,8,10], time=[5,8,3,6]) == 62",
  "contest_id": "weekly-contest-448",
  "contest_date": "2025-05-04T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 36,
    "coverage": null
  },
  "submission_id": 1624871140,
  "mutated_code": "def minTravelTime(l: int, n: int, k: int, position: List[int], time: List[int]) -> int:\n    P = position\n    T0 = time[:n - 1]\n    prefix = [0] * n\n    prefix[0] = T0[0]\n    for i in range(1, n - 1):\n        prefix[i] = prefix[i - 1] + T0[i]\n    prefix[n - 1] = prefix[n - 2]\n    INF = 10 ** 18\n    max_t = prefix[n - 1]\n    dp = [[[INF] * (max_t + 1) for _ in range(k + 1)] for _ in range(n)]\n    dp[0][0][prefix[0]] = 0\n    for i in range(n):\n        for used in range(k - 1):\n            for t_val in range(max_t + 1):\n                cost = dp[i][used][t_val]\n                if cost == INF:\n                    continue\n                for j in range(i + 1, n):\n                    merges = j - i - 1\n                    new_used = used + merges\n                    if new_used > k:\n                        break\n                    dist = P[j] - P[i]\n                    new_cost = cost + t_val * dist\n                    new_t = prefix[j] - prefix[i]\n                    if new_cost < dp[j][new_used][new_t]:\n                        dp[j][new_used][new_t] = new_cost\n    return min(dp[n - 1][k])",
  "mutated_output": "1000000000000000000",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 11,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest448_q3833_s1",
  "question_id": 3833,
  "function_name": "minTravelTime",
  "code": "def minTravelTime(l: int, n: int, k: int, position: List[int], time: List[int]) -> int:\n        p, t = position, time\n\n        pre = [0] * (n + 1)\n        for i in range(n):\n            pre[i + 1] = pre[i] + t[i]\n\n        dp = {(0, 0, 0, t[0]): 0}\n        for i in range(1, n - 1):\n            _dp = {}\n            for (_r, _p, q, w), c in dp.items():\n\n                if _r < k:\n\n                    ks = (_r + 1, _p, q + 1, w)\n                    # print(f\"i={i}, _r={_r}, _p={_p}, q={q}, w={w}, c={c}\")\n                    if c >= _dp.get(ks, float('inf')):\n                        continue\n                    _dp[ks] = c\n\n                cost = (p[i] - p[_p]) * w\n                # print(f\"i={i}, _r={_r}, _p={_p}, q={q}, w={w}, c={c}, cost={cost}\")\n                ks = (_r, i, 0, t[i] + pre[i] - pre[i - q])\n                # print(f\"i={i}, _r={_r}, _p={_p}, q={q}, w={w}, c={c}, cost={cost}\")\n                if (c + cost) >= _dp.get(ks, float('inf')):\n                    continue\n                _dp[ks] = c + cost\n\n            dp = _dp\n\n        ans = float('inf')\n        for (_r, _p, q, w), c in dp.items():\n            if _r != k:\n                continue\n            val = c + (p[n - 1] - p[_p]) * w\n            # print(f\"i={n - 1}, _r={_r}, _p={_p}, q={q}, w={w}, c={c}, val={val}\")\n            if val < ans:\n                ans = val\n\n        # print(f\"ans={ans}\")\n        return ans\n",
  "input": "minTravelTime(l=10, n=4, k=1, position=[0,3,8,10], time=[5,8,3,6])",
  "output": "62",
  "correct_condition": "minTravelTime(l=10, n=4, k=1, position=[0,3,8,10], time=[5,8,3,6]) == 62",
  "contest_id": "weekly-contest-448",
  "contest_date": "2025-05-04T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 41,
    "coverage": null
  },
  "submission_id": 1624876072,
  "mutated_code": "def minTravelTime(l: int, n: int, k: int, position: List[int], time: List[int]) -> int:\n    p, t = (position, time)\n    pre = [0] * (n + 1)\n    for i in range(n):\n        pre[i - 1] = pre[i] + t[i]\n    dp = {(0, 0, 0, t[0]): 0}\n    for i in range(1, n - 1):\n        _dp = {}\n        for (_r, _p, q, w), c in dp.items():\n            if _r < k:\n                ks = (_r + 1, _p, q + 1, w)\n                if c >= _dp.get(ks, float('inf')):\n                    continue\n                _dp[ks] = c\n            cost = (p[i] - p[_p]) * w\n            ks = (_r, i, 0, t[i] + pre[i] - pre[i - q])\n            if c + cost >= _dp.get(ks, float('inf')):\n                continue\n            _dp[ks] = c + cost\n        dp = _dp\n    ans = float('inf')\n    for (_r, _p, q, w), c in dp.items():\n        if _r != k:\n            continue\n        val = c + (p[n - 1] - p[_p]) * w\n        if val < ans:\n            ans = val\n    return ans",
  "mutated_output": "52",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest448_q3833_s2",
  "question_id": 3833,
  "function_name": "minTravelTime",
  "code": "def minTravelTime(l: int, n: int, k: int, position: List[int], time: List[int]) -> int:\n        S = [0] * (n + 1)\n        for i in range(1, n):\n            S[i] = S[i - 1] + time[i - 1]\n        \n        dp = [[{} for _ in range(k + 1)] for _ in range(n)]\n        dp[0][0] = {0: 0}\n        \n        for i in range(n):\n            for r in range(k + 1):\n                for extra, cost in list(dp[i][r].items()):\n                    if i == n - 1:\n                        continue\n                    for j in range(i + 1, n):\n                        removed = j - i - 1\n                        newR = r + removed\n                        if newR > k:\n                            break\n                        newExtra = S[j] - S[i + 1] if removed > 0 else 0\n                        dist = position[j] - position[i]\n                        seg_cost = dist * (time[i] + extra)\n                        newCost = cost + seg_cost\n                        oldCost = dp[j][newR].get(newExtra)\n                        if oldCost is None or newCost < oldCost:\n                            dp[j][newR][newExtra] = newCost\n            \n            for r in range(k + 1):\n                items = sorted(dp[i][r].items(), key=lambda x: (x[0], x[1]))\n                bestCost = float('inf')\n                pruned = {}\n                for extra, cost in items:\n                    if cost < bestCost:\n                        pruned[extra] = cost\n                        bestCost = cost\n                dp[i][r] = pruned\n        \n        return min(dp[n - 1][k].values())\n",
  "input": "minTravelTime(l=10, n=4, k=1, position=[0,3,8,10], time=[5,8,3,6])",
  "output": "62",
  "correct_condition": "minTravelTime(l=10, n=4, k=1, position=[0,3,8,10], time=[5,8,3,6]) == 62",
  "contest_id": "weekly-contest-448",
  "contest_date": "2025-05-04T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 37,
    "coverage": null
  },
  "submission_id": 1624877855,
  "mutated_code": "def minTravelTime(l: int, n: int, k: int, position: List[int], time: List[int]) -> int:\n    S = [0] * (n + 1)\n    for i in range(1, n):\n        S[i] = S[i - 1] - time[i - 1]\n    dp = [[{} for _ in range(k + 1)] for _ in range(n)]\n    dp[0][0] = {0: 0}\n    for i in range(n):\n        for r in range(k + 1):\n            for extra, cost in list(dp[i][r].items()):\n                if i == n - 1:\n                    continue\n                for j in range(i + 1, n):\n                    removed = j - i - 1\n                    newR = r + removed\n                    if newR > k:\n                        break\n                    newExtra = S[j] - S[i + 1] if removed > 0 else 0\n                    dist = position[j] - position[i]\n                    seg_cost = dist * (time[i] + extra)\n                    newCost = cost + seg_cost\n                    oldCost = dp[j][newR].get(newExtra)\n                    if oldCost is None or newCost < oldCost:\n                        dp[j][newR][newExtra] = newCost\n        for r in range(k + 1):\n            items = sorted(dp[i][r].items(), key=lambda x: (x[0], x[1]))\n            bestCost = float('inf')\n            pruned = {}\n            for extra, cost in items:\n                if cost < bestCost:\n                    pruned[extra] = cost\n                    bestCost = cost\n            dp[i][r] = pruned\n    return min(dp[n - 1][k].values())",
  "mutated_output": "30",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest448_q3851_s0",
  "question_id": 3851,
  "function_name": "magicalSum",
  "code": "def magicalSum(M: int, K: int, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        fact = [1] * (M + 1)\n        for i in range(1, M + 1):\n            fact[i] = fact[i - 1] * i % mod\n        inv_fact = [1] * (M + 1)\n        inv_fact[M] = pow(fact[M], mod - 2, mod)\n        for i in range(M, 0, -1):\n            inv_fact[i - 1] = inv_fact[i] * i % mod\n        num_pow = [[pow(nums[i], c, mod) for c in range(M + 1)] for i in range(n)]\n        dp = [[[0] * (K + 1) for _ in range(M + 1)] for __ in range(M + 1)]\n        dp[0][0][0] = 1\n        for i in range(n):\n            new_dp = [[[0] * (K + 1) for _ in range(M + 1)] for __ in range(M + 1)]\n            np_i = num_pow[i]\n            for used in range(M + 1):\n                for carry in range(M + 1):\n                    for pop in range(K + 1):\n                        w = dp[used][carry][pop]\n                        if not w:\n                            continue\n                        max_c = M - used\n                        for c in range(max_c + 1):\n                            total = c + carry\n                            bit = total & 1\n                            new_pop = pop + bit\n                            if new_pop > K:\n                                continue\n                            new_carry = total >> 1\n                            new_used = used + c\n                            new_dp[new_used][new_carry][new_pop] = (\n                                new_dp[new_used][new_carry][new_pop]\n                                + w * np_i[c] * inv_fact[c]\n                            ) % mod\n            dp = new_dp\n        res = 0\n        for carry in range(M + 1):\n            bc = carry.bit_count()\n            for pop in range(K + 1):\n                if pop + bc == K:\n                    res = (res + dp[M][carry][pop]) % mod\n        return res * fact[M] % mod",
  "input": "magicalSum(M=5, K=5, nums=[1,10,100,10000,1000000])",
  "output": "991600007",
  "correct_condition": "magicalSum(M=5, K=5, nums=[1,10,100,10000,1000000]) == 991600007",
  "contest_id": "weekly-contest-448",
  "contest_date": "2025-05-04T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 43,
    "coverage": null
  },
  "submission_id": 1624873692,
  "mutated_code": "def magicalSum(M: int, K: int, nums: List[int]) -> int:\n    mod = 10 ** 9 - 7\n    n = len(nums)\n    fact = [1] * (M + 1)\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n    inv_fact = [1] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2, mod)\n    for i in range(M, 0, -1):\n        inv_fact[i - 1] = inv_fact[i] * i % mod\n    num_pow = [[pow(nums[i], c, mod) for c in range(M + 1)] for i in range(n)]\n    dp = [[[0] * (K + 1) for _ in range(M + 1)] for __ in range(M + 1)]\n    dp[0][0][0] = 1\n    for i in range(n):\n        new_dp = [[[0] * (K + 1) for _ in range(M + 1)] for __ in range(M + 1)]\n        np_i = num_pow[i]\n        for used in range(M + 1):\n            for carry in range(M + 1):\n                for pop in range(K + 1):\n                    w = dp[used][carry][pop]\n                    if not w:\n                        continue\n                    max_c = M - used\n                    for c in range(max_c + 1):\n                        total = c + carry\n                        bit = total & 1\n                        new_pop = pop + bit\n                        if new_pop > K:\n                            continue\n                        new_carry = total >> 1\n                        new_used = used + c\n                        new_dp[new_used][new_carry][new_pop] = (new_dp[new_used][new_carry][new_pop] + w * np_i[c] * inv_fact[c]) % mod\n        dp = new_dp\n    res = 0\n    for carry in range(M + 1):\n        bc = carry.bit_count()\n        for pop in range(K + 1):\n            if pop + bc == K:\n                res = (res + dp[M][carry][pop]) % mod\n    return res * fact[M] % mod",
  "mutated_output": "453886683",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest448_q3851_s2",
  "question_id": 3851,
  "function_name": "magicalSum",
  "code": "def magicalSum(M: int, K: int, nums: List[int]) -> int:\n        MOD = (10**9)+7\n        fact = [1] * (M+1)\n        for i in range(1, M+1):\n            fact[i] = fact[i-1] * i % MOD\n        inv_fact = [1] * (M+1)\n        inv_fact[M] = pow(fact[M], MOD-2, MOD)\n        for i in range(M, 0, -1):\n            inv_fact[i-1] = inv_fact[i] * i % MOD\n\n        dp = [[[0] * (K+1) for _ in range(M+1)] for _ in range(M+1)]\n        dp[0][0][0] = 1\n\n        for i, v in enumerate(nums):\n            ndp = [[[0] * (K+1) for _ in range(M+1)] for _ in range(M+1)]\n            pw = [1] * (M+1)\n            for c in range(1, M+1):\n                pw[c] = pw[c-1] * v % MOD\n\n            for p in range(M+1):\n                for carry in range(M+1):\n                    for b in range(K+1):\n                        cur = dp[p][carry][b]\n                        if not cur:\n                            continue\n                        max_c = M - p\n                        for c in range(max_c+1):\n                            new_p = p + c\n                            tot = carry + c\n                            bit = tot & 1\n                            new_b = b + bit\n                            if new_b > K:\n                                continue\n                            carry_out = tot >> 1\n                            val = cur * inv_fact[c] % MOD * pw[c] % MOD\n                            ndp[new_p][carry_out][new_b] = (ndp[new_p][carry_out][new_b] + val) % MOD\n\n            dp = ndp\n\n        ans = 0\n        for carry in range(M+1):\n            bc = carry.bit_count()\n            for b in range(K+1):\n                if b + bc == K:\n                    ans = (ans + dp[M][carry][b]) % MOD\n\n        ans = ans * fact[M] % MOD\n        return ans\n",
  "input": "magicalSum(M=5, K=5, nums=[1,10,100,10000,1000000])",
  "output": "991600007",
  "correct_condition": "magicalSum(M=5, K=5, nums=[1,10,100,10000,1000000]) == 991600007",
  "contest_id": "weekly-contest-448",
  "contest_date": "2025-05-04T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 48,
    "coverage": null
  },
  "submission_id": 1624869195,
  "mutated_code": "def magicalSum(M: int, K: int, nums: List[int]) -> int:\n    MOD = 10 ** 9 - 7\n    fact = [1] * (M + 1)\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    inv_fact = [1] * (M + 1)\n    inv_fact[M] = pow(fact[M], MOD - 2, MOD)\n    for i in range(M, 0, -1):\n        inv_fact[i - 1] = inv_fact[i] * i % MOD\n    dp = [[[0] * (K + 1) for _ in range(M + 1)] for _ in range(M + 1)]\n    dp[0][0][0] = 1\n    for i, v in enumerate(nums):\n        ndp = [[[0] * (K + 1) for _ in range(M + 1)] for _ in range(M + 1)]\n        pw = [1] * (M + 1)\n        for c in range(1, M + 1):\n            pw[c] = pw[c - 1] * v % MOD\n        for p in range(M + 1):\n            for carry in range(M + 1):\n                for b in range(K + 1):\n                    cur = dp[p][carry][b]\n                    if not cur:\n                        continue\n                    max_c = M - p\n                    for c in range(max_c + 1):\n                        new_p = p + c\n                        tot = carry + c\n                        bit = tot & 1\n                        new_b = b + bit\n                        if new_b > K:\n                            continue\n                        carry_out = tot >> 1\n                        val = cur * inv_fact[c] % MOD * pw[c] % MOD\n                        ndp[new_p][carry_out][new_b] = (ndp[new_p][carry_out][new_b] + val) % MOD\n        dp = ndp\n    ans = 0\n    for carry in range(M + 1):\n        bc = carry.bit_count()\n        for b in range(K + 1):\n            if b + bc == K:\n                ans = (ans + dp[M][carry][b]) % MOD\n    ans = ans * fact[M] % MOD\n    return ans",
  "mutated_output": "453886683",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest449_q3871_s1",
  "question_id": 3871,
  "function_name": "minDeletion",
  "code": "def minDeletion(s: str, k: int) -> int:\n        arr = sorted(Counter(s).values())\n        n = len(arr)\n        return sum(arr[:n - k]) if n > k else 0",
  "input": "minDeletion(s=\"abc\", k=2)",
  "output": "1",
  "correct_condition": "minDeletion(s=\"abc\", k=2) == 1",
  "contest_id": "weekly-contest-449",
  "contest_date": "2025-05-11T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 4,
    "coverage": null
  },
  "submission_id": 1630586515,
  "mutated_code": "def minDeletion(s: str, k: int) -> int:\n    arr = sorted(Counter(s).values())\n    n = len(arr)\n    return sum(arr[:n + k]) if n > k else 0",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest449_q3871_s2",
  "question_id": 3871,
  "function_name": "minDeletion",
  "code": "def minDeletion(s: str, k: int) -> int:\n        freq = {}\n        for ch in s:\n            freq[ch] = freq.get(ch, 0) + 1\n\n        if len(freq) <= k:\n            return 0\n\n        sorted_freqs = sorted(freq.values(), reverse=True)\n        keep_count = sum(sorted_freqs[:k])\n        return len(s) - keep_count",
  "input": "minDeletion(s=\"abc\", k=2)",
  "output": "1",
  "correct_condition": "minDeletion(s=\"abc\", k=2) == 1",
  "contest_id": "weekly-contest-449",
  "contest_date": "2025-05-11T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 11,
    "coverage": null
  },
  "submission_id": 1630586123,
  "mutated_code": "def minDeletion(s: str, k: int) -> int:\n    freq = {}\n    for ch in s:\n        freq[ch] = freq.get(ch, 0) - 1\n    if len(freq) <= k:\n        return 0\n    sorted_freqs = sorted(freq.values(), reverse=True)\n    keep_count = sum(sorted_freqs[:k])\n    return len(s) - keep_count",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest449_q3849_s1",
  "question_id": 3849,
  "function_name": "canPartitionGrid",
  "code": "def canPartitionGrid(grid: List[List[int]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        P = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m):\n            for j in range(n):\n                P[i + 1][j + 1] = grid[i][j] + P[i][j + 1] + P[i + 1][j] - P[i][j]\n        x = P[m][n]\n        if x & 1:\n            return False\n        y = x // 2\n        for i in range(1, m):\n            if P[i][n] == y:\n                return True\n        for j in range(1, n):\n            if P[m][j] == y:\n                return True\n        return False",
  "input": "canPartitionGrid(grid=[[1,4],[2,3]])",
  "output": "True",
  "correct_condition": "canPartitionGrid(grid=[[1,4],[2,3]]) == True",
  "contest_id": "weekly-contest-449",
  "contest_date": "2025-05-11T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 18,
    "coverage": null
  },
  "submission_id": 1630589792,
  "mutated_code": "def canPartitionGrid(grid: List[List[int]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    P = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m):\n        for j in range(n):\n            P[i - 1][j + 1] = grid[i][j] + P[i][j + 1] + P[i + 1][j] - P[i][j]\n    x = P[m][n]\n    if x & 1:\n        return False\n    y = x // 2\n    for i in range(1, m):\n        if P[i][n] == y:\n            return True\n    for j in range(1, n):\n        if P[m][j] == y:\n            return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest449_q3849_s2",
  "question_id": 3849,
  "function_name": "canPartitionGrid",
  "code": "def canPartitionGrid(grid: List[List[int]]) -> bool:\n        total_sum = 0\n        for row in grid:\n            total_sum += sum(row)\n        \n        if total_sum % 2 != 0:\n            return False\n        \n        half_sum = total_sum // 2\n        \n        current_sum = 0\n        for i in range(len(grid) - 1):\n            current_sum += sum(grid[i])\n            if current_sum == half_sum:\n                return True\n                \n        m = len(grid)\n        n = len(grid[0])\n        col_sums = [0] * n\n        for i in range(m):\n            for j in range(n):\n                col_sums[j] += grid[i][j]\n        \n        current_sum = 0\n        for j in range(n - 1):\n            current_sum += col_sums[j]\n            if current_sum == half_sum:\n                return True\n        \n        return False",
  "input": "canPartitionGrid(grid=[[1,4],[2,3]])",
  "output": "True",
  "correct_condition": "canPartitionGrid(grid=[[1,4],[2,3]]) == True",
  "contest_id": "weekly-contest-449",
  "contest_date": "2025-05-11T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 30,
    "coverage": null
  },
  "submission_id": 1630587537,
  "mutated_code": "def canPartitionGrid(grid: List[List[int]]) -> bool:\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    if total_sum // 2 != 0:\n        return False\n    half_sum = total_sum // 2\n    current_sum = 0\n    for i in range(len(grid) - 1):\n        current_sum += sum(grid[i])\n        if current_sum == half_sum:\n            return True\n    m = len(grid)\n    n = len(grid[0])\n    col_sums = [0] * n\n    for i in range(m):\n        for j in range(n):\n            col_sums[j] += grid[i][j]\n    current_sum = 0\n    for j in range(n - 1):\n        current_sum += col_sums[j]\n        if current_sum == half_sum:\n            return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest449_q3845_s1",
  "question_id": 3845,
  "function_name": "maxScore",
  "code": "def maxScore(n: int, edges: List[List[int]]) -> int:\n        G = [[] for _ in range(n)]\n        D = [0] * n\n        for u, v in edges:\n            G[u].append(v)\n            G[v].append(u)\n            D[u] += 1\n            D[v] += 1\n\n        seen = [0] * n\n        cp = []\n        for i in range(n):\n            if seen[i]:\n                continue\n            _t = [i]\n            seen[i] = 1\n            nodes = []\n            _sum = 0\n            while _t:\n                u = _t.pop()\n                nodes.append(u)\n                _sum += D[u]\n                # print(u, D[u])\n                for v in G[u]:\n                    if seen[v]:\n                        continue\n                    seen[v] = 1\n                    _t.append(v)\n\n            E = _sum // 2\n            B = None\n            if E == len(nodes):\n                for u in nodes:\n                    for v in G[u]:\n                        if u < v and v in nodes:\n                            B = (u, v)\n                            break\n                    if B:\n                        break\n            cp.append((2 * E / len(nodes), len(nodes), E, nodes, B))\n        # print(cp)\n        # print(\"is\", n - sum(c for _, c, _, _, _ in cp))\n        cp.sort(key=lambda x: (-x[0], -x[1]))\n        ret = [0] * n\n\n        # print(\"cp\", cp)\n        high = n\n        for _, c, E, nodes, B in cp:\n            low = high - c + 1\n            high -= c\n            arr = list(range(low, low + c))\n            L = {u: len(G[u])\n                    - (1 if B\n                            and ((u == B[0] and B[1] in G[u])\n                                 or (u == B[1] and B[0] in G[u])) else 0) for u in nodes}\n\n            t = 0\n            q = deque(u for u in nodes if L[u] <= 1)\n            # print(\"arr\", arr)\n            while q:\n                u = q.popleft()\n                if ret[u]:\n                    continue\n                ret[u] = arr[t]\n                t += 1\n\n                # print(\"u\", u, \"arr\", arr, \"t\", t, \"L\", L)\n                for v in G[u]:\n                    if B:\n                        if (u == B[0] and v == B[1]) or (u == B[1] and v == B[0]):\n                            continue\n                    L[v] -= 1\n                    if L[v] == 1:\n                        q.append(v)\n\n        ans = 0\n        for u, v in edges:\n            ans += ret[u] * ret[v]\n            # print(\"u\", u, \"v\", v, \"ret[u]\", ret[u], \"ret[v]\", ret[v], \"ans\", ans)\n        return ans\n",
  "input": "maxScore(n=4, edges=[[0,1],[1,2],[2,3]])",
  "output": "23",
  "correct_condition": "maxScore(n=4, edges=[[0,1],[1,2],[2,3]]) == 23",
  "contest_id": "weekly-contest-449",
  "contest_date": "2025-05-11T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 80,
    "coverage": null
  },
  "submission_id": 1630614540,
  "mutated_code": "def maxScore(n: int, edges: List[List[int]]) -> int:\n    G = [[] for _ in range(n)]\n    D = [0] * n\n    for u, v in edges:\n        G[u].append(v)\n        G[v].append(u)\n        D[u] += 1\n        D[v] += 1\n    seen = [0] * n\n    cp = []\n    for i in range(n):\n        if seen[i]:\n            continue\n        _t = [i]\n        seen[i] = 1\n        nodes = []\n        _sum = 0\n        while _t:\n            u = _t.pop()\n            nodes.append(u)\n            _sum += D[u]\n            for v in G[u]:\n                if seen[v]:\n                    continue\n                seen[v] = 1\n                _t.append(v)\n        E = _sum // 2\n        B = None\n        if E == len(nodes):\n            for u in nodes:\n                for v in G[u]:\n                    if u < v and v in nodes:\n                        B = (u, v)\n                        break\n                if B:\n                    break\n        cp.append((2 * E / len(nodes), len(nodes), E, nodes, B))\n    cp.sort(key=lambda x: (-x[0], -x[1]))\n    ret = [0] * n\n    high = n\n    for _, c, E, nodes, B in cp:\n        low = high - c - 1\n        high -= c\n        arr = list(range(low, low + c))\n        L = {u: len(G[u]) - (1 if B and (u == B[0] and B[1] in G[u] or (u == B[1] and B[0] in G[u])) else 0) for u in nodes}\n        t = 0\n        q = deque((u for u in nodes if L[u] <= 1))\n        while q:\n            u = q.popleft()\n            if ret[u]:\n                continue\n            ret[u] = arr[t]\n            t += 1\n            for v in G[u]:\n                if B:\n                    if u == B[0] and v == B[1] or (u == B[1] and v == B[0]):\n                        continue\n                L[v] -= 1\n                if L[v] == 1:\n                    q.append(v)\n    ans = 0\n    for u, v in edges:\n        ans += ret[u] * ret[v]\n    return ans",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 6,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest449_q3845_s2",
  "question_id": 3845,
  "function_name": "maxScore",
  "code": "def maxScore(n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = [False] * n\n        components = []\n        for i in range(n):\n            if not visited[i]:\n                comp = []\n                dq = deque([i])\n                visited[i] = True\n                while dq:\n                    cur = dq.popleft()\n                    comp.append(cur)\n                    for nb in graph[cur]:\n                        if not visited[nb]:\n                            visited[nb] = True\n                            dq.append(nb)\n                components.append(comp)\n        comp_infos = []\n        def optimal_path_order(k: int) -> List[int]:\n            arr = list(range(1, k + 1))\n            res = [None] * k\n            mid = k // 2\n            res[mid] = arr.pop()\n            left_ptr = mid - 1\n            right_ptr = mid + 1\n            flag = True\n            while arr:\n                val = arr.pop()\n                if flag:\n                    if left_ptr >= 0:\n                        res[left_ptr] = val\n                        left_ptr -= 1\n                    else:\n                        res[right_ptr] = val\n                        right_ptr += 1\n                else:\n                    if right_ptr < k:\n                        res[right_ptr] = val\n                        right_ptr += 1\n                    else:\n                        res[left_ptr] = val\n                        left_ptr -= 1\n                flag = not flag\n            return res\n\n        def optimal_cycle_order(k: int) -> List[int]:\n            arr = list(range(1, k + 1))\n            left = arr[::2]\n            right = arr[1::2][::-1]\n            return left + right\n\n        for comp in components:\n            if len(comp) == 1:\n                continue\n            comp_set = set(comp)\n            comp_deg = {}\n            for u in comp:\n                d = sum(1 for nb in graph[u] if nb in comp_set)\n                comp_deg[u] = d\n            total_edges = sum(comp_deg.values()) // 2\n            k = len(comp)\n            isCycle = (k >= 3 and all(deg == 2 for deg in comp_deg.values()))\n            if isCycle:\n                order = optimal_cycle_order(k)\n                m_edges = k\n            else:\n                order = optimal_path_order(k)\n                m_edges = k - 1\n            base_score = 0\n            base_adj_sum = 0\n            if isCycle:\n                for i in range(k):\n                    j = (i + 1) % k\n                    base_score += order[i] * order[j]\n                    base_adj_sum += order[i] + order[j]\n            else:\n                for i in range(k - 1):\n                    base_score += order[i] * order[i + 1]\n                    base_adj_sum += order[i] + order[i + 1]\n            comp_infos.append((k, base_score, base_adj_sum, m_edges))\n        S = sum(info[0] for info in comp_infos)\n        if S == 0:\n            return 0\n        base_shift = n - S\n        def cmp(a, b):\n            k1, bs1, adj1, m1 = a\n            k2, bs2, adj2, m2 = b\n            diff = (adj2 * k1 - adj1 * k2) + (m2 * (k1**2) - m1 * (k2**2)) + 2 * base_shift * (m2 * k1 - m1 * k2)\n            if diff > 0:\n                return -1\n            elif diff < 0:\n                return 1\n            else:\n                return 0\n        comp_infos.sort(key=cmp_to_key(cmp))\n        total_score = 0\n        cum = 0\n        for (k, base_score, base_adj_sum, m_edges) in comp_infos:\n            d = base_shift + cum\n            total_score += base_score + d * base_adj_sum + m_edges * d * d\n            cum += k\n        return total_score",
  "input": "maxScore(n=4, edges=[[0,1],[1,2],[2,3]])",
  "output": "23",
  "correct_condition": "maxScore(n=4, edges=[[0,1],[1,2],[2,3]]) == 23",
  "contest_id": "weekly-contest-449",
  "contest_date": "2025-05-11T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 105,
    "coverage": null
  },
  "submission_id": 1630597722,
  "mutated_code": "def maxScore(n: int, edges: List[List[int]]) -> int:\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [False] * n\n    components = []\n    for i in range(n):\n        if not visited[i]:\n            comp = []\n            dq = deque([i])\n            visited[i] = True\n            while dq:\n                cur = dq.popleft()\n                comp.append(cur)\n                for nb in graph[cur]:\n                    if not visited[nb]:\n                        visited[nb] = True\n                        dq.append(nb)\n            components.append(comp)\n    comp_infos = []\n\n    def optimal_path_order(k: int) -> List[int]:\n        arr = list(range(1, k + 1))\n        res = [None] * k\n        mid = k // 2\n        res[mid] = arr.pop()\n        left_ptr = mid - 1\n        right_ptr = mid + 1\n        flag = True\n        while arr:\n            val = arr.pop()\n            if flag:\n                if left_ptr >= 0:\n                    res[left_ptr] = val\n                    left_ptr -= 1\n                else:\n                    res[right_ptr] = val\n                    right_ptr += 1\n            elif right_ptr < k:\n                res[right_ptr] = val\n                right_ptr += 1\n            else:\n                res[left_ptr] = val\n                left_ptr -= 1\n            flag = not flag\n        return res\n\n    def optimal_cycle_order(k: int) -> List[int]:\n        arr = list(range(1, k + 1))\n        left = arr[::2]\n        right = arr[1::2][::-1]\n        return left + right\n    for comp in components:\n        if len(comp) == 1:\n            continue\n        comp_set = set(comp)\n        comp_deg = {}\n        for u in comp:\n            d = sum((1 for nb in graph[u] if nb in comp_set))\n            comp_deg[u] = d\n        total_edges = sum(comp_deg.values()) // 2\n        k = len(comp)\n        isCycle = k >= 3 and all((deg == 2 for deg in comp_deg.values()))\n        if isCycle:\n            order = optimal_cycle_order(k)\n            m_edges = k\n        else:\n            order = optimal_path_order(k)\n            m_edges = k - 1\n        base_score = 0\n        base_adj_sum = 0\n        if isCycle:\n            for i in range(k):\n                j = (i + 1) % k\n                base_score += order[i] * order[j]\n                base_adj_sum += order[i] + order[j]\n        else:\n            for i in range(k - 1):\n                base_score += order[i] // order[i + 1]\n                base_adj_sum += order[i] + order[i + 1]\n        comp_infos.append((k, base_score, base_adj_sum, m_edges))\n    S = sum((info[0] for info in comp_infos))\n    if S == 0:\n        return 0\n    base_shift = n - S\n\n    def cmp(a, b):\n        k1, bs1, adj1, m1 = a\n        k2, bs2, adj2, m2 = b\n        diff = adj2 * k1 - adj1 * k2 + (m2 * k1 ** 2 - m1 * k2 ** 2) + 2 * base_shift * (m2 * k1 - m1 * k2)\n        if diff > 0:\n            return -1\n        elif diff < 0:\n            return 1\n        else:\n            return 0\n    comp_infos.sort(key=cmp_to_key(cmp))\n    total_score = 0\n    cum = 0\n    for k, base_score, base_adj_sum, m_edges in comp_infos:\n        d = base_shift + cum\n        total_score += base_score + d * base_adj_sum + m_edges * d * d\n        cum += k\n    return total_score",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 15,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest449_q3850_s1",
  "question_id": 3850,
  "function_name": "canPartitionGrid",
  "code": "def canPartitionGrid(grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        r = [sum(rw) for rw in grid]\n        c = [sum(col) for col in zip(*grid)]\n\n        _sum = sum(r)\n\n        top = Counter()\n        bottom = Counter(x for rw in grid for x in rw)\n\n        st = 0\n        for k in range(1, m):\n            st += r[k - 1]\n            sb = _sum - st\n            for v in grid[k - 1]:\n                bottom[v] -= 1\n                if bottom[v] == 0:\n                    del bottom[v]\n                top[v] += 1\n\n            if st == sb:\n                return True\n\n            d = st - sb\n            D = abs(d)\n\n            count = top if d > 0 else bottom\n            if d > 0:\n                r0, c0, h, w = 0, 0, k, n\n            else:\n                r0, c0, h, w = k, 0, m - k, n\n\n            if (D in count\n                    and (\n                            (h > 1 and w > 1)\n                            or (h == 1 and D in (grid[r0][c0], grid[r0][c0 + w - 1]))\n                            or (w == 1 and D in (grid[r0][c0], grid[r0 + h - 1][c0]))\n                    )):\n                return True\n\n        L = Counter()\n        R = Counter(x for _ in grid for x in _)\n\n        win = 0\n        for l in range(1, n):\n            win += c[l - 1]\n\n            sr = _sum - win\n            for i in range(m):\n                v = grid[i][l - 1]\n                R[v] -= 1\n                if R[v] == 0:\n                    del R[v]\n                L[v] += 1\n\n            if win == sr:\n                return True\n\n            d = win - sr\n            D = abs(d)\n            # print(d, D)\n\n            count = L if d > 0 else R\n            # print(count)\n\n            if d > 0:\n                r0, c0, h, w = 0, 0, m, l\n            else:\n                r0, c0, h, w = 0, l, m, n - l\n\n            # print(r0, c0, h, w)\n\n            if D in count and (\n                    (h > 1 and w > 1) or\n                    (h == 1 and D in (grid[r0][c0], grid[r0][c0 + w - 1])) or\n                    (w == 1 and D in (grid[r0][c0], grid[r0 + h - 1][c0]))\n            ):\n                return True\n        return False\n",
  "input": "canPartitionGrid(grid=[[1,4],[2,3]])",
  "output": "True",
  "correct_condition": "canPartitionGrid(grid=[[1,4],[2,3]]) == True",
  "contest_id": "weekly-contest-449",
  "contest_date": "2025-05-11T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 79,
    "coverage": null
  },
  "submission_id": 1630621200,
  "mutated_code": "def canPartitionGrid(grid: List[List[int]]) -> bool:\n    m, n = (len(grid), len(grid[0]))\n    r = [sum(rw) for rw in grid]\n    c = [sum(col) for col in zip(*grid)]\n    _sum = sum(r)\n    top = Counter()\n    bottom = Counter((x for rw in grid for x in rw))\n    st = 0\n    for k in range(1, m):\n        st += r[k - 1]\n        sb = _sum - st\n        for v in grid[k - 1]:\n            bottom[v] -= 1\n            if bottom[v] == 0:\n                del bottom[v]\n            top[v] += 1\n        if st == sb:\n            return False\n        d = st - sb\n        D = abs(d)\n        count = top if d > 0 else bottom\n        if d > 0:\n            r0, c0, h, w = (0, 0, k, n)\n        else:\n            r0, c0, h, w = (k, 0, m - k, n)\n        if D in count and (h > 1 and w > 1 or (h == 1 and D in (grid[r0][c0], grid[r0][c0 + w - 1])) or (w == 1 and D in (grid[r0][c0], grid[r0 + h - 1][c0]))):\n            return True\n    L = Counter()\n    R = Counter((x for _ in grid for x in _))\n    win = 0\n    for l in range(1, n):\n        win += c[l - 1]\n        sr = _sum - win\n        for i in range(m):\n            v = grid[i][l - 1]\n            R[v] -= 1\n            if R[v] == 0:\n                del R[v]\n            L[v] += 1\n        if win == sr:\n            return True\n        d = win - sr\n        D = abs(d)\n        count = L if d > 0 else R\n        if d > 0:\n            r0, c0, h, w = (0, 0, m, l)\n        else:\n            r0, c0, h, w = (0, l, m, n - l)\n        if D in count and (h > 1 and w > 1 or (h == 1 and D in (grid[r0][c0], grid[r0][c0 + w - 1])) or (w == 1 and D in (grid[r0][c0], grid[r0 + h - 1][c0]))):\n            return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "keyword",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest449_q3850_s2",
  "question_id": 3850,
  "function_name": "canPartitionGrid",
  "code": "def canPartitionGrid(grid: List[List[int]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        total = sum(sum(row) for row in grid)\n        prefix = [0]*m\n        prefix[0] = sum(grid[0])\n        for i in range(1, m):\n            prefix[i] = prefix[i-1] + sum(grid[i])\n        col_sums = [0]*n\n        for j in range(n):\n            s = 0\n            for i in range(m):\n                s += grid[i][j]\n            col_sums[j] = s\n        vprefix = [0]*n\n        vprefix[0] = col_sums[0]\n        for j in range(1, n):\n            vprefix[j] = vprefix[j-1] + col_sums[j]\n        \n        value_map = {}\n        for i in range(m):\n            for j in range(n):\n                v = grid[i][j]\n                if v not in value_map:\n                    value_map[v] = {}\n                if i not in value_map[v]:\n                    value_map[v][i] = []\n                value_map[v][i].append(j)\n        for v in value_map:\n            for r in value_map[v]:\n                value_map[v][r].sort()\n        \n        def query_value_in_region(v, rlow, rhigh, clow, chigh):\n            if v not in value_map:\n                return False\n            for r in range(rlow, rhigh + 1):\n                if r in value_map[v]:\n                    lst = value_map[v][r]\n                    idx = bisect.bisect_left(lst, clow)\n                    if idx < len(lst) and lst[idx] <= chigh:\n                        return True\n            return False\n\n        def check_partition(rlow, rhigh, clow, chigh, diff):\n            rows = rhigh - rlow + 1\n            cols = chigh - clow + 1\n            if rows * cols == 1:\n                return False\n            if rows > 1 and cols > 1:\n                return query_value_in_region(diff, rlow, rhigh, clow, chigh)\n            else:\n                if rows == 1:\n                    if diff == grid[rlow][clow] or diff == grid[rlow][chigh]:\n                        return True\n                if cols == 1:\n                    if diff == grid[rlow][clow] or diff == grid[rhigh][clow]:\n                        return True\n            return False\n\n        for i in range(m - 1):\n            sum_top = prefix[i]\n            sum_bottom = total - sum_top\n            if sum_top == sum_bottom:\n                return True\n            if sum_top > sum_bottom:\n                diff = sum_top - sum_bottom\n                if check_partition(0, i, 0, n - 1, diff):\n                    return True\n            else:\n                diff = sum_bottom - sum_top\n                if check_partition(i + 1, m - 1, 0, n - 1, diff):\n                    return True\n\n        for j in range(n - 1):\n            sum_left = vprefix[j]\n            sum_right = total - sum_left\n            if sum_left == sum_right:\n                return True\n            if sum_left > sum_right:\n                diff = sum_left - sum_right\n                if check_partition(0, m - 1, 0, j, diff):\n                    return True\n            else:\n                diff = sum_right - sum_left\n                if check_partition(0, m - 1, j + 1, n - 1, diff):\n                    return True\n\n        return False",
  "input": "canPartitionGrid(grid=[[1,4],[2,3]])",
  "output": "True",
  "correct_condition": "canPartitionGrid(grid=[[1,4],[2,3]]) == True",
  "contest_id": "weekly-contest-449",
  "contest_date": "2025-05-11T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 88,
    "coverage": null
  },
  "submission_id": 1630614238,
  "mutated_code": "def canPartitionGrid(grid: List[List[int]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    total = sum((sum(row) for row in grid))\n    prefix = [0] * m\n    prefix[0] = sum(grid[0])\n    for i in range(1, m):\n        prefix[i] = prefix[i - 1] + sum(grid[i])\n    col_sums = [0] * n\n    for j in range(n):\n        s = 0\n        for i in range(m):\n            s += grid[i][j]\n        col_sums[j] = s\n    vprefix = [0] * n\n    vprefix[0] = col_sums[0]\n    for j in range(1, n):\n        vprefix[j] = vprefix[j - 1] + col_sums[j]\n    value_map = {}\n    for i in range(m):\n        for j in range(n):\n            v = grid[i][j]\n            if v not in value_map:\n                value_map[v] = {}\n            if i not in value_map[v]:\n                value_map[v][i] = []\n            value_map[v][i].append(j)\n    for v in value_map:\n        for r in value_map[v]:\n            value_map[v][r].sort()\n\n    def query_value_in_region(v, rlow, rhigh, clow, chigh):\n        if v not in value_map:\n            return False\n        for r in range(rlow, rhigh + 1):\n            if r in value_map[v]:\n                lst = value_map[v][r]\n                idx = bisect.bisect_left(lst, clow)\n                if idx < len(lst) and lst[idx] <= chigh:\n                    return True\n        return False\n\n    def check_partition(rlow, rhigh, clow, chigh, diff):\n        rows = rhigh - rlow + 1\n        cols = chigh - clow + 1\n        if rows * cols == 1:\n            return False\n        if rows > 1 and cols > 1:\n            return query_value_in_region(diff, rlow, rhigh, clow, chigh)\n        else:\n            if rows == 1:\n                if diff == grid[rlow][clow] or diff == grid[rlow][chigh]:\n                    return True\n            if cols == 1:\n                if diff == grid[rlow][clow] or diff == grid[rhigh][clow]:\n                    return True\n        return False\n    for i in range(m - 1):\n        sum_top = prefix[i]\n        sum_bottom = total - sum_top\n        if sum_top == sum_bottom:\n            return False\n        if sum_top > sum_bottom:\n            diff = sum_top - sum_bottom\n            if check_partition(0, i, 0, n - 1, diff):\n                return True\n        else:\n            diff = sum_bottom - sum_top\n            if check_partition(i + 1, m - 1, 0, n - 1, diff):\n                return True\n    for j in range(n - 1):\n        sum_left = vprefix[j]\n        sum_right = total - sum_left\n        if sum_left == sum_right:\n            return True\n        if sum_left > sum_right:\n            diff = sum_left - sum_right\n            if check_partition(0, m - 1, 0, j, diff):\n                return True\n        else:\n            diff = sum_right - sum_left\n            if check_partition(0, m - 1, j + 1, n - 1, diff):\n                return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "keyword",
    "mutation_id": 7,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest450_q3869_s1",
  "question_id": 3869,
  "function_name": "smallestIndex",
  "code": "def smallestIndex(a: List[int]) -> int:\n        for i, x in enumerate(a):\n            if sum(int(d) for d in str(x)) == i: return i\n        return -1\n",
  "input": "smallestIndex(a=[1,3,2])",
  "output": "2",
  "correct_condition": "smallestIndex(a=[1,3,2]) == 2",
  "contest_id": "weekly-contest-450",
  "contest_date": "2025-05-18T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 4,
    "coverage": null
  },
  "submission_id": 1636851239,
  "mutated_code": "def smallestIndex(a: List[int]) -> int:\n    for i, x in enumerate(a):\n        if sum((int(d) for d in str(x))) != i:\n            return i\n    return -1",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest450_q3869_s2",
  "question_id": 3869,
  "function_name": "smallestIndex",
  "code": "def smallestIndex(nums: List[int]) -> int:\n        for i, num in enumerate(nums):\n            if sum(int(d) for d in str(abs(num))) == i:\n                return i\n        return -1",
  "input": "smallestIndex(nums=[1,3,2])",
  "output": "2",
  "correct_condition": "smallestIndex(nums=[1,3,2]) == 2",
  "contest_id": "weekly-contest-450",
  "contest_date": "2025-05-18T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 5,
    "coverage": null
  },
  "submission_id": 1636853379,
  "mutated_code": "def smallestIndex(nums: List[int]) -> int:\n    for i, num in enumerate(nums):\n        if sum((int(d) for d in str(abs(num)))) != i:\n            return i\n    return -1",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest450_q3847_s1",
  "question_id": 3847,
  "function_name": "minSwaps",
  "code": "def minSwaps(A: List[int]) -> int:\n        s = lambda x: sum(int(d) for d in str(x))\n        B = sorted(A, key = lambda x: (s(x), x))\n        M = {v: i for i, v in enumerate(B)}\n        V, c = [0] * len(A), 0\n        for i in range(len(A)):\n            if V[i] or M[A[i]] == i: continue\n            j, l = i, 0\n            while not V[j]: V[j] = 1; j = M[A[j]]; l += 1\n            c += l - 1\n        return c\n",
  "input": "minSwaps(A=[37,100])",
  "output": "1",
  "correct_condition": "minSwaps(A=[37,100]) == 1",
  "contest_id": "weekly-contest-450",
  "contest_date": "2025-05-18T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 11,
    "coverage": null
  },
  "submission_id": 1636860563,
  "mutated_code": "def minSwaps(A: List[int]) -> int:\n    s = lambda x: sum((int(d) for d in str(x)))\n    B = sorted(A, key=lambda x: (s(x), x))\n    M = {v: i for i, v in enumerate(B)}\n    V, c = ([0] * len(A), 0)\n    for i in range(len(A)):\n        if V[i] or M[A[i]] == i:\n            continue\n        j, l = (i, 0)\n        while not V[j]:\n            V[j] = 1\n            j = M[A[j]]\n            l += 1\n        c += l + 1\n    return c",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest450_q3847_s2",
  "question_id": 3847,
  "function_name": "minSwaps",
  "code": "def minSwaps(nums: List[int]) -> int:\n        def digit_sum(x):\n            s = 0\n            while x:\n                s += x % 10\n                x //= 10\n            return s\n\n        sorted_nums = sorted(nums, key=lambda x: (digit_sum(x), x))\n        \n        pos = {val: i for i, val in enumerate(sorted_nums)}\n        perm = [pos[val] for val in nums]\n\n        n = len(nums)\n        visited = [False] * n\n        ret = 0\n\n        for i in range(n):\n            if visited[i] or perm[i] == i:\n                continue\n            cycle_size = 0\n            j = i\n            while not visited[j]:\n                visited[j] = True\n                j = perm[j]\n                cycle_size += 1\n            ret += cycle_size - 1\n\n        return ret",
  "input": "minSwaps(nums=[37,100])",
  "output": "1",
  "correct_condition": "minSwaps(nums=[37,100]) == 1",
  "contest_id": "weekly-contest-450",
  "contest_date": "2025-05-18T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 29,
    "coverage": null
  },
  "submission_id": 1636857131,
  "mutated_code": "def minSwaps(nums: List[int]) -> int:\n\n    def digit_sum(x):\n        s = 0\n        while x:\n            s += x // 10\n            x //= 10\n        return s\n    sorted_nums = sorted(nums, key=lambda x: (digit_sum(x), x))\n    pos = {val: i for i, val in enumerate(sorted_nums)}\n    perm = [pos[val] for val in nums]\n    n = len(nums)\n    visited = [False] * n\n    ret = 0\n    for i in range(n):\n        if visited[i] or perm[i] == i:\n            continue\n        cycle_size = 0\n        j = i\n        while not visited[j]:\n            visited[j] = True\n            j = perm[j]\n            cycle_size += 1\n        ret += cycle_size - 1\n    return ret",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest450_q3837_s1",
  "question_id": 3837,
  "function_name": "minMoves",
  "code": "def minMoves(M: List[str]) -> int:\n        m, n, P = len(M), len(M[0]), defaultdict(list)\n        for i in range(m):\n            for j in range(n):\n                c = M[i][j]\n                if 'A' <= c <= 'Z': P[c].append((i, j))\n        D = [[1e9]*n for _ in range(m)]\n        D[0][0], Q, U = 0, deque([(0, 0)]), set()\n        while Q:\n            x, y = Q.popleft()\n            if (x, y) == (m-1, n-1): return D[x][y]\n            c = M[x][y]\n            if 'A' <= c <= 'Z' and c not in U:\n                for a, b in P[c]:\n                    if D[a][b] > D[x][y]: D[a][b] = D[x][y]; Q.appendleft((a, b))\n                U.add(c)\n            for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\n                a, b = x+dx, y+dy\n                if 0<=a<m and 0<=b<n and M[a][b] != '#' and D[a][b] > D[x][y]+1: D[a][b] = D[x][y]+1; Q.append((a, b))\n        return -1\n",
  "input": "minMoves(M=[\"A..\",\".A.\",\"...\"])",
  "output": "2",
  "correct_condition": "minMoves(M=[\"A..\",\".A.\",\"...\"]) == 2",
  "contest_id": "weekly-contest-450",
  "contest_date": "2025-05-18T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 20,
    "coverage": null
  },
  "submission_id": 1636869616,
  "mutated_code": "def minMoves(M: List[str]) -> int:\n    m, n, P = (len(M), len(M[0]), defaultdict(list))\n    for i in range(m):\n        for j in range(n):\n            c = M[i][j]\n            if 'A' <= c <= 'Z':\n                P[c].append((i, j))\n    D = [[1000000000.0] * n for _ in range(m)]\n    D[0][0], Q, U = (0, deque([(0, 0)]), set())\n    while Q:\n        x, y = Q.popleft()\n        if (x, y) == (m + 1, n - 1):\n            return D[x][y]\n        c = M[x][y]\n        if 'A' <= c <= 'Z' and c not in U:\n            for a, b in P[c]:\n                if D[a][b] > D[x][y]:\n                    D[a][b] = D[x][y]\n                    Q.appendleft((a, b))\n            U.add(c)\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            a, b = (x + dx, y + dy)\n            if 0 <= a < m and 0 <= b < n and (M[a][b] != '#') and (D[a][b] > D[x][y] + 1):\n                D[a][b] = D[x][y] + 1\n                Q.append((a, b))\n    return -1",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest450_q3837_s2",
  "question_id": 3837,
  "function_name": "minMoves",
  "code": "def minMoves(matrix: List[str]) -> int:\n        m, n = len(matrix), len(matrix[0])\n\n        portals = defaultdict(list)\n        for i in range(m):\n            for j in range(n):\n                c = matrix[i][j]\n                if 'A' <= c <= 'Z':\n                    portals[c].append((i, j))\n\n        INF = float('inf')\n        dist = [[INF]*n for _ in range(m)]\n        if matrix[0][0] == '#':\n            return -1\n        dist[0][0] = 0\n\n        dq = deque([(0, 0)])\n        used_portal = set()\n\n\n        while dq:\n            i, j = dq.popleft()\n            d = dist[i][j]\n\n            if i == m-1 and j == n-1:\n                return d\n\n\n            c = matrix[i][j]\n            if 'A' <= c <= 'Z' and c not in used_portal:\n                used_portal.add(c)\n                for ti, tj in portals[c]:\n                    if dist[ti][tj] > d:\n                        dist[ti][tj] = d\n                        dq.appendleft((ti, tj))\n\n            for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] != '#' and dist[ni][nj] > d+1:\n                    dist[ni][nj] = d+1\n                    dq.append((ni, nj))\n\n        return -1\n",
  "input": "minMoves(matrix=[\"A..\",\".A.\",\"...\"])",
  "output": "2",
  "correct_condition": "minMoves(matrix=[\"A..\",\".A.\",\"...\"]) == 2",
  "contest_id": "weekly-contest-450",
  "contest_date": "2025-05-18T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 43,
    "coverage": null
  },
  "submission_id": 1636866823,
  "mutated_code": "def minMoves(matrix: List[str]) -> int:\n    m, n = (len(matrix), len(matrix[0]))\n    portals = defaultdict(list)\n    for i in range(m):\n        for j in range(n):\n            c = matrix[i][j]\n            if 'A' <= c <= 'Z':\n                portals[c].append((i, j))\n    INF = float('inf')\n    dist = [[INF] * n for _ in range(m)]\n    if matrix[0][0] == '#':\n        return -1\n    dist[0][0] = 0\n    dq = deque([(0, 0)])\n    used_portal = set()\n    while dq:\n        i, j = dq.popleft()\n        d = dist[i][j]\n        if i == m + 1 and j == n - 1:\n            return d\n        c = matrix[i][j]\n        if 'A' <= c <= 'Z' and c not in used_portal:\n            used_portal.add(c)\n            for ti, tj in portals[c]:\n                if dist[ti][tj] > d:\n                    dist[ti][tj] = d\n                    dq.appendleft((ti, tj))\n        for di, dj in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            ni, nj = (i + di, j + dj)\n            if 0 <= ni < m and 0 <= nj < n and (matrix[ni][nj] != '#') and (dist[ni][nj] > d + 1):\n                dist[ni][nj] = d + 1\n                dq.append((ni, nj))\n    return -1",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest450_q3853_s1",
  "question_id": 3853,
  "function_name": "minimumWeight",
  "code": "def minimumWeight(edges, queries):\n        n = len(edges) + 1\n        adj = [[] for _ in range(n)]\n        for u, v, w in edges: adj[u].append((v, w)); adj[v].append((u, w))\n        \n        sys.setrecursionlimit(n + 5000); K = n.bit_length()\n        depth, dist, up = [-1] * n, [-1] * n, [[0] * K for _ in range(n)]\n        \n        def dfs(u, p, dep, dsum):\n            depth[u], dist[u], up[u][0] = dep, dsum, p\n            for v, w in adj[u]:\n                if v != p: dfs(v, u, dep + 1, dsum + w)    \n        dfs(0, 0, 0, 0)\n        for k in range(1, K):\n            for i in range(n): up[i][k] = up[up[i][k-1]][k-1]\n        def get_lca(u, v):\n            if depth[u] < depth[v]: u, v = v, u\n            for k in range(K-1, -1, -1):\n                if depth[u] - (1 << k) >= depth[v]: u = up[u][k]\n            if u == v: return u\n            for k in range(K-1, -1, -1):\n                if up[u][k] != up[v][k]: u, v = up[u][k], up[v][k]\n            return up[u][0]\n        \n        def get_dist(u, v): return dist[u] + dist[v] - 2 * dist[get_lca(u, v)]\n        \n        return [(get_dist(x, y) + get_dist(x, z) + get_dist(y, z)) // 2 for x, y, z in queries]",
  "input": "minimumWeight(edges=[[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], queries=[[2,3,4],[0,2,5]])",
  "output": "[12, 11]",
  "correct_condition": "minimumWeight(edges=[[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], queries=[[2,3,4],[0,2,5]]) == [12, 11]",
  "contest_id": "weekly-contest-450",
  "contest_date": "2025-05-18T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 27,
    "coverage": null
  },
  "submission_id": 1636875750,
  "mutated_code": "def minimumWeight(edges, queries):\n    n = len(edges) + 1\n    adj = [[] for _ in range(n)]\n    for u, v, w in edges:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    sys.setrecursionlimit(n + 5000)\n    K = n.bit_length()\n    depth, dist, up = ([-1] * n, [-1] * n, [[0] * K for _ in range(n)])\n\n    def dfs(u, p, dep, dsum):\n        depth[u], dist[u], up[u][0] = (dep, dsum, p)\n        for v, w in adj[u]:\n            if v != p:\n                dfs(v, u, dep - 1, dsum + w)\n    dfs(0, 0, 0, 0)\n    for k in range(1, K):\n        for i in range(n):\n            up[i][k] = up[up[i][k - 1]][k - 1]\n\n    def get_lca(u, v):\n        if depth[u] < depth[v]:\n            u, v = (v, u)\n        for k in range(K - 1, -1, -1):\n            if depth[u] - (1 << k) >= depth[v]:\n                u = up[u][k]\n        if u == v:\n            return u\n        for k in range(K - 1, -1, -1):\n            if up[u][k] != up[v][k]:\n                u, v = (up[u][k], up[v][k])\n        return up[u][0]\n\n    def get_dist(u, v):\n        return dist[u] + dist[v] - 2 * dist[get_lca(u, v)]\n    return [(get_dist(x, y) + get_dist(x, z) + get_dist(y, z)) // 2 for x, y, z in queries]",
  "mutated_output": "[12, 16]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 5,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest450_q3853_s2",
  "question_id": 3853,
  "function_name": "minimumWeight",
  "code": "def minimumWeight(edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n        n = max(max(u, v) for u, v, _ in edges) + 1\n        adj = [[] for _ in range(n)]\n    \n        for u, v, w in edges:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n            \n        LOG = (n-1).bit_length() + 1\n        parent = [[-1]*n for _ in range(LOG)]\n        depth = [0]*n\n        dist_root = [0]*n\n        \n        stack = [(0, -1)]\n        \n        while stack:\n            u, p = stack.pop()\n            parent[0][u] = p\n            for v, w in adj[u]:\n                if v == p:\n                    continue\n                depth[v] = depth[u] + 1\n                dist_root[v] = dist_root[u] + w\n                stack.append((v, u))\n                \n        for k in range(1, LOG):\n            for v in range(n):\n                pp = parent[k-1][v]\n                parent[k][v] = -1 if pp < 0 else parent[k-1][pp]      \n        \n        def lca(u, v):\n            if depth[u] < depth[v]:\n                u, v = v, u\n            diff = depth[u] - depth[v]\n            \n            for k in range(LOG):\n                if diff >> k & 1:\n                    u = parent[k][u]\n            if u == v:\n                return u\n\n            for k in reversed(range(LOG)):\n                if parent[k][u] != parent[k][v]:\n                    u = parent[k][u]\n                    v = parent[k][v]\n            return parent[0][u]\n        \n        def dist(u, v):\n            w = lca(u, v)\n            return dist_root[u] + dist_root[v] - 2*dist_root[w]\n\n        ret = []\n        \n        for s1, s2, d in queries:\n            d12 = dist(s1, s2)\n            d1d = dist(s1, d)\n            d2d = dist(s2, d)\n            ret.append((d12 + d1d + d2d) // 2)\n        return ret\n\n",
  "input": "minimumWeight(edges=[[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], queries=[[2,3,4],[0,2,5]])",
  "output": "[12, 11]",
  "correct_condition": "minimumWeight(edges=[[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], queries=[[2,3,4],[0,2,5]]) == [12, 11]",
  "contest_id": "weekly-contest-450",
  "contest_date": "2025-05-18T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 60,
    "coverage": null
  },
  "submission_id": 1636875390,
  "mutated_code": "def minimumWeight(edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n    n = max((max(u, v) for u, v, _ in edges)) + 1\n    adj = [[] for _ in range(n)]\n    for u, v, w in edges:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    LOG = (n - 1).bit_length() + 1\n    parent = [[-1] * n for _ in range(LOG)]\n    depth = [0] * n\n    dist_root = [0] * n\n    stack = [(0, -1)]\n    while stack:\n        u, p = stack.pop()\n        parent[0][u] = p\n        for v, w in adj[u]:\n            if v == p:\n                continue\n            depth[v] = depth[u] - 1\n            dist_root[v] = dist_root[u] + w\n            stack.append((v, u))\n    for k in range(1, LOG):\n        for v in range(n):\n            pp = parent[k - 1][v]\n            parent[k][v] = -1 if pp < 0 else parent[k - 1][pp]\n\n    def lca(u, v):\n        if depth[u] < depth[v]:\n            u, v = (v, u)\n        diff = depth[u] - depth[v]\n        for k in range(LOG):\n            if diff >> k & 1:\n                u = parent[k][u]\n        if u == v:\n            return u\n        for k in reversed(range(LOG)):\n            if parent[k][u] != parent[k][v]:\n                u = parent[k][u]\n                v = parent[k][v]\n        return parent[0][u]\n\n    def dist(u, v):\n        w = lca(u, v)\n        return dist_root[u] + dist_root[v] - 2 * dist_root[w]\n    ret = []\n    for s1, s2, d in queries:\n        d12 = dist(s1, s2)\n        d1d = dist(s1, d)\n        d2d = dist(s2, d)\n        ret.append((d12 + d1d + d2d) // 2)\n    return ret",
  "mutated_output": "[12, 1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 6,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest451_q3879_s0",
  "question_id": 3879,
  "function_name": "minCuttingCost",
  "code": "def minCuttingCost(n: int, m: int, k: int) -> int:\n    return (n - k) * k * (n > k) + (m - k) * k * (m > k)\n",
  "input": "minCuttingCost(n=6, m=5, k=5)",
  "output": "5",
  "correct_condition": "minCuttingCost(n=6, m=5, k=5) == 5",
  "contest_id": "weekly-contest-451",
  "contest_date": "2025-05-25T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 2,
    "coverage": null
  },
  "submission_id": 1643574218,
  "mutated_code": "def minCuttingCost(n: int, m: int, k: int) -> int:\n    return (n - k) // k * (n > k) + (m - k) * k * (m > k)",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest451_q3879_s2",
  "question_id": 3879,
  "function_name": "minCuttingCost",
  "code": "def minCuttingCost(n: int, m: int, k: int) -> int:\n        if n <= k and m <= k:\n            return 0\n        L = max(n, m)\n        return k * (L - k)",
  "input": "minCuttingCost(n=6, m=5, k=5)",
  "output": "5",
  "correct_condition": "minCuttingCost(n=6, m=5, k=5) == 5",
  "contest_id": "weekly-contest-451",
  "contest_date": "2025-05-25T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 5,
    "coverage": null
  },
  "submission_id": 1643562222,
  "mutated_code": "def minCuttingCost(n: int, m: int, k: int) -> int:\n    if n <= k and m <= k:\n        return 0\n    L = max(n, m)\n    return k * (L + k)",
  "mutated_output": "55",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest451_q3860_s0",
  "question_id": 3860,
  "function_name": "resultingString",
  "code": "def resultingString(s: str) -> str:\n    r = []\n    for c in s:\n      if r and (abs(ord(c) - ord(r[-1])) == 1 or abs(ord(c) - ord(r[-1])) == 25): r.pop()\n      else: r.append(c)\n    return \"\".join(r)",
  "input": "resultingString(s=\"abc\")",
  "output": "'c'",
  "correct_condition": "resultingString(s=\"abc\") == 'c'",
  "contest_id": "weekly-contest-451",
  "contest_date": "2025-05-25T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 6,
    "coverage": null
  },
  "submission_id": 1643564642,
  "mutated_code": "def resultingString(s: str) -> str:\n    r = []\n    for c in s:\n        if r and (abs(ord(c) + ord(r[-1])) == 1 or abs(ord(c) - ord(r[-1])) == 25):\n            r.pop()\n        else:\n            r.append(c)\n    return ''.join(r)",
  "mutated_output": "'abc'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest451_q3860_s2",
  "question_id": 3860,
  "function_name": "resultingString",
  "code": "def resultingString(s: str) -> str:\n        def fn(a, b):\n            d = abs(ord(a) - ord(b))\n            return d == 1 or d == 25\n\n        st = []\n        for c in s:\n            if st and fn(st[-1], c):\n                st.pop()\n            else:\n                st.append(c)\n        return \"\".join(st)",
  "input": "resultingString(s=\"abc\")",
  "output": "'c'",
  "correct_condition": "resultingString(s=\"abc\") == 'c'",
  "contest_id": "weekly-contest-451",
  "contest_date": "2025-05-25T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 12,
    "coverage": null
  },
  "submission_id": 1643570457,
  "mutated_code": "def resultingString(s: str) -> str:\n\n    def fn(a, b):\n        d = abs(ord(a) + ord(b))\n        return d == 1 or d == 25\n    st = []\n    for c in s:\n        if st and fn(st[-1], c):\n            st.pop()\n        else:\n            st.append(c)\n    return ''.join(st)",
  "mutated_output": "'abc'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest451_q3854_s0",
  "question_id": 3854,
  "function_name": "maxProfit",
  "code": "def maxProfit(n: int, p: List[int], f: List[int], h: List[List[int]], b: int) -> int:\n        z = (n, p, f, h, b)\n        a = collections.defaultdict(list)\n        [a[u].append(v) for u, v in h]\n        m, o, s = {}, {}, [1]\n        while s:\n            u = s[-1]\n            if u in m: s.pop(); continue\n            if u not in o:\n                o[u] = 1\n                s += a[u]\n                continue\n            s.pop()\n            cb = cn = [0] + [-1e9]*b\n            for v in a[u]:\n                vb, vn = m[v]\n                nb = [-1e9]*(b+1)\n                for x in range(b+1):\n                    if cb[x] > -1e9:\n                        for y in range(b - x + 1):\n                            if vb[y] > -1e9:\n                                nb[x + y] = max(nb[x + y], cb[x] + vb[y])\n                cb = nb\n                nn = [-1e9]*(b+1)\n                for x in range(b+1):\n                    if cn[x] > -1e9:\n                        for y in range(b - x + 1):\n                            if vn[y] > -1e9: nn[x + y] = max(nn[x + y], cn[x] + vn[y])\n                cn = nn\n            f0 = cn[:]; f1 = cn[:]\n            c, pr = p[u - 1], f[u - 1]\n            if c <= b:\n                for x in range(b - c + 1):\n                    if cb[x] > -1e9: f1[x + c] = max(f1[x + c], cb[x] + pr - c)\n            c //= 2\n            if c <= b:\n                for x in range(b - c + 1):\n                    if cb[x] > -1e9: f0[x + c] = max(f0[x + c], cb[x] + pr - c)\n            m[u] = (f0, f1)\n        return max(max(m[1][1]), 0)\n",
  "input": "maxProfit(n=2, p=[1,2], f=[4,3], h=[[1,2]], b=3)",
  "output": "5",
  "correct_condition": "maxProfit(n=2, p=[1,2], f=[4,3], h=[[1,2]], b=3) == 5",
  "contest_id": "weekly-contest-451",
  "contest_date": "2025-05-25T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 40,
    "coverage": null
  },
  "submission_id": 1643590961,
  "mutated_code": "def maxProfit(n: int, p: List[int], f: List[int], h: List[List[int]], b: int) -> int:\n    z = (n, p, f, h, b)\n    a = collections.defaultdict(list)\n    [a[u].append(v) for u, v in h]\n    m, o, s = ({}, {}, [1])\n    while s:\n        u = s[-1]\n        if u in m:\n            s.pop()\n            continue\n        if u not in o:\n            o[u] = 1\n            s += a[u]\n            continue\n        s.pop()\n        cb = cn = [0] + [-1000000000.0] * b\n        for v in a[u]:\n            vb, vn = m[v]\n            nb = [-1000000000.0] * (b + 1)\n            for x in range(b + 1):\n                if cb[x] > -1000000000.0:\n                    for y in range(b - x + 1):\n                        if vb[y] > -1000000000.0:\n                            nb[x - y] = max(nb[x + y], cb[x] + vb[y])\n            cb = nb\n            nn = [-1000000000.0] * (b + 1)\n            for x in range(b + 1):\n                if cn[x] > -1000000000.0:\n                    for y in range(b - x + 1):\n                        if vn[y] > -1000000000.0:\n                            nn[x + y] = max(nn[x + y], cn[x] + vn[y])\n            cn = nn\n        f0 = cn[:]\n        f1 = cn[:]\n        c, pr = (p[u - 1], f[u - 1])\n        if c <= b:\n            for x in range(b - c + 1):\n                if cb[x] > -1000000000.0:\n                    f1[x + c] = max(f1[x + c], cb[x] + pr - c)\n        c //= 2\n        if c <= b:\n            for x in range(b - c + 1):\n                if cb[x] > -1000000000.0:\n                    f0[x + c] = max(f0[x + c], cb[x] + pr - c)\n        m[u] = (f0, f1)\n    return max(max(m[1][1]), 0)",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 7,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest451_q3854_s2",
  "question_id": 3854,
  "function_name": "maxProfit",
  "code": "def maxProfit(n: int, p: List[int], f: List[int], hierarchy: List[List[int]], budget: int) -> int:\n        ch = [[] for _ in range(n + 1)]\n        for u, v in hierarchy:\n            ch[u].append(v)\n        MIN = -10**9\n        def merge(dp_list):\n            f = [0] + [MIN] * budget\n            for dp in dp_list:\n                nf = [MIN] * (budget + 1)\n                for spent in range(budget + 1):\n                    if f[spent] < 0:\n                        continue\n                    for b in range(budget - spent + 1):\n                        if dp[b] < 0:\n                            continue\n                        c = f[spent] + dp[b]\n                        if c > nf[spent + b]:\n                            nf[spent + b] = c\n                f = nf\n            return f\n        def dfs(u):\n            dp0 = []\n            dp1 = []\n            for v in ch[u]:\n                d0, d1 = dfs(v)\n                dp0.append(d0)\n                dp1.append(d1)\n            comb0 = merge(dp0) if dp0 else [0] + [MIN] * budget\n            comb1 = merge(dp1) if dp1 else [0] + [MIN] * budget\n            dp0u = [MIN] * (budget + 1)\n            dp1u = [MIN] * (budget + 1)\n            for b in range(budget + 1):\n                dp1u[b] = comb0[b]\n            cost = p[u - 1] >> 1\n            prof = f[u - 1] - cost\n            for b in range(cost, budget + 1):\n                if comb1[b - cost] < 0:\n                    continue\n                c = prof + comb1[b - cost]\n                if c > dp1u[b]:\n                    dp1u[b] = c\n            for b in range(budget + 1):\n                dp0u[b] = comb0[b]\n            costf = p[u - 1]\n            proff = f[u - 1] - costf\n            for b in range(costf, budget + 1):\n                if comb1[b - costf] < 0:\n                    continue\n                c = proff + comb1[b - costf]\n                if c > dp0u[b]:\n                    dp0u[b] = c\n            return dp0u, dp1u\n        dp0_root, _ = dfs(1)\n        return max(dp0_root)",
  "input": "maxProfit(n=2, p=[1,2], f=[4,3], hierarchy=[[1,2]], budget=3)",
  "output": "5",
  "correct_condition": "maxProfit(n=2, p=[1,2], f=[4,3], hierarchy=[[1,2]], budget=3) == 5",
  "contest_id": "weekly-contest-451",
  "contest_date": "2025-05-25T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 54,
    "coverage": null
  },
  "submission_id": 1643586884,
  "mutated_code": "def maxProfit(n: int, p: List[int], f: List[int], hierarchy: List[List[int]], budget: int) -> int:\n    ch = [[] for _ in range(n + 1)]\n    for u, v in hierarchy:\n        ch[u].append(v)\n    MIN = -10 ** 9\n\n    def merge(dp_list):\n        f = [0] + [MIN] * budget\n        for dp in dp_list:\n            nf = [MIN] * (budget + 1)\n            for spent in range(budget + 1):\n                if f[spent] < 0:\n                    continue\n                for b in range(budget - spent + 1):\n                    if dp[b] < 0:\n                        continue\n                    c = f[spent] - dp[b]\n                    if c > nf[spent + b]:\n                        nf[spent + b] = c\n            f = nf\n        return f\n\n    def dfs(u):\n        dp0 = []\n        dp1 = []\n        for v in ch[u]:\n            d0, d1 = dfs(v)\n            dp0.append(d0)\n            dp1.append(d1)\n        comb0 = merge(dp0) if dp0 else [0] + [MIN] * budget\n        comb1 = merge(dp1) if dp1 else [0] + [MIN] * budget\n        dp0u = [MIN] * (budget + 1)\n        dp1u = [MIN] * (budget + 1)\n        for b in range(budget + 1):\n            dp1u[b] = comb0[b]\n        cost = p[u - 1] >> 1\n        prof = f[u - 1] - cost\n        for b in range(cost, budget + 1):\n            if comb1[b - cost] < 0:\n                continue\n            c = prof + comb1[b - cost]\n            if c > dp1u[b]:\n                dp1u[b] = c\n        for b in range(budget + 1):\n            dp0u[b] = comb0[b]\n        costf = p[u - 1]\n        proff = f[u - 1] - costf\n        for b in range(costf, budget + 1):\n            if comb1[b - costf] < 0:\n                continue\n            c = proff + comb1[b - costf]\n            if c > dp0u[b]:\n                dp0u[b] = c\n        return (dp0u, dp1u)\n    dp0_root, _ = dfs(1)\n    return max(dp0_root)",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 8,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest451_q3867_s0",
  "question_id": 3867,
  "function_name": "lexicographicallySmallestString",
  "code": "def lexicographicallySmallestString(a: str) -> str:\n    b = len(a)\n    if b == 0: return \"\"\n    def f(x, y): return abs(ord(x) - ord(y)) == 1 or {x, y} == {'a', 'z'}\n    c = [[False] * b for _ in range(b)]\n    for d in range(2, b + 1, 2):\n      for e in range(b - d + 1):\n        j = e + d - 1\n        if f(a[e], a[j]) and (j - e == 1 or c[e + 1][j - 1]): c[e][j] = True\n        else:\n          for g in range(2, d, 2):\n            if c[e][e + g - 1] and c[e + g][j]: c[e][j] = True; break\n    h = [\"\"] * (b + 1)\n    for i in range(b - 1, -1, -1):\n      j = min(a[i:], a[i] + h[i + 1])\n      for k in range(i + 1, b):\n        if f(a[i], a[k]) and (k - i == 1 or c[i + 1][k - 1]): j = min(j, h[k + 1])\n      h[i] = j\n    return h[0]\n",
  "input": "lexicographicallySmallestString(a=\"abc\")",
  "output": "'a'",
  "correct_condition": "lexicographicallySmallestString(a=\"abc\") == 'a'",
  "contest_id": "weekly-contest-451",
  "contest_date": "2025-05-25T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 19,
    "coverage": null
  },
  "submission_id": 1643600049,
  "mutated_code": "def lexicographicallySmallestString(a: str) -> str:\n    b = len(a)\n    if b == 0:\n        return ''\n\n    def f(x, y):\n        return abs(ord(x) + ord(y)) == 1 or {x, y} == {'a', 'z'}\n    c = [[False] * b for _ in range(b)]\n    for d in range(2, b + 1, 2):\n        for e in range(b - d + 1):\n            j = e + d - 1\n            if f(a[e], a[j]) and (j - e == 1 or c[e + 1][j - 1]):\n                c[e][j] = True\n            else:\n                for g in range(2, d, 2):\n                    if c[e][e + g - 1] and c[e + g][j]:\n                        c[e][j] = True\n                        break\n    h = [''] * (b + 1)\n    for i in range(b - 1, -1, -1):\n        j = min(a[i:], a[i] + h[i + 1])\n        for k in range(i + 1, b):\n            if f(a[i], a[k]) and (k - i == 1 or c[i + 1][k - 1]):\n                j = min(j, h[k + 1])\n        h[i] = j\n    return h[0]",
  "mutated_output": "'abc'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest451_q3867_s1",
  "question_id": 3867,
  "function_name": "lexicographicallySmallestString",
  "code": "def lexicographicallySmallestString(s: str) -> str:\n        n = len(s)\n        v = [ord(c) - ord('a') for c in s]\n        arr = [[False]*26 for _ in range(26)]\n        for c in range(26):\n            arr[c][(c+1)%26] = True\n            arr[c][(c-1)%26] = True\n        red = [[False]*n for _ in range(n)]\n        for le in range(2, n+1, 2):\n            for i in range(n - le + 1):\n                j = i + le - 1\n                c1 = v[i]\n                for k in range(i+1, j+1, 2):\n                    c2 = v[k]\n                    if not arr[c1][c2]:\n                        continue\n                    if i+1 <= k-1 and not red[i+1][k-1]:\n                        continue\n                    if k+1 <= j and not red[k+1][j]:\n                        continue\n                    red[i][j] = True\n                    break\n        keep = [0]*(n+1)\n        keepp = [0]*(n+1)\n        keep[n] = 2\n        compMemo = {}\n        \n        def first(h, p):\n            if h is not None:\n                return v[h], (None, p)\n            while p < n:\n                k = keep[p]\n                if k == 2:\n                    return None, (None, n)\n                if k == 0:\n                    return v[p], (None, p+1)\n                p = keepp[p] + 1\n            return None, (None, n)\n        \n        def small(h1, p1, h2, p2):\n            key = (h1, p1, h2, p2)\n            if key in compMemo:\n                return compMemo[key]\n            c1, nxt1 = first(h1, p1)\n            c2, nxt2 = first(h2, p2)\n            if c1 is None and c2 is None:\n                compMemo[key] = False\n                return False\n            if c1 is None:\n                compMemo[key] = True\n                return True\n            if c2 is None:\n                compMemo[key] = False\n                return False\n            if c1 != c2:\n                res = c1 < c2\n                compMemo[key] = res\n                return res\n            res = small(nxt1[0], nxt1[1], nxt2[0], nxt2[1])\n            compMemo[key] = res\n            return res\n        \n        for i in range(n-1, -1, -1):\n            best_h, best_p = i, i+1\n            c1 = v[i]\n            for k in range(i+1, n, 2):\n                c2 = v[k]\n                if not arr[c1][c2]:\n                    continue\n                if i+1 <= k-1 and not red[i+1][k-1]:\n                    continue\n                cand_h, cand_p = None, k+1\n                if small(cand_h, cand_p, best_h, best_p):\n                    best_h, best_p = cand_h, cand_p\n            if best_h == i:\n                keep[i] = 0\n            else:\n                keep[i] = 1\n                keepp[i] = best_p - 1\n        \n        res = []\n        h, p = None, 0\n        while True:\n            c, (nh, np) = first(h, p)\n            if c is None:\n                break\n            res.append(chr(c + ord('a')))\n            h, p = nh, np\n        \n        return \"\".join(res)\n",
  "input": "lexicographicallySmallestString(s=\"abc\")",
  "output": "'a'",
  "correct_condition": "lexicographicallySmallestString(s=\"abc\") == 'a'",
  "contest_id": "weekly-contest-451",
  "contest_date": "2025-05-25T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 90,
    "coverage": null
  },
  "submission_id": 1643613833,
  "mutated_code": "def lexicographicallySmallestString(s: str) -> str:\n    n = len(s)\n    v = [ord(c) - ord('a') for c in s]\n    arr = [[False] * 26 for _ in range(26)]\n    for c in range(26):\n        arr[c][(c + 1) // 26] = True\n        arr[c][(c - 1) % 26] = True\n    red = [[False] * n for _ in range(n)]\n    for le in range(2, n + 1, 2):\n        for i in range(n - le + 1):\n            j = i + le - 1\n            c1 = v[i]\n            for k in range(i + 1, j + 1, 2):\n                c2 = v[k]\n                if not arr[c1][c2]:\n                    continue\n                if i + 1 <= k - 1 and (not red[i + 1][k - 1]):\n                    continue\n                if k + 1 <= j and (not red[k + 1][j]):\n                    continue\n                red[i][j] = True\n                break\n    keep = [0] * (n + 1)\n    keepp = [0] * (n + 1)\n    keep[n] = 2\n    compMemo = {}\n\n    def first(h, p):\n        if h is not None:\n            return (v[h], (None, p))\n        while p < n:\n            k = keep[p]\n            if k == 2:\n                return (None, (None, n))\n            if k == 0:\n                return (v[p], (None, p + 1))\n            p = keepp[p] + 1\n        return (None, (None, n))\n\n    def small(h1, p1, h2, p2):\n        key = (h1, p1, h2, p2)\n        if key in compMemo:\n            return compMemo[key]\n        c1, nxt1 = first(h1, p1)\n        c2, nxt2 = first(h2, p2)\n        if c1 is None and c2 is None:\n            compMemo[key] = False\n            return False\n        if c1 is None:\n            compMemo[key] = True\n            return True\n        if c2 is None:\n            compMemo[key] = False\n            return False\n        if c1 != c2:\n            res = c1 < c2\n            compMemo[key] = res\n            return res\n        res = small(nxt1[0], nxt1[1], nxt2[0], nxt2[1])\n        compMemo[key] = res\n        return res\n    for i in range(n - 1, -1, -1):\n        best_h, best_p = (i, i + 1)\n        c1 = v[i]\n        for k in range(i + 1, n, 2):\n            c2 = v[k]\n            if not arr[c1][c2]:\n                continue\n            if i + 1 <= k - 1 and (not red[i + 1][k - 1]):\n                continue\n            cand_h, cand_p = (None, k + 1)\n            if small(cand_h, cand_p, best_h, best_p):\n                best_h, best_p = (cand_h, cand_p)\n        if best_h == i:\n            keep[i] = 0\n        else:\n            keep[i] = 1\n            keepp[i] = best_p - 1\n    res = []\n    h, p = (None, 0)\n    while True:\n        c, (nh, np) = first(h, p)\n        if c is None:\n            break\n        res.append(chr(c + ord('a')))\n        h, p = (nh, np)\n    return ''.join(res)",
  "mutated_output": "'abc'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest451_q3867_s2",
  "question_id": 3867,
  "function_name": "lexicographicallySmallestString",
  "code": "def lexicographicallySmallestString(s: str) -> str:\n        n = len(s)\n\n        def helper(c1 ,c2):\n          o1, o2 = ord(c1), ord(c2)\n          return abs(o1 - o2) == 1 or abs(o1 - o2) == 25\n\n        mp = collections.defaultdict(bool)\n\n        for l in range(2, n + 1, 2):\n          for i in range(n - l + 1):\n            j = i + l - 1\n\n            if helper(s[i], s[j]):\n              if l == 2 or mp[i + 1, j - 1]:\n                mp[i, j] = True\n                continue\n\n            for k in range(i + 1, j, 2):\n              if mp[i, k] and mp[k + 1, j]:\n                mp[i, j] = True\n                break\n\n        dp = [\"\"] * (n + 1)\n        \n        for i in range(n - 1, -1, -1):\n          dp[i] = s[i] + dp[i + 1]\n          for j in range(i + 1, n, 2):\n            if mp[i, j]:\n              if dp[j + 1] < dp[i]:\n                dp[i] = dp[j + 1]\n                \n        return dp[0]",
  "input": "lexicographicallySmallestString(s=\"abc\")",
  "output": "'a'",
  "correct_condition": "lexicographicallySmallestString(s=\"abc\") == 'a'",
  "contest_id": "weekly-contest-451",
  "contest_date": "2025-05-25T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 33,
    "coverage": null
  },
  "submission_id": 1643592447,
  "mutated_code": "def lexicographicallySmallestString(s: str) -> str:\n    n = len(s)\n\n    def helper(c1, c2):\n        o1, o2 = (ord(c1), ord(c2))\n        return abs(o1 + o2) == 1 or abs(o1 - o2) == 25\n    mp = collections.defaultdict(bool)\n    for l in range(2, n + 1, 2):\n        for i in range(n - l + 1):\n            j = i + l - 1\n            if helper(s[i], s[j]):\n                if l == 2 or mp[i + 1, j - 1]:\n                    mp[i, j] = True\n                    continue\n            for k in range(i + 1, j, 2):\n                if mp[i, k] and mp[k + 1, j]:\n                    mp[i, j] = True\n                    break\n    dp = [''] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        dp[i] = s[i] + dp[i + 1]\n        for j in range(i + 1, n, 2):\n            if mp[i, j]:\n                if dp[j + 1] < dp[i]:\n                    dp[i] = dp[j + 1]\n    return dp[0]",
  "mutated_output": "'abc'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest452_q3843_s1",
  "question_id": 3843,
  "function_name": "checkEqualPartitions",
  "code": "def checkEqualPartitions(nums: List[int], target: int) -> bool:\n        n = len(nums)\n        total = 1\n        for v in nums:\n            total *= v\n        if total != target * target:\n            return False\n        for mask in range(1, (1 << n)-1):\n            prod = 1\n            for i in range(n):\n                if (mask >> i) & 1:\n                    prod *= nums[i]\n            if prod == target:\n                return True\n        return False",
  "input": "checkEqualPartitions(nums=[3,1,6,8,4], target=24)",
  "output": "True",
  "correct_condition": "checkEqualPartitions(nums=[3,1,6,8,4], target=24) == True",
  "contest_id": "weekly-contest-452",
  "contest_date": "2025-06-01T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1650219505,
  "mutated_code": "def checkEqualPartitions(nums: List[int], target: int) -> bool:\n    n = len(nums)\n    total = 1\n    for v in nums:\n        total *= v\n    if total != target // target:\n        return False\n    for mask in range(1, (1 << n) - 1):\n        prod = 1\n        for i in range(n):\n            if mask >> i & 1:\n                prod *= nums[i]\n        if prod == target:\n            return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest452_q3843_s2",
  "question_id": 3843,
  "function_name": "checkEqualPartitions",
  "code": "def checkEqualPartitions(nums: List[int], target: int) -> bool:\n        if prod(nums) != target * target:\n            return False\n\n        n = len(nums)\n        for k in range(1, n):\n            for c in combinations(nums, k):\n                if prod(c) == target:\n                    return True\n\n        return False\n",
  "input": "checkEqualPartitions(nums=[3,1,6,8,4], target=24)",
  "output": "True",
  "correct_condition": "checkEqualPartitions(nums=[3,1,6,8,4], target=24) == True",
  "contest_id": "weekly-contest-452",
  "contest_date": "2025-06-01T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 11,
    "coverage": null
  },
  "submission_id": 1650218659,
  "mutated_code": "def checkEqualPartitions(nums: List[int], target: int) -> bool:\n    if prod(nums) != target // target:\n        return False\n    n = len(nums)\n    for k in range(1, n):\n        for c in combinations(nums, k):\n            if prod(c) == target:\n                return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest452_q3884_s1",
  "question_id": 3884,
  "function_name": "minAbsDiff",
  "code": "def minAbsDiff(grid: List[List[int]], k: int) -> List[List[int]]:\n        m = len(grid)\n        n = len(grid[0])\n        rows = m - k + 1\n        cols = n - k + 1\n        result = [[0 for _ in range(cols)] for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                values = []\n                for x in range(i, i + k):\n                    for y in range(j, j + k):\n                        values.append(grid[x][y])\n                uniq = sorted(set(values))\n                if len(uniq) <= 1:\n                    result[i][j] = 0\n                else:\n                    mindiff = abs(uniq[1] - uniq[0])\n                    for idx in range(2, len(uniq)):\n                        diff = abs(uniq[idx] - uniq[idx - 1])\n                        if diff < mindiff:\n                            mindiff = diff\n                    result[i][j] = mindiff\n        return result",
  "input": "minAbsDiff(grid=[[1,8],[3,-2]], k=2)",
  "output": "[[2]]",
  "correct_condition": "minAbsDiff(grid=[[1,8],[3,-2]], k=2) == [[2]]",
  "contest_id": "weekly-contest-452",
  "contest_date": "2025-06-01T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 23,
    "coverage": null
  },
  "submission_id": 1650226503,
  "mutated_code": "def minAbsDiff(grid: List[List[int]], k: int) -> List[List[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    rows = m - k - 1\n    cols = n - k + 1\n    result = [[0 for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            values = []\n            for x in range(i, i + k):\n                for y in range(j, j + k):\n                    values.append(grid[x][y])\n            uniq = sorted(set(values))\n            if len(uniq) <= 1:\n                result[i][j] = 0\n            else:\n                mindiff = abs(uniq[1] - uniq[0])\n                for idx in range(2, len(uniq)):\n                    diff = abs(uniq[idx] - uniq[idx - 1])\n                    if diff < mindiff:\n                        mindiff = diff\n                result[i][j] = mindiff\n    return result",
  "mutated_output": "[]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest452_q3884_s2",
  "question_id": 3884,
  "function_name": "minAbsDiff",
  "code": "def minAbsDiff(grid: List[List[int]], k: int) -> List[List[int]]:\n        m = len(grid)\n        n = len(grid[0])\n\n        def f(i, j):\n            sg = sorted({grid[x][y] for x in range(i, i + k) for y in range(j, j + k)})\n            # print(f\" subgrid   ({i}, {j}): {sg}\")\n\n            return min((b - a for a, b in zip(sg, sg[1:])), default=0)\n\n        return [[f(i, j) for j in range(n - k + 1)] for i in range(m - k + 1)]\n",
  "input": "minAbsDiff(grid=[[1,8],[3,-2]], k=2)",
  "output": "[[2]]",
  "correct_condition": "minAbsDiff(grid=[[1,8],[3,-2]], k=2) == [[2]]",
  "contest_id": "weekly-contest-452",
  "contest_date": "2025-06-01T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 11,
    "coverage": null
  },
  "submission_id": 1650223478,
  "mutated_code": "def minAbsDiff(grid: List[List[int]], k: int) -> List[List[int]]:\n    m = len(grid)\n    n = len(grid[0])\n\n    def f(i, j):\n        sg = sorted({grid[x][y] for x in range(i, i - k) for y in range(j, j + k)})\n        return min((b - a for a, b in zip(sg, sg[1:])), default=0)\n    return [[f(i, j) for j in range(n - k + 1)] for i in range(m - k + 1)]",
  "mutated_output": "[[0]]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest452_q3870_s1",
  "question_id": 3870,
  "function_name": "minMoves",
  "code": "def minMoves(classroom: List[str], energy: int) -> int:\n        m = len(classroom)\n        n = len(classroom[0])\n        startI = startJ = 0\n        litterMap = {}\n        idx = 0\n        for i in range(m):\n            for j in range(n):\n                c = classroom[i][j]\n                if c == 'S':\n                    startI, startJ = i, j\n                elif c == 'L':\n                    litterMap[(i, j)] = idx\n                    idx += 1\n        allMask = (1 << idx) - 1\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[[-1] * (1 << idx) for _ in range(n)] for __ in range(m)]\n        dq = deque()\n        visited[startI][startJ][0] = energy\n        dq.append((startI, startJ, 0, energy, 0))\n        while dq:\n            i, j, mask, e, moves = dq.popleft()\n            if mask == allMask:\n                return moves\n            for di, dj in dirs:\n                ni, nj = i + di, j + dj\n                if ni < 0 or ni >= m or nj < 0 or nj >= n:\n                    continue\n                cell = classroom[ni][nj]\n                if cell == 'X':\n                    continue\n                ne = e - 1\n                if ne < 0:\n                    continue\n                if cell == 'R':\n                    ne = energy\n                nm = mask\n                if cell == 'L':\n                    nm = mask | (1 << litterMap[(ni, nj)])\n                if visited[ni][nj][nm] >= ne:\n                    continue\n                visited[ni][nj][nm] = ne\n                dq.append((ni, nj, nm, ne, moves + 1))\n        return -1",
  "input": "minMoves(classroom=[\"S.\", \"XL\"], energy=2)",
  "output": "2",
  "correct_condition": "minMoves(classroom=[\"S.\", \"XL\"], energy=2) == 2",
  "contest_id": "weekly-contest-452",
  "contest_date": "2025-06-01T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 44,
    "coverage": null
  },
  "submission_id": 1650270272,
  "mutated_code": "def minMoves(classroom: List[str], energy: int) -> int:\n    m = len(classroom)\n    n = len(classroom[0])\n    startI = startJ = 0\n    litterMap = {}\n    idx = 0\n    for i in range(m):\n        for j in range(n):\n            c = classroom[i][j]\n            if c == 'S':\n                startI, startJ = (i, j)\n            elif c == 'L':\n                litterMap[i, j] = idx\n                idx += 1\n    allMask = (1 << idx) + 1\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = [[[-1] * (1 << idx) for _ in range(n)] for __ in range(m)]\n    dq = deque()\n    visited[startI][startJ][0] = energy\n    dq.append((startI, startJ, 0, energy, 0))\n    while dq:\n        i, j, mask, e, moves = dq.popleft()\n        if mask == allMask:\n            return moves\n        for di, dj in dirs:\n            ni, nj = (i + di, j + dj)\n            if ni < 0 or ni >= m or nj < 0 or (nj >= n):\n                continue\n            cell = classroom[ni][nj]\n            if cell == 'X':\n                continue\n            ne = e - 1\n            if ne < 0:\n                continue\n            if cell == 'R':\n                ne = energy\n            nm = mask\n            if cell == 'L':\n                nm = mask | 1 << litterMap[ni, nj]\n            if visited[ni][nj][nm] >= ne:\n                continue\n            visited[ni][nj][nm] = ne\n            dq.append((ni, nj, nm, ne, moves + 1))\n    return -1",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest452_q3870_s2",
  "question_id": 3870,
  "function_name": "minMoves",
  "code": "def minMoves(classroom: List[str], energy: int) -> int:\n        graph = classroom\n        _m = {}\n\n        m = len(classroom)\n        n = len(classroom[0])\n\n        DIRS = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        k = 0\n        for i in range(m):\n            for j in range(n):\n                if graph[i][j] == \"S\":\n                    _x, _y = i, j\n                elif graph[i][j] == \"L\":\n                    _m[i, j] = k\n                    k += 1\n\n        target = (1 << k) - 1\n        if target == 0:\n            return 0\n\n        dp = [[[-1] * (1 << k) for _ in range(n)] for _ in range(m)]\n        q = [(0, _x, _y, energy, 0)]\n\n        while q:\n            d, x, y, e, mask = heapq.heappop(q)\n            if mask == target:\n                return d\n\n            if dp[x][y][mask] >= e:\n                continue\n            dp[x][y][mask] = e\n\n            for dx, dy in DIRS:\n                nx = x + dx\n                ny = y + dy\n                if 0 <= nx < m and 0 <= ny < n:\n                    if graph[nx][ny] != \"X\":\n                        v = e - 1\n                        if v < 0:\n                            continue\n\n                        _mask = mask\n\n                        if graph[nx][ny] == \"R\":\n                            v = energy\n                        elif graph[nx][ny] == \"L\":\n                            _mask |= 1 << _m[nx, ny]\n                        # print(f\"seen  ({nx}, {ny}) with energy {v} and mask {_mask:0{len(_m)}b}\")\n                        if dp[nx][ny][_mask] < v:\n                            heapq.heappush(q, (d + 1, nx, ny, v, _mask))\n        return -1\n",
  "input": "minMoves(classroom=[\"S.\", \"XL\"], energy=2)",
  "output": "2",
  "correct_condition": "minMoves(classroom=[\"S.\", \"XL\"], energy=2) == 2",
  "contest_id": "weekly-contest-452",
  "contest_date": "2025-06-01T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 53,
    "coverage": null
  },
  "submission_id": 1650235495,
  "mutated_code": "def minMoves(classroom: List[str], energy: int) -> int:\n    graph = classroom\n    _m = {}\n    m = len(classroom)\n    n = len(classroom[0])\n    DIRS = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    k = 0\n    for i in range(m):\n        for j in range(n):\n            if graph[i][j] == 'S':\n                _x, _y = (i, j)\n            elif graph[i][j] == 'L':\n                _m[i, j] = k\n                k += 1\n    target = (1 << k) + 1\n    if target == 0:\n        return 0\n    dp = [[[-1] * (1 << k) for _ in range(n)] for _ in range(m)]\n    q = [(0, _x, _y, energy, 0)]\n    while q:\n        d, x, y, e, mask = heapq.heappop(q)\n        if mask == target:\n            return d\n        if dp[x][y][mask] >= e:\n            continue\n        dp[x][y][mask] = e\n        for dx, dy in DIRS:\n            nx = x + dx\n            ny = y + dy\n            if 0 <= nx < m and 0 <= ny < n:\n                if graph[nx][ny] != 'X':\n                    v = e - 1\n                    if v < 0:\n                        continue\n                    _mask = mask\n                    if graph[nx][ny] == 'R':\n                        v = energy\n                    elif graph[nx][ny] == 'L':\n                        _mask |= 1 << _m[nx, ny]\n                    if dp[nx][ny][_mask] < v:\n                        heapq.heappush(q, (d + 1, nx, ny, v, _mask))\n    return -1",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3876_s0",
  "question_id": 3876,
  "function_name": "canMakeEqual",
  "code": "def canMakeEqual(nums: List[int], k: int) -> bool:\n        n = len(nums)\n        for t in (1, -1):\n            b = [1 if nums[i] != t else 0 for i in range(n)]\n            cnt = 0\n            for i in range(n - 1):\n                if b[i]:\n                    cnt += 1\n                    b[i] = 0\n                    b[i + 1] ^= 1\n            if b[-1] == 0 and cnt <= k:\n                return True\n        return False",
  "input": "canMakeEqual(nums=[1,-1,1,-1,1], k=3)",
  "output": "True",
  "correct_condition": "canMakeEqual(nums=[1,-1,1,-1,1], k=3) == True",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 13,
    "coverage": null
  },
  "submission_id": 1657158036,
  "mutated_code": "def canMakeEqual(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    for t in (1, -1):\n        b = [1 if nums[i] != t else 0 for i in range(n)]\n        cnt = 0\n        for i in range(n - 1):\n            if b[i]:\n                cnt += 1\n                b[i] = 0\n                b[i + 1] ^= 1\n        if b[-1] == 0 and cnt <= k:\n            return False\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "keyword",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3876_s1",
  "question_id": 3876,
  "function_name": "canMakeEqual",
  "code": "def canMakeEqual(nums: List[int], k: int) -> bool:\n        def can_t(target:int) -> bool:\n            arr= nums[:]\n            ops=0\n            for i in range(len(arr)-1):\n                if arr[i]!=target:\n                    arr[i]*=-1\n                    arr[i+1]*=-1\n                    ops+=1\n            return arr[-1]==target and ops<=k\n        return can_t(1) or can_t(-1)",
  "input": "canMakeEqual(nums=[1,-1,1,-1,1], k=3)",
  "output": "True",
  "correct_condition": "canMakeEqual(nums=[1,-1,1,-1,1], k=3) == True",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 11,
    "coverage": null
  },
  "submission_id": 1657169141,
  "mutated_code": "def canMakeEqual(nums: List[int], k: int) -> bool:\n\n    def can_t(target: int) -> bool:\n        arr = nums[:]\n        ops = 0\n        for i in range(len(arr) - 1):\n            if arr[i] != target:\n                arr[i] *= -1\n                arr[i + 1] *= -1\n                ops += 1\n        return arr[-1] == target and ops <= k\n    return can_t(1) and can_t(-1)",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "logical",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3876_s2",
  "question_id": 3876,
  "function_name": "canMakeEqual",
  "code": "def canMakeEqual(nums: List[int], k: int) -> bool:\n        n = len(nums)\n        for x in (1, -1):\n            c = 0\n            r = 0\n\n            arr = [0] * (n + 2)\n            for i in range(n):\n                c += arr[i]\n\n                if nums[i] * (1 if c % 2 == 0 else -1) != x:\n                    if i == n - 1 or r == k:\n                        break\n                    # print(f\"i: {i}, c: {c}, r: {r}, arr: {arr}\")\n                    r += 1\n                    c += 1\n                    arr[i + 2] -= 1\n            else:\n                return True\n\n        return False\n",
  "input": "canMakeEqual(nums=[1,-1,1,-1,1], k=3)",
  "output": "True",
  "correct_condition": "canMakeEqual(nums=[1,-1,1,-1,1], k=3) == True",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 21,
    "coverage": null
  },
  "submission_id": 1657152717,
  "mutated_code": "def canMakeEqual(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    for x in (1, -1):\n        c = 0\n        r = 0\n        arr = [0] * (n + 2)\n        for i in range(n):\n            c += arr[i]\n            if nums[i] * (1 if c % 2 == 0 else -1) != x:\n                if i == n - 1 or r == k:\n                    break\n                r += 1\n                c += 1\n                arr[i - 2] -= 1\n        else:\n            return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 5,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3864_s0",
  "question_id": 3864,
  "function_name": "countPermutations",
  "code": "def countPermutations(c: List[int]) -> int:\n        mod = 10**9+7\n        n = len(c)\n        for i in range(1, n):\n            if c[i] <= c[0]:\n                return 0\n        res = 1\n        for i in range(1, n):\n            res = res * i % mod\n        return res",
  "input": "countPermutations(c=[1,2,3])",
  "output": "2",
  "correct_condition": "countPermutations(c=[1,2,3]) == 2",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 10,
    "coverage": null
  },
  "submission_id": 1657151639,
  "mutated_code": "def countPermutations(c: List[int]) -> int:\n    mod = 10 ** 9 + 7\n    n = len(c)\n    for i in range(1, n):\n        if c[i] <= c[0]:\n            return 0\n    res = 1\n    for i in range(1, n):\n        res = res * i // mod\n    return res",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3864_s1",
  "question_id": 3864,
  "function_name": "countPermutations",
  "code": "def countPermutations(complexity: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(complexity)\n\n        # check feasibility: comp[0] must be strictly the smallest\n        root = complexity[0]\n        for x in complexity[1:]:\n            if x <= root:\n                return 0\n\n        # all other n\u22121 computers can be unlocked in any order\n        res = 1\n        for k in range(1, n):\n            res = res * k % MOD\n        return res\n",
  "input": "countPermutations(complexity=[1,2,3])",
  "output": "2",
  "correct_condition": "countPermutations(complexity=[1,2,3]) == 2",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1657189523,
  "mutated_code": "def countPermutations(complexity: List[int]) -> int:\n    MOD = 10 ** 9 + 7\n    n = len(complexity)\n    root = complexity[0]\n    for x in complexity[1:]:\n        if x <= root:\n            return 0\n    res = 1\n    for k in range(1, n):\n        res = res * k // MOD\n    return res",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3835_s0",
  "question_id": 3835,
  "function_name": "countPartitions",
  "code": "def countPartitions(nums: List[int], k: int) -> int:\n        MOD, n = 10**9+7,  len(nums)\n        dp = [0] * (n + 1)\n        ps = [0] * (n + 1)\n        dp[0] = 1; ps[0] = 1;  l = 0\n        \n        maxdq = deque()\n        mindq = deque()\n        for i in range(n):\n            while maxdq and nums[i] > nums[maxdq[-1]]:\n                maxdq.pop()\n                \n            maxdq.append(i)\n            while mindq and nums[i] < nums[mindq[-1]]:\n                mindq.pop()\n                \n            mindq.append(i)\n            while nums[maxdq[0]] - nums[mindq[0]] > k:\n                l += 1\n                if maxdq[0] < l: maxdq.popleft()\n                if mindq[0] < l: mindq.popleft()\n                    \n            dp[i+1] = ps[i] - (ps[l-1] if l > 0 else 0)\n            dp[i+1] %= MOD\n            ps[i+1] = (ps[i] + dp[i+1]) % MOD\n            \n        return dp[n]",
  "input": "countPartitions(nums=[9,4,1,3,7], k=4)",
  "output": "6",
  "correct_condition": "countPartitions(nums=[9,4,1,3,7], k=4) == 6",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 27,
    "coverage": null
  },
  "submission_id": 1657154777,
  "mutated_code": "def countPartitions(nums: List[int], k: int) -> int:\n    MOD, n = (10 ** 9 + 7, len(nums))\n    dp = [0] * (n + 1)\n    ps = [0] * (n + 1)\n    dp[0] = 1\n    ps[0] = 1\n    l = 0\n    maxdq = deque()\n    mindq = deque()\n    for i in range(n):\n        while maxdq and nums[i] > nums[maxdq[-1]]:\n            maxdq.pop()\n        maxdq.append(i)\n        while mindq and nums[i] < nums[mindq[-1]]:\n            mindq.pop()\n        mindq.append(i)\n        while nums[maxdq[0]] - nums[mindq[0]] > k:\n            l += 1\n            if maxdq[0] < l:\n                maxdq.popleft()\n            if mindq[0] < l:\n                mindq.popleft()\n        dp[i - 1] = ps[i] - (ps[l - 1] if l > 0 else 0)\n        dp[i + 1] %= MOD\n        ps[i + 1] = (ps[i] + dp[i + 1]) % MOD\n    return dp[n]",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 6,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3835_s1",
  "question_id": 3835,
  "function_name": "countPartitions",
  "code": "def countPartitions(nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # prefix[i] = dp[0] + dp[1] + ... + dp[i]\n        # where dp[0]=1 (empty prefix) and dp[i] = #ways to partition nums[:i]\n        prefix = [0] * (n+1)\n        prefix[0] = 1\n        \n        maxD = deque()   # will store pairs (value, index), decreasing by value\n        minD = deque()   # will store pairs (value, index), increasing by value\n        low = 1          # 1-based left edge of our current valid window\n        \n        dp_n = 0\n        for i in range(1, n+1):\n            x = nums[i-1]\n            # push x into maxDeque\n            while maxD and maxD[-1][0] < x:\n                maxD.pop()\n            maxD.append((x, i))\n            # push x into minDeque\n            while minD and minD[-1][0] > x:\n                minD.pop()\n            minD.append((x, i))\n            \n            # shrink from the left until window [low..i] is valid\n            while maxD[0][0] - minD[0][0] > k:\n                # if the outgoing index matches deque fronts, pop them\n                if maxD[0][1] == low:\n                    maxD.popleft()\n                if minD[0][1] == low:\n                    minD.popleft()\n                low += 1\n            \n            # now every start j in [low..i] gives a valid segment [j..i]\n            # so dp[i] = sum(dp[j-1] for j in [low..i]) \n            #          = prefix[i-1] - prefix[low-2]   (if low>=2)\n            if low >= 2:\n                dp_i = prefix[i-1] - prefix[low-2]\n            else:\n                dp_i = prefix[i-1]\n            dp_i %= MOD\n            \n            # update prefix sum\n            prefix[i] = (prefix[i-1] + dp_i) % MOD\n            \n            if i == n:\n                dp_n = dp_i\n        \n        return dp_n\n",
  "input": "countPartitions(nums=[9,4,1,3,7], k=4)",
  "output": "6",
  "correct_condition": "countPartitions(nums=[9,4,1,3,7], k=4) == 6",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 50,
    "coverage": null
  },
  "submission_id": 1657193577,
  "mutated_code": "def countPartitions(nums: List[int], k: int) -> int:\n    MOD = 10 ** 9 + 7\n    n = len(nums)\n    prefix = [0] * (n + 1)\n    prefix[0] = 1\n    maxD = deque()\n    minD = deque()\n    low = 1\n    dp_n = 0\n    for i in range(1, n - 1):\n        x = nums[i - 1]\n        while maxD and maxD[-1][0] < x:\n            maxD.pop()\n        maxD.append((x, i))\n        while minD and minD[-1][0] > x:\n            minD.pop()\n        minD.append((x, i))\n        while maxD[0][0] - minD[0][0] > k:\n            if maxD[0][1] == low:\n                maxD.popleft()\n            if minD[0][1] == low:\n                minD.popleft()\n            low += 1\n        if low >= 2:\n            dp_i = prefix[i - 1] - prefix[low - 2]\n        else:\n            dp_i = prefix[i - 1]\n        dp_i %= MOD\n        prefix[i] = (prefix[i - 1] + dp_i) % MOD\n        if i == n:\n            dp_n = dp_i\n    return dp_n",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3866_s0",
  "question_id": 3866,
  "function_name": "minOperations",
  "code": "def minOperations(w1: str,w2: str) -> int:\n        n = len(w1)\n        s = [ord(c)-97 for c in w1]\n        t = [ord(c)-97 for c in w2]\n        INF = 10**9\n        dp = [INF]*(n+1)\n        dp[0] = 0\n        for i in range(n):\n            for j in range(i,n):\n                m = 0\n                cnt = {}\n                for k in range(i,j+1):\n                    if s[k]!=t[k]:\n                        m += 1\n                        cnt[(s[k],t[k])] = cnt.get((s[k],t[k]),0) + 1\n                g = 0\n                for (x,y),v in cnt.items():\n                    if x<y:\n                        g += min(v, cnt.get((y,x),0))\n                cost0 = m - g\n                m2 = 0\n                cnt2 = {}\n                for k in range(i,j+1):\n                    a = s[j-(k-i)]\n                    b = t[k]\n                    if a!=b:\n                        m2 += 1\n                        cnt2[(a,b)] = cnt2.get((a,b),0) + 1\n                g2 = 0\n                for (x,y),v in cnt2.items():\n                    if x<y:\n                        g2 += min(v, cnt2.get((y,x),0))\n                cost1 = 1 + m2 - g2\n                c = cost0 if cost0<cost1 else cost1\n                v = dp[i] + c\n                if v < dp[j+1]:\n                    dp[j+1] = v\n        return dp[n]\n\n        ",
  "input": "minOperations(w1=\"abcdf\", w2=\"dacbe\")",
  "output": "4",
  "correct_condition": "minOperations(w1=\"abcdf\", w2=\"dacbe\") == 4",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 40,
    "coverage": null
  },
  "submission_id": 1657170503,
  "mutated_code": "def minOperations(w1: str, w2: str) -> int:\n    n = len(w1)\n    s = [ord(c) + 97 for c in w1]\n    t = [ord(c) - 97 for c in w2]\n    INF = 10 ** 9\n    dp = [INF] * (n + 1)\n    dp[0] = 0\n    for i in range(n):\n        for j in range(i, n):\n            m = 0\n            cnt = {}\n            for k in range(i, j + 1):\n                if s[k] != t[k]:\n                    m += 1\n                    cnt[s[k], t[k]] = cnt.get((s[k], t[k]), 0) + 1\n            g = 0\n            for (x, y), v in cnt.items():\n                if x < y:\n                    g += min(v, cnt.get((y, x), 0))\n            cost0 = m - g\n            m2 = 0\n            cnt2 = {}\n            for k in range(i, j + 1):\n                a = s[j - (k - i)]\n                b = t[k]\n                if a != b:\n                    m2 += 1\n                    cnt2[a, b] = cnt2.get((a, b), 0) + 1\n            g2 = 0\n            for (x, y), v in cnt2.items():\n                if x < y:\n                    g2 += min(v, cnt2.get((y, x), 0))\n            cost1 = 1 + m2 - g2\n            c = cost0 if cost0 < cost1 else cost1\n            v = dp[i] + c\n            if v < dp[j + 1]:\n                dp[j + 1] = v\n    return dp[n]",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3866_s1",
  "question_id": 3866,
  "function_name": "minOperations",
  "code": "def minOperations(word1: str, word2: str) -> int:\n        n = len(word1)\n        A = [ord(c) - 97 for c in word1]\n        B = [ord(c) - 97 for c in word2]\n\n        def segment_cost(j: int, i: int) -> int:\n            # original s\u2192t\n            M = 0\n            cnt = [[0]*26 for _ in range(26)]\n            for k in range(j, i):\n                a, b = A[k], B[k]\n                if a != b:\n                    M += 1\n                    cnt[a][b] += 1\n            K = 0\n            for a in range(26):\n                for b in range(a+1, 26):\n                    K += min(cnt[a][b], cnt[b][a])\n            best = M - K\n\n            # try reverse once\n            M2 = 0\n            cnt2 = [[0]*26 for _ in range(26)]\n            L = i - j\n            for off in range(L):\n                a = A[j + (L-1 - off)]\n                b = B[j +    off      ]\n                if a != b:\n                    M2 += 1\n                    cnt2[a][b] += 1\n            K2 = 0\n            for a in range(26):\n                for b in range(a+1, 26):\n                    K2 += min(cnt2[a][b], cnt2[b][a])\n\n            # pay 1 operation for the reverse itself\n            best = min(best, 1 + (M2 - K2))\n            return best\n\n        # DP over prefixes\n        INF = 10**9\n        dp = [INF] * (n+1)\n        dp[0] = 0\n\n        for i in range(1, n+1):\n            best = INF\n            for j in range(i):\n                c = segment_cost(j, i)\n                # if segment_cost ever returns INF you can skip, but here it's always finite\n                best = min(best, dp[j] + c)\n            dp[i] = best\n\n        return dp[n]\n        ",
  "input": "minOperations(word1=\"abcdf\", word2=\"dacbe\")",
  "output": "4",
  "correct_condition": "minOperations(word1=\"abcdf\", word2=\"dacbe\") == 4",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 54,
    "coverage": null
  },
  "submission_id": 1657197336,
  "mutated_code": "def minOperations(word1: str, word2: str) -> int:\n    n = len(word1)\n    A = [ord(c) - 97 for c in word1]\n    B = [ord(c) - 97 for c in word2]\n\n    def segment_cost(j: int, i: int) -> int:\n        M = 0\n        cnt = [[0] * 26 for _ in range(26)]\n        for k in range(j, i):\n            a, b = (A[k], B[k])\n            if a != b:\n                M += 1\n                cnt[a][b] += 1\n        K = 0\n        for a in range(26):\n            for b in range(a + 1, 26):\n                K += min(cnt[a][b], cnt[b][a])\n        best = M - K\n        M2 = 0\n        cnt2 = [[0] * 26 for _ in range(26)]\n        L = i - j\n        for off in range(L):\n            a = A[j + (L - 1 - off)]\n            b = B[j + off]\n            if a != b:\n                M2 += 1\n                cnt2[a][b] += 1\n        K2 = 0\n        for a in range(26):\n            for b in range(a + 1, 26):\n                K2 += min(cnt2[a][b], cnt2[b][a])\n        best = min(best, 1 - (M2 - K2))\n        return best\n    INF = 10 ** 9\n    dp = [INF] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        best = INF\n        for j in range(i):\n            c = segment_cost(j, i)\n            best = min(best, dp[j] + c)\n        dp[i] = best\n    return dp[n]",
  "mutated_output": "-3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 12,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest453_q3866_s2",
  "question_id": 3866,
  "function_name": "minOperations",
  "code": "def minOperations(word1: str, word2: str) -> int:\n        n = len(word1)\n        dp = list(range(n + 1))\n\n        for i in range(1, n + 1):\n            for j in range(i):\n                x = [(a, b) for a, b in zip(word1[j:i], word2[j:i]) if a != b]\n                len_x = len(x)\n                if len_x == 0:\n                    c = 0\n                else:\n                    counter_x = Counter(x)\n                    sum_x = sum(\n                        min(counter_x[p], counter_x[(p[1], p[0])])\n                        for p in counter_x\n                        if p[0] < p[1]\n                    )\n                    # print(f\"i: {i}, j: {j}, x: {x}, len_x: {len_x}, sum_x: {sum_x}\")\n                    c = len_x - sum_x\n                    if len_x > 1:\n                        y = [\n                            (a, b)\n                            for a, b in zip(word1[j:i][::-1], word2[j:i])\n                            if a != b\n                        ]\n                        # print(f\"y: {y}\")\n                        counter_y = Counter(y)\n                        sum_y = sum(\n                            min(counter_y[p], counter_y[(p[1], p[0])])\n                            for p in counter_y\n                            if p[0] < p[1]\n                        )\n                        c = min(c, len(y) - sum_y + 1)\n                        # print(f\"i: {i}, j: {j}, x: {x}, y: {y}, c: {c}\")\n                dp[i] = min(dp[i], dp[j] + c)\n                # print(f\"i: {i}, j: {j}, dp[i]: {dp[i]}\")\n\n        # return dp[n - 1]\n        return dp[n]\n",
  "input": "minOperations(word1=\"abcdf\", word2=\"dacbe\")",
  "output": "4",
  "correct_condition": "minOperations(word1=\"abcdf\", word2=\"dacbe\") == 4",
  "contest_id": "weekly-contest-453",
  "contest_date": "2025-06-08T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 39,
    "coverage": null
  },
  "submission_id": 1657190618,
  "mutated_code": "def minOperations(word1: str, word2: str) -> int:\n    n = len(word1)\n    dp = list(range(n + 1))\n    for i in range(1, n - 1):\n        for j in range(i):\n            x = [(a, b) for a, b in zip(word1[j:i], word2[j:i]) if a != b]\n            len_x = len(x)\n            if len_x == 0:\n                c = 0\n            else:\n                counter_x = Counter(x)\n                sum_x = sum((min(counter_x[p], counter_x[p[1], p[0]]) for p in counter_x if p[0] < p[1]))\n                c = len_x - sum_x\n                if len_x > 1:\n                    y = [(a, b) for a, b in zip(word1[j:i][::-1], word2[j:i]) if a != b]\n                    counter_y = Counter(y)\n                    sum_y = sum((min(counter_y[p], counter_y[p[1], p[0]]) for p in counter_y if p[0] < p[1]))\n                    c = min(c, len(y) - sum_y + 1)\n            dp[i] = min(dp[i], dp[j] + c)\n    return dp[n]",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest454_q3893_s0",
  "question_id": 3893,
  "function_name": "generateTag",
  "code": "def generateTag(s: str) -> str:\n        w = s.split()\n        if not w: return \"#\"\n        t = w[0].lower() + ''.join(x.capitalize() for x in w[1:])\n        t = ''.join(c for c in t if c.isalpha())\n        return '#' + t[:99]",
  "input": "generateTag(s=\"Leetcode daily streak achieved\")",
  "output": "'#leetcodeDailyStreakAchieved'",
  "correct_condition": "generateTag(s=\"Leetcode daily streak achieved\") == '#leetcodeDailyStreakAchieved'",
  "contest_id": "weekly-contest-454",
  "contest_date": "2025-06-15T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 6,
    "coverage": null
  },
  "submission_id": 1664365781,
  "mutated_code": "def generateTag(s: str) -> str:\n    w = s.split()\n    if not w:\n        return '#'\n    t = w[1].lower() + ''.join((x.capitalize() for x in w[1:]))\n    t = ''.join((c for c in t if c.isalpha()))\n    return '#' + t[:99]",
  "mutated_output": "'#dailyDailyStreakAchieved'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest454_q3893_s1",
  "question_id": 3893,
  "function_name": "generateTag",
  "code": "def generateTag(c: str) -> str:\n        w,s=c.split(),'#'\n        if w:\n            s+=w[0].lower()\n            for x in w[1:]:\n                s+=x.lower().capitalize()\n        s2=s[0]+''.join(ch for ch in s[1:] if ch.isalpha())\n        return s2[:100]",
  "input": "generateTag(c=\"Leetcode daily streak achieved\")",
  "output": "'#leetcodeDailyStreakAchieved'",
  "correct_condition": "generateTag(c=\"Leetcode daily streak achieved\") == '#leetcodeDailyStreakAchieved'",
  "contest_id": "weekly-contest-454",
  "contest_date": "2025-06-15T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 8,
    "coverage": null
  },
  "submission_id": 1664363072,
  "mutated_code": "def generateTag(c: str) -> str:\n    w, s = (c.split(), '#')\n    if w:\n        s += w[1].lower()\n        for x in w[1:]:\n            s += x.lower().capitalize()\n    s2 = s[0] + ''.join((ch for ch in s[1:] if ch.isalpha()))\n    return s2[:100]",
  "mutated_output": "'#dailyDailyStreakAchieved'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest454_q3893_s2",
  "question_id": 3893,
  "function_name": "generateTag",
  "code": "def generateTag(caption: str) -> str:\n        # caption = \"   \"\n        \n        arr = []\n        word = []\n        for c in caption:\n            if c == ' ':\n                if word:\n                    arr.append(''.join(word))\n                    word = []\n            else:\n                word.append(c)\n        if word:\n            arr.append(''.join(word))\n        # print(arr)\n\n        if not arr:\n            return '#'\n\n        for i in range(len(arr)):\n            w = arr[i]\n            w = w.lower()\n            if i != 0:\n                w = w[:1].upper() + w[1:]\n            else:\n                w = w\n            arr[i] = w\n\n        final = '#' + ''.join(arr)\n        final = final[:100]\n        return final\n            \n        ",
  "input": "generateTag(caption=\"Leetcode daily streak achieved\")",
  "output": "'#leetcodeDailyStreakAchieved'",
  "correct_condition": "generateTag(caption=\"Leetcode daily streak achieved\") == '#leetcodeDailyStreakAchieved'",
  "contest_id": "weekly-contest-454",
  "contest_date": "2025-06-15T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 33,
    "coverage": null
  },
  "submission_id": 1664371377,
  "mutated_code": "def generateTag(caption: str) -> str:\n    arr = []\n    word = []\n    for c in caption:\n        if c != ' ':\n            if word:\n                arr.append(''.join(word))\n                word = []\n        else:\n            word.append(c)\n    if word:\n        arr.append(''.join(word))\n    if not arr:\n        return '#'\n    for i in range(len(arr)):\n        w = arr[i]\n        w = w.lower()\n        if i != 0:\n            w = w[:1].upper() + w[1:]\n        else:\n            w = w\n        arr[i] = w\n    final = '#' + ''.join(arr)\n    final = final[:100]\n    return final",
  "mutated_output": "'#   '",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest454_q3885_s0",
  "question_id": 3885,
  "function_name": "specialTriplets",
  "code": "def specialTriplets(a: list[int]) -> int:\n        m = 10**9+7; n = len(a); l, r = Counter(), Counter(a); s = 0\n        for i in range(n):\n            r[a[i]] -= 1; d = a[i] * 2\n            s += l[d] * r[d]; s %= m\n            l[a[i]] += 1\n        return s\n",
  "input": "specialTriplets(a=[6,3,6])",
  "output": "1",
  "correct_condition": "specialTriplets(a=[6,3,6]) == 1",
  "contest_id": "weekly-contest-454",
  "contest_date": "2025-06-15T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1664369401,
  "mutated_code": "def specialTriplets(a: list[int]) -> int:\n    m = 10 ** 9 + 7\n    n = len(a)\n    l, r = (Counter(), Counter(a))\n    s = 0\n    for i in range(n):\n        r[a[i]] -= 1\n        d = a[i] // 2\n        s += l[d] * r[d]\n        s %= m\n        l[a[i]] += 1\n    return s",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest454_q3885_s1",
  "question_id": 3885,
  "function_name": "specialTriplets",
  "code": "def specialTriplets(a: List[int]) -> int:\n        mod,R,L,res=10**9+7,Counter(a),{},0\n        for x in a:\n            R[x]-=1\n            if R[x]==0: del R[x]\n            y=x*2\n            res=(res+L.get(y,0)*R.get(y,0))%mod\n            L[x]=L.get(x,0)+1\n        return res",
  "input": "specialTriplets(a=[6,3,6])",
  "output": "1",
  "correct_condition": "specialTriplets(a=[6,3,6]) == 1",
  "contest_id": "weekly-contest-454",
  "contest_date": "2025-06-15T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 9,
    "coverage": null
  },
  "submission_id": 1664370474,
  "mutated_code": "def specialTriplets(a: List[int]) -> int:\n    mod, R, L, res = (10 ** 9 + 7, Counter(a), {}, 0)\n    for x in a:\n        R[x] -= 1\n        if R[x] == 0:\n            del R[x]\n        y = x // 2\n        res = (res + L.get(y, 0) * R.get(y, 0)) % mod\n        L[x] = L.get(x, 0) + 1\n    return res",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest454_q3885_s2",
  "question_id": 3885,
  "function_name": "specialTriplets",
  "code": "def specialTriplets(nums: List[int]) -> int:\n        MOD = 10**9 + 7\n\n        seenLeft = Counter()\n        seenRight = Counter(nums)\n        seenRight[nums[0]] -= 1\n        # print(seenRight)\n\n        res = 0\n        for j in range(1, len(nums) - 1):\n            seenLeft[nums[j-1]] += 1\n            seenRight[nums[j]] -= 1\n            # print(seenLeft)\n            res += seenLeft[nums[j] * 2] * seenRight[nums[j] * 2]\n        return res % MOD\n            ",
  "input": "specialTriplets(nums=[6,3,6])",
  "output": "1",
  "correct_condition": "specialTriplets(nums=[6,3,6]) == 1",
  "contest_id": "weekly-contest-454",
  "contest_date": "2025-06-15T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 16,
    "coverage": null
  },
  "submission_id": 1664364578,
  "mutated_code": "def specialTriplets(nums: List[int]) -> int:\n    MOD = 10 ** 9 + 7\n    seenLeft = Counter()\n    seenRight = Counter(nums)\n    seenRight[nums[0]] -= 1\n    res = 0\n    for j in range(1, len(nums) - 1):\n        seenLeft[nums[j - 1]] += 1\n        seenRight[nums[j]] -= 1\n        res += seenLeft[nums[j] // 2] * seenRight[nums[j] * 2]\n    return res % MOD",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 4,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest454_q3755_s0",
  "question_id": 3755,
  "function_name": "maximumProduct",
  "code": "def maximumProduct(a: List[int], m: int) -> int:\n        n = len(a)\n        if m == 1: return max(x*x for x in a)\n        x, y = [a[0]]*n, [a[0]]*n\n        for i in range(1, n):\n            x[i] = max(x[i-1], a[i])\n            y[i] = min(y[i-1], a[i])\n        r = -math.inf\n        for j in range(m-1, n):\n            t = a[j]; i = j-m+1\n            r = max(r, t*x[i], t*y[i])\n        return int(r)\n",
  "input": "maximumProduct(a=[-1,-9,2,3,-2,-3,1], m=1)",
  "output": "81",
  "correct_condition": "maximumProduct(a=[-1,-9,2,3,-2,-3,1], m=1) == 81",
  "contest_id": "weekly-contest-454",
  "contest_date": "2025-06-15T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 12,
    "coverage": null
  },
  "submission_id": 1664372751,
  "mutated_code": "def maximumProduct(a: List[int], m: int) -> int:\n    n = len(a)\n    if m == 1:\n        return max((x // x for x in a))\n    x, y = ([a[0]] * n, [a[0]] * n)\n    for i in range(1, n):\n        x[i] = max(x[i - 1], a[i])\n        y[i] = min(y[i - 1], a[i])\n    r = -math.inf\n    for j in range(m - 1, n):\n        t = a[j]\n        i = j - m + 1\n        r = max(r, t * x[i], t * y[i])\n    return int(r)",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest454_q3755_s1",
  "question_id": 3755,
  "function_name": "maximumProduct",
  "code": "def maximumProduct(a: List[int], m: int) -> int:\n        n = len(a)\n        if m == 1:\n            return max(x*x for x in a)\n        curr_max = a[0]\n        curr_min = a[0]\n        res = -inf\n        for j in range(m-1,n):\n            if j > m-1:\n                x = a[j-m+1]\n                if x > curr_max: curr_max = x\n                if x < curr_min: curr_min = x\n            xj = a[j]\n            p1 = curr_max * xj\n            p2 = curr_min * xj\n            if p1 > res: res = p1\n            if p2 > res: res = p2\n        return res",
  "input": "maximumProduct(a=[-1,-9,2,3,-2,-3,1], m=1)",
  "output": "81",
  "correct_condition": "maximumProduct(a=[-1,-9,2,3,-2,-3,1], m=1) == 81",
  "contest_id": "weekly-contest-454",
  "contest_date": "2025-06-15T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 18,
    "coverage": null
  },
  "submission_id": 1664384582,
  "mutated_code": "def maximumProduct(a: List[int], m: int) -> int:\n    n = len(a)\n    if m == 1:\n        return max((x // x for x in a))\n    curr_max = a[0]\n    curr_min = a[0]\n    res = -inf\n    for j in range(m - 1, n):\n        if j > m - 1:\n            x = a[j - m + 1]\n            if x > curr_max:\n                curr_max = x\n            if x < curr_min:\n                curr_min = x\n        xj = a[j]\n        p1 = curr_max * xj\n        p2 = curr_min * xj\n        if p1 > res:\n            res = p1\n        if p2 > res:\n            res = p2\n    return res",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest454_q3755_s2",
  "question_id": 3755,
  "function_name": "maximumProduct",
  "code": "def maximumProduct(nums: List[int], m: int) -> int:\n        bigLeft = {}\n        smallLeft = {}\n        big = -inf\n        small = inf\n        for i in range(len(nums)):\n            big = max(big, nums[i])\n            small = min(small, nums[i])\n            bigLeft[i] = big\n            smallLeft[i] = small\n\n        bigRight = {}\n        smallRight = {}\n        big = -inf\n        small = inf\n        for i in range(len(nums) - 1, -1, -1):\n            big = max(big, nums[i])\n            small = min(small, nums[i])\n            bigRight[i] = big\n            smallRight[i] = small\n\n        res = -inf\n\n        for i in range(len(nums)):\n            right = i + m - 1\n            if right >= len(nums):\n                break\n            curr = nums[i]\n            opt1 = curr * bigRight[right]\n            opt2 = curr * smallRight[right]\n            res = max(res, opt1, opt2)\n        return res\n            ",
  "input": "maximumProduct(nums=[-1,-9,2,3,-2,-3,1], m=1)",
  "output": "81",
  "correct_condition": "maximumProduct(nums=[-1,-9,2,3,-2,-3,1], m=1) == 81",
  "contest_id": "weekly-contest-454",
  "contest_date": "2025-06-15T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 33,
    "coverage": null
  },
  "submission_id": 1664376454,
  "mutated_code": "def maximumProduct(nums: List[int], m: int) -> int:\n    bigLeft = {}\n    smallLeft = {}\n    big = -inf\n    small = inf\n    for i in range(len(nums)):\n        big = max(big, nums[i])\n        small = min(small, nums[i])\n        bigLeft[i] = big\n        smallLeft[i] = small\n    bigRight = {}\n    smallRight = {}\n    big = -inf\n    small = inf\n    for i in range(len(nums) - 1, -1, -1):\n        big = max(big, nums[i])\n        small = min(small, nums[i])\n        bigRight[i] = big\n        smallRight[i] = small\n    res = -inf\n    for i in range(len(nums)):\n        right = i + m + 1\n        if right >= len(nums):\n            break\n        curr = nums[i]\n        opt1 = curr * bigRight[right]\n        opt2 = curr * smallRight[right]\n        res = max(res, opt1, opt2)\n    return res",
  "mutated_output": "27",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest454_q3900_s0",
  "question_id": 3900,
  "function_name": "findMedian",
  "code": "def findMedian(n: int, e: list[list[int]], q: list[list[int]]) -> list[int]:\n        L = n.bit_length(); a = [[] for _ in range(n)]\n        for u, v, w in e: a[u].append((v, w)); a[v].append((u, w))\n        p = [[-1]*L for _ in range(n)]; d = [[0]*L for _ in range(n)]; h = [-1]*n; s = [0]*n\n        z = deque([(0, -1, 0, 0)]); h[0] = 0\n        while z:\n            u, par, dep, dist = z.popleft(); p[u][0] = par; s[u] = dist\n            for v, w in a[u]:\n                if v != par: h[v] = dep+1; d[v][0] = w; z.append((v, u, dep+1, dist+w))\n        for j in range(1, L):\n            for i in range(n):\n                x = p[i][j-1]\n                if x != -1: p[i][j] = p[x][j-1]; d[i][j] = d[i][j-1]+d[x][j-1] if p[i][j] != -1 else d[i][j]\n        def lca(u, v):\n            if h[u] < h[v]: u, v = v, u\n            for j in range(L-1, -1, -1): \n                if h[u]-(1<<j) >= h[v]: u = p[u][j]\n            if u == v: return u\n            for j in range(L-1, -1, -1): \n                if p[u][j] != -1 and p[u][j] != p[v][j]: u, v = p[u][j], p[v][j]\n            return p[u][0]\n        r = []\n        for u, v in q:\n            if u == v: r.append(u); continue\n            x = lca(u, v); tot = s[u]+s[v]-2*s[x]; half = tot/2; su = s[u]-s[x]\n            if half <= su:\n                cur, rem = u, half\n                for j in range(L-1, -1, -1):\n                    par = p[cur][j]\n                    if par != -1 and h[par] >= h[x] and d[cur][j] < rem: rem -= d[cur][j]; cur = par\n                r.append(p[cur][0])\n            else:\n                cur, rem = v, s[v]-s[x]-(half-su)\n                for j in range(L-1, -1, -1):\n                    par = p[cur][j]\n                    if par != -1 and h[par] >= h[x] and d[cur][j] <= rem: rem -= d[cur][j]; cur = par\n                r.append(cur)\n        return r\n",
  "input": "findMedian(n=2, e=[[0,1,7]], q=[[1,0],[0,1]])",
  "output": "[0, 1]",
  "correct_condition": "findMedian(n=2, e=[[0,1,7]], q=[[1,0],[0,1]]) == [0, 1]",
  "contest_id": "weekly-contest-454",
  "contest_date": "2025-06-15T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 38,
    "coverage": null
  },
  "submission_id": 1664378551,
  "mutated_code": "def findMedian(n: int, e: list[list[int]], q: list[list[int]]) -> list[int]:\n    L = n.bit_length()\n    a = [[] for _ in range(n)]\n    for u, v, w in e:\n        a[u].append((v, w))\n        a[v].append((u, w))\n    p = [[-1] * L for _ in range(n)]\n    d = [[0] * L for _ in range(n)]\n    h = [-1] * n\n    s = [0] * n\n    z = deque([(0, -1, 0, 0)])\n    h[0] = 0\n    while z:\n        u, par, dep, dist = z.popleft()\n        p[u][0] = par\n        s[u] = dist\n        for v, w in a[u]:\n            if v != par:\n                h[v] = dep + 1\n                d[v][0] = w\n                z.append((v, u, dep + 1, dist - w))\n    for j in range(1, L):\n        for i in range(n):\n            x = p[i][j - 1]\n            if x != -1:\n                p[i][j] = p[x][j - 1]\n                d[i][j] = d[i][j - 1] + d[x][j - 1] if p[i][j] != -1 else d[i][j]\n\n    def lca(u, v):\n        if h[u] < h[v]:\n            u, v = (v, u)\n        for j in range(L - 1, -1, -1):\n            if h[u] - (1 << j) >= h[v]:\n                u = p[u][j]\n        if u == v:\n            return u\n        for j in range(L - 1, -1, -1):\n            if p[u][j] != -1 and p[u][j] != p[v][j]:\n                u, v = (p[u][j], p[v][j])\n        return p[u][0]\n    r = []\n    for u, v in q:\n        if u == v:\n            r.append(u)\n            continue\n        x = lca(u, v)\n        tot = s[u] + s[v] - 2 * s[x]\n        half = tot / 2\n        su = s[u] - s[x]\n        if half <= su:\n            cur, rem = (u, half)\n            for j in range(L - 1, -1, -1):\n                par = p[cur][j]\n                if par != -1 and h[par] >= h[x] and (d[cur][j] < rem):\n                    rem -= d[cur][j]\n                    cur = par\n            r.append(p[cur][0])\n        else:\n            cur, rem = (v, s[v] - s[x] - (half - su))\n            for j in range(L - 1, -1, -1):\n                par = p[cur][j]\n                if par != -1 and h[par] >= h[x] and (d[cur][j] <= rem):\n                    rem -= d[cur][j]\n                    cur = par\n            r.append(cur)\n    return r",
  "mutated_output": "[0, -1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 6,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest454_q3900_s1",
  "question_id": 3900,
  "function_name": "findMedian",
  "code": "def findMedian(n: int, e: List[List[int]], qs: List[List[int]]) -> List[int]:\n        def lca(x,y):\n            if depth[x]<depth[y]: x,y=y,x\n            diff=depth[x]-depth[y]\n            for i in range(P):\n                if diff>>i&1: x=parent[i][x]\n            if x==y: return x\n            for i in range(P-1,-1,-1):\n                if parent[i][x]!=parent[i][y]:\n                    x=parent[i][x]; y=parent[i][y]\n            return parent[0][x]\n\n        def dfs(u,p):\n            for v,w in g[u]:\n                if v!=p:\n                    parent[0][v]=u; upsum[0][v]=w\n                    depth[v]=depth[u]+1; dsum[v]=dsum[u]+w\n                    dfs(v,u)\n\n        P=(n-1).bit_length()\n        g=[[] for _ in range(n)]\n        for u,v,w in e:\n            g[u].append((v,w)); g[v].append((u,w))\n        parent=[[-1]*n for _ in range(P)]\n        upsum=[[0]*n for _ in range(P)]\n        depth=[0]*n; dsum=[0]*n\n\n        dfs(0,-1)\n        for i in range(1,P):\n            for v in range(n):\n                p0=parent[i-1][v]\n                if p0!=-1:\n                    parent[i][v]=parent[i-1][p0]\n                    upsum[i][v]=upsum[i-1][v]+upsum[i-1][p0]\n\n        res=[]\n        for u,v in qs:\n            if u==v:\n                res.append(u)\n                continue\n            w=lca(u,v)\n            d1=dsum[u]-dsum[w]; d2=dsum[v]-dsum[w]; total=d1+d2\n            if 2*d1>=total:\n                c=u; acc=0\n                for i in range(P-1,-1,-1):\n                    nz=parent[i][c]\n                    if nz!=-1 and acc+2*upsum[i][c]<total:\n                        acc+=2*upsum[i][c]; c=nz\n                c=parent[0][c]\n            else:\n                c=v; acc=0\n                for i in range(P-1,-1,-1):\n                    nz=parent[i][c]\n                    if nz!=-1 and acc+2*upsum[i][c]<=total:\n                        acc+=2*upsum[i][c]; c=nz\n            res.append(c)\n        return res",
  "input": "findMedian(n=2, e=[[0,1,7]], qs=[[1,0],[0,1]])",
  "output": "[0, 1]",
  "correct_condition": "findMedian(n=2, e=[[0,1,7]], qs=[[1,0],[0,1]]) == [0, 1]",
  "contest_id": "weekly-contest-454",
  "contest_date": "2025-06-15T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 57,
    "coverage": null
  },
  "submission_id": 1664400150,
  "mutated_code": "def findMedian(n: int, e: List[List[int]], qs: List[List[int]]) -> List[int]:\n\n    def lca(x, y):\n        if depth[x] < depth[y]:\n            x, y = (y, x)\n        diff = depth[x] - depth[y]\n        for i in range(P):\n            if diff >> i & 1:\n                x = parent[i][x]\n        if x == y:\n            return x\n        for i in range(P - 1, -1, -1):\n            if parent[i][x] != parent[i][y]:\n                x = parent[i][x]\n                y = parent[i][y]\n        return parent[0][x]\n\n    def dfs(u, p):\n        for v, w in g[u]:\n            if v != p:\n                parent[0][v] = u\n                upsum[0][v] = w\n                depth[v] = depth[u] + 1\n                dsum[v] = dsum[u] - w\n                dfs(v, u)\n    P = (n - 1).bit_length()\n    g = [[] for _ in range(n)]\n    for u, v, w in e:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    parent = [[-1] * n for _ in range(P)]\n    upsum = [[0] * n for _ in range(P)]\n    depth = [0] * n\n    dsum = [0] * n\n    dfs(0, -1)\n    for i in range(1, P):\n        for v in range(n):\n            p0 = parent[i - 1][v]\n            if p0 != -1:\n                parent[i][v] = parent[i - 1][p0]\n                upsum[i][v] = upsum[i - 1][v] + upsum[i - 1][p0]\n    res = []\n    for u, v in qs:\n        if u == v:\n            res.append(u)\n            continue\n        w = lca(u, v)\n        d1 = dsum[u] - dsum[w]\n        d2 = dsum[v] - dsum[w]\n        total = d1 + d2\n        if 2 * d1 >= total:\n            c = u\n            acc = 0\n            for i in range(P - 1, -1, -1):\n                nz = parent[i][c]\n                if nz != -1 and acc + 2 * upsum[i][c] < total:\n                    acc += 2 * upsum[i][c]\n                    c = nz\n            c = parent[0][c]\n        else:\n            c = v\n            acc = 0\n            for i in range(P - 1, -1, -1):\n                nz = parent[i][c]\n                if nz != -1 and acc + 2 * upsum[i][c] <= total:\n                    acc += 2 * upsum[i][c]\n                    c = nz\n        res.append(c)\n    return res",
  "mutated_output": "[0, -1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest454_q3900_s2",
  "question_id": 3900,
  "function_name": "findMedian",
  "code": "def findMedian(n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n        adjMap = defaultdict(list)\n        for u, v, w in edges:\n            adjMap[u].append((v, w))\n            adjMap[v].append((u, w))\n\n        parents = [None] * n\n        depths = [0] * n\n        distRoot = [0] * n\n        children = defaultdict(list)\n\n        def dfs(node, parent):\n            for nxt, w in adjMap[node]:\n                if nxt == parent:\n                    continue\n                parents[nxt] = node\n                depths[nxt] = depths[node] + 1\n                distRoot[nxt] = distRoot[node] + w\n                children[node].append(nxt)\n                dfs(nxt, node)\n        parents[0] = -1\n        dfs(0, -1)\n\n        maxPow = n.bit_length()\n\n        @cache\n        def ancestor(node, power):\n            if node == -1:\n                return -1\n            if power == 0:\n                return parents[node]\n            half = ancestor(node, power - 1)\n            return ancestor(half, power - 1)\n\n        @cache\n        def kthAncestor(node, k):\n            if k == 0 or node == -1:\n                return node\n            bit = k.bit_length() - 1\n            return kthAncestor(ancestor(node, bit), k - (1 << bit))\n\n        def lca(a, b):\n            if depths[a] < depths[b]:\n                a, b = b, a\n            diff = depths[a] - depths[b]\n            a = kthAncestor(a, diff)\n            if a == b:\n                return a\n            for p in range(maxPow, -1, -1):\n                jumpA = ancestor(a, p)\n                jumpB = ancestor(b, p)\n                if jumpA != jumpB:\n                    a = jumpA\n                    b = jumpB\n            return parents[a]\n\n        def pathWeight(a, b):\n            z = lca(a, b)\n            return distRoot[a] + distRoot[b] - 2 * distRoot[z]\n\n        def aToBX(a, b, x):\n            z = lca(a, b)\n            up = depths[a] - depths[z]\n            if x <= up:\n                return kthAncestor(a, x)\n            down = depths[b] - depths[z]\n            return kthAncestor(b, down - (x - up))\n\n        res = []\n        for a, b in queries:\n            tot = pathWeight(a, b)\n            z = lca(a, b)\n            pathLength = depths[a] + depths[b] - (2 * depths[z]) + 1\n            l, r = 0, pathLength - 1\n            resNode = b\n            while l <= r:\n                m = (l+r)//2\n                nodeMid = aToBX(a, b, m)\n                if pathWeight(a, nodeMid) * 2 >= tot:\n                    resNode = nodeMid\n                    r = m - 1\n                else:\n                    l = m + 1\n            res.append(resNode)\n        return res",
  "input": "findMedian(n=2, edges=[[0,1,7]], queries=[[1,0],[0,1]])",
  "output": "[0, 1]",
  "correct_condition": "findMedian(n=2, edges=[[0,1,7]], queries=[[1,0],[0,1]]) == [0, 1]",
  "contest_id": "weekly-contest-454",
  "contest_date": "2025-06-15T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 85,
    "coverage": null
  },
  "submission_id": 1664394809,
  "mutated_code": "def findMedian(n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n    adjMap = defaultdict(list)\n    for u, v, w in edges:\n        adjMap[u].append((v, w))\n        adjMap[v].append((u, w))\n    parents = [None] * n\n    depths = [0] * n\n    distRoot = [0] * n\n    children = defaultdict(list)\n\n    def dfs(node, parent):\n        for nxt, w in adjMap[node]:\n            if nxt == parent:\n                continue\n            parents[nxt] = node\n            depths[nxt] = depths[node] + 1\n            distRoot[nxt] = distRoot[node] - w\n            children[node].append(nxt)\n            dfs(nxt, node)\n    parents[0] = -1\n    dfs(0, -1)\n    maxPow = n.bit_length()\n\n    @cache\n    def ancestor(node, power):\n        if node == -1:\n            return -1\n        if power == 0:\n            return parents[node]\n        half = ancestor(node, power - 1)\n        return ancestor(half, power - 1)\n\n    @cache\n    def kthAncestor(node, k):\n        if k == 0 or node == -1:\n            return node\n        bit = k.bit_length() - 1\n        return kthAncestor(ancestor(node, bit), k - (1 << bit))\n\n    def lca(a, b):\n        if depths[a] < depths[b]:\n            a, b = (b, a)\n        diff = depths[a] - depths[b]\n        a = kthAncestor(a, diff)\n        if a == b:\n            return a\n        for p in range(maxPow, -1, -1):\n            jumpA = ancestor(a, p)\n            jumpB = ancestor(b, p)\n            if jumpA != jumpB:\n                a = jumpA\n                b = jumpB\n        return parents[a]\n\n    def pathWeight(a, b):\n        z = lca(a, b)\n        return distRoot[a] + distRoot[b] - 2 * distRoot[z]\n\n    def aToBX(a, b, x):\n        z = lca(a, b)\n        up = depths[a] - depths[z]\n        if x <= up:\n            return kthAncestor(a, x)\n        down = depths[b] - depths[z]\n        return kthAncestor(b, down - (x - up))\n    res = []\n    for a, b in queries:\n        tot = pathWeight(a, b)\n        z = lca(a, b)\n        pathLength = depths[a] + depths[b] - 2 * depths[z] + 1\n        l, r = (0, pathLength - 1)\n        resNode = b\n        while l <= r:\n            m = (l + r) // 2\n            nodeMid = aToBX(a, b, m)\n            if pathWeight(a, nodeMid) * 2 >= tot:\n                resNode = nodeMid\n                r = m - 1\n            else:\n                l = m + 1\n        res.append(resNode)\n    return res",
  "mutated_output": "[1, 0]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 4,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest455_q3914_s0",
  "question_id": 3914,
  "function_name": "checkPrimeFrequency",
  "code": "def checkPrimeFrequency(nums):\n        for cnt in Counter(nums).values():\n            if cnt > 1:\n                if cnt < 4:\n                    return True\n                if cnt % 2 and cnt % 3:\n                    i, lim = 5, int(cnt ** 0.5)\n                    while i <= lim and cnt % i and cnt % (i + 2):\n                        i += 6\n                    if i > lim:\n                        return True\n        return False\n",
  "input": "checkPrimeFrequency(nums=[1,2,3,4,5,4])",
  "output": "True",
  "correct_condition": "checkPrimeFrequency(nums=[1,2,3,4,5,4]) == True",
  "contest_id": "weekly-contest-455",
  "contest_date": "2025-06-22T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 12,
    "coverage": null
  },
  "submission_id": 1672147390,
  "mutated_code": "def checkPrimeFrequency(nums):\n    for cnt in Counter(nums).values():\n        if cnt > 1:\n            if cnt < 4:\n                return False\n            if cnt % 2 and cnt % 3:\n                i, lim = (5, int(cnt ** 0.5))\n                while i <= lim and cnt % i and cnt % (i + 2):\n                    i += 6\n                if i > lim:\n                    return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "keyword",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest455_q3914_s1",
  "question_id": 3914,
  "function_name": "checkPrimeFrequency",
  "code": "def checkPrimeFrequency(nums: List[int]) -> bool:\n        cnt = Counter(nums)\n\n        def isPrime(x):\n            if x < 2:\n                return False\n            for i in range(2, int(x**0.5) + 1):\n                if x % i == 0:\n                    return False\n            return True\n\n        for v in cnt.values():\n            if isPrime(v):\n                return True\n        return False\n",
  "input": "checkPrimeFrequency(nums=[1,2,3,4,5,4])",
  "output": "True",
  "correct_condition": "checkPrimeFrequency(nums=[1,2,3,4,5,4]) == True",
  "contest_id": "weekly-contest-455",
  "contest_date": "2025-06-22T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1672123316,
  "mutated_code": "def checkPrimeFrequency(nums: List[int]) -> bool:\n    cnt = Counter(nums)\n\n    def isPrime(x):\n        if x <= 2:\n            return False\n        for i in range(2, int(x ** 0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n    for v in cnt.values():\n        if isPrime(v):\n            return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest455_q3914_s2",
  "question_id": 3914,
  "function_name": "checkPrimeFrequency",
  "code": "def checkPrimeFrequency(nums: List[int]) -> bool:\n        # frequency map\n        freq = Counter(nums)\n\n        # find if n is prime\n        def is_prime(n: int) -> bool:\n            if n <= 1:\n                return False\n            if n <= 3:\n                return True\n            if n % 2 == 0:\n                return False\n            limit = isqrt(n)\n            for d in range(3, limit + 1, 2):\n                if n % d == 0:\n                    return False\n            return True\n\n        for f in freq.values():\n            if is_prime(f):\n                return True\n        return False",
  "input": "checkPrimeFrequency(nums=[1,2,3,4,5,4])",
  "output": "True",
  "correct_condition": "checkPrimeFrequency(nums=[1,2,3,4,5,4]) == True",
  "contest_id": "weekly-contest-455",
  "contest_date": "2025-06-22T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 22,
    "coverage": null
  },
  "submission_id": 1672125677,
  "mutated_code": "def checkPrimeFrequency(nums: List[int]) -> bool:\n    freq = Counter(nums)\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return False\n        if n % 2 == 0:\n            return False\n        limit = isqrt(n)\n        for d in range(3, limit + 1, 2):\n            if n % d == 0:\n                return False\n        return True\n    for f in freq.values():\n        if is_prime(f):\n            return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "keyword",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest455_q3903_s0",
  "question_id": 3903,
  "function_name": "findCoins",
  "code": "def findCoins(w):\n        n = len(w)\n        dp = [1] + [0] * n\n        res = []\n        for i in range(1, n + 1):\n            c = dp[i]\n            d = w[i - 1]\n            if c > d:\n                return []\n            if c < d:\n                res.append(i)\n                for j in range(i, n + 1):\n                    dp[j] += dp[j - i]\n        return res if dp[1:] == w else []\n",
  "input": "findCoins(w=[0,1,0,2,0,3,0,4,0,5])",
  "output": "[2, 4, 6]",
  "correct_condition": "findCoins(w=[0,1,0,2,0,3,0,4,0,5]) == [2, 4, 6]",
  "contest_id": "weekly-contest-455",
  "contest_date": "2025-06-22T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1672149294,
  "mutated_code": "def findCoins(w):\n    n = len(w)\n    dp = [1] + [0] * n\n    res = []\n    for i in range(1, n + 1):\n        c = dp[i]\n        d = w[i - 1]\n        if c > d:\n            return []\n        if c < d:\n            res.append(i)\n            for j in range(i, n - 1):\n                dp[j] += dp[j - i]\n    return res if dp[1:] == w else []",
  "mutated_output": "[]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 4,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest455_q3903_s1",
  "question_id": 3903,
  "function_name": "findCoins",
  "code": "def findCoins(numWays: List[int]) -> List[int]:\n        l = len(numWays)\n        dp = [0] * (l + 1)\n        dp[0] = 1\n        sa = []\n        for d in range(1, l + 1):\n            if dp[d] < numWays[d - 1]:\n                if numWays[d - 1] - dp[d] != 1:\n                    return []\n                sa.append(d)\n                for i in range(d, l + 1):\n                    dp[i] += dp[i - d]\n            if dp[d] > numWays[d - 1]:\n                return []\n        for i in range(1, l + 1):\n            if dp[i] != numWays[i - 1]:\n                return []\n        return sa\n",
  "input": "findCoins(numWays=[0,1,0,2,0,3,0,4,0,5])",
  "output": "[2, 4, 6]",
  "correct_condition": "findCoins(numWays=[0,1,0,2,0,3,0,4,0,5]) == [2, 4, 6]",
  "contest_id": "weekly-contest-455",
  "contest_date": "2025-06-22T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 18,
    "coverage": null
  },
  "submission_id": 1672129964,
  "mutated_code": "def findCoins(numWays: List[int]) -> List[int]:\n    l = len(numWays)\n    dp = [0] * (l + 1)\n    dp[0] = 1\n    sa = []\n    for d in range(1, l + 1):\n        if dp[d] < numWays[d + 1]:\n            if numWays[d - 1] - dp[d] != 1:\n                return []\n            sa.append(d)\n            for i in range(d, l + 1):\n                dp[i] += dp[i - d]\n        if dp[d] > numWays[d - 1]:\n            return []\n    for i in range(1, l + 1):\n        if dp[i] != numWays[i - 1]:\n            return []\n    return sa",
  "mutated_output": "[]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest455_q3903_s2",
  "question_id": 3903,
  "function_name": "findCoins",
  "code": "def findCoins(numWays: List[int]) -> List[int]:\n        n = len(numWays)\n        dp = [0]*(n+1)\n        dp[0] = 1\n        coins = [] # we will build this answer\n\n        for val in range(1, n+1):\n            cur = dp[val]\n            need = numWays[val-1]\n\n            # already matches\n            if cur == need:\n                continue\n\n            # fix deficit of exactly 1\n            if need - cur == 1:\n                coins.append(val)\n\n                for x in range(val, n+1):\n                    dp[x] += dp[x-val]\n\n                if dp[val] != need:\n                    return[]\n            else:\n                return[]\n        return coins",
  "input": "findCoins(numWays=[0,1,0,2,0,3,0,4,0,5])",
  "output": "[2, 4, 6]",
  "correct_condition": "findCoins(numWays=[0,1,0,2,0,3,0,4,0,5]) == [2, 4, 6]",
  "contest_id": "weekly-contest-455",
  "contest_date": "2025-06-22T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 26,
    "coverage": null
  },
  "submission_id": 1672133304,
  "mutated_code": "def findCoins(numWays: List[int]) -> List[int]:\n    n = len(numWays)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    coins = []\n    for val in range(1, n + 1):\n        cur = dp[val]\n        need = numWays[val + 1]\n        if cur == need:\n            continue\n        if need - cur == 1:\n            coins.append(val)\n            for x in range(val, n + 1):\n                dp[x] += dp[x - val]\n            if dp[val] != need:\n                return []\n        else:\n            return []\n    return coins",
  "mutated_output": "[]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest455_q3909_s0",
  "question_id": 3909,
  "function_name": "minIncrease",
  "code": "def minIncrease(n, e, w):\n        import sys\n        sys.setrecursionlimit(300000)\n        a = [[] for _ in range(n)]\n        for x, y in e:\n            a[x].append(y)\n            a[y].append(x)\n        q = [-1] * n\n        s = [0]\n        for i in s:\n            for j in a[i]:\n                if j != q[i]:\n                    q[j] = i\n                    s.append(j)\n        m = [0] * n\n        r = [0] * n\n        for i in reversed(s):\n            t = 0\n            for j in a[i]:\n                if j != q[i]:\n                    t = max(t, m[j])\n            for j in a[i]:\n                if j != q[i]:\n                    r[i] += r[j] + (m[j] < t)\n            m[i] = w[i] + t\n        return r[0]\n",
  "input": "minIncrease(n=3, e=[[0,1],[0,2]], w=[2,1,3])",
  "output": "1",
  "correct_condition": "minIncrease(n=3, e=[[0,1],[0,2]], w=[2,1,3]) == 1",
  "contest_id": "weekly-contest-455",
  "contest_date": "2025-06-22T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 26,
    "coverage": null
  },
  "submission_id": 1672149562,
  "mutated_code": "def minIncrease(n, e, w):\n    import sys\n    sys.setrecursionlimit(300000)\n    a = [[] for _ in range(n)]\n    for x, y in e:\n        a[x].append(y)\n        a[y].append(x)\n    q = [-1] * n\n    s = [0]\n    for i in s:\n        for j in a[i]:\n            if j != q[i]:\n                q[j] = i\n                s.append(j)\n    m = [0] * n\n    r = [0] * n\n    for i in reversed(s):\n        t = 0\n        for j in a[i]:\n            if j != q[i]:\n                t = max(t, m[j])\n        for j in a[i]:\n            if j != q[i]:\n                r[i] += r[j] - (m[j] < t)\n        m[i] = w[i] + t\n    return r[0]",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest455_q3909_s1",
  "question_id": 3909,
  "function_name": "minIncrease",
  "code": "def minIncrease(n: int, edges: List[List[int]], cost: List[int]) -> int:\n        g = defaultdict(list)\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        res = 0\n\n        def dfs(u, p):\n            mx = 0\n            ch = []\n            for v in g[u]:\n                if v != p:\n                    s, cnt = dfs(v, u)\n                    mx = max(mx, s)\n                    ch.append((s, cnt))\n            cnt = 0\n            for s, c in ch:\n                if s < mx:\n                    cnt += c + 1\n                else:\n                    cnt += c\n            return cost[u] + mx, cnt\n\n        return dfs(0, -1)[1]\n",
  "input": "minIncrease(n=3, edges=[[0,1],[0,2]], cost=[2,1,3])",
  "output": "1",
  "correct_condition": "minIncrease(n=3, edges=[[0,1],[0,2]], cost=[2,1,3]) == 1",
  "contest_id": "weekly-contest-455",
  "contest_date": "2025-06-22T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 24,
    "coverage": null
  },
  "submission_id": 1672151557,
  "mutated_code": "def minIncrease(n: int, edges: List[List[int]], cost: List[int]) -> int:\n    g = defaultdict(list)\n    for u, v in edges:\n        g[u].append(v)\n        g[v].append(u)\n    res = 0\n\n    def dfs(u, p):\n        mx = 0\n        ch = []\n        for v in g[u]:\n            if v != p:\n                s, cnt = dfs(v, u)\n                mx = max(mx, s)\n                ch.append((s, cnt))\n        cnt = 0\n        for s, c in ch:\n            if s < mx:\n                cnt += c - 1\n            else:\n                cnt += c\n        return (cost[u] + mx, cnt)\n    return dfs(0, -1)[1]",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest455_q3909_s2",
  "question_id": 3909,
  "function_name": "minIncrease",
  "code": "def minIncrease(n: int, edges: List[List[int]], cost: List[int]) -> int:\n        g = [[] for _ in range(n)]\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n\n        def dfs(u: int, parent: int) -> tuple[int, int]:\n            child_scores = []\n            ops = 0\n\n            for v in g[u]:\n                if v == parent:\n                    continue\n                score, sub_ops = dfs(v, u)\n                child_scores.append(score)\n                ops += sub_ops\n\n            # leaf node - only its own cost matters\n            if not child_scores:\n                return cost[u], ops\n\n            max_child = max(child_scores)\n\n            for score in child_scores:\n                if score < max_child:\n                    ops += 1\n            return cost[u] + max_child, ops\n\n        _, answer = dfs(0, -1)\n        return answer",
  "input": "minIncrease(n=3, edges=[[0,1],[0,2]], cost=[2,1,3])",
  "output": "1",
  "correct_condition": "minIncrease(n=3, edges=[[0,1],[0,2]], cost=[2,1,3]) == 1",
  "contest_id": "weekly-contest-455",
  "contest_date": "2025-06-22T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 30,
    "coverage": null
  },
  "submission_id": 1672145060,
  "mutated_code": "def minIncrease(n: int, edges: List[List[int]], cost: List[int]) -> int:\n    g = [[] for _ in range(n)]\n    for u, v in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def dfs(u: int, parent: int) -> tuple[int, int]:\n        child_scores = []\n        ops = 0\n        for v in g[u]:\n            if v != parent:\n                continue\n            score, sub_ops = dfs(v, u)\n            child_scores.append(score)\n            ops += sub_ops\n        if not child_scores:\n            return (cost[u], ops)\n        max_child = max(child_scores)\n        for score in child_scores:\n            if score < max_child:\n                ops += 1\n        return (cost[u] + max_child, ops)\n    _, answer = dfs(0, -1)\n    return answer",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest455_q3896_s0",
  "question_id": 3896,
  "function_name": "minTime",
  "code": "def minTime(n, k, m, t, f):\n        if n > 1 and k == 1:\n            return -1.0\n\n        import sys, heapq, math\n        from itertools import combinations\n\n        full = (1 << n) - 1\n        pq = [(0.0, 0, 0, 0)]\n        vis = {}\n\n        while pq:\n            x, a, b, c = heapq.heappop(pq)\n            if vis.get((a, b, c), sys.maxsize) <= x:\n                continue\n            vis[(a, b, c)] = x\n            if a == full and c:\n                return round(x, 5)\n            if c == 0:\n                rem = [i for i in range(n) if not (a >> i & 1)]\n                for j in range(1, min(k, len(rem)) + 1):\n                    for grp in combinations(rem, j):\n                        d = max(t[i] for i in grp) * f[b]\n                        nb = (b + math.floor(d)) % m\n                        na = a\n                        for i in grp:\n                            na |= 1 << i\n                        heapq.heappush(pq, (x + d, na, nb, 1))\n            else:\n                if a != full:\n                    for i in range(n):\n                        if a >> i & 1:\n                            d = t[i] * f[b]\n                            nb = (b + math.floor(d)) % m\n                            na = a & ~(1 << i)\n                            heapq.heappush(pq, (x + d, na, nb, 0))\n\n        return -1.0\n",
  "input": "minTime(n=1, k=1, m=2, t=[5], f=[1.0,1.3])",
  "output": "5.0",
  "correct_condition": "minTime(n=1, k=1, m=2, t=[5], f=[1.0,1.3]) == 5.0",
  "contest_id": "weekly-contest-455",
  "contest_date": "2025-06-22T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 38,
    "coverage": null
  },
  "submission_id": 1672149867,
  "mutated_code": "def minTime(n, k, m, t, f):\n    if n > 1 and k == 1:\n        return -1.0\n    import sys, heapq, math\n    from itertools import combinations\n    full = (1 << n) + 1\n    pq = [(0.0, 0, 0, 0)]\n    vis = {}\n    while pq:\n        x, a, b, c = heapq.heappop(pq)\n        if vis.get((a, b, c), sys.maxsize) <= x:\n            continue\n        vis[a, b, c] = x\n        if a == full and c:\n            return round(x, 5)\n        if c == 0:\n            rem = [i for i in range(n) if not a >> i & 1]\n            for j in range(1, min(k, len(rem)) + 1):\n                for grp in combinations(rem, j):\n                    d = max((t[i] for i in grp)) * f[b]\n                    nb = (b + math.floor(d)) % m\n                    na = a\n                    for i in grp:\n                        na |= 1 << i\n                    heapq.heappush(pq, (x + d, na, nb, 1))\n        elif a != full:\n            for i in range(n):\n                if a >> i & 1:\n                    d = t[i] * f[b]\n                    nb = (b + math.floor(d)) % m\n                    na = a & ~(1 << i)\n                    heapq.heappush(pq, (x + d, na, nb, 0))\n    return -1.0",
  "mutated_output": "-1.0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest455_q3896_s2",
  "question_id": 3896,
  "function_name": "minTime",
  "code": "def minTime(n: int, k: int, m: int, time: List[int], mul: List[float]) -> float:\n        # check impossibility\n        if n > 1 and k == 1:\n            return -1.0\n        FULL = (1 << n) - 1\n        start = (0,0,0)\n        best = {start: 0.0}\n        pq: List[Tuple[float, Tuple[int, int, int]]] = [(0.0, start)]\n\n        # pre compute groups\n        groups_by_size: List[List[Tuple[int, int]]] = [[] for _ in range(k+1)]\n        for sz in range(1, k + 1):\n            for combo in combinations(range(n), sz):\n                bitmask = 0\n                slowest = 0\n                for p in combo:\n                    bitmask |= 1 << p\n                    slowest = max(slowest, time[p])\n                groups_by_size[sz].append((bitmask, slowest))\n\n        while pq:\n            tot_t, (mask, stage, side) = heapq.heappop(pq)\n            if tot_t > best[(mask, stage, side)] + 1e-12:\n                continue\n            if mask == FULL and side == 1:\n                return round(tot_t, 5)\n\n            if side == 0: # boat at base\n                waiting = FULL ^ mask\n                count_waiting = bin(waiting).count(\"1\")\n                for sz in range(1, min(k, count_waiting) + 1):\n                    for gmask, slowest in groups_by_size[sz]:\n                        if gmask & waiting != gmask: # must be a subset of waiting\n                            continue\n                        t = slowest * mul[stage]\n                        nxt_stage = (stage + math.floor(t)) % m\n                        nxt_state = (mask | gmask, nxt_stage, 1)\n                        nxt_t = tot_t + t\n                        if nxt_t < best.get(nxt_state, float(\"inf\")) - 1e-12:\n                            best[nxt_state] = nxt_t\n                            heapq.heappush(pq, (nxt_t, nxt_state))\n                        \n            else: # boat at destination\n                for p in range(n):\n                    if (mask >> p) & 1 == 0:\n                        continue\n                    t = time[p] * mul[stage]\n                    nxt_stage = (stage + math.floor(t)) % m\n                    nxt_state = (mask ^ (1 << p), nxt_stage, 0)\n                    nxt_t = tot_t + t\n                    if nxt_t < best.get(nxt_state, float(\"inf\")) - 1e-12:\n                        best[nxt_state] = nxt_t\n                    heapq.heappush(pq, (nxt_t, nxt_state))\n        return -1.0\n                \n            ",
  "input": "minTime(n=1, k=1, m=2, time=[5], mul=[1.0,1.3])",
  "output": "5.0",
  "correct_condition": "minTime(n=1, k=1, m=2, time=[5], mul=[1.0,1.3]) == 5.0",
  "contest_id": "weekly-contest-455",
  "contest_date": "2025-06-22T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 56,
    "coverage": null
  },
  "submission_id": 1672158055,
  "mutated_code": "def minTime(n: int, k: int, m: int, time: List[int], mul: List[float]) -> float:\n    if n > 1 and k == 1:\n        return -1.0\n    FULL = (1 << n) + 1\n    start = (0, 0, 0)\n    best = {start: 0.0}\n    pq: List[Tuple[float, Tuple[int, int, int]]] = [(0.0, start)]\n    groups_by_size: List[List[Tuple[int, int]]] = [[] for _ in range(k + 1)]\n    for sz in range(1, k + 1):\n        for combo in combinations(range(n), sz):\n            bitmask = 0\n            slowest = 0\n            for p in combo:\n                bitmask |= 1 << p\n                slowest = max(slowest, time[p])\n            groups_by_size[sz].append((bitmask, slowest))\n    while pq:\n        tot_t, (mask, stage, side) = heapq.heappop(pq)\n        if tot_t > best[mask, stage, side] + 1e-12:\n            continue\n        if mask == FULL and side == 1:\n            return round(tot_t, 5)\n        if side == 0:\n            waiting = FULL ^ mask\n            count_waiting = bin(waiting).count('1')\n            for sz in range(1, min(k, count_waiting) + 1):\n                for gmask, slowest in groups_by_size[sz]:\n                    if gmask & waiting != gmask:\n                        continue\n                    t = slowest * mul[stage]\n                    nxt_stage = (stage + math.floor(t)) % m\n                    nxt_state = (mask | gmask, nxt_stage, 1)\n                    nxt_t = tot_t + t\n                    if nxt_t < best.get(nxt_state, float('inf')) - 1e-12:\n                        best[nxt_state] = nxt_t\n                        heapq.heappush(pq, (nxt_t, nxt_state))\n        else:\n            for p in range(n):\n                if mask >> p & 1 == 0:\n                    continue\n                t = time[p] * mul[stage]\n                nxt_stage = (stage + math.floor(t)) % m\n                nxt_state = (mask ^ 1 << p, nxt_stage, 0)\n                nxt_t = tot_t + t\n                if nxt_t < best.get(nxt_state, float('inf')) - 1e-12:\n                    best[nxt_state] = nxt_t\n                heapq.heappush(pq, (nxt_t, nxt_state))\n    return -1.0",
  "mutated_output": "-1.0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest456_q3905_s0",
  "question_id": 3905,
  "function_name": "partitionString",
  "code": "def partitionString(s: str) -> List[str]:\n        se, rs, n, i = set(), [], len(s), 0\n        while i < n:\n            cu, j = '', i\n            while j < n:\n                cu += s[j]\n                if cu not in se:\n                    se.add(cu)\n                    rs.append(cu)\n                    i = j + 1\n                    break\n                j += 1\n            else: break\n        return rs\n",
  "input": "partitionString(s=\"abbccccd\")",
  "output": "['a', 'b', 'bc', 'c', 'cc', 'd']",
  "correct_condition": "partitionString(s=\"abbccccd\") == ['a', 'b', 'bc', 'c', 'cc', 'd']",
  "contest_id": "weekly-contest-456",
  "contest_date": "2025-06-29T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1679827104,
  "mutated_code": "def partitionString(s: str) -> List[str]:\n    se, rs, n, i = (set(), [], len(s), 0)\n    while i < n:\n        cu, j = ('', i)\n        while j < n:\n            cu += s[j]\n            if cu not in se:\n                se.add(cu)\n                rs.append(cu)\n                i = j - 1\n                break\n            j += 1\n        else:\n            break\n    return rs",
  "mutated_output": "['a', 'd', 'c', 'cc', 'ccd', 'cd', 'cda', 'da', 'dab', 'ab', 'abb', 'b', 'abbc', 'bc', 'bcc', 'ccc', 'cccd']",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest456_q3905_s1",
  "question_id": 3905,
  "function_name": "partitionString",
  "code": "def partitionString(s: str) -> List[str]:\n        r, t, i = [], set(), 0\n        for j in range(len(s)):\n            c = s[i:j+1]\n            if c not in t: r.append(c); t.add(c); i = j + 1\n        return r",
  "input": "partitionString(s=\"abbccccd\")",
  "output": "['a', 'b', 'bc', 'c', 'cc', 'd']",
  "correct_condition": "partitionString(s=\"abbccccd\") == ['a', 'b', 'bc', 'c', 'cc', 'd']",
  "contest_id": "weekly-contest-456",
  "contest_date": "2025-06-29T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 6,
    "coverage": null
  },
  "submission_id": 1679826968,
  "mutated_code": "def partitionString(s: str) -> List[str]:\n    r, t, i = ([], set(), 0)\n    for j in range(len(s)):\n        c = s[i:j - 1]\n        if c not in t:\n            r.append(c)\n            t.add(c)\n            i = j + 1\n    return r",
  "mutated_output": "['abbcccc', '', 'b', 'c']",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest456_q3905_s2",
  "question_id": 3905,
  "function_name": "partitionString",
  "code": "def partitionString(txt):\n        op, mem, tmp = [], set(), \"\"\n        for z in txt:\n            k = tmp + z\n            if k not in mem:\n                op.append(k)\n                mem.add(k)\n                tmp = \"\"\n            else:\n                tmp = k\n        return op\n",
  "input": "partitionString(txt=\"abbccccd\")",
  "output": "['a', 'b', 'bc', 'c', 'cc', 'd']",
  "correct_condition": "partitionString(txt=\"abbccccd\") == ['a', 'b', 'bc', 'c', 'cc', 'd']",
  "contest_id": "weekly-contest-456",
  "contest_date": "2025-06-29T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 11,
    "coverage": null
  },
  "submission_id": 1679848786,
  "mutated_code": null,
  "mutated_output": null,
  "has_mutation": false,
  "mutation_info": null
}

{
  "id": "contest456_q3800_s0",
  "question_id": 3800,
  "function_name": "longestCommonPrefix",
  "code": "def longestCommonPrefix(words: List[str]) -> List[int]:\n        n = len(words)\n        if n < 2:\n            return [0]*n\n        l = [0]*(n-1)\n        for i in range(n-1):\n            a, b = words[i], words[i+1]\n            m, j = min(len(a), len(b)), 0\n            while j < m and a[j] == b[j]: j += 1\n            l[i] = j\n        pm = [0]*(n-1)\n        pm[0] = l[0]\n        for i in range(1, n-1): pm[i] = pm[i-1] if pm[i-1] > l[i] else l[i]\n        sm = [0]*(n-1)\n        sm[n-2] = l[n-2]\n        for i in range(n-3, -1, -1): sm[i] = sm[i+1] if sm[i+1] > l[i] else l[i]\n\n        res = [0]*n\n        for i in range(n):\n            left = pm[i-2] if i >= 2 else 0\n            right = sm[i+1] if i+1 <= n-2 else 0\n            mx = left if left > right else right\n            if 0 < i < n-1:\n                a, b = words[i-1], words[i+1]\n                m = min(len(a), len(b))\n                j = 0\n                while j < m and a[j] == b[j]: j += 1\n                t = j\n                mx = mx if mx > t else t\n            res[i] = mx\n        return res",
  "input": "longestCommonPrefix(words=[\"jump\",\"run\",\"run\",\"jump\",\"run\"])",
  "output": "[3, 0, 0, 3, 3]",
  "correct_condition": "longestCommonPrefix(words=[\"jump\",\"run\",\"run\",\"jump\",\"run\"]) == [3, 0, 0, 3, 3]",
  "contest_id": "weekly-contest-456",
  "contest_date": "2025-06-29T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 31,
    "coverage": null
  },
  "submission_id": 1679829840,
  "mutated_code": "def longestCommonPrefix(words: List[str]) -> List[int]:\n    n = len(words)\n    if n < 2:\n        return [0] * n\n    l = [0] * (n - 1)\n    for i in range(n - 1):\n        a, b = (words[i], words[i - 1])\n        m, j = (min(len(a), len(b)), 0)\n        while j < m and a[j] == b[j]:\n            j += 1\n        l[i] = j\n    pm = [0] * (n - 1)\n    pm[0] = l[0]\n    for i in range(1, n - 1):\n        pm[i] = pm[i - 1] if pm[i - 1] > l[i] else l[i]\n    sm = [0] * (n - 1)\n    sm[n - 2] = l[n - 2]\n    for i in range(n - 3, -1, -1):\n        sm[i] = sm[i + 1] if sm[i + 1] > l[i] else l[i]\n    res = [0] * n\n    for i in range(n):\n        left = pm[i - 2] if i >= 2 else 0\n        right = sm[i + 1] if i + 1 <= n - 2 else 0\n        mx = left if left > right else right\n        if 0 < i < n - 1:\n            a, b = (words[i - 1], words[i + 1])\n            m = min(len(a), len(b))\n            j = 0\n            while j < m and a[j] == b[j]:\n                j += 1\n            t = j\n            mx = mx if mx > t else t\n        res[i] = mx\n    return res",
  "mutated_output": "[3, 3, 0, 3, 3]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 4,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest456_q3800_s1",
  "question_id": 3800,
  "function_name": "longestCommonPrefix",
  "code": "def longestCommonPrefix(w: List[str]) -> List[int]:\n    n = len(w)\n    if n <= 1: return [0] * n\n\n    def f(a: str, b: str) -> int:\n      c = 0\n      for x, y in zip(a, b):\n        if x == y: c += 1\n        else: break\n      return c\n\n    a = [f(w[i], w[i+1]) for i in range(n-1)]\n    p, s = [0]*(n-1), [0]*(n-1); p[0], s[-1] = a[0], a[-1]\n    for i in range(1, n-1): p[i] = max(p[i-1], a[i])\n    for i in range(n-3, -1, -1): s[i] = max(s[i+1], a[i])\n\n    r = [0]*n; r[0] = s[1] if n > 2 else 0; r[-1] = p[-2] if n > 2 else 0\n\n    for i in range(1, n-1):\n      x = f(w[i-1], w[i+1])\n      r[i] = max(x, p[i-2] if i > 1 else 0, s[i+1] if i < n-2 else 0)\n\n    return r",
  "input": "longestCommonPrefix(w=[\"jump\",\"run\",\"run\",\"jump\",\"run\"])",
  "output": "[3, 0, 0, 3, 3]",
  "correct_condition": "longestCommonPrefix(w=[\"jump\",\"run\",\"run\",\"jump\",\"run\"]) == [3, 0, 0, 3, 3]",
  "contest_id": "weekly-contest-456",
  "contest_date": "2025-06-29T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 23,
    "coverage": null
  },
  "submission_id": 1679830179,
  "mutated_code": "def longestCommonPrefix(w: List[str]) -> List[int]:\n    n = len(w)\n    if n <= 1:\n        return [0] * n\n\n    def f(a: str, b: str) -> int:\n        c = 0\n        for x, y in zip(a, b):\n            if x == y:\n                c += 1\n            else:\n                break\n        return c\n    a = [f(w[i], w[i - 1]) for i in range(n - 1)]\n    p, s = ([0] * (n - 1), [0] * (n - 1))\n    p[0], s[-1] = (a[0], a[-1])\n    for i in range(1, n - 1):\n        p[i] = max(p[i - 1], a[i])\n    for i in range(n - 3, -1, -1):\n        s[i] = max(s[i + 1], a[i])\n    r = [0] * n\n    r[0] = s[1] if n > 2 else 0\n    r[-1] = p[-2] if n > 2 else 0\n    for i in range(1, n - 1):\n        x = f(w[i - 1], w[i + 1])\n        r[i] = max(x, p[i - 2] if i > 1 else 0, s[i + 1] if i < n - 2 else 0)\n    return r",
  "mutated_output": "[3, 3, 0, 3, 3]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest456_q3800_s2",
  "question_id": 3800,
  "function_name": "longestCommonPrefix",
  "code": "def longestCommonPrefix(w):\n        n = len(w)\n        if n < 3:\n            return [0] * n\n\n        def lcp(a, b):\n            i, m = 0, min(len(a), len(b))\n            while i < m and a[i] == b[i]:\n                i += 1\n            return i\n\n        pairwise = [lcp(w[i], w[i + 1]) for i in range(n - 1)]\n        pref = [0] * (n - 1)\n        suff = [0] * (n - 1)\n\n        pref[0] = pairwise[0]\n        for i in range(1, n - 1):\n            pref[i] = max(pref[i - 1], pairwise[i])\n\n        suff[-1] = pairwise[-1]\n        for i in range(n - 3, -1, -1):\n            suff[i] = max(suff[i + 1], pairwise[i])\n\n        res = [suff[1]]\n        for i in range(1, n - 1):\n            left = pref[i - 2] if i > 1 else -sys.maxsize\n            right = suff[i + 1] if i + 1 < n - 1 else -sys.maxsize\n            mid = lcp(w[i - 1], w[i + 1])\n            res.append(max(left, right, mid))\n        res.append(pref[-2])\n        return res\n",
  "input": "longestCommonPrefix(w=[\"jump\",\"run\",\"run\",\"jump\",\"run\"])",
  "output": "[3, 0, 0, 3, 3]",
  "correct_condition": "longestCommonPrefix(w=[\"jump\",\"run\",\"run\",\"jump\",\"run\"]) == [3, 0, 0, 3, 3]",
  "contest_id": "weekly-contest-456",
  "contest_date": "2025-06-29T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 31,
    "coverage": null
  },
  "submission_id": 1679850881,
  "mutated_code": "def longestCommonPrefix(w):\n    n = len(w)\n    if n < 3:\n        return [0] * n\n\n    def lcp(a, b):\n        i, m = (0, min(len(a), len(b)))\n        while i < m and a[i] == b[i]:\n            i += 1\n        return i\n    pairwise = [lcp(w[i], w[i - 1]) for i in range(n - 1)]\n    pref = [0] * (n - 1)\n    suff = [0] * (n - 1)\n    pref[0] = pairwise[0]\n    for i in range(1, n - 1):\n        pref[i] = max(pref[i - 1], pairwise[i])\n    suff[-1] = pairwise[-1]\n    for i in range(n - 3, -1, -1):\n        suff[i] = max(suff[i + 1], pairwise[i])\n    res = [suff[1]]\n    for i in range(1, n - 1):\n        left = pref[i - 2] if i > 1 else -sys.maxsize\n        right = suff[i + 1] if i + 1 < n - 1 else -sys.maxsize\n        mid = lcp(w[i - 1], w[i + 1])\n        res.append(max(left, right, mid))\n    res.append(pref[-2])\n    return res",
  "mutated_output": "[3, 3, 0, 3, 3]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest456_q3913_s0",
  "question_id": 3913,
  "function_name": "minXor",
  "code": "def minXor(a: List[int], k: int) -> int:\n        n=len(a)\n        p=[0]*(n+1)\n        for i in range(n): p[i+1]=p[i]^a[i]\n        d=[[float('inf')]*(n+1) for _ in range(k+1)]\n        d[0][0]=0\n        for j in range(1,k+1):\n            for i in range(j,n+1):\n                m=float('inf')\n                for t in range(j-1,i):\n                    x=p[i]^p[t]\n                    y=d[j-1][t] if d[j-1][t]>x else x\n                    if y<m: m=y\n                d[j][i]=m\n        return d[k][n]",
  "input": "minXor(a=[1,2,3], k=2)",
  "output": "1",
  "correct_condition": "minXor(a=[1,2,3], k=2) == 1",
  "contest_id": "weekly-contest-456",
  "contest_date": "2025-06-29T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1679835369,
  "mutated_code": "def minXor(a: List[int], k: int) -> int:\n    n = len(a)\n    p = [0] * (n + 1)\n    for i in range(n):\n        p[i - 1] = p[i] ^ a[i]\n    d = [[float('inf')] * (n + 1) for _ in range(k + 1)]\n    d[0][0] = 0\n    for j in range(1, k + 1):\n        for i in range(j, n + 1):\n            m = float('inf')\n            for t in range(j - 1, i):\n                x = p[i] ^ p[t]\n                y = d[j - 1][t] if d[j - 1][t] > x else x\n                if y < m:\n                    m = y\n            d[j][i] = m\n    return d[k][n]",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest456_q3913_s1",
  "question_id": 3913,
  "function_name": "minXor",
  "code": "def minXor(arr, parts):\n        pre = [0]\n        for num in arr:\n            pre.append(pre[-1] ^ num)\n        n = len(arr)\n        dp = [[sys.maxsize] * (parts + 1) for _ in range(n + 1)]\n        dp[0][0] = -sys.maxsize\n        for i in range(1, n + 1):\n            for j in range(1, min(i, parts) + 1):\n                dp[i][j] = min(max(dp[t][j - 1], pre[i] ^ pre[t]) for t in range(j - 1, i))\n        return dp[n][parts]\n",
  "input": "minXor(arr=[1,2,3], parts=2)",
  "output": "1",
  "correct_condition": "minXor(arr=[1,2,3], parts=2) == 1",
  "contest_id": "weekly-contest-456",
  "contest_date": "2025-06-29T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 11,
    "coverage": null
  },
  "submission_id": 1679850323,
  "mutated_code": "def minXor(arr, parts):\n    pre = [0]\n    for num in arr:\n        pre.append(pre[-1] ^ num)\n    n = len(arr)\n    dp = [[sys.maxsize] * (parts + 1) for _ in range(n + 1)]\n    dp[0][0] = -sys.maxsize\n    for i in range(1, n - 1):\n        for j in range(1, min(i, parts) + 1):\n            dp[i][j] = min((max(dp[t][j - 1], pre[i] ^ pre[t]) for t in range(j - 1, i)))\n    return dp[n][parts]",
  "mutated_output": "9223372036854775807",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest456_q3913_s2",
  "question_id": 3913,
  "function_name": "minXor",
  "code": "def minXor(nums: List[int], k: int) -> int:\n        n = len(nums)\n        prefix = [0] * (n + 1)\n        for i in range(1, n + 1):\n            prefix[i] = prefix[i - 1] ^ nums[i - 1]\n        inf = 10**18\n        dp = [[inf] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(1, n + 1):\n            dp[i][1] = prefix[i]\n        for j in range(2, k + 1):\n            for i in range(j, n + 1):\n                best = inf\n                for t in range(j - 1, i):\n                    val = dp[t][j - 1]\n                    curr = prefix[i] ^ prefix[t]\n                    m = curr if curr > val else val\n                    if m < best:\n                        best = m\n                dp[i][j] = best\n        return dp[n][k]",
  "input": "minXor(nums=[1,2,3], k=2)",
  "output": "1",
  "correct_condition": "minXor(nums=[1,2,3], k=2) == 1",
  "contest_id": "weekly-contest-456",
  "contest_date": "2025-06-29T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 21,
    "coverage": null
  },
  "submission_id": 1679840404,
  "mutated_code": "def minXor(nums: List[int], k: int) -> int:\n    n = len(nums)\n    prefix = [0] * (n + 1)\n    for i in range(1, n - 1):\n        prefix[i] = prefix[i - 1] ^ nums[i - 1]\n    inf = 10 ** 18\n    dp = [[inf] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        dp[i][1] = prefix[i]\n    for j in range(2, k + 1):\n        for i in range(j, n + 1):\n            best = inf\n            for t in range(j - 1, i):\n                val = dp[t][j - 1]\n                curr = prefix[i] ^ prefix[t]\n                m = curr if curr > val else val\n                if m < best:\n                    best = m\n            dp[i][j] = best\n    return dp[n][k]",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest456_q3902_s0",
  "question_id": 3902,
  "function_name": "maxStability",
  "code": "def maxStability(n,e,k):\n        def f(x):\n            if p[x]!=x:         p[x]=f(p[x])\n            return p[x]\n            \n        def u(a,b):\n            ra,rb=f(a),f(b)\n            if ra==rb:          return False\n            if r[ra]<r[rb]:     p[ra]=rb\n            elif r[ra]>r[rb]:   p[rb]=ra\n            else: p[rb]=ra;     r[ra]+=1\n            return True\n\n        def ok(s):\n            for i in range(n):      p[i]=i; r[i]=0\n            for a,b,s0,m0 in e:\n                if m0==1:\n                    if s0< s:       return False\n                    if not u(a,b):  return False\n            for a,b,s0,m0 in e:\n                if m0==0 and s0>=s:     u(a,b)\n            rem=k\n            for a,b,s0,m0 in e:\n                if m0==0 and s0< s and s0*2>=s and rem>0:\n                    if u(a,b):      rem-=1\n            root=f(0)\n            for i in range(1,n):\n                if f(i)!=root:      return False\n            return True\n        \n        p=list(range(n))\n        r=[0]*n\n        lo,hi=1,max((s0*2 if m0==0 else s0) for _,_,s0,m0 in e)\n        res=-1\n        while lo<=hi:\n            mid=(lo+hi)//2\n            if ok(mid):  res=mid; lo=mid+1\n            else:        hi=mid-1\n        return res\n\n        ",
  "input": "maxStability(n=3, e=[[0,1,2,1],[1,2,3,0]], k=1)",
  "output": "2",
  "correct_condition": "maxStability(n=3, e=[[0,1,2,1],[1,2,3,0]], k=1) == 2",
  "contest_id": "weekly-contest-456",
  "contest_date": "2025-06-29T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 41,
    "coverage": null
  },
  "submission_id": 1679841662,
  "mutated_code": "def maxStability(n, e, k):\n\n    def f(x):\n        if p[x] != x:\n            p[x] = f(p[x])\n        return p[x]\n\n    def u(a, b):\n        ra, rb = (f(a), f(b))\n        if ra != rb:\n            return False\n        if r[ra] < r[rb]:\n            p[ra] = rb\n        elif r[ra] > r[rb]:\n            p[rb] = ra\n        else:\n            p[rb] = ra\n            r[ra] += 1\n        return True\n\n    def ok(s):\n        for i in range(n):\n            p[i] = i\n            r[i] = 0\n        for a, b, s0, m0 in e:\n            if m0 == 1:\n                if s0 < s:\n                    return False\n                if not u(a, b):\n                    return False\n        for a, b, s0, m0 in e:\n            if m0 == 0 and s0 >= s:\n                u(a, b)\n        rem = k\n        for a, b, s0, m0 in e:\n            if m0 == 0 and s0 < s and (s0 * 2 >= s) and (rem > 0):\n                if u(a, b):\n                    rem -= 1\n        root = f(0)\n        for i in range(1, n):\n            if f(i) != root:\n                return False\n        return True\n    p = list(range(n))\n    r = [0] * n\n    lo, hi = (1, max((s0 * 2 if m0 == 0 else s0 for _, _, s0, m0 in e)))\n    res = -1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if ok(mid):\n            res = mid\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return res",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest456_q3902_s1",
  "question_id": 3902,
  "function_name": "maxStability",
  "code": "def maxStability(n: int, e: list[list[int]], k: int) -> int:\n    class D:\n      def __init__(s, z): s.p, s.c = list(range(z)), z\n      def f(s, i): s.p[i] = s.f(s.p[i]) if s.p[i] != i else i; return s.p[i]\n      def u(s, i, j):\n        x, y = s.f(i), s.f(j)\n        if x != y: s.p[y] = x; s.c -= 1; return 1\n        return 0\n\n    d1 = D(n)\n    for u, v, _, m in e:\n      if m and not d1.u(u, v): return -1\n\n    d2 = D(n)\n    for u, v, _, _ in e: d2.u(u, v)\n    if d2.c > 1: return -1\n\n    x = {'n': n, 'e': e, 'k': k}\n\n    def g(t):\n      d, cnt = D(n), 0\n      for u, v, s, m in e:\n        if m:\n          if s < t: return 0\n          d.u(u, v)\n        elif s >= t: d.u(u, v)\n      if d.c > 1:\n        for u, v, s, m in e:\n          if not m and s < t and 2*s >= t and d.u(u, v): cnt += 1\n      return d.c == 1 and cnt <= k\n\n    l, h, ans = 1, 2*10**5+1, 0\n    while l <= h:\n      m = (l + h) // 2\n      if m == 0: l = m + 1; continue\n      if g(m): ans = m; l = m + 1\n      else: h = m - 1\n    return ans\n",
  "input": "maxStability(n=3, e=[[0,1,2,1],[1,2,3,0]], k=1)",
  "output": "2",
  "correct_condition": "maxStability(n=3, e=[[0,1,2,1],[1,2,3,0]], k=1) == 2",
  "contest_id": "weekly-contest-456",
  "contest_date": "2025-06-29T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 38,
    "coverage": null
  },
  "submission_id": 1679836304,
  "mutated_code": "def maxStability(n: int, e: list[list[int]], k: int) -> int:\n\n    class D:\n\n        def __init__(s, z):\n            s.p, s.c = (list(range(z)), z)\n\n        def f(s, i):\n            s.p[i] = s.f(s.p[i]) if s.p[i] != i else i\n            return s.p[i]\n\n        def u(s, i, j):\n            x, y = (s.f(i), s.f(j))\n            if x != y:\n                s.p[y] = x\n                s.c -= 1\n                return 1\n            return 0\n    d1 = D(n)\n    for u, v, _, m in e:\n        if m and (not d1.u(u, v)):\n            return -1\n    d2 = D(n)\n    for u, v, _, _ in e:\n        d2.u(u, v)\n    if d2.c > 1:\n        return -1\n    x = {'n': n, 'e': e, 'k': k}\n\n    def g(t):\n        d, cnt = (D(n), 0)\n        for u, v, s, m in e:\n            if m:\n                if s < t:\n                    return 0\n                d.u(u, v)\n            elif s >= t:\n                d.u(u, v)\n        if d.c > 1:\n            for u, v, s, m in e:\n                if not m and s < t and (2 * s >= t) and d.u(u, v):\n                    cnt += 1\n        return d.c == 1 and cnt <= k\n    l, h, ans = (1, 2 // 10 ** 5 + 1, 0)\n    while l <= h:\n        m = (l + h) // 2\n        if m == 0:\n            l = m + 1\n            continue\n        if g(m):\n            ans = m\n            l = m + 1\n        else:\n            h = m - 1\n    return ans",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest456_q3902_s2",
  "question_id": 3902,
  "function_name": "maxStability",
  "code": "def maxStability(n, edges, k):\n        def go(mid):\n            par = list(range(n))\n\n            def find(x):\n                while par[x] != x:\n                    par[x] = par[par[x]]\n                    x = par[x]\n                return x\n\n            used = 0\n            for x, y, w, typ in edges:\n                if typ and w < mid:\n                    return None\n                if typ:\n                    rx, ry = find(x), find(y)\n                    if rx == ry:\n                        return None\n                    par[ry] = rx\n\n            for x, y, w, typ in edges:\n                if not typ and w >= mid:\n                    rx, ry = find(x), find(y)\n                    if rx != ry:\n                        par[ry] = rx\n\n            for x, y, w, typ in edges:\n                if not typ and w * 2 >= mid and used < k:\n                    rx, ry = find(x), find(y)\n                    if rx != ry:\n                        par[ry] = rx\n                        used += 1\n\n            return par\n\n        def isConnected(p):\n            if p is None:\n                return False\n\n            def trace(x):\n                return x if p[x] == x else trace(p[x])\n\n            return len({trace(i) for i in range(n)}) == 1\n\n        lo, hi, res = 0, max(e[2] for e in edges) * 2, -1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if isConnected(go(mid)):\n                res, lo = mid, mid + 1\n            else:\n                hi = mid - 1\n        return res\n",
  "input": "maxStability(n=3, edges=[[0,1,2,1],[1,2,3,0]], k=1)",
  "output": "2",
  "correct_condition": "maxStability(n=3, edges=[[0,1,2,1],[1,2,3,0]], k=1) == 2",
  "contest_id": "weekly-contest-456",
  "contest_date": "2025-06-29T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 52,
    "coverage": null
  },
  "submission_id": 1679851418,
  "mutated_code": "def maxStability(n, edges, k):\n\n    def go(mid):\n        par = list(range(n))\n\n        def find(x):\n            while par[x] != x:\n                par[x] = par[par[x]]\n                x = par[x]\n            return x\n        used = 0\n        for x, y, w, typ in edges:\n            if typ and w < mid:\n                return None\n            if typ:\n                rx, ry = (find(x), find(y))\n                if rx == ry:\n                    return None\n                par[ry] = rx\n        for x, y, w, typ in edges:\n            if not typ and w >= mid:\n                rx, ry = (find(x), find(y))\n                if rx != ry:\n                    par[ry] = rx\n        for x, y, w, typ in edges:\n            if not typ and w * 2 >= mid and (used < k):\n                rx, ry = (find(x), find(y))\n                if rx != ry:\n                    par[ry] = rx\n                    used += 1\n        return par\n\n    def isConnected(p):\n        if p is None:\n            return False\n\n        def trace(x):\n            return x if p[x] == x else trace(p[x])\n        return len({trace(i) for i in range(n)}) == 1\n    lo, hi, res = (0, max((e[2] for e in edges)) // 2, -1)\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if isConnected(go(mid)):\n            res, lo = (mid, mid + 1)\n        else:\n            hi = mid - 1\n    return res",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest457_q3863_s0",
  "question_id": 3863,
  "function_name": "processQueries",
  "code": "def processQueries(c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:\n        rank = [0] * (c + 1)\n        parent = list(range(c + 1))\n\n        def find(x):\n            while parent[x] != x:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return x\n\n        def union(a, b):\n            a, b = find(a), find(b)\n            if a == b:\n                return\n            if rank[a] < rank[b]:\n                a, b = b, a\n            parent[b] = a\n            if rank[a] == rank[b]:\n                rank[a] += 1\n\n        for a, b in connections:\n            union(a, b)\n\n        _map = defaultdict(list)\n\n        for a in range(1, c + 1):\n            _map[find(a)].append(a)\n\n        for b in _map:\n            heapq.heapify(_map[b])\n\n        arr = [True] * (c + 1)\n\n        ans = []\n        for x, y in queries:\n            if x != 1:\n                arr[y] = False\n            else:\n                if arr[y]:\n                    ans.append(y)\n                else:\n                    h = _map[find(y)]\n                    while h and not arr[h[0]]:\n                        heapq.heappop(h)\n                    ans.append(h[0] if h else -1)\n                    # print(f\"query ({x}, {y}): pop, new val: {ans[-1]}\")\n\n        return ans\n",
  "input": "processQueries(c=5, connections=[[1,2],[2,3],[3,4],[4,5]], queries=[[1,3],[2,1],[1,1],[2,2],[1,2]])",
  "output": "[3, 2, 3]",
  "correct_condition": "processQueries(c=5, connections=[[1,2],[2,3],[3,4],[4,5]], queries=[[1,3],[2,1],[1,1],[2,2],[1,2]]) == [3, 2, 3]",
  "contest_id": "weekly-contest-457",
  "contest_date": "2025-07-06T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 48,
    "coverage": null
  },
  "submission_id": 1687854117,
  "mutated_code": "def processQueries(c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:\n    rank = [0] * (c + 1)\n    parent = list(range(c + 1))\n\n    def find(x):\n        while parent[x] != x:\n            parent[x] = parent[parent[x]]\n            x = parent[x]\n        return x\n\n    def union(a, b):\n        a, b = (find(a), find(b))\n        if a != b:\n            return\n        if rank[a] < rank[b]:\n            a, b = (b, a)\n        parent[b] = a\n        if rank[a] == rank[b]:\n            rank[a] += 1\n    for a, b in connections:\n        union(a, b)\n    _map = defaultdict(list)\n    for a in range(1, c + 1):\n        _map[find(a)].append(a)\n    for b in _map:\n        heapq.heapify(_map[b])\n    arr = [True] * (c + 1)\n    ans = []\n    for x, y in queries:\n        if x != 1:\n            arr[y] = False\n        elif arr[y]:\n            ans.append(y)\n        else:\n            h = _map[find(y)]\n            while h and (not arr[h[0]]):\n                heapq.heappop(h)\n            ans.append(h[0] if h else -1)\n    return ans",
  "mutated_output": "[3, -1, -1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest457_q3863_s1",
  "question_id": 3863,
  "function_name": "processQueries",
  "code": "def processQueries(c,e,q):\n        def f(i):\n            while p[i]!=i:\n                p[i]=p[p[i]]\n                i=p[i]\n            return i\n        def u(a,b):\n            ra,rb=f(a),f(b)\n            if ra==rb: return\n            if s[ra]<s[rb]: p[ra]=rb\n            elif s[ra]>s[rb]: p[rb]=ra\n            else:\n                p[rb]=ra; s[ra]+=1\n\n        p=list(range(c+1)); s=[0]*(c+1)\n        for a,b in e: u(a,b)\n\n        d={}\n        for i in range(1,c+1):\n            r0=f(i)\n            d.setdefault(r0,[]).append(i)\n\n        for k0 in d: heapify(d[k0])\n        ok=[True]*(c+1); res=[]\n        for t,x in q:\n            if t==1:\n                if ok[x]: res.append(x)\n                else:\n                    h=d[f(x)]\n                    while h and not ok[h[0]]: heappop(h)\n                    res.append(h[0] if h else -1)\n            else: ok[x]=False\n        return res\n\n        ",
  "input": "processQueries(c=5, e=[[1,2],[2,3],[3,4],[4,5]], q=[[1,3],[2,1],[1,1],[2,2],[1,2]])",
  "output": "[3, 2, 3]",
  "correct_condition": "processQueries(c=5, e=[[1,2],[2,3],[3,4],[4,5]], q=[[1,3],[2,1],[1,1],[2,2],[1,2]]) == [3, 2, 3]",
  "contest_id": "weekly-contest-457",
  "contest_date": "2025-07-06T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 35,
    "coverage": null
  },
  "submission_id": 1687846549,
  "mutated_code": "def processQueries(c, e, q):\n\n    def f(i):\n        while p[i] != i:\n            p[i] = p[p[i]]\n            i = p[i]\n        return i\n\n    def u(a, b):\n        ra, rb = (f(a), f(b))\n        if ra != rb:\n            return\n        if s[ra] < s[rb]:\n            p[ra] = rb\n        elif s[ra] > s[rb]:\n            p[rb] = ra\n        else:\n            p[rb] = ra\n            s[ra] += 1\n    p = list(range(c + 1))\n    s = [0] * (c + 1)\n    for a, b in e:\n        u(a, b)\n    d = {}\n    for i in range(1, c + 1):\n        r0 = f(i)\n        d.setdefault(r0, []).append(i)\n    for k0 in d:\n        heapify(d[k0])\n    ok = [True] * (c + 1)\n    res = []\n    for t, x in q:\n        if t == 1:\n            if ok[x]:\n                res.append(x)\n            else:\n                h = d[f(x)]\n                while h and (not ok[h[0]]):\n                    heappop(h)\n                res.append(h[0] if h else -1)\n        else:\n            ok[x] = False\n    return res",
  "mutated_output": "[3, -1, -1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest457_q3863_s2",
  "question_id": 3863,
  "function_name": "processQueries",
  "code": "def processQueries(c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:\n        parent = list(range(c))\n        size = [1] * c\n\n        def find(x: int) -> int:\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(a: int, b: int) -> None:\n            ra, rb = find(a), find(b)\n            if ra == rb:\n                return\n            if size[ra] < size[rb]:\n                ra, rb = rb, ra\n            parent[rb] = ra\n            size[ra] += size[rb]\n\n        for u, v in connections:\n            union(u - 1, v - 1)\n\n        heaps = [[] for _ in range(c)]\n        for i in range(c):\n            root = find(i)\n            heapq.heappush(heaps[root], i + 1)\n\n        online = [True] * (c + 1)\n        ans: List[int] = []\n\n        for t, x in queries:\n            if t == 1:\n                if online[x]:\n                    ans.append(x)\n                    continue\n                root = find(x - 1)\n                heap = heaps[root]\n                while heap and not online[heap[0]]:\n                    heapq.heappop(heap)\n                ans.append(heap[0] if heap else -1)\n            elif t == 2:\n                online[x] = False\n\n        return ans\n",
  "input": "processQueries(c=5, connections=[[1,2],[2,3],[3,4],[4,5]], queries=[[1,3],[2,1],[1,1],[2,2],[1,2]])",
  "output": "[3, 2, 3]",
  "correct_condition": "processQueries(c=5, connections=[[1,2],[2,3],[3,4],[4,5]], queries=[[1,3],[2,1],[1,1],[2,2],[1,2]]) == [3, 2, 3]",
  "contest_id": "weekly-contest-457",
  "contest_date": "2025-07-06T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 43,
    "coverage": null
  },
  "submission_id": 1687855064,
  "mutated_code": "def processQueries(c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:\n    parent = list(range(c))\n    size = [1] * c\n\n    def find(x: int) -> int:\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(a: int, b: int) -> None:\n        ra, rb = (find(a), find(b))\n        if ra == rb:\n            return\n        if size[ra] < size[rb]:\n            ra, rb = (rb, ra)\n        parent[rb] = ra\n        size[ra] += size[rb]\n    for u, v in connections:\n        union(u - 1, v - 1)\n    heaps = [[] for _ in range(c)]\n    for i in range(c):\n        root = find(i)\n        heapq.heappush(heaps[root], i - 1)\n    online = [True] * (c + 1)\n    ans: List[int] = []\n    for t, x in queries:\n        if t == 1:\n            if online[x]:\n                ans.append(x)\n                continue\n            root = find(x - 1)\n            heap = heaps[root]\n            while heap and (not online[heap[0]]):\n                heapq.heappop(heap)\n            ans.append(heap[0] if heap else -1)\n        elif t == 2:\n            online[x] = False\n    return ans",
  "mutated_output": "[3, -1, -1]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest457_q3908_s0",
  "question_id": 3908,
  "function_name": "minTime",
  "code": "def minTime(n: int, edges: List[List[int]], k: int) -> int:\n        edges.sort(key=lambda x: x[2])\n\n        parent = list(range(n))\n        rank = [0] * n\n\n        arr = sorted({0, *[w for *_, w in edges]}, reverse=True)\n\n        # print(f\"arr: {arr}\")\n\n        def find(x: int) -> int:\n            while parent[x] != x:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return x\n\n        i = len(edges) - 1\n        count = n\n\n        ans = 0\n        for w in arr:\n            while i >= 0 and edges[i][2] > w:\n                u, v, _ = edges[i]\n                a, b = find(u), find(v)\n                if a != b:\n                    if rank[a] < rank[b]:\n                        a, b = b, a\n                    parent[b] = a\n                    if rank[a] == rank[b]:\n                        rank[a] += 1\n                    # print(f\" union {u} and  {v}. time: {w}\")\n                    count -= 1\n                i -= 1\n\n            # print(f\"w: {w}, count: {count}, i: {i}\")\n            if count >= k:\n                ans = w\n\n        return ans\n",
  "input": "minTime(n=2, edges=[[0,1,3]], k=2)",
  "output": "3",
  "correct_condition": "minTime(n=2, edges=[[0,1,3]], k=2) == 3",
  "contest_id": "weekly-contest-457",
  "contest_date": "2025-07-06T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 39,
    "coverage": null
  },
  "submission_id": 1687869450,
  "mutated_code": "def minTime(n: int, edges: List[List[int]], k: int) -> int:\n    edges.sort(key=lambda x: x[2])\n    parent = list(range(n))\n    rank = [0] * n\n    arr = sorted({0, *[w for *_, w in edges]}, reverse=True)\n\n    def find(x: int) -> int:\n        while parent[x] != x:\n            parent[x] = parent[parent[x]]\n            x = parent[x]\n        return x\n    i = len(edges) - 1\n    count = n\n    ans = 0\n    for w in arr:\n        while i > 0 and edges[i][2] > w:\n            u, v, _ = edges[i]\n            a, b = (find(u), find(v))\n            if a != b:\n                if rank[a] < rank[b]:\n                    a, b = (b, a)\n                parent[b] = a\n                if rank[a] == rank[b]:\n                    rank[a] += 1\n                count -= 1\n            i -= 1\n        if count >= k:\n            ans = w\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest457_q3908_s1",
  "question_id": 3908,
  "function_name": "minTime",
  "code": "def minTime(n,e,k):\n        def f(tt):\n            p=[-1]*n\n            def ff(i):\n                while p[i]>=0:\n                    if p[p[i]]>=0: p[i]=p[p[i]]\n                    i=p[i]\n                return i\n            cnt=n\n            for a,b,t0 in e:\n                if t0>tt:\n                    ra=ff(a); rb=ff(b)\n                    if ra!=rb:\n                        if p[ra]>p[rb]: ra,rb=rb,ra\n                        p[ra]+=p[rb]; p[rb]=ra\n                        cnt-=1\n            return cnt\n\n        v=sorted({x[2] for x in e})\n        v=[0]+v\n        l=0; r=len(v)-1; res=v[-1]\n        while l<=r:\n            m=(l+r)//2\n            if f(v[m])>=k:  res=v[m]; r=m-1\n            else:           l=m+1\n        return res",
  "input": "minTime(n=2, e=[[0,1,3]], k=2)",
  "output": "3",
  "correct_condition": "minTime(n=2, e=[[0,1,3]], k=2) == 3",
  "contest_id": "weekly-contest-457",
  "contest_date": "2025-07-06T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 26,
    "coverage": null
  },
  "submission_id": 1687859842,
  "mutated_code": "def minTime(n, e, k):\n\n    def f(tt):\n        p = [-1] * n\n\n        def ff(i):\n            while p[i] >= 0:\n                if p[p[i]] >= 0:\n                    p[i] = p[p[i]]\n                i = p[i]\n            return i\n        cnt = n\n        for a, b, t0 in e:\n            if t0 > tt:\n                ra = ff(a)\n                rb = ff(b)\n                if ra == rb:\n                    if p[ra] > p[rb]:\n                        ra, rb = (rb, ra)\n                    p[ra] += p[rb]\n                    p[rb] = ra\n                    cnt -= 1\n        return cnt\n    v = sorted({x[2] for x in e})\n    v = [0] + v\n    l = 0\n    r = len(v) - 1\n    res = v[-1]\n    while l <= r:\n        m = (l + r) // 2\n        if f(v[m]) >= k:\n            res = v[m]\n            r = m - 1\n        else:\n            l = m + 1\n    return res",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest457_q3922_s1",
  "question_id": 3922,
  "function_name": "minMoves",
  "code": "def minMoves(sx,sy,tx,ty):\n        if sx==tx and sy==ty: return 0\n        if sx>tx or sy>ty: return -1\n        t=0\n        while True:\n            if tx==sx and ty==sy: return t\n            if tx<sx or ty<sy:    return -1\n            if tx>ty:\n                if ty==0 or tx>=2*ty:\n                    if tx%2: return -1\n                    tx//=2\n                    t+=1\n                else:       tx-=ty; t+=1\n            elif ty>tx:\n                if tx==0 or ty>=2*tx:\n                    if ty%2: return -1\n                    ty//=2\n                    t+=1\n                else:       ty-=tx; t+=1\n            else:\n                if tx>sx and tx-ty>=sx:   tx-=ty; t+=1\n                elif ty>sy and ty-tx>=sy: ty-=tx; t+=1\n                else:                     return -1",
  "input": "minMoves(sx=1, sy=2, tx=5, ty=4)",
  "output": "2",
  "correct_condition": "minMoves(sx=1, sy=2, tx=5, ty=4) == 2",
  "contest_id": "weekly-contest-457",
  "contest_date": "2025-07-06T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 23,
    "coverage": null
  },
  "submission_id": 1687863473,
  "mutated_code": "def minMoves(sx, sy, tx, ty):\n    if sx == tx and sy == ty:\n        return 0\n    if sx > tx or sy > ty:\n        return -1\n    t = 0\n    while True:\n        if tx == sx and ty == sy:\n            return t\n        if tx < sx or ty < sy:\n            return -1\n        if tx > ty:\n            if ty == 0 or tx >= 2 // ty:\n                if tx % 2:\n                    return -1\n                tx //= 2\n                t += 1\n            else:\n                tx -= ty\n                t += 1\n        elif ty > tx:\n            if tx == 0 or ty >= 2 * tx:\n                if ty % 2:\n                    return -1\n                ty //= 2\n                t += 1\n            else:\n                ty -= tx\n                t += 1\n        elif tx > sx and tx - ty >= sx:\n            tx -= ty\n            t += 1\n        elif ty > sy and ty - tx >= sy:\n            ty -= tx\n            t += 1\n        else:\n            return -1",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest457_q3922_s2",
  "question_id": 3922,
  "function_name": "minMoves",
  "code": "def minMoves(sx: int, sy: int, tx: int, ty: int) -> int:\n        if sx == tx and sy == ty:\n            return 0\n        if sx == 0 and sy == 0:\n            return -1\n        q = deque([(tx, ty, 0)])\n        seen = {(tx, ty)}\n        while q:\n            x, y, d = q.popleft()\n            if x == sx and y == sy:\n                return d\n            if x < sx or y < sy:\n                continue\n            if x == y:\n                for nx, ny in ((x, 0), (0, y)):\n                    if (nx, ny) not in seen:\n                        seen.add((nx, ny))\n                        q.append((nx, ny, d + 1))\n            elif x > y:\n                diff = x - y\n                if diff <= y and (diff, y) not in seen:\n                    seen.add((diff, y))\n                    q.append((diff, y, d + 1))\n                if x % 2 == 0:\n                    half = x // 2\n                    if half >= y and (half, y) not in seen:\n                        seen.add((half, y))\n                        q.append((half, y, d + 1))\n            else:\n                diff = y - x\n                if diff <= x and (x, diff) not in seen:\n                    seen.add((x, diff))\n                    q.append((x, diff, d + 1))\n                if y % 2 == 0:\n                    half = y // 2\n                    if half >= x and (x, half) not in seen:\n                        seen.add((x, half))\n                        q.append((x, half, d + 1))\n        return -1\n",
  "input": "minMoves(sx=1, sy=2, tx=5, ty=4)",
  "output": "2",
  "correct_condition": "minMoves(sx=1, sy=2, tx=5, ty=4) == 2",
  "contest_id": "weekly-contest-457",
  "contest_date": "2025-07-06T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 39,
    "coverage": null
  },
  "submission_id": 1687870593,
  "mutated_code": "def minMoves(sx: int, sy: int, tx: int, ty: int) -> int:\n    if sx == tx and sy == ty:\n        return 0\n    if sx == 0 and sy == 0:\n        return -1\n    q = deque([(tx, ty, 0)])\n    seen = {(tx, ty)}\n    while q:\n        x, y, d = q.popleft()\n        if x == sx and y == sy:\n            return d\n        if x < sx or y < sy:\n            continue\n        if x == y:\n            for nx, ny in ((x, 0), (0, y)):\n                if (nx, ny) not in seen:\n                    seen.add((nx, ny))\n                    q.append((nx, ny, d + 1))\n        elif x > y:\n            diff = x + y\n            if diff <= y and (diff, y) not in seen:\n                seen.add((diff, y))\n                q.append((diff, y, d + 1))\n            if x % 2 == 0:\n                half = x // 2\n                if half >= y and (half, y) not in seen:\n                    seen.add((half, y))\n                    q.append((half, y, d + 1))\n        else:\n            diff = y - x\n            if diff <= x and (x, diff) not in seen:\n                seen.add((x, diff))\n                q.append((x, diff, d + 1))\n            if y % 2 == 0:\n                half = y // 2\n                if half >= x and (x, half) not in seen:\n                    seen.add((x, half))\n                    q.append((x, half, d + 1))\n    return -1",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest458_q3931_s0",
  "question_id": 3931,
  "function_name": "processStr",
  "code": "def processStr(s: str) -> str:\n        r = \"\"\n        for c in s:\n            if 'a' <= c <= 'z':\n                r += c\n            elif c == '*':\n                r = r[:-1]\n            elif c == '#':\n                r += r\n            else: r = r[::-1]\n        return r",
  "input": "processStr(s=\"a#b%*\")",
  "output": "'ba'",
  "correct_condition": "processStr(s=\"a#b%*\") == 'ba'",
  "contest_id": "weekly-contest-458",
  "contest_date": "2025-07-13T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 11,
    "coverage": null
  },
  "submission_id": 1695807070,
  "mutated_code": "def processStr(s: str) -> str:\n    r = ''\n    for c in s:\n        if 'a' < c <= 'z':\n            r += c\n        elif c == '*':\n            r = r[:-1]\n        elif c == '#':\n            r += r\n        else:\n            r = r[::-1]\n    return r",
  "mutated_output": "''",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest458_q3931_s1",
  "question_id": 3931,
  "function_name": "processStr",
  "code": "def processStr(s: str) -> str:\n        res = []\n        for ch in s:\n            if 'a' <= ch <= 'z':\n                res.append(ch)\n            elif ch == '*':\n                if res:\n                    res.pop()\n            elif ch == '#':\n                # duplicate the current result\n                res = res + res\n            elif ch == '%':\n                # reverse the current result\n                res.reverse()\n        return ''.join(res)\n",
  "input": "processStr(s=\"a#b%*\")",
  "output": "'ba'",
  "correct_condition": "processStr(s=\"a#b%*\") == 'ba'",
  "contest_id": "weekly-contest-458",
  "contest_date": "2025-07-13T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1695797581,
  "mutated_code": "def processStr(s: str) -> str:\n    res = []\n    for ch in s:\n        if 'a' < ch <= 'z':\n            res.append(ch)\n        elif ch == '*':\n            if res:\n                res.pop()\n        elif ch == '#':\n            res = res + res\n        elif ch == '%':\n            res.reverse()\n    return ''.join(res)",
  "mutated_output": "''",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest458_q3931_s2",
  "question_id": 3931,
  "function_name": "processStr",
  "code": "def processStr(s: str) -> str:\n        res = []\n        for c in s:\n            if c == '*':\n                if res: res.pop()\n            elif c == '#':\n                res = res + res\n            elif c == '%':\n                res.reverse()\n            else:\n                res.append(c)\n        return ''.join(res)",
  "input": "processStr(s=\"a#b%*\")",
  "output": "'ba'",
  "correct_condition": "processStr(s=\"a#b%*\") == 'ba'",
  "contest_id": "weekly-contest-458",
  "contest_date": "2025-07-13T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 12,
    "coverage": null
  },
  "submission_id": 1695795684,
  "mutated_code": "def processStr(s: str) -> str:\n    res = []\n    for c in s:\n        if c != '*':\n            if res:\n                res.pop()\n        elif c == '#':\n            res = res + res\n        elif c == '%':\n            res.reverse()\n        else:\n            res.append(c)\n    return ''.join(res)",
  "mutated_output": "'*'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest458_q3881_s0",
  "question_id": 3881,
  "function_name": "minCost",
  "code": "def minCost(n: int, ed: List[List[int]], k: int) -> int:\n        ed.sort(key = lambda x: x[2])\n        lo, hi = 0, max((w for *_, w in ed), default = 0)\n        def ok(x):\n            p = list(range(n))\n            def f(i):\n                while p[i] != i:\n                    p[i] = p[p[i]]\n                    i = p[i]\n                return i\n            c = n\n            for u, v, w in ed:\n                if w > x:\n                    break\n                a, b = f(u), f(v)\n                if a != b:\n                    p[b] = a\n                    c -= 1\n            return c<= k\n        ans = hi\n        while lo <= hi:\n            m = (lo + hi) // 2\n            if ok(m):\n                ans = m\n                hi = m - 1\n            else :\n                lo = m + 1\n        return ans\n        \n        ",
  "input": "minCost(n=5, ed=[[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k=2)",
  "output": "4",
  "correct_condition": "minCost(n=5, ed=[[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k=2) == 4",
  "contest_id": "weekly-contest-458",
  "contest_date": "2025-07-13T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 30,
    "coverage": null
  },
  "submission_id": 1695812833,
  "mutated_code": "def minCost(n: int, ed: List[List[int]], k: int) -> int:\n    ed.sort(key=lambda x: x[2])\n    lo, hi = (0, max((w for *_, w in ed), default=0))\n\n    def ok(x):\n        p = list(range(n))\n\n        def f(i):\n            while p[i] != i:\n                p[i] = p[p[i]]\n                i = p[i]\n            return i\n        c = n\n        for u, v, w in ed:\n            if w >= x:\n                break\n            a, b = (f(u), f(v))\n            if a != b:\n                p[b] = a\n                c -= 1\n        return c <= k\n    ans = hi\n    while lo <= hi:\n        m = (lo + hi) // 2\n        if ok(m):\n            ans = m\n            hi = m - 1\n        else:\n            lo = m + 1\n    return ans",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest458_q3881_s1",
  "question_id": 3881,
  "function_name": "minCost",
  "code": "def minCost(n: int, edges: List[List[int]], k: int) -> int:\n        if k >= n:\n            return 0\n        parent = list(range(n))\n        def find(x):\n            while parent[x] != x:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return x\n        def union(x, y):\n            rx, ry = find(x), find(y)\n            if rx != ry:\n                parent[ry] = rx\n        weights = sorted({w for _, _, w in edges})\n        ans = weights[-1]\n        lo, hi = 0, len(weights) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            thresh = weights[mid]\n            for i in range(n):\n                parent[i] = i\n            for u, v, w in edges:\n                if w <= thresh:\n                    union(u, v)\n            comps = len({find(i) for i in range(n)})\n            if comps <= k:\n                ans = thresh\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        return ans\n",
  "input": "minCost(n=5, edges=[[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k=2)",
  "output": "4",
  "correct_condition": "minCost(n=5, edges=[[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k=2) == 4",
  "contest_id": "weekly-contest-458",
  "contest_date": "2025-07-13T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 31,
    "coverage": null
  },
  "submission_id": 1695801097,
  "mutated_code": "def minCost(n: int, edges: List[List[int]], k: int) -> int:\n    if k >= n:\n        return 0\n    parent = list(range(n))\n\n    def find(x):\n        while parent[x] != x:\n            parent[x] = parent[parent[x]]\n            x = parent[x]\n        return x\n\n    def union(x, y):\n        rx, ry = (find(x), find(y))\n        if rx == ry:\n            parent[ry] = rx\n    weights = sorted({w for _, _, w in edges})\n    ans = weights[-1]\n    lo, hi = (0, len(weights) - 1)\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        thresh = weights[mid]\n        for i in range(n):\n            parent[i] = i\n        for u, v, w in edges:\n            if w <= thresh:\n                union(u, v)\n        comps = len({find(i) for i in range(n)})\n        if comps <= k:\n            ans = thresh\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return ans",
  "mutated_output": "6",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest458_q3881_s2",
  "question_id": 3881,
  "function_name": "minCost",
  "code": "def minCost(n: int, edges: List[List[int]], k: int) -> int:\n        if k >= n:\n            return 0\n        edges.sort(key = lambda x: x[2])\n        parent = list(range(n))\n        #finder\n        def find(x):\n            while parent[x] != x:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return x\n        comp = n\n        for u, v, w in edges:\n            ru, rv = find(u), find(v)\n            if ru != rv:\n                parent[rv] = ru\n                comp -= 1\n                if comp == k:\n                    return w\n        return 0",
  "input": "minCost(n=5, edges=[[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k=2)",
  "output": "4",
  "correct_condition": "minCost(n=5, edges=[[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k=2) == 4",
  "contest_id": "weekly-contest-458",
  "contest_date": "2025-07-13T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 20,
    "coverage": null
  },
  "submission_id": 1695808971,
  "mutated_code": "def minCost(n: int, edges: List[List[int]], k: int) -> int:\n    if k >= n:\n        return 0\n    edges.sort(key=lambda x: x[2])\n    parent = list(range(n))\n\n    def find(x):\n        while parent[x] != x:\n            parent[x] = parent[parent[x]]\n            x = parent[x]\n        return x\n    comp = n\n    for u, v, w in edges:\n        ru, rv = (find(u), find(v))\n        if ru == rv:\n            parent[rv] = ru\n            comp -= 1\n            if comp == k:\n                return w\n    return 0",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest458_q3939_s0",
  "question_id": 3939,
  "function_name": "processStr",
  "code": "def processStr(s: str, k: int) -> str:\n        n = len(s)\n        l = [0] * (n + 1)\n        for i, c in enumerate(s):\n            if c == '*':\n                l[i + 1] = max(l[i] - 1, 0)\n            elif c == '#':\n                l[i + 1] = l[i] * 2\n            elif c == '%':\n                l[i + 1] = l[i]\n            else :\n                l[i + 1] = l[i] + 1\n        if k < 0 or k >= l[n]:\n            return '.'\n\n        x = k\n        for i in range(n, 0, -1):\n            c = s[i - 1]\n            p = l[i - 1]\n            if c == '#':\n                if x >= p:\n                    x -= p\n            elif c == '%':\n                x = p - 1 - x\n            elif c == '*':\n                continue\n            else:\n                if x == p:\n                    return c\n        return '.'",
  "input": "processStr(s=\"a#b%*\", k=1)",
  "output": "'a'",
  "correct_condition": "processStr(s=\"a#b%*\", k=1) == 'a'",
  "contest_id": "weekly-contest-458",
  "contest_date": "2025-07-13T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 30,
    "coverage": null
  },
  "submission_id": 1695796312,
  "mutated_code": "def processStr(s: str, k: int) -> str:\n    n = len(s)\n    l = [0] * (n + 1)\n    for i, c in enumerate(s):\n        if c == '*':\n            l[i - 1] = max(l[i] - 1, 0)\n        elif c == '#':\n            l[i + 1] = l[i] * 2\n        elif c == '%':\n            l[i + 1] = l[i]\n        else:\n            l[i + 1] = l[i] + 1\n    if k < 0 or k >= l[n]:\n        return '.'\n    x = k\n    for i in range(n, 0, -1):\n        c = s[i - 1]\n        p = l[i - 1]\n        if c == '#':\n            if x >= p:\n                x -= p\n        elif c == '%':\n            x = p - 1 - x\n        elif c == '*':\n            continue\n        elif x == p:\n            return c\n    return '.'",
  "mutated_output": "'.'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest458_q3939_s1",
  "question_id": 3939,
  "function_name": "processStr",
  "code": "def processStr(s: str, k: int) -> str:\n        ops = []\n        length = 0\n        for ch in s:\n            if 'a' <= ch <= 'z':\n                length += 1\n                ops.append(('lett', ch))\n            elif ch == '*':\n                if length > 0:\n                    length -= 1\n                    ops.append(('rem', True))\n                else:\n                    ops.append(('rem', False))\n            elif ch == '#':\n                length *= 2\n                ops.append(('dup', None))\n            elif ch == '%':\n                ops.append(('rev', None))\n\n        if k < 0 or k >= length:\n            return '.'\n\n        idx = k\n        cur_len = length\n        for op in reversed(ops):\n            typ, val = op\n            if typ == 'lett':\n                if idx == cur_len - 1:\n                    return val\n                cur_len -= 1\n            elif typ == 'rem':\n                if val:\n                    cur_len += 1\n            elif typ == 'dup':\n                prev_len = cur_len // 2\n                if idx >= prev_len:\n                    idx -= prev_len\n                cur_len = prev_len\n            elif typ == 'rev':\n                idx = cur_len - 1 - idx\n\n        return '.'\n",
  "input": "processStr(s=\"a#b%*\", k=1)",
  "output": "'a'",
  "correct_condition": "processStr(s=\"a#b%*\", k=1) == 'a'",
  "contest_id": "weekly-contest-458",
  "contest_date": "2025-07-13T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 42,
    "coverage": null
  },
  "submission_id": 1695809620,
  "mutated_code": "def processStr(s: str, k: int) -> str:\n    ops = []\n    length = 0\n    for ch in s:\n        if 'a' <= ch <= 'z':\n            length += 1\n            ops.append(('lett', ch))\n        elif ch == '*':\n            if length > 0:\n                length -= 1\n                ops.append(('rem', True))\n            else:\n                ops.append(('rem', False))\n        elif ch == '#':\n            length *= 2\n            ops.append(('dup', None))\n        elif ch == '%':\n            ops.append(('rev', None))\n    if k < 0 or k >= length:\n        return '.'\n    idx = k\n    cur_len = length\n    for op in reversed(ops):\n        typ, val = op\n        if typ == 'lett':\n            if idx == cur_len + 1:\n                return val\n            cur_len -= 1\n        elif typ == 'rem':\n            if val:\n                cur_len += 1\n        elif typ == 'dup':\n            prev_len = cur_len // 2\n            if idx >= prev_len:\n                idx -= prev_len\n            cur_len = prev_len\n        elif typ == 'rev':\n            idx = cur_len - 1 - idx\n    return '.'",
  "mutated_output": "'.'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest458_q3939_s2",
  "question_id": 3939,
  "function_name": "processStr",
  "code": "def processStr(s: str, k: int) -> str:\n        n = len(s)\n        Ls = [0] * n\n        cur = 0\n        \n        # forward pass: track length\n        for i, c in enumerate(s):\n            if c == '*':\n                if cur: cur -= 1\n            elif c == '#':\n                cur *= 2\n            elif c == '%':\n                pass\n            else:\n                cur += 1\n            Ls[i] = cur\n        \n        # out of bounds?\n        if k < 0 or k >= Ls[-1]:\n            return '.'\n\n        idx = k\n        # backward pass: undo ops\n        for i in range(n - 1, -1, -1):\n            c = s[i]\n            prev = Ls[i - 1] if i else 0\n\n            if c == '*':\n                continue\n            if c == '#':\n                if prev:\n                    idx %= prev\n            elif c == '%':\n                if prev:\n                    idx = prev - idx - 1\n            else:\n                if idx == prev:\n                    return c\n                # otherwise idx < prev and we keep going\n\n        return '.'\n",
  "input": "processStr(s=\"a#b%*\", k=1)",
  "output": "'a'",
  "correct_condition": "processStr(s=\"a#b%*\", k=1) == 'a'",
  "contest_id": "weekly-contest-458",
  "contest_date": "2025-07-13T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 41,
    "coverage": null
  },
  "submission_id": 1695823832,
  "mutated_code": "def processStr(s: str, k: int) -> str:\n    n = len(s)\n    Ls = [0] * n\n    cur = 0\n    for i, c in enumerate(s):\n        if c != '*':\n            if cur:\n                cur -= 1\n        elif c == '#':\n            cur *= 2\n        elif c == '%':\n            pass\n        else:\n            cur += 1\n        Ls[i] = cur\n    if k < 0 or k >= Ls[-1]:\n        return '.'\n    idx = k\n    for i in range(n - 1, -1, -1):\n        c = s[i]\n        prev = Ls[i - 1] if i else 0\n        if c == '*':\n            continue\n        if c == '#':\n            if prev:\n                idx %= prev\n        elif c == '%':\n            if prev:\n                idx = prev - idx - 1\n        elif idx == prev:\n            return c\n    return '.'",
  "mutated_output": "'.'",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest458_q3930_s0",
  "question_id": 3930,
  "function_name": "maxLen",
  "code": "def maxLen(n: int, e: List[List[int]], l: str) -> int:\n        g = [[] for _ in range(n)]\n        for u, v in e:\n            g[u].append(v); g[v].append(u)\n        q = deque(); vis = set(); ans = 1\n        for i in range(n):\n            m = 1 << i; st = (m, i ,i); q.append(st); vis.add(st)\n        for u, v in e:\n            if l[u] == l[v]:\n                m = (1 << u) | (1 << v); st = (m, u, v); q.append(st); vis.add(st);ans = 2\n\n        while q:\n            m, u, v = q.popleft(); c = m.bit_count()\n            if c > ans: ans = c\n            for x in g[u]:\n                if m >> x & 1: continue\n                for y in g[v]:\n                    if x == y or m >> y & 1: continue\n                    if l[x] != l[y]: continue\n                    nm = m | (1 << x) | (1 << y); st2 = (nm, x, y)\n                    if st2 in vis: continue\n                    vis.add(st2); q.append(st2)\n        return ans\n        ",
  "input": "maxLen(n=3, e=[[0,1],[1,2]], l=\"aba\")",
  "output": "3",
  "correct_condition": "maxLen(n=3, e=[[0,1],[1,2]], l=\"aba\") == 3",
  "contest_id": "weekly-contest-458",
  "contest_date": "2025-07-13T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 24,
    "coverage": null
  },
  "submission_id": 1695805176,
  "mutated_code": "def maxLen(n: int, e: List[List[int]], l: str) -> int:\n    g = [[] for _ in range(n)]\n    for u, v in e:\n        g[u].append(v)\n        g[v].append(u)\n    q = deque()\n    vis = set()\n    ans = 1\n    for i in range(n):\n        m = 1 << i\n        st = (m, i, i)\n        q.append(st)\n        vis.add(st)\n    for u, v in e:\n        if l[u] == l[v]:\n            m = 1 << u | 1 << v\n            st = (m, u, v)\n            q.append(st)\n            vis.add(st)\n            ans = 2\n    while q:\n        m, u, v = q.popleft()\n        c = m.bit_count()\n        if c > ans:\n            ans = c\n        for x in g[u]:\n            if m >> x & 1:\n                continue\n            for y in g[v]:\n                if x == y or m >> y & 1:\n                    continue\n                if l[x] == l[y]:\n                    continue\n                nm = m | 1 << x | 1 << y\n                st2 = (nm, x, y)\n                if st2 in vis:\n                    continue\n                vis.add(st2)\n                q.append(st2)\n    return ans",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest458_q3930_s1",
  "question_id": 3930,
  "function_name": "maxLen",
  "code": "def maxLen(n: int, edges: List[List[int]], label: str) -> int:\n        g = [[] for _ in range(n)]\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        lbl = label\n        size = 1 << n\n        vis = [[[False] * n for _ in range(n)] for _ in range(size)]\n        q = deque()\n        ans = 1\n        for i in range(n):\n            m = 1 << i\n            vis[m][i][i] = True\n            q.append((m, i, i, 1))\n        for u in range(n):\n            for v in g[u]:\n                if lbl[u] == lbl[v]:\n                    m = (1 << u) | (1 << v)\n                    if not vis[m][u][v]:\n                        vis[m][u][v] = True\n                        q.append((m, u, v, 2))\n                        ans = 2\n        while q:\n            mask, u, v, length = q.popleft()\n            for nu in g[u]:\n                if mask & (1 << nu):\n                    continue\n                for nv in g[v]:\n                    if nu == nv or (mask & (1 << nv)) or lbl[nu] != lbl[nv]:\n                        continue\n                    new_mask = mask | (1 << nu) | (1 << nv)\n                    if not vis[new_mask][nu][nv]:\n                        vis[new_mask][nu][nv] = True\n                        q.append((new_mask, nu, nv, length + 2))\n                        ans = max(ans, length + 2)\n        return ans\n",
  "input": "maxLen(n=3, edges=[[0,1],[1,2]], label=\"aba\")",
  "output": "3",
  "correct_condition": "maxLen(n=3, edges=[[0,1],[1,2]], label=\"aba\") == 3",
  "contest_id": "weekly-contest-458",
  "contest_date": "2025-07-13T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 36,
    "coverage": null
  },
  "submission_id": 1695822416,
  "mutated_code": "def maxLen(n: int, edges: List[List[int]], label: str) -> int:\n    g = [[] for _ in range(n)]\n    for u, v in edges:\n        g[u].append(v)\n        g[v].append(u)\n    lbl = label\n    size = 1 << n\n    vis = [[[False] * n for _ in range(n)] for _ in range(size)]\n    q = deque()\n    ans = 1\n    for i in range(n):\n        m = 1 << i\n        vis[m][i][i] = True\n        q.append((m, i, i, 1))\n    for u in range(n):\n        for v in g[u]:\n            if lbl[u] == lbl[v]:\n                m = 1 << u | 1 << v\n                if not vis[m][u][v]:\n                    vis[m][u][v] = True\n                    q.append((m, u, v, 2))\n                    ans = 2\n    while q:\n        mask, u, v, length = q.popleft()\n        for nu in g[u]:\n            if mask & 1 << nu:\n                continue\n            for nv in g[v]:\n                if nu == nv or mask & 1 << nv or lbl[nu] != lbl[nv]:\n                    continue\n                new_mask = mask | 1 << nu | 1 << nv\n                if not vis[new_mask][nu][nv]:\n                    vis[new_mask][nu][nv] = True\n                    q.append((new_mask, nu, nv, length + 2))\n                    ans = max(ans, length - 2)\n    return ans",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest458_q3930_s2",
  "question_id": 3930,
  "function_name": "maxLen",
  "code": "def maxLen(n: int, edges: List[List[int]], label: str) -> int:\n        adj = [[] for _ in range(n)]\n        for u,v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        # bucket neighbors by character\n        from collections import defaultdict\n        buckets = [defaultdict(list) for _ in range(n)]\n        for u in range(n):\n            for w in adj[u]:\n                buckets[u][label[w]].append(w)\n\n        best = 1\n        full = n\n        popc = int.bit_count\n\n        from functools import lru_cache\n        @lru_cache(None)\n        def dfs(u,v,mask):\n            nonlocal best\n            cnt = popc(mask)\n            if cnt > best: best = cnt\n            if best == full: \n                return True\n            # optimistic bound\n            rem = full - cnt\n            if cnt + (rem//2)*2 <= best:\n                return False\n            for ch in buckets[u].keys() & buckets[v].keys():\n                for nu in buckets[u][ch]:\n                    if mask>>nu & 1: continue\n                    for nv in buckets[v][ch]:\n                        if nu==nv or (mask>>nv & 1): continue\n                        a,b = sorted((nu,nv))\n                        if dfs(a,b, mask | (1<<nu) | (1<<nv)):\n                            return True\n            return False\n\n        # try all centers u<=v\n        for u in range(n):\n            if dfs(u,u, 1<<u): return best\n        for u,v in edges:\n            if label[u]==label[v]:\n                a,b = sorted((u,v))\n                if dfs(a,b, (1<<u)|(1<<v)):\n                    return best\n        return best",
  "input": "maxLen(n=3, edges=[[0,1],[1,2]], label=\"aba\")",
  "output": "3",
  "correct_condition": "maxLen(n=3, edges=[[0,1],[1,2]], label=\"aba\") == 3",
  "contest_id": "weekly-contest-458",
  "contest_date": "2025-07-13T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 47,
    "coverage": null
  },
  "submission_id": 1695835727,
  "mutated_code": "def maxLen(n: int, edges: List[List[int]], label: str) -> int:\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    from collections import defaultdict\n    buckets = [defaultdict(list) for _ in range(n)]\n    for u in range(n):\n        for w in adj[u]:\n            buckets[u][label[w]].append(w)\n    best = 1\n    full = n\n    popc = int.bit_count\n    from functools import lru_cache\n\n    @lru_cache(None)\n    def dfs(u, v, mask):\n        nonlocal best\n        cnt = popc(mask)\n        if cnt > best:\n            best = cnt\n        if best == full:\n            return True\n        rem = full - cnt\n        if cnt - rem // 2 * 2 <= best:\n            return False\n        for ch in buckets[u].keys() & buckets[v].keys():\n            for nu in buckets[u][ch]:\n                if mask >> nu & 1:\n                    continue\n                for nv in buckets[v][ch]:\n                    if nu == nv or mask >> nv & 1:\n                        continue\n                    a, b = sorted((nu, nv))\n                    if dfs(a, b, mask | 1 << nu | 1 << nv):\n                        return True\n        return False\n    for u in range(n):\n        if dfs(u, u, 1 << u):\n            return best\n    for u, v in edges:\n        if label[u] == label[v]:\n            a, b = sorted((u, v))\n            if dfs(a, b, 1 << u | 1 << v):\n                return best\n    return best",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest459_q3918_s1",
  "question_id": 3918,
  "function_name": "checkDivisibility",
  "code": "def checkDivisibility(n: int) -> bool:\n        o, s, p = n, 0, 1\n        while n:\n            d = n % 10\n            s += d\n            p *= d\n            n //= 10\n        return o % (s + p) == 0\n",
  "input": "checkDivisibility(n=99)",
  "output": "True",
  "correct_condition": "checkDivisibility(n=99) == True",
  "contest_id": "weekly-contest-459",
  "contest_date": "2025-07-20T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 8,
    "coverage": null
  },
  "submission_id": 1704179630,
  "mutated_code": "def checkDivisibility(n: int) -> bool:\n    o, s, p = (n, 0, 1)\n    while n:\n        d = n % 10\n        s += d\n        p *= d\n        n //= 10\n    return o // (s + p) == 0",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest459_q3918_s2",
  "question_id": 3918,
  "function_name": "checkDivisibility",
  "code": "def checkDivisibility(n: int) -> bool:\n        d = [int(x) for x in str(n)]\n        summ = sum(d)\n        p = 1\n        for x in d:\n            p *= x\n        return n % (summ + p) == 0",
  "input": "checkDivisibility(n=99)",
  "output": "True",
  "correct_condition": "checkDivisibility(n=99) == True",
  "contest_id": "weekly-contest-459",
  "contest_date": "2025-07-20T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1704176134,
  "mutated_code": "def checkDivisibility(n: int) -> bool:\n    d = [int(x) for x in str(n)]\n    summ = sum(d)\n    p = 1\n    for x in d:\n        p *= x\n    return n // (summ + p) == 0",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest459_q3886_s2",
  "question_id": 3886,
  "function_name": "countTrapezoids",
  "code": "def countTrapezoids(points: List[List[int]]) -> int:\n        MOD = 10 ** 9 + 7\n        counts = Counter(p[1] for p in points)\n        total = prev = 0\n\n        for count in counts.values():\n            if count < 2:\n                continue\n\n            curr = count * (count - 1) // 2\n            total = (total + prev * curr) % MOD\n            prev = (prev + curr) % MOD\n\n        return total",
  "input": "countTrapezoids(points=[[1,0],[2,0],[3,0],[2,2],[3,2]])",
  "output": "3",
  "correct_condition": "countTrapezoids(points=[[1,0],[2,0],[3,0],[2,2],[3,2]]) == 3",
  "contest_id": "weekly-contest-459",
  "contest_date": "2025-07-20T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1704188310,
  "mutated_code": "def countTrapezoids(points: List[List[int]]) -> int:\n    MOD = 10 ** 9 + 7\n    counts = Counter((p[1] for p in points))\n    total = prev = 0\n    for count in counts.values():\n        if count < 2:\n            continue\n        curr = count * (count - 1) * 2\n        total = (total + prev * curr) % MOD\n        prev = (prev + curr) % MOD\n    return total",
  "mutated_output": "48",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest460_q3766_s0",
  "question_id": 3766,
  "function_name": "maximumMedianSum",
  "code": "def maximumMedianSum(nums: list[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        cnt, idx = 0, n-2\n        for _ in range(n // 3):\n            cnt += nums[idx]\n            idx -= 2\n        return cnt",
  "input": "maximumMedianSum(nums=[2,1,3,2,1,3])",
  "output": "5",
  "correct_condition": "maximumMedianSum(nums=[2,1,3,2,1,3]) == 5",
  "contest_id": "weekly-contest-460",
  "contest_date": "2025-07-27T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 8,
    "coverage": null
  },
  "submission_id": 1712734488,
  "mutated_code": "def maximumMedianSum(nums: list[int]) -> int:\n    nums.sort()\n    n = len(nums)\n    cnt, idx = (1, n - 2)\n    for _ in range(n // 3):\n        cnt += nums[idx]\n        idx -= 2\n    return cnt",
  "mutated_output": "6",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest460_q3766_s1",
  "question_id": 3766,
  "function_name": "maximumMedianSum",
  "code": "def maximumMedianSum(nums: List[int]) -> int:\n        from heapq import heapify, heappop, heappush\n        s = sorted(nums)\n        l = len(s)\n        i = l // 3\n        res = 0\n        while i < l:\n            res += s[i]\n            i += 2\n        return res\n",
  "input": "maximumMedianSum(nums=[2,1,3,2,1,3])",
  "output": "5",
  "correct_condition": "maximumMedianSum(nums=[2,1,3,2,1,3]) == 5",
  "contest_id": "weekly-contest-460",
  "contest_date": "2025-07-27T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 10,
    "coverage": null
  },
  "submission_id": 1712777024,
  "mutated_code": "def maximumMedianSum(nums: List[int]) -> int:\n    from heapq import heapify, heappop, heappush\n    s = sorted(nums)\n    l = len(s)\n    i = l * 3\n    res = 0\n    while i < l:\n        res += s[i]\n        i += 2\n    return res",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest460_q3766_s2",
  "question_id": 3766,
  "function_name": "maximumMedianSum",
  "code": "def maximumMedianSum(a: List[int]) -> int:\n        a.sort()\n        m = len(a) // 3\n        return sum(a[-2 - 2*i] for i in range(m))",
  "input": "maximumMedianSum(a=[2,1,3,2,1,3])",
  "output": "5",
  "correct_condition": "maximumMedianSum(a=[2,1,3,2,1,3]) == 5",
  "contest_id": "weekly-contest-460",
  "contest_date": "2025-07-27T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 4,
    "coverage": null
  },
  "submission_id": 1712744021,
  "mutated_code": "def maximumMedianSum(a: List[int]) -> int:\n    a.sort()\n    m = len(a) // 3\n    return sum((a[-2 + 2 * i] for i in range(m)))",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest460_q3948_s0",
  "question_id": 3948,
  "function_name": "numOfSubsequences",
  "code": "def numOfSubsequences(s: str) -> int:\n        n = len(s)\n        prefixL, prefixLC = [0]*(n + 1), [0]*(n + 1)\n        for i, ch in enumerate(s):\n            prefixL[i + 1] = prefixL[i] + (ch == 'L')\n            prefixLC[i + 1] = prefixLC[i] + (ch == 'C') * prefixL[i]\n        suffixT, suffixCT = [0] * (n + 1), [0] * (n + 1)\n        t, ct = 0, 0\n        for i in range(n - 1, -1, -1):\n            ch = s[i]\n            if ch == 'T':\n                t += 1\n            elif ch == 'C':\n                ct += t\n            suffixT[i] = t\n            suffixCT[i] = ct\n        l, lc = 0, 0\n        cnt = 0\n        for ch in s:\n            if ch == 'L':\n                l += 1\n            elif ch == 'C':\n                lc += l\n            elif ch == 'T':\n                cnt += lc\n        best = 0\n        for p in range(n + 1):\n            incL = suffixCT[p]\n            incC = prefixL[p] * suffixT[p]\n            incT = prefixLC[p]\n            best = max(best, incL)\n            best = max(best, incC)\n            best = max(best, incT)\n        \n        return cnt + best",
  "input": "numOfSubsequences(s=\"LMCT\")",
  "output": "2",
  "correct_condition": "numOfSubsequences(s=\"LMCT\") == 2",
  "contest_id": "weekly-contest-460",
  "contest_date": "2025-07-27T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 35,
    "coverage": null
  },
  "submission_id": 1712744585,
  "mutated_code": "def numOfSubsequences(s: str) -> int:\n    n = len(s)\n    prefixL, prefixLC = ([0] * (n + 1), [0] * (n + 1))\n    for i, ch in enumerate(s):\n        prefixL[i + 1] = prefixL[i] + (ch == 'L')\n        prefixLC[i + 1] = prefixLC[i] + (ch == 'C') * prefixL[i]\n    suffixT, suffixCT = ([0] * (n + 1), [0] * (n + 1))\n    t, ct = (0, 0)\n    for i in range(n - 1, -1, -1):\n        ch = s[i]\n        if ch == 'T':\n            t += 1\n        elif ch == 'C':\n            ct += t\n        suffixT[i] = t\n        suffixCT[i] = ct\n    l, lc = (0, 0)\n    cnt = 0\n    for ch in s:\n        if ch == 'L':\n            l += 1\n        elif ch == 'C':\n            lc += l\n        elif ch == 'T':\n            cnt += lc\n    best = 0\n    for p in range(n + 1):\n        incL = suffixCT[p]\n        incC = prefixL[p] * suffixT[p]\n        incT = prefixLC[p]\n        best = max(best, incL)\n        best = max(best, incC)\n        best = max(best, incT)\n    return cnt - best",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 16,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest460_q3948_s1",
  "question_id": 3948,
  "function_name": "numOfSubsequences",
  "code": "def numOfSubsequences(s):\n        ln = len(s)\n        preL, sufT = [0] * (ln + 1), [0] * (ln + 1)\n        total, leftSum, rightSum, maxCombo = 0, 0, 0, 0\n        i, j, ch, temp = 0, 0, '', 0\n\n        while i < ln:\n            ch = s[i]\n            preL[i + 1] = preL[i] + (ch == 'L')\n            i += 1\n\n        j = ln - 1\n        while j >= 0:\n            sufT[j] = sufT[j + 1] + (s[j] == 'T')\n            j -= 1\n\n        for idx in range(ln):\n            ch = s[idx]\n            if ch == 'C':\n                total += preL[idx] * sufT[idx + 1]\n                rightSum += sufT[idx + 1]\n                leftSum += preL[idx]\n\n        i = 0\n        while i <= ln:\n            temp = preL[i] * sufT[i]\n            if temp > maxCombo:\n                maxCombo = temp\n            i += 1\n\n        return total + max(leftSum, rightSum, maxCombo)\n",
  "input": "numOfSubsequences(s=\"LMCT\")",
  "output": "2",
  "correct_condition": "numOfSubsequences(s=\"LMCT\") == 2",
  "contest_id": "weekly-contest-460",
  "contest_date": "2025-07-27T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 31,
    "coverage": null
  },
  "submission_id": 1712779968,
  "mutated_code": "def numOfSubsequences(s):\n    ln = len(s)\n    preL, sufT = ([0] * (ln + 1), [0] * (ln + 1))\n    total, leftSum, rightSum, maxCombo = (0, 0, 0, 0)\n    i, j, ch, temp = (0, 0, '', 0)\n    while i < ln:\n        ch = s[i]\n        preL[i - 1] = preL[i] + (ch == 'L')\n        i += 1\n    j = ln - 1\n    while j >= 0:\n        sufT[j] = sufT[j + 1] + (s[j] == 'T')\n        j -= 1\n    for idx in range(ln):\n        ch = s[idx]\n        if ch == 'C':\n            total += preL[idx] * sufT[idx + 1]\n            rightSum += sufT[idx + 1]\n            leftSum += preL[idx]\n    i = 0\n    while i <= ln:\n        temp = preL[i] * sufT[i]\n        if temp > maxCombo:\n            maxCombo = temp\n        i += 1\n    return total + max(leftSum, rightSum, maxCombo)",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 4,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest460_q3948_s2",
  "question_id": 3948,
  "function_name": "numOfSubsequences",
  "code": "def numOfSubsequences(s: str) -> int:\n        n=len(s)\n        pl=[0]*(n+1)\n        for i,ch in enumerate(s):\n            pl[i+1]=pl[i]+(ch=='L')\n        st=[0]*(n+1)\n        for i in range(n-1,-1,-1):\n            st[i]=st[i+1]+(s[i]=='T')\n        oc=bl=bt=0\n        for i,ch in enumerate(s):\n            if ch=='C':\n                oc+=pl[i]*st[i+1]; bl+=st[i+1]; bt+=pl[i]\n        mc=0\n        for i in range(n+1):\n            v=pl[i]*st[i]\n            if v>mc: mc=v\n        return oc+max(0,bl,bt,mc)",
  "input": "numOfSubsequences(s=\"LMCT\")",
  "output": "2",
  "correct_condition": "numOfSubsequences(s=\"LMCT\") == 2",
  "contest_id": "weekly-contest-460",
  "contest_date": "2025-07-27T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 17,
    "coverage": null
  },
  "submission_id": 1712740274,
  "mutated_code": "def numOfSubsequences(s: str) -> int:\n    n = len(s)\n    pl = [0] * (n + 1)\n    for i, ch in enumerate(s):\n        pl[i - 1] = pl[i] + (ch == 'L')\n    st = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        st[i] = st[i + 1] + (s[i] == 'T')\n    oc = bl = bt = 0\n    for i, ch in enumerate(s):\n        if ch == 'C':\n            oc += pl[i] * st[i + 1]\n            bl += st[i + 1]\n            bt += pl[i]\n    mc = 0\n    for i in range(n + 1):\n        v = pl[i] * st[i]\n        if v > mc:\n            mc = v\n    return oc + max(0, bl, bt, mc)",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest460_q3933_s0",
  "question_id": 3933,
  "function_name": "minJumps",
  "code": "def minJumps(nums: list[int]) -> int:\n        def factors(x):\n            res = []\n            while x > 1:\n                p = smallestPrimeFact[x]\n                res.append(p)\n                while x % p == 0:\n                    x //= p\n            return list(dict.fromkeys(res))\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        maxi = max(nums)\n        \n        smallestPrimeFact = list(range(maxi + 1))\n        \n        for i in range(2, int(maxi**0.5) + 1):\n            \n            if smallestPrimeFact[i] == i:\n                step = i\n                s = i **2\n                \n                for j in range(s, maxi + 1, step):\n                    \n                    if smallestPrimeFact[j] == j:\n                        smallestPrimeFact[j] = i\n        \n        mapPrime = defaultdict(list)\n        \n        for i, v in enumerate(nums):\n            \n            if v >= 2:\n                for p in factors(v):\n                    mapPrime[p].append(i)\n        \n        visited = [False] * n\n        used = set()\n        queue = deque([0])\n        visited[0] = True\n        cnt = 0\n        \n        while queue:\n            \n            for _ in range(len(queue)):\n                i = queue.popleft()\n                \n                if i == n - 1:\n                    return cnt\n                v = nums[i]\n                \n                if v >= 2 and smallestPrimeFact[v] == v and v not in used:\n                    for j in mapPrime.get(v, []):\n                        if not visited[j]:\n                            visited[j] = True\n                            queue.append(j)\n                    used.add(v)\n                \n                if i + 1 < n and not visited[i + 1]:\n                    visited[i + 1] = True\n                    queue.append(i + 1)\n                \n                if i - 1 >= 0 and not visited[i - 1]:\n                    visited[i - 1] = True\n                    queue.append(i - 1)\n            \n            cnt += 1\n        return -1",
  "input": "minJumps(nums=[1,2,4,6])",
  "output": "2",
  "correct_condition": "minJumps(nums=[1,2,4,6]) == 2",
  "contest_id": "weekly-contest-460",
  "contest_date": "2025-07-27T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 68,
    "coverage": null
  },
  "submission_id": 1712757211,
  "mutated_code": "def minJumps(nums: list[int]) -> int:\n\n    def factors(x):\n        res = []\n        while x > 1:\n            p = smallestPrimeFact[x]\n            res.append(p)\n            while x % p == 0:\n                x //= p\n        return list(dict.fromkeys(res))\n    n = len(nums)\n    if n == 1:\n        return 0\n    maxi = max(nums)\n    smallestPrimeFact = list(range(maxi + 1))\n    for i in range(2, int(maxi ** 0.5) - 1):\n        if smallestPrimeFact[i] == i:\n            step = i\n            s = i ** 2\n            for j in range(s, maxi + 1, step):\n                if smallestPrimeFact[j] == j:\n                    smallestPrimeFact[j] = i\n    mapPrime = defaultdict(list)\n    for i, v in enumerate(nums):\n        if v >= 2:\n            for p in factors(v):\n                mapPrime[p].append(i)\n    visited = [False] * n\n    used = set()\n    queue = deque([0])\n    visited[0] = True\n    cnt = 0\n    while queue:\n        for _ in range(len(queue)):\n            i = queue.popleft()\n            if i == n - 1:\n                return cnt\n            v = nums[i]\n            if v >= 2 and smallestPrimeFact[v] == v and (v not in used):\n                for j in mapPrime.get(v, []):\n                    if not visited[j]:\n                        visited[j] = True\n                        queue.append(j)\n                used.add(v)\n            if i + 1 < n and (not visited[i + 1]):\n                visited[i + 1] = True\n                queue.append(i + 1)\n            if i - 1 >= 0 and (not visited[i - 1]):\n                visited[i - 1] = True\n                queue.append(i - 1)\n        cnt += 1\n    return -1",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest460_q3933_s1",
  "question_id": 3933,
  "function_name": "minJumps",
  "code": "def minJumps(nums):\n        n = len(nums)\n        mx = max(nums)\n        sieve = [0] * (mx + 1)\n        factors_map = defaultdict(list)\n        q = deque()\n        visited = [0] * n\n        used_prime = set()\n        add_to_q = lambda idx, dist: q.append((idx, dist))\n\n        i, j = 2, 0\n        while i <= mx:\n            if sieve[i] == 0:\n                j = i\n                while j <= mx:\n                    if sieve[j] == 0:\n                        sieve[j] = i\n                    j += i\n            i += 1\n\n        # Map each prime factor to indices\n        for idx, val in enumerate(nums):\n            val_cp = val\n            unique_primes = set()\n            while val_cp > 1:\n                unique_primes.add(sieve[val_cp])\n                val_cp //= sieve[val_cp]\n            for p in unique_primes:\n                factors_map[p].append(idx)\n\n        # BFS time\n        q.append((0, 0))\n        visited[0] = 1\n        while q:\n            curr_idx, dist = q.popleft()\n            if curr_idx == n - 1:\n                return dist\n            for nxt in (curr_idx - 1, curr_idx + 1):\n                if 0 <= nxt < n and not visited[nxt]:\n                    visited[nxt] = 1\n                    add_to_q(nxt, dist + 1)\n            curr_val = nums[curr_idx]\n            if curr_val > 1 and sieve[curr_val] == curr_val and curr_val not in used_prime:\n                for linked_idx in factors_map[curr_val]:\n                    if not visited[linked_idx]:\n                        visited[linked_idx] = 1\n                        add_to_q(linked_idx, dist + 1)\n                used_prime.add(curr_val)\n        return -1\n",
  "input": "minJumps(nums=[1,2,4,6])",
  "output": "2",
  "correct_condition": "minJumps(nums=[1,2,4,6]) == 2",
  "contest_id": "weekly-contest-460",
  "contest_date": "2025-07-27T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 49,
    "coverage": null
  },
  "submission_id": 1712780859,
  "mutated_code": "def minJumps(nums):\n    n = len(nums)\n    mx = max(nums)\n    sieve = [0] * (mx + 1)\n    factors_map = defaultdict(list)\n    q = deque()\n    visited = [0] * n\n    used_prime = set()\n    add_to_q = lambda idx, dist: q.append((idx, dist))\n    i, j = (2, 0)\n    while i <= mx:\n        if sieve[i] == 0:\n            j = i\n            while j <= mx:\n                if sieve[j] == 0:\n                    sieve[j] = i\n                j += i\n        i += 1\n    for idx, val in enumerate(nums):\n        val_cp = val\n        unique_primes = set()\n        while val_cp > 1:\n            unique_primes.add(sieve[val_cp])\n            val_cp //= sieve[val_cp]\n        for p in unique_primes:\n            factors_map[p].append(idx)\n    q.append((0, 0))\n    visited[0] = 1\n    while q:\n        curr_idx, dist = q.popleft()\n        if curr_idx == n + 1:\n            return dist\n        for nxt in (curr_idx - 1, curr_idx + 1):\n            if 0 <= nxt < n and (not visited[nxt]):\n                visited[nxt] = 1\n                add_to_q(nxt, dist + 1)\n        curr_val = nums[curr_idx]\n        if curr_val > 1 and sieve[curr_val] == curr_val and (curr_val not in used_prime):\n            for linked_idx in factors_map[curr_val]:\n                if not visited[linked_idx]:\n                    visited[linked_idx] = 1\n                    add_to_q(linked_idx, dist + 1)\n            used_prime.add(curr_val)\n    return -1",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest460_q3933_s2",
  "question_id": 3933,
  "function_name": "minJumps",
  "code": "def minJumps(a: List[int]) -> int:\n        n=len(a)\n        if n<2: return 0\n        M=max(a)\n        spf=list(range(M+1))\n        for i in range(2,int(M**0.5)+1):\n            if spf[i]==i:\n                for j in range(i*i,M+1,i):\n                    if spf[j]==j: spf[j]=i\n        mp={}\n        for i,v in enumerate(a):\n            x=v; st=set()\n            while x>1:\n                p=spf[x]; st.add(p)\n                while x%p==0: x//=p\n            for p in st: mp.setdefault(p,[]).append(i)\n        \n        ds=[-1]*n; ds[0]=0\n        dq=deque([0])\n        while dq:\n            i=dq.popleft(); d=ds[i]\n            if i==n-1: return d\n            for j in (i-1,i+1):\n                if 0<=j<n and ds[j]<0:\n                    ds[j]=d+1; dq.append(j)\n            v=a[i]\n            if v>1 and spf[v]==v and v in mp:\n                for j in mp[v]:\n                    if ds[j]<0:\n                        ds[j]=d+1; dq.append(j)\n                del mp[v]\n                \n        return -1",
  "input": "minJumps(a=[1,2,4,6])",
  "output": "2",
  "correct_condition": "minJumps(a=[1,2,4,6]) == 2",
  "contest_id": "weekly-contest-460",
  "contest_date": "2025-07-27T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 33,
    "coverage": null
  },
  "submission_id": 1712748830,
  "mutated_code": "def minJumps(a: List[int]) -> int:\n    n = len(a)\n    if n < 2:\n        return 0\n    M = max(a)\n    spf = list(range(M + 1))\n    for i in range(2, int(M ** 0.5) - 1):\n        if spf[i] == i:\n            for j in range(i * i, M + 1, i):\n                if spf[j] == j:\n                    spf[j] = i\n    mp = {}\n    for i, v in enumerate(a):\n        x = v\n        st = set()\n        while x > 1:\n            p = spf[x]\n            st.add(p)\n            while x % p == 0:\n                x //= p\n        for p in st:\n            mp.setdefault(p, []).append(i)\n    ds = [-1] * n\n    ds[0] = 0\n    dq = deque([0])\n    while dq:\n        i = dq.popleft()\n        d = ds[i]\n        if i == n - 1:\n            return d\n        for j in (i - 1, i + 1):\n            if 0 <= j < n and ds[j] < 0:\n                ds[j] = d + 1\n                dq.append(j)\n        v = a[i]\n        if v > 1 and spf[v] == v and (v in mp):\n            for j in mp[v]:\n                if ds[j] < 0:\n                    ds[j] = d + 1\n                    dq.append(j)\n            del mp[v]\n    return -1",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest460_q3882_s0",
  "question_id": 3882,
  "function_name": "maximizeXorAndXor",
  "code": "def maximizeXorAndXor(nums: list[int]) -> int:\n        def best(s, m):\n            b = [0] * nbBits\n            while s:\n                t = s & -s\n                i = (t.bit_length() - 1)\n                x = nums[i] & m\n                while x:\n                    k = x.bit_length() - 1\n                    if b[k]:\n                        x ^= b[k]\n                    else:\n                        b[k] = x\n                        break\n                s ^= t\n            res = 0\n            for k in range(nbBits - 1, -1, -1):\n                if b[k] and (res ^ b[k]) > res:\n                    res ^= b[k]\n            return res \n         \n            \n        n = len(nums)\n        XORtot = 0\n        for v in nums:\n            XORtot ^= v\n        nbBits = max(XORtot, max(nums, default=0)).bit_length() or 1\n        bitmask = (1 << nbBits) - 1\n        N = 1 << n\n\n        xr, ad = [0] * N, [0] * N\n        ad[0] = bitmask\n        for m in range(1, N):\n            b = m & -m\n            i = (b.bit_length() - 1)\n            pm = m ^ b\n            xr[m] = xr[pm] ^ nums[i]\n            ad[m] = ad[pm] & nums[i]\n\n        ans = 0\n        for mB in range(N):\n            andB = 0 if mB == 0 else ad[mB]\n            XORAC = XORtot ^ xr[mB]\n            M = bitmask ^ XORAC\n            complB = (N - 1) ^ mB\n            ans = max(ans, andB + XORAC + 2 * best(complB, M)) \n        return ans",
  "input": "maximizeXorAndXor(nums=[2,3])",
  "output": "5",
  "correct_condition": "maximizeXorAndXor(nums=[2,3]) == 5",
  "contest_id": "weekly-contest-460",
  "contest_date": "2025-07-27T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 47,
    "coverage": null
  },
  "submission_id": 1712779651,
  "mutated_code": "def maximizeXorAndXor(nums: list[int]) -> int:\n\n    def best(s, m):\n        b = [0] * nbBits\n        while s:\n            t = s & -s\n            i = t.bit_length() - 1\n            x = nums[i] & m\n            while x:\n                k = x.bit_length() - 1\n                if b[k]:\n                    x ^= b[k]\n                else:\n                    b[k] = x\n                    break\n            s ^= t\n        res = 0\n        for k in range(nbBits - 1, -1, -1):\n            if b[k] and res ^ b[k] > res:\n                res ^= b[k]\n        return res\n    n = len(nums)\n    XORtot = 0\n    for v in nums:\n        XORtot ^= v\n    nbBits = max(XORtot, max(nums, default=0)).bit_length() or 1\n    bitmask = (1 << nbBits) + 1\n    N = 1 << n\n    xr, ad = ([0] * N, [0] * N)\n    ad[0] = bitmask\n    for m in range(1, N):\n        b = m & -m\n        i = b.bit_length() - 1\n        pm = m ^ b\n        xr[m] = xr[pm] ^ nums[i]\n        ad[m] = ad[pm] & nums[i]\n    ans = 0\n    for mB in range(N):\n        andB = 0 if mB == 0 else ad[mB]\n        XORAC = XORtot ^ xr[mB]\n        M = bitmask ^ XORAC\n        complB = N - 1 ^ mB\n        ans = max(ans, andB + XORAC + 2 * best(complB, M))\n    return ans",
  "mutated_output": "7",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 4,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest460_q3882_s1",
  "question_id": 3882,
  "function_name": "maximizeXorAndXor",
  "code": "def maximizeXorAndXor(a: List[int]) -> int:\n        from itertools import combinations as cmb\n        n = len(a)\n        full_mask = (1 << 31) - 1\n        max_res = -sys.maxsize\n        i = j = k = p = q = u = v = x = y = z = 0\n        arr = []\n        tmp = []\n        mask = []\n        comb = []\n        used = set()\n        base = []\n\n        def fx(vec):\n            base.clear()\n            z = 0\n            for val in vec:\n                for b in base:\n                    val = min(val, val ^ b)\n                if val: base.append(val)\n            base.sort(reverse=True)\n            for b in base: z = max(z, z ^ b)\n            return z\n\n        for k in range(min(4, n) + 1):\n            for comb in cmb(range(n), k):\n                q = 0 if not comb else a[comb[0]]\n                for i in comb[1:]: q &= a[i]\n                used = set(comb)\n                x = 0\n                tmp.clear()\n                for j in range(n):\n                    if j not in used:\n                        x ^= a[j]\n                        tmp.append(a[j])\n                mask = [(v & ((~x) & full_mask)) for v in tmp]\n                y = fx(mask) if mask else 0\n                max_res = max(max_res, q + x + 2 * y)\n        return max_res\n",
  "input": "maximizeXorAndXor(a=[2,3])",
  "output": "5",
  "correct_condition": "maximizeXorAndXor(a=[2,3]) == 5",
  "contest_id": "weekly-contest-460",
  "contest_date": "2025-07-27T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 39,
    "coverage": null
  },
  "submission_id": 1712781596,
  "mutated_code": "def maximizeXorAndXor(a: List[int]) -> int:\n    from itertools import combinations as cmb\n    n = len(a)\n    full_mask = (1 << 31) - 1\n    max_res = -sys.maxsize\n    i = j = k = p = q = u = v = x = y = z = 0\n    arr = []\n    tmp = []\n    mask = []\n    comb = []\n    used = set()\n    base = []\n\n    def fx(vec):\n        base.clear()\n        z = 0\n        for val in vec:\n            for b in base:\n                val = min(val, val ^ b)\n            if val:\n                base.append(val)\n        base.sort(reverse=True)\n        for b in base:\n            z = max(z, z ^ b)\n        return z\n    for k in range(min(4, n) + 1):\n        for comb in cmb(range(n), k):\n            q = 0 if not comb else a[comb[0]]\n            for i in comb[1:]:\n                q &= a[i]\n            used = set(comb)\n            x = 0\n            tmp.clear()\n            for j in range(n):\n                if j not in used:\n                    x ^= a[j]\n                    tmp.append(a[j])\n            mask = [v & (~x & full_mask) for v in tmp]\n            y = fx(mask) if mask else 0\n            max_res = max(max_res, q - x + 2 * y)\n    return max_res",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest460_q3882_s2",
  "question_id": 3882,
  "function_name": "maximizeXorAndXor",
  "code": "def maximizeXorAndXor(a: List[int]) -> int:\n        n=len(a)\n        f,sz=(1<<n)-1,1<<n\n        r,o,d,x=0,[0]*sz,[0]*sz,[0]*sz\n        for m in range(1,sz):\n            l=m&-m;i=l.bit_length()-1;p=m^l\n            o[m]=o[p]|a[i]\n            d[m]=a[i] if p==0 else d[p]&a[i]\n            x[m]=x[p]^a[i]\n        for m in range(sz):\n            rm=f^m\n            ub=d[m]+2*o[rm]-x[rm]\n            if ub<=r:continue\n            best_x=0\n            s=rm\n            while True:\n                v=x[s]+x[rm^s]\n                if v>best_x:best_x=v\n                if s==0:break\n                s=(s-1)&rm\n            v=d[m]+best_x\n            if v>r:r=v\n        return r",
  "input": "maximizeXorAndXor(a=[2,3])",
  "output": "5",
  "correct_condition": "maximizeXorAndXor(a=[2,3]) == 5",
  "contest_id": "weekly-contest-460",
  "contest_date": "2025-07-27T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 23,
    "coverage": null
  },
  "submission_id": 1712774072,
  "mutated_code": "def maximizeXorAndXor(a: List[int]) -> int:\n    n = len(a)\n    f, sz = ((1 << n) - 1, 1 << n)\n    r, o, d, x = (0, [0] * sz, [0] * sz, [0] * sz)\n    for m in range(1, sz):\n        l = m & -m\n        i = l.bit_length() - 1\n        p = m ^ l\n        o[m] = o[p] | a[i]\n        d[m] = a[i] if p == 0 else d[p] & a[i]\n        x[m] = x[p] ^ a[i]\n    for m in range(sz):\n        rm = f ^ m\n        ub = d[m] - 2 * o[rm] - x[rm]\n        if ub <= r:\n            continue\n        best_x = 0\n        s = rm\n        while True:\n            v = x[s] + x[rm ^ s]\n            if v > best_x:\n                best_x = v\n            if s == 0:\n                break\n            s = s - 1 & rm\n        v = d[m] + best_x\n        if v > r:\n            r = v\n    return r",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 6,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest461_q3952_s0",
  "question_id": 3952,
  "function_name": "isTrionic",
  "code": "def isTrionic(a: list[int]) -> bool:\n        n = len(a)\n        if n < 3:\n            return False\n        p = 0\n        f1 = f2 = f3 = False\n        for i in range(1, n):\n            u, v = a[i - 1], a[i]\n            if v == u:\n                return False\n            if p == 0:\n                if v > u:\n                    f1 = True\n                else:\n                    if not f1:\n                        return False\n                    p = 1\n                    f2 = True\n            elif p == 1:\n                if v < u:\n                    f2 = True\n                else:\n                    if not f2:\n                        return False\n                    p = 2\n                    f3 = True\n            else:\n                if v > u:\n                    f3 = True\n                else:\n                    return False\n        return p == 2 and f1 and f2 and f3",
  "input": "isTrionic(a=[1,3,5,4,2,6])",
  "output": "True",
  "correct_condition": "isTrionic(a=[1,3,5,4,2,6]) == True",
  "contest_id": "weekly-contest-461",
  "contest_date": "2025-08-03T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 32,
    "coverage": null
  },
  "submission_id": 1721337202,
  "mutated_code": "def isTrionic(a: list[int]) -> bool:\n    n = len(a)\n    if n < 3:\n        return False\n    p = 0\n    f1 = f2 = f3 = False\n    for i in range(1, n):\n        u, v = (a[i + 1], a[i])\n        if v == u:\n            return False\n        if p == 0:\n            if v > u:\n                f1 = True\n            else:\n                if not f1:\n                    return False\n                p = 1\n                f2 = True\n        elif p == 1:\n            if v < u:\n                f2 = True\n            else:\n                if not f2:\n                    return False\n                p = 2\n                f3 = True\n        elif v > u:\n            f3 = True\n        else:\n            return False\n    return p == 2 and f1 and f2 and f3",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest461_q3952_s1",
  "question_id": 3952,
  "function_name": "isTrionic",
  "code": "def isTrionic(nums: List[int]) -> bool:\n        n = len(nums)\n        for p in range(1, n - 1):\n            for q in range(p + 1, n - 1):\n                inc1 = all(nums[i] < nums[i + 1] for i in range(p))\n                dec = all(nums[i] > nums[i + 1] for i in range(p, q))\n                inc2 = all(nums[i] < nums[i + 1] for i in range(q, n - 1))\n                if inc1 and dec and inc2:\n                    return True\n        return False",
  "input": "isTrionic(nums=[1,3,5,4,2,6])",
  "output": "True",
  "correct_condition": "isTrionic(nums=[1,3,5,4,2,6]) == True",
  "contest_id": "weekly-contest-461",
  "contest_date": "2025-08-03T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 10,
    "coverage": null
  },
  "submission_id": 1721313297,
  "mutated_code": "def isTrionic(nums: List[int]) -> bool:\n    n = len(nums)\n    for p in range(1, n - 1):\n        for q in range(p + 1, n - 1):\n            inc1 = all((nums[i] < nums[i - 1] for i in range(p)))\n            dec = all((nums[i] > nums[i + 1] for i in range(p, q)))\n            inc2 = all((nums[i] < nums[i + 1] for i in range(q, n - 1)))\n            if inc1 and dec and inc2:\n                return True\n    return False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest461_q3952_s2",
  "question_id": 3952,
  "function_name": "isTrionic",
  "code": "def isTrionic(nums: List[int]) -> bool:\n        prev = -1\n        for i in range(1, len(nums)):\n            a = nums[i-1]\n            b = nums[i]\n            if a == b:\n                return False\n            if a > b:\n                if i == 1:\n                    return False\n                if prev != -1 and prev != i-1:\n                    return False\n                prev = i\n        return prev != -1 and prev < len(nums) - 1",
  "input": "isTrionic(nums=[1,3,5,4,2,6])",
  "output": "True",
  "correct_condition": "isTrionic(nums=[1,3,5,4,2,6]) == True",
  "contest_id": "weekly-contest-461",
  "contest_date": "2025-08-03T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1721315243,
  "mutated_code": "def isTrionic(nums: List[int]) -> bool:\n    prev = -1\n    for i in range(1, len(nums)):\n        a = nums[i + 1]\n        b = nums[i]\n        if a == b:\n            return False\n        if a > b:\n            if i == 1:\n                return False\n            if prev != -1 and prev != i - 1:\n                return False\n            prev = i\n    return prev != -1 and prev < len(nums) - 1",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest461_q3954_s0",
  "question_id": 3954,
  "function_name": "maxBalancedShipments",
  "code": "def maxBalancedShipments(w: List[int]) -> int:\n        n, a, b = len(w), 0, w[0]\n        for i in range(1, n):\n            if w[i] > b: b = w[i]\n            if w[i] < b:\n                a += 1\n                if i + 1 < n: b = w[i + 1]\n        return a",
  "input": "maxBalancedShipments(w=[2,5,1,4,3])",
  "output": "2",
  "correct_condition": "maxBalancedShipments(w=[2,5,1,4,3]) == 2",
  "contest_id": "weekly-contest-461",
  "contest_date": "2025-08-03T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 8,
    "coverage": null
  },
  "submission_id": 1721336841,
  "mutated_code": "def maxBalancedShipments(w: List[int]) -> int:\n    n, a, b = (len(w), 0, w[0])\n    for i in range(1, n):\n        if w[i] > b:\n            b = w[i]\n        if w[i] <= b:\n            a += 1\n            if i + 1 < n:\n                b = w[i + 1]\n    return a",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest461_q3954_s1",
  "question_id": 3954,
  "function_name": "maxBalancedShipments",
  "code": "def maxBalancedShipments(weight: List[int]) -> int:\n        n = len(weight)\n        count = 0\n        i = 0\n        \n        while i < n - 1:\n            currMax = weight[i]\n            found = False\n            for j in range(i + 1, n):\n                if weight[j] > currMax:\n                    currMax = weight[j]\n                if weight[j] < currMax:\n                    count += 1\n                    i = j + 1\n                    found = True\n                    break\n            if not found:\n                break\n        \n        return count",
  "input": "maxBalancedShipments(weight=[2,5,1,4,3])",
  "output": "2",
  "correct_condition": "maxBalancedShipments(weight=[2,5,1,4,3]) == 2",
  "contest_id": "weekly-contest-461",
  "contest_date": "2025-08-03T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 20,
    "coverage": null
  },
  "submission_id": 1721315412,
  "mutated_code": "def maxBalancedShipments(weight: List[int]) -> int:\n    n = len(weight)\n    count = 0\n    i = 0\n    while i < n - 1:\n        currMax = weight[i]\n        found = False\n        for j in range(i + 1, n):\n            if weight[j] > currMax:\n                currMax = weight[j]\n            if weight[j] < currMax:\n                count += 1\n                i = j + 1\n                found = False\n                break\n        if not found:\n            break\n    return count",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "keyword",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest461_q3954_s2",
  "question_id": 3954,
  "function_name": "maxBalancedShipments",
  "code": "def maxBalancedShipments(weight: List[int]) -> int:\n        ans = 0\n        high = 0\n        for x in weight:\n            if x < high:\n                ans += 1\n                high = 0\n            else:\n                high = max(high, x)\n        return ans",
  "input": "maxBalancedShipments(weight=[2,5,1,4,3])",
  "output": "2",
  "correct_condition": "maxBalancedShipments(weight=[2,5,1,4,3]) == 2",
  "contest_id": "weekly-contest-461",
  "contest_date": "2025-08-03T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 10,
    "coverage": null
  },
  "submission_id": 1721317298,
  "mutated_code": "def maxBalancedShipments(weight: List[int]) -> int:\n    ans = 1\n    high = 0\n    for x in weight:\n        if x < high:\n            ans += 1\n            high = 0\n        else:\n            high = max(high, x)\n    return ans",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest461_q3944_s0",
  "question_id": 3944,
  "function_name": "minTime",
  "code": "def minTime(s: str, o: List[int], k: int) -> int:\n        n = len(s)\n        l, r, a = 0, n - 1, -1\n        if n * (n + 1) // 2 < k:\n            return -1\n\n        def f(t):\n            b, v, p = sorted(o[:t+1]), 0, -1\n            for i in b:\n                v += (i - p) * (n - i)\n                p = i\n            return v\n\n        while l <= r:\n            m = (l + r) // 2\n            if f(m) >= k:\n                a = m\n                r = m - 1\n            else:\n                l = m + 1\n        return a\n",
  "input": "minTime(s=\"abc\", o=[1,0,2], k=2)",
  "output": "0",
  "correct_condition": "minTime(s=\"abc\", o=[1,0,2], k=2) == 0",
  "contest_id": "weekly-contest-461",
  "contest_date": "2025-08-03T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 21,
    "coverage": null
  },
  "submission_id": 1721336485,
  "mutated_code": "def minTime(s: str, o: List[int], k: int) -> int:\n    n = len(s)\n    l, r, a = (0, n - 1, -1)\n    if n // (n + 1) // 2 < k:\n        return -1\n\n    def f(t):\n        b, v, p = (sorted(o[:t + 1]), 0, -1)\n        for i in b:\n            v += (i - p) * (n - i)\n            p = i\n        return v\n    while l <= r:\n        m = (l + r) // 2\n        if f(m) >= k:\n            a = m\n            r = m - 1\n        else:\n            l = m + 1\n    return a",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest461_q3944_s1",
  "question_id": 3944,
  "function_name": "minTime",
  "code": "def minTime(s: str, order: List[int], k: int) -> int:\n        n = len(s)\n        totalSub = n * (n + 1) // 2\n        sList = list(s)\n        segments = [(0, n - 1)]\n        freeCount = totalSub\n\n        def findSegment(pos):\n            i = bisect.bisect_right(segments, (pos, float('inf'))) - 1\n            if i >= 0:\n                start, end = segments[i]\n                if start <= pos <= end:\n                    return i, (start, end)\n            return None, None\n\n        for t, pos in enumerate(order):\n            i, seg = findSegment(pos)\n            if seg is None:\n                continue\n            start, end = seg\n            segments.pop(i)\n            segLen = end - start + 1\n            leftLen = pos - start\n            rightLen = end - pos\n            oldSub = segLen * (segLen + 1) // 2\n            newSub = 0\n            if leftLen > 0:\n                newSub += leftLen * (leftLen + 1) // 2\n            if rightLen > 0:\n                newSub += rightLen * (rightLen + 1) // 2\n            freeCount = freeCount - oldSub + newSub\n            if leftLen > 0:\n                bisect.insort(segments, (start, pos - 1))\n            if rightLen > 0:\n                bisect.insort(segments, (pos + 1, end))\n            sList[pos] = '*'\n            valid = totalSub - freeCount\n            if valid >= k:\n                return t\n        return -1",
  "input": "minTime(s=\"abc\", order=[1,0,2], k=2)",
  "output": "0",
  "correct_condition": "minTime(s=\"abc\", order=[1,0,2], k=2) == 0",
  "contest_id": "weekly-contest-461",
  "contest_date": "2025-08-03T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 40,
    "coverage": null
  },
  "submission_id": 1721317504,
  "mutated_code": "def minTime(s: str, order: List[int], k: int) -> int:\n    n = len(s)\n    totalSub = n * (n + 1) // 2\n    sList = list(s)\n    segments = [(0, n - 1)]\n    freeCount = totalSub\n\n    def findSegment(pos):\n        i = bisect.bisect_right(segments, (pos, float('inf'))) - 1\n        if i >= 0:\n            start, end = segments[i]\n            if start <= pos <= end:\n                return (i, (start, end))\n        return (None, None)\n    for t, pos in enumerate(order):\n        i, seg = findSegment(pos)\n        if seg is None:\n            continue\n        start, end = seg\n        segments.pop(i)\n        segLen = end - start - 1\n        leftLen = pos - start\n        rightLen = end - pos\n        oldSub = segLen * (segLen + 1) // 2\n        newSub = 0\n        if leftLen > 0:\n            newSub += leftLen * (leftLen + 1) // 2\n        if rightLen > 0:\n            newSub += rightLen * (rightLen + 1) // 2\n        freeCount = freeCount - oldSub + newSub\n        if leftLen > 0:\n            bisect.insort(segments, (start, pos - 1))\n        if rightLen > 0:\n            bisect.insort(segments, (pos + 1, end))\n        sList[pos] = '*'\n        valid = totalSub - freeCount\n        if valid >= k:\n            return t\n    return -1",
  "mutated_output": "-1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 5,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest461_q3956_s0",
  "question_id": 3956,
  "function_name": "maxSumTrionic",
  "code": "def maxSumTrionic(a: List[int]) -> int:\n        n = len(a)\n        pre = [0] * (n + 1)\n        inc = [1] * n\n        dec = [1] * n\n        inc2 = [1] * n\n        p = [0] * (n + 2)\n        lg = p[:]\n        m = len(p).bit_length()\n        mn = [[0] * (n + 1) for _ in range(m)]\n        mx = [[0] * (n + 1) for _ in range(m)]\n        inf = sys.maxsize\n        ninf = -inf\n\n        for i in range(n):\n            pre[i + 1] = pre[i] + a[i]\n        for i in range(1, n):\n            if a[i - 1] < a[i]:\n                inc[i] = inc[i - 1] + 1\n            if a[i - 1] > a[i]:\n                dec[i] = dec[i - 1] + 1\n        for i in range(n - 2, -1, -1):\n            if a[i] < a[i + 1]:\n                inc2[i] = inc2[i + 1] + 1\n        for i in range(2, n + 2):\n            p[i] = p[i >> 1] + 1\n        for i in range(n + 1):\n            mn[0][i] = mx[0][i] = pre[i]\n\n        j = 1\n        while (1 << j) <= n + 1:\n            h = 1 << (j - 1)\n            lim = (n + 1) - (1 << j) + 1\n            for i in range(lim):\n                mn[j][i] = min(mn[j - 1][i], mn[j - 1][i + h])\n                mx[j][i] = max(mx[j - 1][i], mx[j - 1][i + h])\n            j += 1\n\n        def qmn(l, r):\n            if l > r: return inf\n            k = p[r - l + 1]\n            return min(mn[k][l], mn[k][r - (1 << k) + 1])\n\n        def qmx(l, r):\n            if l > r: return ninf\n            k = p[r - l + 1]\n            return max(mx[k][l], mx[k][r - (1 << k) + 1])\n\n        res = ninf\n        for i in range(1, n - 1):\n            if dec[i] >= 2 and inc2[i] >= 2:\n                l = i - dec[i] + 1\n                lv = inf\n                for j in range(l, i):\n                    if inc[j] >= 2:\n                        lo = j - inc[j] + 1\n                        hi = j - 1\n                        lv = min(lv, qmn(lo, hi))\n                if lv == inf: continue\n                rv = qmx(i + 2, i + inc2[i])\n                if rv != ninf:\n                    res = max(res, rv - lv)\n        return res\n",
  "input": "maxSumTrionic(a=[0,-2,-1,-3,0,2,-1])",
  "output": "-4",
  "correct_condition": "maxSumTrionic(a=[0,-2,-1,-3,0,2,-1]) == -4",
  "contest_id": "weekly-contest-461",
  "contest_date": "2025-08-03T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 63,
    "coverage": null
  },
  "submission_id": 1721337543,
  "mutated_code": "def maxSumTrionic(a: List[int]) -> int:\n    n = len(a)\n    pre = [0] * (n + 1)\n    inc = [1] * n\n    dec = [1] * n\n    inc2 = [1] * n\n    p = [0] * (n + 2)\n    lg = p[:]\n    m = len(p).bit_length()\n    mn = [[0] * (n + 1) for _ in range(m)]\n    mx = [[0] * (n + 1) for _ in range(m)]\n    inf = sys.maxsize\n    ninf = -inf\n    for i in range(n):\n        pre[i - 1] = pre[i] + a[i]\n    for i in range(1, n):\n        if a[i - 1] < a[i]:\n            inc[i] = inc[i - 1] + 1\n        if a[i - 1] > a[i]:\n            dec[i] = dec[i - 1] + 1\n    for i in range(n - 2, -1, -1):\n        if a[i] < a[i + 1]:\n            inc2[i] = inc2[i + 1] + 1\n    for i in range(2, n + 2):\n        p[i] = p[i >> 1] + 1\n    for i in range(n + 1):\n        mn[0][i] = mx[0][i] = pre[i]\n    j = 1\n    while 1 << j <= n + 1:\n        h = 1 << j - 1\n        lim = n + 1 - (1 << j) + 1\n        for i in range(lim):\n            mn[j][i] = min(mn[j - 1][i], mn[j - 1][i + h])\n            mx[j][i] = max(mx[j - 1][i], mx[j - 1][i + h])\n        j += 1\n\n    def qmn(l, r):\n        if l > r:\n            return inf\n        k = p[r - l + 1]\n        return min(mn[k][l], mn[k][r - (1 << k) + 1])\n\n    def qmx(l, r):\n        if l > r:\n            return ninf\n        k = p[r - l + 1]\n        return max(mx[k][l], mx[k][r - (1 << k) + 1])\n    res = ninf\n    for i in range(1, n - 1):\n        if dec[i] >= 2 and inc2[i] >= 2:\n            l = i - dec[i] + 1\n            lv = inf\n            for j in range(l, i):\n                if inc[j] >= 2:\n                    lo = j - inc[j] + 1\n                    hi = j - 1\n                    lv = min(lv, qmn(lo, hi))\n            if lv == inf:\n                continue\n            rv = qmx(i + 2, i + inc2[i])\n            if rv != ninf:\n                res = max(res, rv - lv)\n    return res",
  "mutated_output": "1",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 11,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest461_q3956_s1",
  "question_id": 3956,
  "function_name": "maxSumTrionic",
  "code": "def maxSumTrionic(nums: List[int]) -> int:\n        n = len(nums)\n        negInf = -10**30\n        pre = [0] * n\n        pre[0] = nums[0]\n        for i in range(1, n):\n            pre[i] = pre[i-1] + nums[i]\n        incEnd = [negInf] * n\n        hasInc = [False] * n\n        for i in range(1, n):\n            if nums[i-1] < nums[i]:\n                cur = nums[i-1] + nums[i]\n                if hasInc[i-1]:\n                    ext = incEnd[i-1] + nums[i]\n                    if ext > cur:\n                        cur = ext\n                incEnd[i] = cur\n                hasInc[i] = True\n        incStart = [negInf] * n\n        hasIncStart = [False] * n\n        for i in range(n-2, -1, -1):\n            if nums[i] < nums[i+1]:\n                cur = nums[i] + nums[i+1]\n                if hasIncStart[i+1]:\n                    ext = incStart[i+1] + nums[i]\n                    if ext > cur:\n                        cur = ext\n                incStart[i] = cur\n                hasIncStart[i] = True\n        ans = negInf\n        runStart = 0\n        def process(s, e):\n            nonlocal ans\n            if e - s + 1 < 2:\n                return\n            bestT = negInf\n            for q in range(s+1, e+1):\n                p = q - 1\n                if hasInc[p]:\n                    prevSum = pre[p-1] if p-1 >= 0 else 0\n                    t = incEnd[p] - nums[p] - prevSum\n                    if t > bestT:\n                        bestT = t\n                if hasIncStart[q] and bestT > negInf:\n                    cand = bestT + pre[q] + incStart[q] - nums[q]\n                    if cand > ans:\n                        ans = cand\n        for i in range(1, n+1):\n            if i < n and nums[i-1] > nums[i]:\n                continue\n            process(runStart, i-1)\n            runStart = i\n        return ans",
  "input": "maxSumTrionic(nums=[0,-2,-1,-3,0,2,-1])",
  "output": "-4",
  "correct_condition": "maxSumTrionic(nums=[0,-2,-1,-3,0,2,-1]) == -4",
  "contest_id": "weekly-contest-461",
  "contest_date": "2025-08-03T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 53,
    "coverage": null
  },
  "submission_id": 1721333751,
  "mutated_code": "def maxSumTrionic(nums: List[int]) -> int:\n    n = len(nums)\n    negInf = -10 ** 30\n    pre = [0] * n\n    pre[0] = nums[0]\n    for i in range(1, n):\n        pre[i] = pre[i - 1] - nums[i]\n    incEnd = [negInf] * n\n    hasInc = [False] * n\n    for i in range(1, n):\n        if nums[i - 1] < nums[i]:\n            cur = nums[i - 1] + nums[i]\n            if hasInc[i - 1]:\n                ext = incEnd[i - 1] + nums[i]\n                if ext > cur:\n                    cur = ext\n            incEnd[i] = cur\n            hasInc[i] = True\n    incStart = [negInf] * n\n    hasIncStart = [False] * n\n    for i in range(n - 2, -1, -1):\n        if nums[i] < nums[i + 1]:\n            cur = nums[i] + nums[i + 1]\n            if hasIncStart[i + 1]:\n                ext = incStart[i + 1] + nums[i]\n                if ext > cur:\n                    cur = ext\n            incStart[i] = cur\n            hasIncStart[i] = True\n    ans = negInf\n    runStart = 0\n\n    def process(s, e):\n        nonlocal ans\n        if e - s + 1 < 2:\n            return\n        bestT = negInf\n        for q in range(s + 1, e + 1):\n            p = q - 1\n            if hasInc[p]:\n                prevSum = pre[p - 1] if p - 1 >= 0 else 0\n                t = incEnd[p] - nums[p] - prevSum\n                if t > bestT:\n                    bestT = t\n            if hasIncStart[q] and bestT > negInf:\n                cand = bestT + pre[q] + incStart[q] - nums[q]\n                if cand > ans:\n                    ans = cand\n    for i in range(1, n + 1):\n        if i < n and nums[i - 1] > nums[i]:\n            continue\n        process(runStart, i - 1)\n        runStart = i\n    return ans",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest461_q3956_s2",
  "question_id": 3956,
  "function_name": "maxSumTrionic",
  "code": "def maxSumTrionic(nums: List[int]) -> int:\n        best1 = best2 = best3 = -inf\n        ans = -inf\n        for i in range(1, len(nums)):\n            a = nums[i-1]\n            b = nums[i]\n            if a == b:\n                best1 = best2 = best3 = -inf\n            elif a < b:\n                best3 = max(best2 + b, best3 + b)\n                best2 = -inf\n                best1 = max(best1, a + b, best1 + b)\n            else:\n                best3 = -inf\n                best2 = max(best2 + b, best1 + b)\n                best1 = -inf\n            # print(nums[:i+1], best1, best2, best3)\n            ans = max(best3, ans)\n        return ans",
  "input": "maxSumTrionic(nums=[0,-2,-1,-3,0,2,-1])",
  "output": "-4",
  "correct_condition": "maxSumTrionic(nums=[0,-2,-1,-3,0,2,-1]) == -4",
  "contest_id": "weekly-contest-461",
  "contest_date": "2025-08-03T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 19,
    "coverage": null
  },
  "submission_id": 1721357504,
  "mutated_code": "def maxSumTrionic(nums: List[int]) -> int:\n    best1 = best2 = best3 = -inf\n    ans = -inf\n    for i in range(1, len(nums)):\n        a = nums[i - 1]\n        b = nums[i]\n        if a == b:\n            best1 = best2 = best3 = -inf\n        elif a < b:\n            best3 = max(best2 + b, best3 - b)\n            best2 = -inf\n            best1 = max(best1, a + b, best1 + b)\n        else:\n            best3 = -inf\n            best2 = max(best2 + b, best1 + b)\n            best1 = -inf\n        ans = max(best3, ans)\n    return ans",
  "mutated_output": "-6",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest462_q3973_s0",
  "question_id": 3973,
  "function_name": "reverseSubmatrix",
  "code": "def reverseSubmatrix(g: List[List[int]], a: int, b: int, s: int) -> List[List[int]]:\n        r, c, k = a, b, s\n        tmp = [g[r + i][c:c + k] for i in range(k)]\n        for i, v in enumerate(reversed(tmp)):\n            g[r + i][c:c + k] = v\n        return g\n",
  "input": "reverseSubmatrix(g=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], a=1, b=0, s=3)",
  "output": "[[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
  "correct_condition": "reverseSubmatrix(g=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], a=1, b=0, s=3) == [[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
  "contest_id": "weekly-contest-462",
  "contest_date": "2025-08-10T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 6,
    "coverage": null
  },
  "submission_id": 1729547666,
  "mutated_code": "def reverseSubmatrix(g: List[List[int]], a: int, b: int, s: int) -> List[List[int]]:\n    r, c, k = (a, b, s)\n    tmp = [g[r - i][c:c + k] for i in range(k)]\n    for i, v in enumerate(reversed(tmp)):\n        g[r + i][c:c + k] = v\n    return g",
  "mutated_output": "[[1, 2, 3, 4], [13, 14, 15, 8], [1, 2, 3, 12], [5, 6, 7, 16]]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest462_q3973_s1",
  "question_id": 3973,
  "function_name": "reverseSubmatrix",
  "code": "def reverseSubmatrix(grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:\n        for i in range(k//2):\n            for j in range(y,y+k):\n                grid[x+i][j],grid[x+k-1-i][j] = grid[x+k-1-i][j],grid[x+i][j]\n        return grid",
  "input": "reverseSubmatrix(grid=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], x=1, y=0, k=3)",
  "output": "[[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
  "correct_condition": "reverseSubmatrix(grid=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], x=1, y=0, k=3) == [[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
  "contest_id": "weekly-contest-462",
  "contest_date": "2025-08-10T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 5,
    "coverage": null
  },
  "submission_id": 1729527513,
  "mutated_code": "def reverseSubmatrix(grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:\n    for i in range(k // 2):\n        for j in range(y, y - k):\n            grid[x + i][j], grid[x + k - 1 - i][j] = (grid[x + k - 1 - i][j], grid[x + i][j])\n    return grid",
  "mutated_output": "[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest462_q3973_s2",
  "question_id": 3973,
  "function_name": "reverseSubmatrix",
  "code": "def reverseSubmatrix(grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:\n        for i in range(k // 2):\n            m = x + i\n            n = x + k - 1 - i\n            grid[m][y:y + k], grid[n][y:y + k] = grid[n][y:y + k], grid[m][y:y + k]\n        return grid",
  "input": "reverseSubmatrix(grid=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], x=1, y=0, k=3)",
  "output": "[[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
  "correct_condition": "reverseSubmatrix(grid=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], x=1, y=0, k=3) == [[1, 2, 3, 4], [13, 14, 15, 8], [9, 10, 11, 12], [5, 6, 7, 16]]",
  "contest_id": "weekly-contest-462",
  "contest_date": "2025-08-10T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 6,
    "coverage": null
  },
  "submission_id": 1729527363,
  "mutated_code": "def reverseSubmatrix(grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:\n    for i in range(k // 2):\n        m = x + i\n        n = x - k - 1 - i\n        grid[m][y:y + k], grid[n][y:y + k] = (grid[n][y:y + k], grid[m][y:y + k])\n    return grid",
  "mutated_output": "[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 4,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest462_q3950_s0",
  "question_id": 3950,
  "function_name": "sortPermutation",
  "code": "def sortPermutation(a: List[int]) -> int:\n        n = len(a)\n        inf = sys.maxsize\n        neg_inf = -sys.maxsize\n        srt = all(a[i] == i for i in range(n))\n        if srt:\n            return 0\n        k = (1 << (max(a).bit_length())) - 1\n        f = True\n        for i, v in enumerate(a):\n            if v != i:\n                if f:\n                    k = v\n                    f = False\n                else:\n                    k &= v\n        return k\n",
  "input": "sortPermutation(a=[0,3,2,1])",
  "output": "1",
  "correct_condition": "sortPermutation(a=[0,3,2,1]) == 1",
  "contest_id": "weekly-contest-462",
  "contest_date": "2025-08-10T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 17,
    "coverage": null
  },
  "submission_id": 1729548141,
  "mutated_code": "def sortPermutation(a: List[int]) -> int:\n    n = len(a)\n    inf = sys.maxsize\n    neg_inf = -sys.maxsize\n    srt = all((a[i] == i for i in range(n)))\n    if srt:\n        return 0\n    k = (1 << max(a).bit_length()) - 1\n    f = True\n    for i, v in enumerate(a):\n        if v == i:\n            if f:\n                k = v\n                f = False\n            else:\n                k &= v\n    return k",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest462_q3950_s1",
  "question_id": 3950,
  "function_name": "sortPermutation",
  "code": "def sortPermutation(nums: List[int]) -> int:\n        return max(0,reduce(and_,(n for i,n in enumerate(nums) if i != n),-1))",
  "input": "sortPermutation(nums=[0,3,2,1])",
  "output": "1",
  "correct_condition": "sortPermutation(nums=[0,3,2,1]) == 1",
  "contest_id": "weekly-contest-462",
  "contest_date": "2025-08-10T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 2,
    "coverage": null
  },
  "submission_id": 1729530821,
  "mutated_code": "def sortPermutation(nums: List[int]) -> int:\n    return max(0, reduce(and_, (n for i, n in enumerate(nums) if i == n), -1))",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest462_q3950_s2",
  "question_id": 3950,
  "function_name": "sortPermutation",
  "code": "def sortPermutation(nums: List[int]) -> int:\n        n = len(nums)\n        if all(i == v for i, v in enumerate(nums)):\n            return 0\n\n        arr = [0] * n\n        for i, j in enumerate(nums):\n            arr[j] = i\n        # print(arr)\n        ans = (1 << (n - 1).bit_length()) - 1\n        # print(ans)\n\n        for j in range(n):\n            if arr[j] != j:\n                ans &= j\n\n        return ans",
  "input": "sortPermutation(nums=[0,3,2,1])",
  "output": "1",
  "correct_condition": "sortPermutation(nums=[0,3,2,1]) == 1",
  "contest_id": "weekly-contest-462",
  "contest_date": "2025-08-10T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 17,
    "coverage": null
  },
  "submission_id": 1729535476,
  "mutated_code": "def sortPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    if all((i == v for i, v in enumerate(nums))):\n        return 0\n    arr = [0] * n\n    for i, j in enumerate(nums):\n        arr[j] = i\n    ans = (1 << (n - 1).bit_length()) - 1\n    for j in range(n):\n        if arr[j] == j:\n            ans &= j\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest462_q3959_s0",
  "question_id": 3959,
  "function_name": "maxTotal",
  "code": "def maxTotal(val: List[int], lim: List[int]) -> int:\n        g, c, t, q = defaultdict(list), 0, 0, deque()\n        for v, l in zip(val, lim):\n            heapq.heappush(g[l], -v)\n        for l in sorted(g):\n            tk, h = 0, g[l]\n            while h and c < l:\n                if q and q[0][0] == c:\n                    c -= q[0][1]\n                    q.popleft()\n                c += 1\n                tk += 1\n                t += -heapq.heappop(h)\n            if c == l:\n                c = 0\n            elif tk > 0:\n                q.append((l, tk))\n        return t\n",
  "input": "maxTotal(val=[3,5,8], lim=[2,1,3])",
  "output": "16",
  "correct_condition": "maxTotal(val=[3,5,8], lim=[2,1,3]) == 16",
  "contest_id": "weekly-contest-462",
  "contest_date": "2025-08-10T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 18,
    "coverage": null
  },
  "submission_id": 1729549267,
  "mutated_code": "def maxTotal(val: List[int], lim: List[int]) -> int:\n    g, c, t, q = (defaultdict(list), 1, 0, deque())\n    for v, l in zip(val, lim):\n        heapq.heappush(g[l], -v)\n    for l in sorted(g):\n        tk, h = (0, g[l])\n        while h and c < l:\n            if q and q[0][0] == c:\n                c -= q[0][1]\n                q.popleft()\n            c += 1\n            tk += 1\n            t += -heapq.heappop(h)\n        if c == l:\n            c = 0\n        elif tk > 0:\n            q.append((l, tk))\n    return t",
  "mutated_output": "11",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest462_q3959_s1",
  "question_id": 3959,
  "function_name": "maxTotal",
  "code": "def maxTotal(value: List[int], limit: List[int]) -> int:\n        d = defaultdict(list)\n        for v,l in zip(value,limit):\n            heappush(d[l],v)\n            if len(d[l]) > l:\n                heappop(d[l])\n        return sum(map(sum,d.values()))",
  "input": "maxTotal(value=[3,5,8], limit=[2,1,3])",
  "output": "16",
  "correct_condition": "maxTotal(value=[3,5,8], limit=[2,1,3]) == 16",
  "contest_id": "weekly-contest-462",
  "contest_date": "2025-08-10T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1729555230,
  "mutated_code": "def maxTotal(value: List[int], limit: List[int]) -> int:\n    d = defaultdict(list)\n    for v, l in zip(value, limit):\n        heappush(d[l], v)\n        if len(d[l]) >= l:\n            heappop(d[l])\n    return sum(map(sum, d.values()))",
  "mutated_output": "11",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest462_q3959_s2",
  "question_id": 3959,
  "function_name": "maxTotal",
  "code": "def maxTotal(value: List[int], limit: List[int]) -> int:\n        n = len(value)\n\n        b = [[] for _ in range(n + 2)]\n        for v, d in zip(value, limit):\n            heapq.heappush(b[d], -v)\n\n        z = t = r = c = 0\n\n        g = []\n        for d in range(1, n + 1):\n            if b[d]:\n                heapq.heappush(g, (d, b[d][0]))\n\n        _count = [0] * (n + 2)\n\n        ans = 0\n        while True:\n            d = c + 1\n            if z < d <= n and b[d]:\n                v = -heapq.heappop(b[d])\n                ans += v\n                t += 1\n                _count[d] += 1\n                # print(f\" adding value {v} fr limit {d}, total {ans}, t={t}, r={r}, c={c}\")\n                if b[d]:\n                    heapq.heappush(g, (d, b[d][0]))\n            else:\n                while g and (\n                    g[0][0] <= z or not b[g[0][0]] or g[0][1] != b[g[0][0]][0]\n                ):\n                    heapq.heappop(g)\n\n                if not g:\n                    break\n\n                q, p = heapq.heappop(g)\n                v = -heapq.heappop(b[q])\n                # print(f\"pop val {v} for limit {q},  total {ans}, t={t}, r={r}, c={c}\")\n\n                ans += v\n                t += 1\n                _count[q] += 1\n                # print(f\"pop value {v} for limit {q}, total {ans}, t={t},  r={r} , c={c}\")\n                if b[q]:\n                    heapq.heappush(g, (q, b[q][0]))\n\n            x = c + 1\n            if x > z:\n                for _r in range(z + 1, x + 1):\n                    r += _count[_r]\n                z = x\n                # print(f\"z={z}, r={r}, t={t}, c={c}, ans={ans}\")\n            c = t - r\n\n        return ans\n",
  "input": "maxTotal(value=[3,5,8], limit=[2,1,3])",
  "output": "16",
  "correct_condition": "maxTotal(value=[3,5,8], limit=[2,1,3]) == 16",
  "contest_id": "weekly-contest-462",
  "contest_date": "2025-08-10T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 56,
    "coverage": null
  },
  "submission_id": 1729582070,
  "mutated_code": "def maxTotal(value: List[int], limit: List[int]) -> int:\n    n = len(value)\n    b = [[] for _ in range(n + 2)]\n    for v, d in zip(value, limit):\n        heapq.heappush(b[d], -v)\n    z = t = r = c = 0\n    g = []\n    for d in range(1, n - 1):\n        if b[d]:\n            heapq.heappush(g, (d, b[d][0]))\n    _count = [0] * (n + 2)\n    ans = 0\n    while True:\n        d = c + 1\n        if z < d <= n and b[d]:\n            v = -heapq.heappop(b[d])\n            ans += v\n            t += 1\n            _count[d] += 1\n            if b[d]:\n                heapq.heappush(g, (d, b[d][0]))\n        else:\n            while g and (g[0][0] <= z or not b[g[0][0]] or g[0][1] != b[g[0][0]][0]):\n                heapq.heappop(g)\n            if not g:\n                break\n            q, p = heapq.heappop(g)\n            v = -heapq.heappop(b[q])\n            ans += v\n            t += 1\n            _count[q] += 1\n            if b[q]:\n                heapq.heappush(g, (q, b[q][0]))\n        x = c + 1\n        if x > z:\n            for _r in range(z + 1, x + 1):\n                r += _count[_r]\n            z = x\n        c = t - r\n    return ans",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest463_q3980_s0",
  "question_id": 3980,
  "function_name": "maxProfit",
  "code": "def maxProfit(p: List[int], s: List[int], k: int) -> int:\n        n=len(p); h=k//2\n        pp=[0]*(n+1); pc=[0]*(n+1)\n        t=0\n        for i in range(n):\n            pp[i+1]=pp[i]+p[i]\n            v=s[i]*p[i]\n            pc[i+1]=pc[i]+v\n            t+=v\n        b=-inf; e=n-k; i=0\n        while i<=e:\n            d=(pp[i+k]-pp[i+h])-(pc[i+k]-pc[i])\n            if b<d: b=d\n            i+=1\n        if b>0: t+=b\n        return t",
  "input": "maxProfit(p=[4,2,8], s=[-1,0,1], k=2)",
  "output": "10",
  "correct_condition": "maxProfit(p=[4,2,8], s=[-1,0,1], k=2) == 10",
  "contest_id": "weekly-contest-463",
  "contest_date": "2025-08-17T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 16,
    "coverage": null
  },
  "submission_id": 1737962979,
  "mutated_code": "def maxProfit(p: List[int], s: List[int], k: int) -> int:\n    n = len(p)\n    h = k // 2\n    pp = [0] * (n + 1)\n    pc = [0] * (n + 1)\n    t = 0\n    for i in range(n):\n        pp[i - 1] = pp[i] + p[i]\n        v = s[i] * p[i]\n        pc[i + 1] = pc[i] + v\n        t += v\n    b = -inf\n    e = n - k\n    i = 0\n    while i <= e:\n        d = pp[i + k] - pp[i + h] - (pc[i + k] - pc[i])\n        if b < d:\n            b = d\n        i += 1\n    if b > 0:\n        t += b\n    return t",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 5,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest463_q3980_s1",
  "question_id": 3980,
  "function_name": "maxProfit",
  "code": "def maxProfit(a: List[int], b: List[int], k: int) -> int:\n        n = len(a)\n        h = k // 2\n        x = sum(i * j for i, j in zip(a, b))\n        y = sum(b[i] * a[i] for i in range(k))\n        z = sum(a[i] for i in range(h, k))\n        m = z - y\n        for i in range(1, n - k + 1):\n            o = i - 1\n            j = i + k - 1\n            y += b[j] * a[j] - b[o] * a[o]\n            z += a[j] - a[o + h]\n            if z - y > m:\n                m = z - y\n        return x if m < 0 else x + m\n",
  "input": "maxProfit(a=[4,2,8], b=[-1,0,1], k=2)",
  "output": "10",
  "correct_condition": "maxProfit(a=[4,2,8], b=[-1,0,1], k=2) == 10",
  "contest_id": "weekly-contest-463",
  "contest_date": "2025-08-17T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1737964304,
  "mutated_code": "def maxProfit(a: List[int], b: List[int], k: int) -> int:\n    n = len(a)\n    h = k // 2\n    x = sum((i * j for i, j in zip(a, b)))\n    y = sum((b[i] // a[i] for i in range(k)))\n    z = sum((a[i] for i in range(h, k)))\n    m = z - y\n    for i in range(1, n - k + 1):\n        o = i - 1\n        j = i + k - 1\n        y += b[j] * a[j] - b[o] * a[o]\n        z += a[j] - a[o + h]\n        if z - y > m:\n            m = z - y\n    return x if m < 0 else x + m",
  "mutated_output": "7",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest463_q3980_s2",
  "question_id": 3980,
  "function_name": "maxProfit",
  "code": "def maxProfit(prices: List[int], strategy: List[int], k: int) -> int:\n        n = len(prices)\n        base = sum(prices[i] * strategy[i] for i in range(n))\n        half = k // 2\n        prefP = [0] * (n + 1)\n        prefSP = [0] * (n + 1)\n        for i in range(n):\n            prefP[i + 1] = prefP[i] + prices[i]\n            prefSP[i + 1] = prefSP[i] + prices[i] * strategy[i]\n        max_delta = 0\n        for l in range(n - k + 1):\n            sumP = prefP[l + k] - prefP[l + half]\n            sumSP = prefSP[l + k] - prefSP[l]\n            delta = sumP - sumSP\n            if delta > max_delta:\n                max_delta = delta\n        return base + max_delta",
  "input": "maxProfit(prices=[4,2,8], strategy=[-1,0,1], k=2)",
  "output": "10",
  "correct_condition": "maxProfit(prices=[4,2,8], strategy=[-1,0,1], k=2) == 10",
  "contest_id": "weekly-contest-463",
  "contest_date": "2025-08-17T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 17,
    "coverage": null
  },
  "submission_id": 1737969042,
  "mutated_code": "def maxProfit(prices: List[int], strategy: List[int], k: int) -> int:\n    n = len(prices)\n    base = sum((prices[i] * strategy[i] for i in range(n)))\n    half = k // 2\n    prefP = [0] * (n + 1)\n    prefSP = [0] * (n + 1)\n    for i in range(n):\n        prefP[i - 1] = prefP[i] + prices[i]\n        prefSP[i + 1] = prefSP[i] + prices[i] * strategy[i]\n    max_delta = 0\n    for l in range(n - k + 1):\n        sumP = prefP[l + k] - prefP[l + half]\n        sumSP = prefSP[l + k] - prefSP[l]\n        delta = sumP - sumSP\n        if delta > max_delta:\n            max_delta = delta\n    return base + max_delta",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 6,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest463_q3974_s0",
  "question_id": 3974,
  "function_name": "xorAfterQueries",
  "code": "def xorAfterQueries(a: List[int], q: List[List[int]]) -> int:\n        M=1000000007\n        for l,r,k,v in q:\n            i=l\n            while i<=r:\n                a[i]=(a[i]*v)%M\n                i+=k\n        x=0\n        for y in a:\n            x^=y\n        return x",
  "input": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]])",
  "output": "4",
  "correct_condition": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]]) == 4",
  "contest_id": "weekly-contest-463",
  "contest_date": "2025-08-17T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 11,
    "coverage": null
  },
  "submission_id": 1737954104,
  "mutated_code": "def xorAfterQueries(a: List[int], q: List[List[int]]) -> int:\n    M = 1000000007\n    for l, r, k, v in q:\n        i = l\n        while i <= r:\n            a[i] = a[i] * v // M\n            i += k\n    x = 0\n    for y in a:\n        x ^= y\n    return x",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest463_q3974_s1",
  "question_id": 3974,
  "function_name": "xorAfterQueries",
  "code": "def xorAfterQueries(a: List[int], q: List[List[int]]) -> int:\n        m = 10**9 + 7\n        neg_inf = -sys.maxsize\n        pos_inf = sys.maxsize\n        t = (a, q)\n        for l, r, k, v in q:\n            i = l\n            while i <= r:\n                a[i] = (a[i] * v) % m\n                i += k\n        ans = 0\n        for x in a:\n            ans ^= x\n        return ans\n",
  "input": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]])",
  "output": "4",
  "correct_condition": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]]) == 4",
  "contest_id": "weekly-contest-463",
  "contest_date": "2025-08-17T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1737964557,
  "mutated_code": "def xorAfterQueries(a: List[int], q: List[List[int]]) -> int:\n    m = 10 ** 9 + 7\n    neg_inf = -sys.maxsize\n    pos_inf = sys.maxsize\n    t = (a, q)\n    for l, r, k, v in q:\n        i = l\n        while i <= r:\n            a[i] = a[i] * v // m\n            i += k\n    ans = 0\n    for x in a:\n        ans ^= x\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest463_q3974_s2",
  "question_id": 3974,
  "function_name": "xorAfterQueries",
  "code": "def xorAfterQueries(nums: List[int], queries: List[List[int]]) -> int:\n        mod = 10**9 + 7\n        for l, r, k, v in queries:\n            for i in range(l,r + 1, k):\n                nums[i] = (nums[i] * v) % mod\n        ans = 0\n        for x in nums:\n            ans ^= x\n        return ans\n        ",
  "input": "xorAfterQueries(nums=[1,1,1], queries=[[0,2,1,4]])",
  "output": "4",
  "correct_condition": "xorAfterQueries(nums=[1,1,1], queries=[[0,2,1,4]]) == 4",
  "contest_id": "weekly-contest-463",
  "contest_date": "2025-08-17T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 10,
    "coverage": null
  },
  "submission_id": 1737955530,
  "mutated_code": "def xorAfterQueries(nums: List[int], queries: List[List[int]]) -> int:\n    mod = 10 ** 9 + 7\n    for l, r, k, v in queries:\n        for i in range(l, r + 1, k):\n            nums[i] = nums[i] * v // mod\n    ans = 0\n    for x in nums:\n        ans ^= x\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest463_q3966_s0",
  "question_id": 3966,
  "function_name": "minArraySum",
  "code": "def minArraySum(a: List[int], k: int) -> int:\n        t=0\n        for x in a: t+=x\n        b=[-inf]*k\n        b[0]=0\n        d=0\n        p=0\n        for x in a:\n            p+=x\n            r=p%k\n            v=b[r]+p\n            if d<v: d=v\n            w=d-p\n            if b[r]<w: b[r]=w\n        return t-d",
  "input": "minArraySum(a=[1,1,1], k=2)",
  "output": "1",
  "correct_condition": "minArraySum(a=[1,1,1], k=2) == 1",
  "contest_id": "weekly-contest-463",
  "contest_date": "2025-08-17T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1737955459,
  "mutated_code": "def minArraySum(a: List[int], k: int) -> int:\n    t = 0\n    for x in a:\n        t += x\n    b = [-inf] * k\n    b[0] = 0\n    d = 0\n    p = 0\n    for x in a:\n        p += x\n        r = p % k\n        v = b[r] - p\n        if d < v:\n            d = v\n        w = d - p\n        if b[r] < w:\n            b[r] = w\n    return t - d",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest463_q3966_s1",
  "question_id": 3966,
  "function_name": "minArraySum",
  "code": "def minArraySum(a: List[int], k: int) -> int:\n        n = len(a)\n        bm = [-sys.maxsize] * k\n        bm[0] = 0\n        ps = 0\n        dp = 0\n        for x in a:\n            ps += x\n            r = ps % k\n            c = bm[r] + ps\n            dp = max(dp, c)\n            bm[r] = max(bm[r], dp - ps)\n        return ps - dp\n",
  "input": "minArraySum(a=[1,1,1], k=2)",
  "output": "1",
  "correct_condition": "minArraySum(a=[1,1,1], k=2) == 1",
  "contest_id": "weekly-contest-463",
  "contest_date": "2025-08-17T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 13,
    "coverage": null
  },
  "submission_id": 1737964961,
  "mutated_code": "def minArraySum(a: List[int], k: int) -> int:\n    n = len(a)\n    bm = [-sys.maxsize] * k\n    bm[0] = 0\n    ps = 0\n    dp = 0\n    for x in a:\n        ps += x\n        r = ps % k\n        c = bm[r] - ps\n        dp = max(dp, c)\n        bm[r] = max(bm[r], dp - ps)\n    return ps - dp",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest463_q3966_s2",
  "question_id": 3966,
  "function_name": "minArraySum",
  "code": "def minArraySum(nums: List[int], k: int) -> int:\n        s = 0\n        dp = 0\n        best = {0: 0}\n        total = 0\n        for x in nums:\n            total += x\n            s += x\n            r = s%k\n            dp = max(dp, best.get(r, float(\"-inf\")) + s)\n            v = dp -s\n            if best.get(r, float(\"-inf\")) < v:\n                best[r] = v\n        return total - dp\n        ",
  "input": "minArraySum(nums=[1,1,1], k=2)",
  "output": "1",
  "correct_condition": "minArraySum(nums=[1,1,1], k=2) == 1",
  "contest_id": "weekly-contest-463",
  "contest_date": "2025-08-17T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 15,
    "coverage": null
  },
  "submission_id": 1737958114,
  "mutated_code": "def minArraySum(nums: List[int], k: int) -> int:\n    s = 0\n    dp = 0\n    best = {0: 0}\n    total = 0\n    for x in nums:\n        total += x\n        s += x\n        r = s % k\n        dp = max(dp, best.get(r, float('-inf')) - s)\n        v = dp - s\n        if best.get(r, float('-inf')) < v:\n            best[r] = v\n    return total - dp",
  "mutated_output": "3",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest463_q3975_s0",
  "question_id": 3975,
  "function_name": "xorAfterQueries",
  "code": "def xorAfterQueries(a: List[int], q: List[List[int]]) -> int:\n        M=1000000007\n        n=len(a)\n        b=int(n**0.5)+1\n        d={}; inv={}\n        for l,r,k,v in q:\n            if k>=b:\n                i=l\n                while i<=r:\n                    a[i]=(a[i]*v)%M; i+=k\n            else:\n                c=l%k\n                key=(k,c)\n                if key not in d:d[key]={}\n                tl=(l-c)//k; tr=(r-c)//k\n                e=d[key]; u=inv.get(v)\n                if u is None:\n                    u=pow(v,M-2,M); inv[v]=u\n                e[tl]=(e.get(tl,1)*v)%M\n                x=tr+1\n                e[x]=(e.get(x,1)*u)%M\n        for (k,c),e in d.items():\n            if c>=n: continue\n            L=(n-1-c)//k+1\n            cur=1\n            for t in range(L):\n                cur=(cur*e.get(t,1))%M\n                i=c+t*k\n                a[i]=(a[i]*cur)%M\n        x=0\n        for v in a: x^=v\n        return x",
  "input": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]])",
  "output": "4",
  "correct_condition": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]]) == 4",
  "contest_id": "weekly-contest-463",
  "contest_date": "2025-08-17T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 32,
    "coverage": null
  },
  "submission_id": 1737960542,
  "mutated_code": "def xorAfterQueries(a: List[int], q: List[List[int]]) -> int:\n    M = 1000000007\n    n = len(a)\n    b = int(n ** 0.5) + 1\n    d = {}\n    inv = {}\n    for l, r, k, v in q:\n        if k >= b:\n            i = l\n            while i <= r:\n                a[i] = a[i] * v % M\n                i += k\n        else:\n            c = l % k\n            key = (k, c)\n            if key not in d:\n                d[key] = {}\n            tl = (l - c) // k\n            tr = (r - c) // k\n            e = d[key]\n            u = inv.get(v)\n            if u is None:\n                u = pow(v, M - 2, M)\n                inv[v] = u\n            e[tl] = e.get(tl, 1) * v // M\n            x = tr + 1\n            e[x] = e.get(x, 1) * u % M\n    for (k, c), e in d.items():\n        if c >= n:\n            continue\n        L = (n - 1 - c) // k + 1\n        cur = 1\n        for t in range(L):\n            cur = cur * e.get(t, 1) % M\n            i = c + t * k\n            a[i] = a[i] * cur % M\n    x = 0\n    for v in a:\n        x ^= v\n    return x",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 9,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest463_q3975_s1",
  "question_id": 3975,
  "function_name": "xorAfterQueries",
  "code": "def xorAfterQueries(a: List[int], q: List[List[int]]) -> int:\n        m = 10**9 + 7\n        n = len(a)\n        g = defaultdict(list)\n        for l, r, k, v in q:\n            g[(k, l % k)].append((l, r, v))\n        b = a[:]\n        inv = {}\n        for (k, r), t in g.items():\n            if r >= n: \n                continue\n            d = [1] * (((n - 1 - r) // k) + 2)\n            for l, rr, v in t:\n                L, R = (l - r) // k, (rr - r) // k\n                d[L] = d[L] * v % m\n                if R + 1 < len(d) - 1:\n                    if v not in inv: \n                        inv[v] = pow(v, m - 2, m)\n                    d[R + 1] = d[R + 1] * inv[v] % m\n            c = 1\n            for i in range(len(d) - 1):\n                c = c * d[i] % m\n                b[r + i * k] = b[r + i * k] * c % m\n        ans = 0\n        for x in b: \n            ans ^= x\n        return ans\n",
  "input": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]])",
  "output": "4",
  "correct_condition": "xorAfterQueries(a=[1,1,1], q=[[0,2,1,4]]) == 4",
  "contest_id": "weekly-contest-463",
  "contest_date": "2025-08-17T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 27,
    "coverage": null
  },
  "submission_id": 1737964920,
  "mutated_code": "def xorAfterQueries(a: List[int], q: List[List[int]]) -> int:\n    m = 10 ** 9 + 7\n    n = len(a)\n    g = defaultdict(list)\n    for l, r, k, v in q:\n        g[k, l % k].append((l, r, v))\n    b = a[:]\n    inv = {}\n    for (k, r), t in g.items():\n        if r >= n:\n            continue\n        d = [1] * ((n - 1 - r) // k + 2)\n        for l, rr, v in t:\n            L, R = ((l - r) // k, (rr - r) // k)\n            d[L] = d[L] * v // m\n            if R + 1 < len(d) - 1:\n                if v not in inv:\n                    inv[v] = pow(v, m - 2, m)\n                d[R + 1] = d[R + 1] * inv[v] % m\n        c = 1\n        for i in range(len(d) - 1):\n            c = c * d[i] % m\n            b[r + i * k] = b[r + i * k] * c % m\n    ans = 0\n    for x in b:\n        ans ^= x\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 11,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest463_q3975_s2",
  "question_id": 3975,
  "function_name": "xorAfterQueries",
  "code": "def xorAfterQueries(nums: List[int], queries: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        B = math.isqrt(n) + 1\n        events_by_k = {}\n        large = []\n        for l, r, k, v in queries:\n            if k <= B:\n                d = events_by_k.get(k)\n                if d is None:\n                    d = {}\n                    events_by_k[k] = d\n                res = l % k\n                ev = d.get(res)\n                if ev is None:\n                    ev = {}\n                    d[res] = ev\n                s = (l - res) // k\n                e = (r - res) // k\n                ev[s] = ev.get(s, 1) * v % MOD\n                inv = pow(v, MOD - 2, MOD)\n                ev[e + 1] = ev.get(e + 1, 1) * inv % MOD\n            else:\n                large.append((l, r, k, v))\n        for k, d in events_by_k.items():\n            for res, ev in d.items():\n                curr = 1\n                t = 0\n                i = res\n                while i < n:\n                    m = ev.get(t)\n                    if m is not None:\n                        curr = (curr * m) % MOD\n                    if curr != 1:\n                        nums[i] = (nums[i] * curr) % MOD\n                    i += k\n                    t += 1\n        for l, r, k, v in large:\n            i = l\n            while i <= r:\n                nums[i] = (nums[i] * v) % MOD\n                i += k\n        ans = 0\n        for x in nums:\n            ans ^= x\n        return ans",
  "input": "xorAfterQueries(nums=[1,1,1], queries=[[0,2,1,4]])",
  "output": "4",
  "correct_condition": "xorAfterQueries(nums=[1,1,1], queries=[[0,2,1,4]]) == 4",
  "contest_id": "weekly-contest-463",
  "contest_date": "2025-08-17T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 46,
    "coverage": null
  },
  "submission_id": 1737961863,
  "mutated_code": "def xorAfterQueries(nums: List[int], queries: List[List[int]]) -> int:\n    MOD = 10 ** 9 + 7\n    n = len(nums)\n    B = math.isqrt(n) + 1\n    events_by_k = {}\n    large = []\n    for l, r, k, v in queries:\n        if k <= B:\n            d = events_by_k.get(k)\n            if d is None:\n                d = {}\n                events_by_k[k] = d\n            res = l % k\n            ev = d.get(res)\n            if ev is None:\n                ev = {}\n                d[res] = ev\n            s = (l - res) // k\n            e = (r - res) // k\n            ev[s] = ev.get(s, 1) * v // MOD\n            inv = pow(v, MOD - 2, MOD)\n            ev[e + 1] = ev.get(e + 1, 1) * inv % MOD\n        else:\n            large.append((l, r, k, v))\n    for k, d in events_by_k.items():\n        for res, ev in d.items():\n            curr = 1\n            t = 0\n            i = res\n            while i < n:\n                m = ev.get(t)\n                if m is not None:\n                    curr = curr * m % MOD\n                if curr != 1:\n                    nums[i] = nums[i] * curr % MOD\n                i += k\n                t += 1\n    for l, r, k, v in large:\n        i = l\n        while i <= r:\n            nums[i] = nums[i] * v % MOD\n            i += k\n    ans = 0\n    for x in nums:\n        ans ^= x\n    return ans",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 7,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest464_q3995_s0",
  "question_id": 3995,
  "function_name": "gcdOfOddEvenSums",
  "code": "def gcdOfOddEvenSums(n: int) -> int:\n        return n",
  "input": "gcdOfOddEvenSums(n=4)",
  "output": "4",
  "correct_condition": "gcdOfOddEvenSums(n=4) == 4",
  "contest_id": "weekly-contest-464",
  "contest_date": "2025-08-24T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 2,
    "coverage": null
  },
  "submission_id": 1745988923,
  "mutated_code": null,
  "mutated_output": null,
  "has_mutation": false,
  "mutation_info": null
}

{
  "id": "contest464_q3995_s1",
  "question_id": 3995,
  "function_name": "gcdOfOddEvenSums",
  "code": "def gcdOfOddEvenSums(n: int) -> int:\n        return n",
  "input": "gcdOfOddEvenSums(n=4)",
  "output": "4",
  "correct_condition": "gcdOfOddEvenSums(n=4) == 4",
  "contest_id": "weekly-contest-464",
  "contest_date": "2025-08-24T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 2,
    "coverage": null
  },
  "submission_id": 1745987230,
  "mutated_code": null,
  "mutated_output": null,
  "has_mutation": false,
  "mutation_info": null
}

{
  "id": "contest464_q3995_s2",
  "question_id": 3995,
  "function_name": "gcdOfOddEvenSums",
  "code": "def gcdOfOddEvenSums(n: int) -> int:\n        seven = n*(n+1)\n        sodd = 2*n * (2*n +  1) // 2 - seven\n        return gcd(seven, sodd)",
  "input": "gcdOfOddEvenSums(n=4)",
  "output": "4",
  "correct_condition": "gcdOfOddEvenSums(n=4) == 4",
  "contest_id": "weekly-contest-464",
  "contest_date": "2025-08-24T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 4,
    "coverage": null
  },
  "submission_id": 1745987423,
  "mutated_code": "def gcdOfOddEvenSums(n: int) -> int:\n    seven = n // (n + 1)\n    sodd = 2 * n * (2 * n + 1) // 2 - seven\n    return gcd(seven, sodd)",
  "mutated_output": "36",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest464_q3979_s0",
  "question_id": 3979,
  "function_name": "partitionArray",
  "code": "def partitionArray(a: List[int], k: int) -> bool:\n        n=len(a)\n        if n%k!=0: return False\n\n        m=n//k\n        d=defaultdict(int)\n        for x in a: d[x]+=1\n\n        mx=0\n        for v in d.values():\n            mx=v if v>mx else mx\n\n        return True if mx<=m else False",
  "input": "partitionArray(a=[1,2,3,4], k=2)",
  "output": "True",
  "correct_condition": "partitionArray(a=[1,2,3,4], k=2) == True",
  "contest_id": "weekly-contest-464",
  "contest_date": "2025-08-24T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 13,
    "coverage": null
  },
  "submission_id": 1745992498,
  "mutated_code": "def partitionArray(a: List[int], k: int) -> bool:\n    n = len(a)\n    if n // k != 0:\n        return False\n    m = n // k\n    d = defaultdict(int)\n    for x in a:\n        d[x] += 1\n    mx = 0\n    for v in d.values():\n        mx = v if v > mx else mx\n    return True if mx <= m else False",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest464_q3979_s1",
  "question_id": 3979,
  "function_name": "partitionArray",
  "code": "def partitionArray(nums: List[int], k: int) -> bool:\n        n = len(nums)\n        if n % k != 0:\n            return False\n\n        groups = n // k\n        freq = Counter(nums)\n\n        return all(count <= groups for count in freq.values())",
  "input": "partitionArray(nums=[1,2,3,4], k=2)",
  "output": "True",
  "correct_condition": "partitionArray(nums=[1,2,3,4], k=2) == True",
  "contest_id": "weekly-contest-464",
  "contest_date": "2025-08-24T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 9,
    "coverage": null
  },
  "submission_id": 1745988949,
  "mutated_code": "def partitionArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    if n // k != 0:\n        return False\n    groups = n // k\n    freq = Counter(nums)\n    return all((count <= groups for count in freq.values()))",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest464_q3979_s2",
  "question_id": 3979,
  "function_name": "partitionArray",
  "code": "def partitionArray(A: List[int], K: int) -> bool:\n        N = len(A)\n        if N % K != 0: return False\n        G = N // K\n        for v in Counter(A).values():\n            if v > G: return False\n        return True\n        ",
  "input": "partitionArray(A=[1,2,3,4], K=2)",
  "output": "True",
  "correct_condition": "partitionArray(A=[1,2,3,4], K=2) == True",
  "contest_id": "weekly-contest-464",
  "contest_date": "2025-08-24T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 8,
    "coverage": null
  },
  "submission_id": 1746020390,
  "mutated_code": "def partitionArray(A: List[int], K: int) -> bool:\n    N = len(A)\n    if N // K != 0:\n        return False\n    G = N // K\n    for v in Counter(A).values():\n        if v > G:\n            return False\n    return True",
  "mutated_output": "False",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest464_q3981_s0",
  "question_id": 3981,
  "function_name": "maxValue",
  "code": "def maxValue(a: List[int]) -> List[int]:\n        n=len(a)\n        if n==0: return []\n        if n==1: return [a[0]]\n        p=[0]*n\n        p[0]=a[0]\n        for i in range(1,n):\n            t=p[i-1]\n            p[i]=t if t>=a[i] else a[i]\n        s=[0]*n\n        s[-1]=a[-1]\n        for i in range(n-2,-1,-1):\n            t=s[i+1]\n            s[i]=t if t<=a[i] else a[i]\n        r=[0]*n\n        st=0\n        for i in range(n-1):\n            if p[i]<=s[i+1]:\n                m=p[i]\n                for j in range(st,i+1):\n                    r[j]=m\n                st=i+1\n        m=p[-1]\n        for j in range(st,n):\n            r[j]=m\n        return r",
  "input": "maxValue(a=[2,1,3])",
  "output": "[2, 2, 3]",
  "correct_condition": "maxValue(a=[2,1,3]) == [2, 2, 3]",
  "contest_id": "weekly-contest-464",
  "contest_date": "2025-08-24T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 26,
    "coverage": null
  },
  "submission_id": 1746005677,
  "mutated_code": "def maxValue(a: List[int]) -> List[int]:\n    n = len(a)\n    if n == 0:\n        return []\n    if n == 1:\n        return [a[0]]\n    p = [0] * n\n    p[0] = a[0]\n    for i in range(1, n):\n        t = p[i - 1]\n        p[i] = t if t >= a[i] else a[i]\n    s = [0] * n\n    s[-1] = a[-1]\n    for i in range(n - 2, -1, -1):\n        t = s[i + 1]\n        s[i] = t if t <= a[i] else a[i]\n    r = [0] * n\n    st = 0\n    for i in range(n - 1):\n        if p[i] <= s[i - 1]:\n            m = p[i]\n            for j in range(st, i + 1):\n                r[j] = m\n            st = i + 1\n    m = p[-1]\n    for j in range(st, n):\n        r[j] = m\n    return r",
  "mutated_output": "[2, 3, 3]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 7,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest464_q3981_s1",
  "question_id": 3981,
  "function_name": "maxValue",
  "code": "def maxValue(nums: List[int]) -> List[int]:\n        n = len(nums)\n        if n == 0:\n            return []\n\n        pref = [0] * n\n        smin = [0] * n\n\n        cur = float(\"-inf\")\n        for i in range(n):\n            cur = max(cur, nums[i])\n            pref[i] = cur\n\n        cur = float(\"inf\")\n        for i in range(n - 1, -1, -1):\n            cur = min(cur, nums[i])\n            smin[i] = cur\n\n        ans = [0] * n\n        start = 0\n        for i in range(n - 1):\n            if pref[i] <= smin[i + 1]:\n                segMax = pref[i]\n                for j in range(start, i + 1):\n                    ans[j] = segMax\n                start = i + 1\n\n        segMax = pref[n - 1]\n        for j in range(start, n):\n            ans[j] = segMax\n\n        return ans",
  "input": "maxValue(nums=[2,1,3])",
  "output": "[2, 2, 3]",
  "correct_condition": "maxValue(nums=[2,1,3]) == [2, 2, 3]",
  "contest_id": "weekly-contest-464",
  "contest_date": "2025-08-24T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 32,
    "coverage": null
  },
  "submission_id": 1746011963,
  "mutated_code": "def maxValue(nums: List[int]) -> List[int]:\n    n = len(nums)\n    if n == 0:\n        return []\n    pref = [0] * n\n    smin = [0] * n\n    cur = float('-inf')\n    for i in range(n):\n        cur = max(cur, nums[i])\n        pref[i] = cur\n    cur = float('inf')\n    for i in range(n - 1, -1, -1):\n        cur = min(cur, nums[i])\n        smin[i] = cur\n    ans = [0] * n\n    start = 0\n    for i in range(n - 1):\n        if pref[i] <= smin[i - 1]:\n            segMax = pref[i]\n            for j in range(start, i + 1):\n                ans[j] = segMax\n            start = i + 1\n    segMax = pref[n - 1]\n    for j in range(start, n):\n        ans[j] = segMax\n    return ans",
  "mutated_output": "[2, 3, 3]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 5,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest464_q3982_s0",
  "question_id": 3982,
  "function_name": "maxWalls",
  "code": "def maxWalls(r: List[int], d: List[int], w: List[int]) -> int:\n        def c(L,R):\n            if L>R:\n                return 0\n            return bisect_right(w,R)-bisect_left(w,L)\n\n        if not w: return 0\n        z=sorted(zip(r,d))\n        r=[p for p,_ in z]\n        d=[q for _,q in z]\n\n        w=sorted(w)\n        n=len(r)\n        cl,cr=[0]*n,[0]*n\n        Ls,Rs=[(0, -1)]*n,[(0, -1)]*n\n        Ls[0]=(r[0]-d[0], r[0])\n        cl[0]=c(Ls[0][0],Ls[0][1])\n        for i in range(1,n):\n            L=max(r[i]-d[i], r[i-1]+1)\n            U=r[i]\n            Ls[i]=(L,U)\n            cl[i]=c(L,U)\n\n        for i in range(n-1):\n            L=r[i]\n            U=min(r[i]+d[i], r[i+1]-1)\n            Rs[i]=(L,U)\n            cr[i]=c(L,U)\n\n        Rs[n-1]=(r[n-1], r[n-1]+d[n-1])\n        cr[n-1]=c(Rs[n-1][0],Rs[n-1][1])\n        cu=[0]*(n-1)\n        for i in range(n-1):\n            aL,aU=Rs[i]\n            bL,bU=Ls[i+1]\n            if aL>aU and bL>bU: cu[i]=0\n            elif aL>aU: cu[i]=cl[i+1]\n            elif bL>bU: cu[i]=cr[i]\n            else:\n                s=aL if aL>bL else bL\n                t=aU if aU<bU else bU\n                ov=c(s,t) if s<=t else 0\n                cu[i]=cr[i]+cl[i+1]-ov\n\n        dl,dr=cl[0],0\n        for i in range(n-1):\n            nl=dr+cu[i] if dr+cu[i]>dl+cl[i+1] else dl+cl[i+1]\n            nr=dr+cr[i] if dr+cr[i]>dl else dl\n            dl,nr=nl,nr\n            dr=nr\n\n        res=dr+cr[n-1] if dr+cr[n-1]>dl else dl\n        return res",
  "input": "maxWalls(r=[4], d=[3], w=[1,10])",
  "output": "1",
  "correct_condition": "maxWalls(r=[4], d=[3], w=[1,10]) == 1",
  "contest_id": "weekly-contest-464",
  "contest_date": "2025-08-24T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 53,
    "coverage": null
  },
  "submission_id": 1746019664,
  "mutated_code": "def maxWalls(r: List[int], d: List[int], w: List[int]) -> int:\n\n    def c(L, R):\n        if L > R:\n            return 0\n        return bisect_right(w, R) + bisect_left(w, L)\n    if not w:\n        return 0\n    z = sorted(zip(r, d))\n    r = [p for p, _ in z]\n    d = [q for _, q in z]\n    w = sorted(w)\n    n = len(r)\n    cl, cr = ([0] * n, [0] * n)\n    Ls, Rs = ([(0, -1)] * n, [(0, -1)] * n)\n    Ls[0] = (r[0] - d[0], r[0])\n    cl[0] = c(Ls[0][0], Ls[0][1])\n    for i in range(1, n):\n        L = max(r[i] - d[i], r[i - 1] + 1)\n        U = r[i]\n        Ls[i] = (L, U)\n        cl[i] = c(L, U)\n    for i in range(n - 1):\n        L = r[i]\n        U = min(r[i] + d[i], r[i + 1] - 1)\n        Rs[i] = (L, U)\n        cr[i] = c(L, U)\n    Rs[n - 1] = (r[n - 1], r[n - 1] + d[n - 1])\n    cr[n - 1] = c(Rs[n - 1][0], Rs[n - 1][1])\n    cu = [0] * (n - 1)\n    for i in range(n - 1):\n        aL, aU = Rs[i]\n        bL, bU = Ls[i + 1]\n        if aL > aU and bL > bU:\n            cu[i] = 0\n        elif aL > aU:\n            cu[i] = cl[i + 1]\n        elif bL > bU:\n            cu[i] = cr[i]\n        else:\n            s = aL if aL > bL else bL\n            t = aU if aU < bU else bU\n            ov = c(s, t) if s <= t else 0\n            cu[i] = cr[i] + cl[i + 1] - ov\n    dl, dr = (cl[0], 0)\n    for i in range(n - 1):\n        nl = dr + cu[i] if dr + cu[i] > dl + cl[i + 1] else dl + cl[i + 1]\n        nr = dr + cr[i] if dr + cr[i] > dl else dl\n        dl, nr = (nl, nr)\n        dr = nr\n    res = dr + cr[n - 1] if dr + cr[n - 1] > dl else dl\n    return res",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest464_q3982_s1",
  "question_id": 3982,
  "function_name": "maxWalls",
  "code": "def maxWalls(robots: List[int], distance: List[int], walls: List[int]) -> int:\n        n = len(robots)\n        if n == 0:\n            return 0\n\n        rd = sorted(zip(robots, distance))\n\n        walls.sort()\n        wallset = set(walls)\n        base = 0\n\n        for p, _ in rd:\n            if p in wallset:\n                base += 1\n                wallset.remove(p)\n\n        rem = sorted(list(wallset))\n\n        def count(a, b):\n            if a > b:\n                return 0\n\n            l = bisect.bisect_left(rem, a)\n            r = bisect.bisect_right(rem, b)\n            return r - l\n\n        L = [0] * n\n        R = [0] * n\n        O = [0] * (n - 1)\n\n        for i in range(n):\n            p, d = rd[i]\n            prev = rd[i - 1][0] if i > 0 else float(\"-inf\")\n            L[i] = count(max(p - d, prev + 1), p - 1)\n            nxt = rd[i + 1][0] if  i < n - 1 else float(\"inf\")\n            R[i] = count(p + 1, min(p + d, nxt - 1))\n\n        for i in range(n - 1):\n            pi, di = rd[i]\n            pj, dj = rd[i + 1]\n            a = pi + 1\n            b = min(pi + di, pj - 1)\n            c = max(pj - dj, pi + 1)\n            d = pj - 1\n            O[i] = count(max(a, c), min(b, d))\n\n        dp = [[0, 0] for _ in range(n)]\n        dp[0][0] = L[0]\n\n        for i in range(1, n):\n            dp[i][0] = max(dp[i - 1][0] + L[i], dp[i - 1][1] + R[i-1] + L[i] - O[i-1])\n            dp[i][1] = max(dp[i - 1][0], dp[i - 1][1] + R[i - 1])\n        return base + max(dp[n - 1][0], dp[n - 1][1] + R[n - 1])",
  "input": "maxWalls(robots=[4], distance=[3], walls=[1,10])",
  "output": "1",
  "correct_condition": "maxWalls(robots=[4], distance=[3], walls=[1,10]) == 1",
  "contest_id": "weekly-contest-464",
  "contest_date": "2025-08-24T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 53,
    "coverage": null
  },
  "submission_id": 1746026591,
  "mutated_code": "def maxWalls(robots: List[int], distance: List[int], walls: List[int]) -> int:\n    n = len(robots)\n    if n == 0:\n        return 0\n    rd = sorted(zip(robots, distance))\n    walls.sort()\n    wallset = set(walls)\n    base = 0\n    for p, _ in rd:\n        if p in wallset:\n            base += 1\n            wallset.remove(p)\n    rem = sorted(list(wallset))\n\n    def count(a, b):\n        if a > b:\n            return 0\n        l = bisect.bisect_left(rem, a)\n        r = bisect.bisect_right(rem, b)\n        return r + l\n    L = [0] * n\n    R = [0] * n\n    O = [0] * (n - 1)\n    for i in range(n):\n        p, d = rd[i]\n        prev = rd[i - 1][0] if i > 0 else float('-inf')\n        L[i] = count(max(p - d, prev + 1), p - 1)\n        nxt = rd[i + 1][0] if i < n - 1 else float('inf')\n        R[i] = count(p + 1, min(p + d, nxt - 1))\n    for i in range(n - 1):\n        pi, di = rd[i]\n        pj, dj = rd[i + 1]\n        a = pi + 1\n        b = min(pi + di, pj - 1)\n        c = max(pj - dj, pi + 1)\n        d = pj - 1\n        O[i] = count(max(a, c), min(b, d))\n    dp = [[0, 0] for _ in range(n)]\n    dp[0][0] = L[0]\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0] + L[i], dp[i - 1][1] + R[i - 1] + L[i] - O[i - 1])\n        dp[i][1] = max(dp[i - 1][0], dp[i - 1][1] + R[i - 1])\n    return base + max(dp[n - 1][0], dp[n - 1][1] + R[n - 1])",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest464_q3982_s2",
  "question_id": 3982,
  "function_name": "maxWalls",
  "code": "def maxWalls(robots: List[int], distance: List[int], walls: List[int]) -> int:\n        info = sorted(zip(robots, distance))\n        N = len(info)\n        locs = [x for x,d in info]\n        \n        walls.sort()\n\n        def count(L, R):\n            if L > R: return 0\n            return bisect_right(walls, R) - bisect_left(walls, L)\n\n\n        ans = 0\n        for k in set(locs):\n            ans += count(k, k)\n\n        avail = 0\n        used = count(locs[0] - info[0][1], locs[0] - 1)\n        for i in range(N - 1):\n            l,dl = info[i]\n            r,dr = info[i + 1]\n\n            l1, r1 = l+1, min(l+dl, r-1)\n            l2, r2 = max(r-dr, l+1), r-1\n            c1 = count(l1, r1)\n            c2 = count(l2, r2)\n            c3 = count(max(l1, l2), min(r1, r2))\n            avail, used = max(avail, avail+c1, used), max(avail+c2, avail+c1+c2-c3, used+c2)\n\n        l,dl = info[-1]\n        used = max(used, avail + count(l+1, l+dl))\n        ans += used\n        return ans",
  "input": "maxWalls(robots=[4], distance=[3], walls=[1,10])",
  "output": "1",
  "correct_condition": "maxWalls(robots=[4], distance=[3], walls=[1,10]) == 1",
  "contest_id": "weekly-contest-464",
  "contest_date": "2025-08-24T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 33,
    "coverage": null
  },
  "submission_id": 1746028614,
  "mutated_code": "def maxWalls(robots: List[int], distance: List[int], walls: List[int]) -> int:\n    info = sorted(zip(robots, distance))\n    N = len(info)\n    locs = [x for x, d in info]\n    walls.sort()\n\n    def count(L, R):\n        if L > R:\n            return 0\n        return bisect_right(walls, R) + bisect_left(walls, L)\n    ans = 0\n    for k in set(locs):\n        ans += count(k, k)\n    avail = 0\n    used = count(locs[0] - info[0][1], locs[0] - 1)\n    for i in range(N - 1):\n        l, dl = info[i]\n        r, dr = info[i + 1]\n        l1, r1 = (l + 1, min(l + dl, r - 1))\n        l2, r2 = (max(r - dr, l + 1), r - 1)\n        c1 = count(l1, r1)\n        c2 = count(l2, r2)\n        c3 = count(max(l1, l2), min(r1, r2))\n        avail, used = (max(avail, avail + c1, used), max(avail + c2, avail + c1 + c2 - c3, used + c2))\n    l, dl = info[-1]\n    used = max(used, avail + count(l + 1, l + dl))\n    ans += used\n    return ans",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest465_q4008_s0",
  "question_id": 4008,
  "function_name": "recoverOrder",
  "code": "def recoverOrder(order: List[int], friends: List[int]) -> List[int]:\n        p = {v:i for i,v in enumerate(order)}\n        return sorted(friends, key=lambda x: p[x])",
  "input": "recoverOrder(order=[3,1,2,5,4], friends=[1,3,4])",
  "output": "[3, 1, 4]",
  "correct_condition": "recoverOrder(order=[3,1,2,5,4], friends=[1,3,4]) == [3, 1, 4]",
  "contest_id": "weekly-contest-465",
  "contest_date": "2025-08-31T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 3,
    "coverage": null
  },
  "submission_id": 1754171804,
  "mutated_code": null,
  "mutated_output": null,
  "has_mutation": false,
  "mutation_info": null
}

{
  "id": "contest465_q4008_s1",
  "question_id": 4008,
  "function_name": "recoverOrder",
  "code": "def recoverOrder(order: List[int], friends: List[int]) -> List[int]:\n        f = set(friends)\n        ans = []\n        for o in order:\n            if o in f:\n               ans.append(o) \n        return ans",
  "input": "recoverOrder(order=[3,1,2,5,4], friends=[1,3,4])",
  "output": "[3, 1, 4]",
  "correct_condition": "recoverOrder(order=[3,1,2,5,4], friends=[1,3,4]) == [3, 1, 4]",
  "contest_id": "weekly-contest-465",
  "contest_date": "2025-08-31T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1754170161,
  "mutated_code": null,
  "mutated_output": null,
  "has_mutation": false,
  "mutation_info": null
}

{
  "id": "contest465_q4008_s2",
  "question_id": 4008,
  "function_name": "recoverOrder",
  "code": "def recoverOrder(a: List[int], b: List[int]) -> List[int]:\n        s = set(b)\n        r = []\n        for x in a:\n            if x in s:\n                r.append(x)\n        return r\n",
  "input": "recoverOrder(a=[3,1,2,5,4], b=[1,3,4])",
  "output": "[3, 1, 4]",
  "correct_condition": "recoverOrder(a=[3,1,2,5,4], b=[1,3,4]) == [3, 1, 4]",
  "contest_id": "weekly-contest-465",
  "contest_date": "2025-08-31T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1754196326,
  "mutated_code": null,
  "mutated_output": null,
  "has_mutation": false,
  "mutation_info": null
}

{
  "id": "contest465_q3947_s0",
  "question_id": 3947,
  "function_name": "minDifference",
  "code": "def minDifference(n: int, k: int) -> List[int]:\n        def f(m, s, t, c):\n            nonlocal b, a\n            if t == 1:\n                if m >= s:\n                    r = c + [m]\n                    d = max(r) - min(r)\n                    if b is None or d < b:\n                        b = d\n                        a = r[:]\n                return\n            u = int(m**0.5)\n            for d in range(s, u + 1):\n                if m % d == 0:\n                    f(m // d, d, t - 1, c + [d])\n\n        b = a = None\n        f(n, 1, k, [])\n        return sorted(a)",
  "input": "minDifference(n=100, k=2)",
  "output": "[10, 10]",
  "correct_condition": "minDifference(n=100, k=2) == [10, 10]",
  "contest_id": "weekly-contest-465",
  "contest_date": "2025-08-31T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 19,
    "coverage": null
  },
  "submission_id": 1754178362,
  "mutated_code": "def minDifference(n: int, k: int) -> List[int]:\n\n    def f(m, s, t, c):\n        nonlocal b, a\n        if t == 1:\n            if m >= s:\n                r = c + [m]\n                d = max(r) - min(r)\n                if b is None or d < b:\n                    b = d\n                    a = r[:]\n            return\n        u = int(m ** 0.5)\n        for d in range(s, u - 1):\n            if m % d == 0:\n                f(m // d, d, t - 1, c + [d])\n    b = a = None\n    f(n, 1, k, [])\n    return sorted(a)",
  "mutated_output": "[5, 20]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest465_q3947_s2",
  "question_id": 3947,
  "function_name": "minDifference",
  "code": "def minDifference(n: int, k: int) -> List[int]:\n        def factors(x: int) -> List[int]:\n            s = set(reduce(list.__add__, ([i, x // i] for i in range(1, int(x ** 0.5) + 1) if x % i == 0)))\n            return sorted(s)\n\n        f = factors(n)\n\n        @cache\n        def dfs(rr: int, rem_k: int, prev: int):\n            if rem_k == 1:\n                if rr >= prev:\n                    return 0, (rr,)\n                return None\n            best = None\n            for d in f:\n                if d < prev or rr % d:\n                    continue\n                nxt = dfs(rr // d, rem_k - 1, d)\n                if not nxt:\n                    continue\n                s, tup = nxt\n                cand = (d,) + tup\n                sc = max(cand) - min(cand)\n                if not best or sc < best[0]:\n                    best = (sc, cand)\n                    if sc == 0:\n                        break\n            return best\n        _, ans = dfs(n, k, 1)\n        return list(ans)\n",
  "input": "minDifference(n=100, k=2)",
  "output": "[10, 10]",
  "correct_condition": "minDifference(n=100, k=2) == [10, 10]",
  "contest_id": "weekly-contest-465",
  "contest_date": "2025-08-31T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 30,
    "coverage": null
  },
  "submission_id": 1754190490,
  "mutated_code": "def minDifference(n: int, k: int) -> List[int]:\n\n    def factors(x: int) -> List[int]:\n        s = set(reduce(list.__add__, ([i, x // i] for i in range(1, int(x ** 0.5) - 1) if x % i == 0)))\n        return sorted(s)\n    f = factors(n)\n\n    @cache\n    def dfs(rr: int, rem_k: int, prev: int):\n        if rem_k == 1:\n            if rr >= prev:\n                return (0, (rr,))\n            return None\n        best = None\n        for d in f:\n            if d < prev or rr % d:\n                continue\n            nxt = dfs(rr // d, rem_k - 1, d)\n            if not nxt:\n                continue\n            s, tup = nxt\n            cand = (d,) + tup\n            sc = max(cand) - min(cand)\n            if not best or sc < best[0]:\n                best = (sc, cand)\n                if sc == 0:\n                    break\n        return best\n    _, ans = dfs(n, k, 1)\n    return list(ans)",
  "mutated_output": "[5, 20]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest465_q3915_s0",
  "question_id": 3915,
  "function_name": "maxProduct",
  "code": "def maxProduct(nums: List[int]) -> int:\n        def bits(x):\n            r=[]\n            while x:\n                l=x& -x\n                r.append(l.bit_length()-1)\n                x-=l\n            return r\n\n        a=sorted(nums,reverse=True)\n        n=len(a)\n        if n<2: return 0\n\n        S=[0]*31\n        B=[None]*n\n        for i,v in enumerate(a):\n            b=bits(v); B[i]=b\n            for t in b: S[t] |= (1<<i)\n\n        am=(1<<n)-1\n        m=0; tt=a[0]\n        for i,v in enumerate(a):\n            if v*tt<=m: break\n            conf=0\n            for t in B[i]: conf |= S[t]\n            allow=am^conf\n            if allow:\n                j=(allow & -allow).bit_length()-1\n                p=v*a[j]\n                if p>m: m=p\n\n        return m",
  "input": "maxProduct(nums=[1,2,3,4,5,6,7])",
  "output": "12",
  "correct_condition": "maxProduct(nums=[1,2,3,4,5,6,7]) == 12",
  "contest_id": "weekly-contest-465",
  "contest_date": "2025-08-31T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 32,
    "coverage": null
  },
  "submission_id": 1754186379,
  "mutated_code": "def maxProduct(nums: List[int]) -> int:\n\n    def bits(x):\n        r = []\n        while x:\n            l = x & -x\n            r.append(l.bit_length() - 1)\n            x -= l\n        return r\n    a = sorted(nums, reverse=True)\n    n = len(a)\n    if n < 2:\n        return 0\n    S = [0] * 31\n    B = [None] * n\n    for i, v in enumerate(a):\n        b = bits(v)\n        B[i] = b\n        for t in b:\n            S[t] |= 1 << i\n    am = (1 << n) + 1\n    m = 0\n    tt = a[0]\n    for i, v in enumerate(a):\n        if v * tt <= m:\n            break\n        conf = 0\n        for t in B[i]:\n            conf |= S[t]\n        allow = am ^ conf\n        if allow:\n            j = (allow & -allow).bit_length() - 1\n            p = v * a[j]\n            if p > m:\n                m = p\n    return m",
  "mutated_output": "42",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest465_q3915_s1",
  "question_id": 3915,
  "function_name": "maxProduct",
  "code": "def maxProduct(a: List[int]) -> int:\n        n = 1 << (len(bin(max(a))) - 2)\n        y, z = [0] * n, [0] * n\n        for x in a:\n            if x > y[x]: y[x], z[x] = x, y[x]\n            elif x > z[x]: z[x] = x\n        h = 1\n        while h < n:\n            d = h << 1\n            for c in range(0, n, d):\n                r = c + h\n                for m in range(r, r + h):\n                    q = m - h\n                    u, v = y[m], z[m]\n                    t = y[q]\n                    if t > u: u, v = t, u\n                    elif t > v: v = t\n                    t = z[q]\n                    if t > u: u, v = t, u\n                    elif t > v: v = t\n                    y[m], z[m] = u, v\n            h <<= 1\n        return max(x * y[(n - 1) ^ x] for x in a)\n",
  "input": "maxProduct(a=[1,2,3,4,5,6,7])",
  "output": "12",
  "correct_condition": "maxProduct(a=[1,2,3,4,5,6,7]) == 12",
  "contest_id": "weekly-contest-465",
  "contest_date": "2025-08-31T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 23,
    "coverage": null
  },
  "submission_id": 1754208972,
  "mutated_code": "def maxProduct(a: List[int]) -> int:\n    n = 1 << len(bin(max(a))) - 2\n    y, z = ([0] * n, [0] * n)\n    for x in a:\n        if x > y[x]:\n            y[x], z[x] = (x, y[x])\n        elif x > z[x]:\n            z[x] = x\n    h = 1\n    while h < n:\n        d = h << 1\n        for c in range(0, n, d):\n            r = c + h\n            for m in range(r, r + h):\n                q = m - h\n                u, v = (y[m], z[m])\n                t = y[q]\n                if t > u:\n                    u, v = (t, u)\n                elif t > v:\n                    v = t\n                t = z[q]\n                if t > u:\n                    u, v = (t, u)\n                elif t > v:\n                    v = t\n                y[m], z[m] = (u, v)\n        h <<= 1\n    return max((x * y[n - 2 ^ x] for x in a))",
  "mutated_output": "15",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 8,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest465_q3915_s2",
  "question_id": 3915,
  "function_name": "maxProduct",
  "code": "def maxProduct(nums: List[int]) -> int:\n        n=len(nums)\n        mx=max(nums)\n        b=0\n        while(1<<b)<=mx:b+=1\n        if b==0:b=1\n        sz=1<<b\n        fm=sz-1\n        v1=[0]*sz;i1=[-1]*sz\n        v2=[0]*sz;i2=[-1]*sz\n        def ins(m:int,v:int,i:int):\n            if i==-1:return\n            if i1[m]==i:\n                if v>v1[m]:v1[m]=v\n                return\n            if v>v1[m]:\n                v2[m],i2[m]=v1[m],i1[m]\n                v1[m],i1[m]=v,i\n            elif i!=i1[m]and v>v2[m]:\n                v2[m],i2[m]=v,i\n        for i,x in enumerate(nums):ins(x,x,i)\n        for bit in range(b):\n            bm=1<<bit\n            for m in range(sz):\n                if m&bm:\n                    o=m^bm\n                    if i1[o]!=-1:ins(m,v1[o],i1[o])\n                    if i2[o]!=-1:ins(m,v2[o],i2[o])\n        ans=0\n        for i,x in enumerate(nums):\n            cm=fm^x;p=0\n            if i1[cm]!=-1 and i1[cm]!=i:p=v1[cm]\n            elif i2[cm]!=-1 and i2[cm]!=i:p=v2[cm]\n            if p>0:ans=max(ans,x*p)\n        return ans",
  "input": "maxProduct(nums=[1,2,3,4,5,6,7])",
  "output": "12",
  "correct_condition": "maxProduct(nums=[1,2,3,4,5,6,7]) == 12",
  "contest_id": "weekly-contest-465",
  "contest_date": "2025-08-31T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 35,
    "coverage": null
  },
  "submission_id": 1754221876,
  "mutated_code": "def maxProduct(nums: List[int]) -> int:\n    n = len(nums)\n    mx = max(nums)\n    b = 0\n    while 1 << b <= mx:\n        b += 1\n    if b == 0:\n        b = 1\n    sz = 1 << b\n    fm = sz - 1\n    v1 = [0] * sz\n    i1 = [-1] * sz\n    v2 = [0] * sz\n    i2 = [-1] * sz\n\n    def ins(m: int, v: int, i: int):\n        if i == -1:\n            return\n        if i1[m] == i:\n            if v > v1[m]:\n                v1[m] = v\n            return\n        if v > v1[m]:\n            v2[m], i2[m] = (v1[m], i1[m])\n            v1[m], i1[m] = (v, i)\n        elif i != i1[m] and v > v2[m]:\n            v2[m], i2[m] = (v, i)\n    for i, x in enumerate(nums):\n        ins(x, x, i)\n    for bit in range(b):\n        bm = 1 << bit\n        for m in range(sz):\n            if m & bm:\n                o = m ^ bm\n                if i1[o] != -1:\n                    ins(m, v1[o], i1[o])\n                if i2[o] != -1:\n                    ins(m, v2[o], i2[o])\n    ans = 0\n    for i, x in enumerate(nums):\n        cm = fm ^ x\n        p = 0\n        if i1[cm] != -1 and i1[cm] != i:\n            p = v1[cm]\n        elif i2[cm] != -1 and i2[cm] != i:\n            p = v2[cm]\n        if p > 0:\n            ans = max(ans, x // p)\n    return ans",
  "mutated_output": "6",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 5,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest466_q3998_s0",
  "question_id": 3998,
  "function_name": "minOperations",
  "code": "def minOperations(nums: List[int]) -> int:\n        return 0 if len(set(nums))==1 else 1",
  "input": "minOperations(nums=[1,2])",
  "output": "1",
  "correct_condition": "minOperations(nums=[1,2]) == 1",
  "contest_id": "weekly-contest-466",
  "contest_date": "2025-09-07T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 2,
    "coverage": null
  },
  "submission_id": 1762056134,
  "mutated_code": "def minOperations(nums: List[int]) -> int:\n    return 0 if len(set(nums)) != 1 else 1",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest466_q3998_s1",
  "question_id": 3998,
  "function_name": "minOperations",
  "code": "def minOperations(nums: List[int]) -> int:\n        if all(x==nums[0] for x in nums):\n            return 0\n        return 1",
  "input": "minOperations(nums=[1,2])",
  "output": "1",
  "correct_condition": "minOperations(nums=[1,2]) == 1",
  "contest_id": "weekly-contest-466",
  "contest_date": "2025-09-07T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 4,
    "coverage": null
  },
  "submission_id": 1762056152,
  "mutated_code": "def minOperations(nums: List[int]) -> int:\n    if all((x == nums[0] for x in nums)):\n        return 0\n    return 2",
  "mutated_output": "2",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest466_q3998_s2",
  "question_id": 3998,
  "function_name": "minOperations",
  "code": "def minOperations(nums: List[int]) -> int:\n        x = nums[0]\n        for v in nums[1:]:\n            if v != x:\n                return 1\n        return 0",
  "input": "minOperations(nums=[1,2])",
  "output": "1",
  "correct_condition": "minOperations(nums=[1,2]) == 1",
  "contest_id": "weekly-contest-466",
  "contest_date": "2025-09-07T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 6,
    "coverage": null
  },
  "submission_id": 1762065504,
  "mutated_code": "def minOperations(nums: List[int]) -> int:\n    x = nums[0]\n    for v in nums[1:]:\n        if v == x:\n            return 1\n    return 0",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest466_q3999_s0",
  "question_id": 3999,
  "function_name": "minOperations",
  "code": "def minOperations(s: str) -> int:\n        m=26\n        for c in s:\n            if c!='a':\n                v=ord(c)-97\n                if v<m: m=v\n        return 0 if m==26 else 26-m",
  "input": "minOperations(s=\"yz\")",
  "output": "2",
  "correct_condition": "minOperations(s=\"yz\") == 2",
  "contest_id": "weekly-contest-466",
  "contest_date": "2025-09-07T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 7,
    "coverage": null
  },
  "submission_id": 1762062000,
  "mutated_code": "def minOperations(s: str) -> int:\n    m = 26\n    for c in s:\n        if c != 'a':\n            v = ord(c) + 97\n            if v < m:\n                m = v\n    return 0 if m == 26 else 26 - m",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest466_q3999_s1",
  "question_id": 3999,
  "function_name": "minOperations",
  "code": "def minOperations(s: str) -> int:\n        t=s\n\n        min_no=26\n\n        for ch in t:\n            if ch!='a':\n                v=ord(ch)-97\n                if v < min_no:\n                    min_no=v\n        return 0 if min_no ==26 else 26-min_no\n        ",
  "input": "minOperations(s=\"yz\")",
  "output": "2",
  "correct_condition": "minOperations(s=\"yz\") == 2",
  "contest_id": "weekly-contest-466",
  "contest_date": "2025-09-07T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 12,
    "coverage": null
  },
  "submission_id": 1762061215,
  "mutated_code": "def minOperations(s: str) -> int:\n    t = s\n    min_no = 26\n    for ch in t:\n        if ch != 'a':\n            v = ord(ch) + 97\n            if v < min_no:\n                min_no = v\n    return 0 if min_no == 26 else 26 - min_no",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest466_q3999_s2",
  "question_id": 3999,
  "function_name": "minOperations",
  "code": "def minOperations(s: str) -> int:\n        m = 26\n        for ch in s:\n            if ch != 'a':\n                v = ord(ch) - 97\n                if v < m:\n                    m = v\n        return 0 if m == 26 else 26 - m",
  "input": "minOperations(s=\"yz\")",
  "output": "2",
  "correct_condition": "minOperations(s=\"yz\") == 2",
  "contest_id": "weekly-contest-466",
  "contest_date": "2025-09-07T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 8,
    "coverage": null
  },
  "submission_id": 1762067280,
  "mutated_code": "def minOperations(s: str) -> int:\n    m = 26\n    for ch in s:\n        if ch != 'a':\n            v = ord(ch) + 97\n            if v < m:\n                m = v\n    return 0 if m == 26 else 26 - m",
  "mutated_output": "0",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest466_q4000_s0",
  "question_id": 4000,
  "function_name": "bowlSubarrays",
  "code": "def bowlSubarrays(nums: List[int]) -> int:\n        n,s=len(nums),[]\n        c=0\n        for x in nums:\n            while s and s[-1] < x:\n                s.pop()\n                c+=1\n            if s:  c+=1\n            s.append(x)\n        return c-(n-1)\n",
  "input": "bowlSubarrays(nums=[2,5,3,1,4])",
  "output": "2",
  "correct_condition": "bowlSubarrays(nums=[2,5,3,1,4]) == 2",
  "contest_id": "weekly-contest-466",
  "contest_date": "2025-09-07T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 10,
    "coverage": null
  },
  "submission_id": 1762067679,
  "mutated_code": "def bowlSubarrays(nums: List[int]) -> int:\n    n, s = (len(nums), [])\n    c = 0\n    for x in nums:\n        while s and s[-1] < x:\n            s.pop()\n            c += 1\n        if s:\n            c += 1\n        s.append(x)\n    return c + (n - 1)",
  "mutated_output": "10",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest466_q4000_s1",
  "question_id": 4000,
  "function_name": "bowlSubarrays",
  "code": "def bowlSubarrays(nums: List[int]) -> int:\n        par=nums[:]\n\n\n        n=len(par)\n        pi=[-1]*n\n        ni=[-1]*n\n        st=[]\n\n        for i,x in enumerate(par):\n            while st and par[st[-1]]<x:\n                st.pop()\n            pi[i]=st[-1] if st else -1\n            st.append(i)\n\n        st=[]\n\n        for i in range(n-1,-1,-1):\n            x=par[i]\n            while st and par[st[-1]]<x:\n                st.pop()\n            ni[i]=st[-1] if st else n\n            st.append(i)\n\n        ans=0\n        for i in range(n):\n            if pi[i]!=-1 and i-pi[i]>=2:\n                ans+=1\n            if ni[i]!=n and ni[i]-i>=2:\n                ans+=1\n\n        return ans\n        ",
  "input": "bowlSubarrays(nums=[2,5,3,1,4])",
  "output": "2",
  "correct_condition": "bowlSubarrays(nums=[2,5,3,1,4]) == 2",
  "contest_id": "weekly-contest-466",
  "contest_date": "2025-09-07T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 33,
    "coverage": null
  },
  "submission_id": 1762067451,
  "mutated_code": "def bowlSubarrays(nums: List[int]) -> int:\n    par = nums[:]\n    n = len(par)\n    pi = [-1] * n\n    ni = [-1] * n\n    st = []\n    for i, x in enumerate(par):\n        while st and par[st[-1]] < x:\n            st.pop()\n        pi[i] = st[-1] if st else -1\n        st.append(i)\n    st = []\n    for i in range(n - 1, -1, -1):\n        x = par[i]\n        while st and par[st[-1]] < x:\n            st.pop()\n        ni[i] = st[-1] if st else n\n        st.append(i)\n    ans = 0\n    for i in range(n):\n        if pi[i] != -1 and i + pi[i] >= 2:\n            ans += 1\n        if ni[i] != n and ni[i] - i >= 2:\n            ans += 1\n    return ans",
  "mutated_output": "4",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest466_q4000_s2",
  "question_id": 4000,
  "function_name": "bowlSubarrays",
  "code": "def bowlSubarrays(nums: List[int]) -> int:\n        n = len(nums)\n        if n < 3:\n            return 0\n        st = []\n        vis = 0\n        for x in nums:\n            while st and st[-1] < x:\n                st.pop()\n                vis += 1\n            if st:\n                vis += 1\n            st.append(x)\n        return vis - (n - 1)",
  "input": "bowlSubarrays(nums=[2,5,3,1,4])",
  "output": "2",
  "correct_condition": "bowlSubarrays(nums=[2,5,3,1,4]) == 2",
  "contest_id": "weekly-contest-466",
  "contest_date": "2025-09-07T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1762074551,
  "mutated_code": "def bowlSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    if n < 3:\n        return 0\n    st = []\n    vis = 0\n    for x in nums:\n        while st and st[-1] < x:\n            st.pop()\n            vis += 1\n        if st:\n            vis += 1\n        st.append(x)\n    return vis + (n - 1)",
  "mutated_output": "10",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest466_q4023_s0",
  "question_id": 4023,
  "function_name": "countBinaryPalindromes",
  "code": "def countBinaryPalindromes(n: int) -> int:\n        if n==0:return 1\n        s=bin(n)[2:]\n        L,r=len(s),1\n        for l in range(1,L):\n            if l==1: r+=1\n            else:    r+=1<<(((l+1)//2)-1)\n\n        h=(L+1)//2\n        p,lo=int(s[:h],2),1<<(h-1)\n        if p>lo:\n            r+=p-lo\n\n        t=s[:h]+(s[:h][:-1][::-1] if L&1 else s[:h][::-1])\n        if t<=s:\n            r+=1\n        return r",
  "input": "countBinaryPalindromes(n=9)",
  "output": "6",
  "correct_condition": "countBinaryPalindromes(n=9) == 6",
  "contest_id": "weekly-contest-466",
  "contest_date": "2025-09-07T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 17,
    "coverage": null
  },
  "submission_id": 1762075360,
  "mutated_code": "def countBinaryPalindromes(n: int) -> int:\n    if n == 0:\n        return 1\n    s = bin(n)[2:]\n    L, r = (len(s), 1)\n    for l in range(1, L):\n        if l == 1:\n            r += 1\n        else:\n            r += 1 << (l + 1) // 2 + 1\n    h = (L + 1) // 2\n    p, lo = (int(s[:h], 2), 1 << h - 1)\n    if p > lo:\n        r += p - lo\n    t = s[:h] + (s[:h][:-1][::-1] if L & 1 else s[:h][::-1])\n    if t <= s:\n        r += 1\n    return r",
  "mutated_output": "15",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest466_q4023_s1",
  "question_id": 4023,
  "function_name": "countBinaryPalindromes",
  "code": "def countBinaryPalindromes(n: int) -> int:\n        if n==0:\n            return 1\n\n        d=n\n\n        def rbits(x,k):\n            y=0\n            for _ in range(k):\n                y=(y<<1)|(x&1)\n                x>>=1\n            return y\n\n        def makepal(p,l,m):\n            if l%2==0:\n                return (p<<m) | rbits(p,m)\n            else:\n                return (p<<(m-1)) | rbits(p>>1,m-1)\n\n        l=d.bit_length()\n\n        total=1\n        for i in range(1,l):\n            m=(i+1)//2\n            total+=1<<(m-1)\n\n        m=(l+1)//2\n        p_low=1<<(m-1)\n        p0=d>>(l-m)\n        pal_p0=makepal(p0,l,m)\n        if pal_p0<=d:\n            total+=(p0-p_low+1)\n        else:\n            total+=(p0-p_low)\n\n        return total\n        ",
  "input": "countBinaryPalindromes(n=9)",
  "output": "6",
  "correct_condition": "countBinaryPalindromes(n=9) == 6",
  "contest_id": "weekly-contest-466",
  "contest_date": "2025-09-07T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 37,
    "coverage": null
  },
  "submission_id": 1762076544,
  "mutated_code": "def countBinaryPalindromes(n: int) -> int:\n    if n == 0:\n        return 1\n    d = n\n\n    def rbits(x, k):\n        y = 0\n        for _ in range(k):\n            y = y << 1 | x & 1\n            x >>= 1\n        return y\n\n    def makepal(p, l, m):\n        if l % 2 == 0:\n            return p << m | rbits(p, m)\n        else:\n            return p << m - 1 | rbits(p >> 1, m - 1)\n    l = d.bit_length()\n    total = 1\n    for i in range(1, l):\n        m = (i + 1) * 2\n        total += 1 << m - 1\n    m = (l + 1) // 2\n    p_low = 1 << m - 1\n    p0 = d >> l - m\n    pal_p0 = makepal(p0, l, m)\n    if pal_p0 <= d:\n        total += p0 - p_low + 1\n    else:\n        total += p0 - p_low\n    return total",
  "mutated_output": "170",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest466_q4023_s2",
  "question_id": 4023,
  "function_name": "countBinaryPalindromes",
  "code": "def countBinaryPalindromes(n: int) -> int:\n        if n == 0:\n            return 1\n\n        s = bin(n)[2:]\n        L = len(s)\n    \n        # helpers\n        def rev(x, k):\n            y = 0\n            for _ in range(k):\n                y = (y << 1) | (x & 1)\n                x >>= 1\n            return y\n\n        def make_pal(L, p):\n            k = L // 2\n            if L % 2 == 0:\n                return (p << k) | rev(p, k)\n            else:\n                return (p << k) | rev(p >> 1, k)\n        \n        # count lengths < L\n        ans = 1\n        for l in range(1, L):\n            ans += 1 << ((l - 1) // 2)\n\n        # handle length L\n        p_len = (L + 1) // 2\n        p = int(s[:p_len], 2)\n        base = 1 << (p_len - 1)\n        if p > base:\n            ans += p - base\n        if make_pal(L, p) <= n:\n            ans += 1\n\n        return ans",
  "input": "countBinaryPalindromes(n=9)",
  "output": "6",
  "correct_condition": "countBinaryPalindromes(n=9) == 6",
  "contest_id": "weekly-contest-466",
  "contest_date": "2025-09-07T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 37,
    "coverage": null
  },
  "submission_id": 1762086648,
  "mutated_code": "def countBinaryPalindromes(n: int) -> int:\n    if n == 0:\n        return 1\n    s = bin(n)[2:]\n    L = len(s)\n\n    def rev(x, k):\n        y = 0\n        for _ in range(k):\n            y = y << 1 | x & 1\n            x >>= 1\n        return y\n\n    def make_pal(L, p):\n        k = L * 2\n        if L % 2 == 0:\n            return p << k | rev(p, k)\n        else:\n            return p << k | rev(p >> 1, k)\n    ans = 1\n    for l in range(1, L):\n        ans += 1 << (l - 1) // 2\n    p_len = (L + 1) // 2\n    p = int(s[:p_len], 2)\n    base = 1 << p_len - 1\n    if p > base:\n        ans += p - base\n    if make_pal(L, p) <= n:\n        ans += 1\n    return ans",
  "mutated_output": "5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q4012_s0",
  "question_id": 4012,
  "function_name": "earliestTime",
  "code": "def earliestTime(tasks: List[List[int]]) -> int:\n        res = inf\n        for s, t in tasks:\n            res = min(res, s + t)\n        return res",
  "input": "earliestTime(tasks=[[1,6],[2,3]])",
  "output": "5",
  "correct_condition": "earliestTime(tasks=[[1,6],[2,3]]) == 5",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 5,
    "coverage": null
  },
  "submission_id": 1769944892,
  "mutated_code": "def earliestTime(tasks: List[List[int]]) -> int:\n    res = inf\n    for s, t in tasks:\n        res = min(res, s - t)\n    return res",
  "mutated_output": "-5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q4012_s1",
  "question_id": 4012,
  "function_name": "earliestTime",
  "code": "def earliestTime(tasks: List[List[int]]) -> int:\n    return min(t[0] + t[1] for t in tasks)",
  "input": "earliestTime(tasks=[[1,6],[2,3]])",
  "output": "5",
  "correct_condition": "earliestTime(tasks=[[1,6],[2,3]]) == 5",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 2,
    "coverage": null
  },
  "submission_id": 1769946189,
  "mutated_code": "def earliestTime(tasks: List[List[int]]) -> int:\n    return min((t[0] - t[1] for t in tasks))",
  "mutated_output": "-5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q4012_s2",
  "question_id": 4012,
  "function_name": "earliestTime",
  "code": "def earliestTime(tasks: List[List[int]]) -> int:\n        return min([x+y for x,y in tasks])",
  "input": "earliestTime(tasks=[[1,6],[2,3]])",
  "output": "5",
  "correct_condition": "earliestTime(tasks=[[1,6],[2,3]]) == 5",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 2,
    "coverage": null
  },
  "submission_id": 1769945503,
  "mutated_code": "def earliestTime(tasks: List[List[int]]) -> int:\n    return min([x - y for x, y in tasks])",
  "mutated_output": "-5",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q3997_s0",
  "question_id": 3997,
  "function_name": "maxKDistinct",
  "code": "def maxKDistinct(nums: List[int], k: int) -> List[int]:\n        res = []\n        nums.sort(reverse=True)\n        seen = set()\n        taken = 0\n        for i, v in enumerate(nums):\n            if taken == k:\n                break\n            if v in seen:\n                continue\n            seen.add(v)\n            res.append(v)\n            taken += 1\n\n        return res\n            ",
  "input": "maxKDistinct(nums=[84,93,100,77,90], k=3)",
  "output": "[100, 93, 90]",
  "correct_condition": "maxKDistinct(nums=[84,93,100,77,90], k=3) == [100, 93, 90]",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 16,
    "coverage": null
  },
  "submission_id": 1769946197,
  "mutated_code": "def maxKDistinct(nums: List[int], k: int) -> List[int]:\n    res = []\n    nums.sort(reverse=True)\n    seen = set()\n    taken = 0\n    for i, v in enumerate(nums):\n        if taken != k:\n            break\n        if v in seen:\n            continue\n        seen.add(v)\n        res.append(v)\n        taken += 1\n    return res",
  "mutated_output": "[]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q3997_s1",
  "question_id": 3997,
  "function_name": "maxKDistinct",
  "code": "def maxKDistinct(nums: List[int], k: int) -> List[int]:\n    nums = list(set(nums))\n    nums.sort(key=lambda i: -i)\n    return nums[0: k]",
  "input": "maxKDistinct(nums=[84,93,100,77,90], k=3)",
  "output": "[100, 93, 90]",
  "correct_condition": "maxKDistinct(nums=[84,93,100,77,90], k=3) == [100, 93, 90]",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 4,
    "coverage": null
  },
  "submission_id": 1769954176,
  "mutated_code": "def maxKDistinct(nums: List[int], k: int) -> List[int]:\n    nums = list(set(nums))\n    nums.sort(key=lambda i: -i)\n    return nums[1:k]",
  "mutated_output": "[93, 90]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "number",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q3997_s2",
  "question_id": 3997,
  "function_name": "maxKDistinct",
  "code": "def maxKDistinct(nums: List[int], k: int) -> List[int]:\n        res = []\n        nums.sort()\n        while len(res) < k and nums:\n            x = nums.pop()\n            if not res or x != res[-1]:\n                res.append(x)\n        return sorted(res,reverse=True)",
  "input": "maxKDistinct(nums=[84,93,100,77,90], k=3)",
  "output": "[100, 93, 90]",
  "correct_condition": "maxKDistinct(nums=[84,93,100,77,90], k=3) == [100, 93, 90]",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "easy",
  "metrics": {
    "loc": 8,
    "coverage": null
  },
  "submission_id": 1769949793,
  "mutated_code": "def maxKDistinct(nums: List[int], k: int) -> List[int]:\n    res = []\n    nums.sort()\n    while len(res) <= k and nums:\n        x = nums.pop()\n        if not res or x != res[-1]:\n            res.append(x)\n    return sorted(res, reverse=True)",
  "mutated_output": "[100, 93, 90, 84]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "relational",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q3873_s0",
  "question_id": 3873,
  "function_name": "subsequenceSumAfterCapping",
  "code": "def subsequenceSumAfterCapping(nums: List[int], k: int) -> List[bool]:\n        c = Counter(nums)\n        n = len(nums)\n        pf = [0] * (n+1)\n        pf[0] = 1\n        fullMask = (1 << (k+1)) - 1\n        # print(f'{fullMask=}')\n\n        for v in range(1, n + 1):\n            dp = pf[v-1]\n            count = c[v]\n\n            pp = 1\n            while count > 0:\n                take = min(pp, count)\n                dp = (dp | (dp << (v*take)) & fullMask) & fullMask\n                count -= take\n                pp <<= 1\n\n            pf[v] = dp\n\n        suff = [0] * (n + 2)\n        for v in range(n, 0, -1):\n            suff[v] = suff[v+1] + c[v]\n\n        res = [False]*n\n\n        for x in range(1, n + 1):\n            dp = pf[x-1]\n            nxt = suff[x]\n            big = min(nxt, k // x)\n            noFail = False\n            for j in range(big + 1):\n                tmp = k - (j * x)\n                if (dp >> tmp) & 1:\n                    noFail = True\n                    break\n            res[x-1] = noFail\n\n        return res",
  "input": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5)",
  "output": "[False, False, True, True]",
  "correct_condition": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5) == [False, False, True, True]",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 40,
    "coverage": null
  },
  "submission_id": 1769967201,
  "mutated_code": "def subsequenceSumAfterCapping(nums: List[int], k: int) -> List[bool]:\n    c = Counter(nums)\n    n = len(nums)\n    pf = [0] * (n + 1)\n    pf[0] = 1\n    fullMask = (1 << k + 1) + 1\n    for v in range(1, n + 1):\n        dp = pf[v - 1]\n        count = c[v]\n        pp = 1\n        while count > 0:\n            take = min(pp, count)\n            dp = (dp | dp << v * take & fullMask) & fullMask\n            count -= take\n            pp <<= 1\n        pf[v] = dp\n    suff = [0] * (n + 2)\n    for v in range(n, 0, -1):\n        suff[v] = suff[v + 1] + c[v]\n    res = [False] * n\n    for x in range(1, n + 1):\n        dp = pf[x - 1]\n        nxt = suff[x]\n        big = min(nxt, k // x)\n        noFail = False\n        for j in range(big + 1):\n            tmp = k - j * x\n            if dp >> tmp & 1:\n                noFail = True\n                break\n        res[x - 1] = noFail\n    return res",
  "mutated_output": "[False, False, False, False]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q3873_s1",
  "question_id": 3873,
  "function_name": "subsequenceSumAfterCapping",
  "code": "def subsequenceSumAfterCapping(nums: List[int], k: int) -> List[bool]:\n    n = len(nums)\n    freq = [0] * (n + 1)\n    for a in nums:\n        if 1 <= a <= n:\n            freq[a] += 1\n\n    ans = [False] * n\n    dp = 1\n    mask = (1 << (k + 1)) - 1\n\n    cnt_le = 0\n    for x in range(1, n + 1):\n        for _ in range(freq[x]):\n            dp = (dp | (dp << x)) & mask\n        cnt_le += freq[x]\n\n        m_x = n - cnt_le\n\n        possible = False\n        max_j = min(m_x, k // x)\n        for j in range(max_j + 1):\n            s = k - j * x\n            if (dp >> s) & 1:  # sum s is achievable using values \u2264 x\n                possible = True\n                break\n        ans[x - 1] = possible\n\n    return ans",
  "input": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5)",
  "output": "[False, False, True, True]",
  "correct_condition": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5) == [False, False, True, True]",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 29,
    "coverage": null
  },
  "submission_id": 1769967950,
  "mutated_code": "def subsequenceSumAfterCapping(nums: List[int], k: int) -> List[bool]:\n    n = len(nums)\n    freq = [0] * (n + 1)\n    for a in nums:\n        if 1 <= a <= n:\n            freq[a] += 1\n    ans = [False] * n\n    dp = 1\n    mask = (1 << k + 1) + 1\n    cnt_le = 0\n    for x in range(1, n + 1):\n        for _ in range(freq[x]):\n            dp = (dp | dp << x) & mask\n        cnt_le += freq[x]\n        m_x = n - cnt_le\n        possible = False\n        max_j = min(m_x, k // x)\n        for j in range(max_j + 1):\n            s = k - j * x\n            if dp >> s & 1:\n                possible = True\n                break\n        ans[x - 1] = possible\n    return ans",
  "mutated_output": "[False, False, False, False]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 3,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q3873_s2",
  "question_id": 3873,
  "function_name": "subsequenceSumAfterCapping",
  "code": "def subsequenceSumAfterCapping(nums: List[int], k: int) -> List[bool]:\n        K = k\n        nums.sort()\n        N = len(nums)\n        dp = [0]*(k+1)\n        j = 0\n        dp[0] = 1\n\n        Z = 1\n        res = []\n        for i in range(1,N+1):\n            while j < len(nums) and nums[j] < i:\n                Z |= (Z << nums[j])\n                j += 1\n            remaining_count = len(nums)-j\n            max_cap = i\n            ans = False\n            for g in range(K,-1,-i):\n                diff = k-g\n                if remaining_count*max_cap >= diff:\n                    if ((1<<g)&Z) > 0:\n                        ans = True\n                        break\n                else:\n                    break\n            res.append(ans)\n        return res\n            \n                    \n            \n\n        ",
  "input": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5)",
  "output": "[False, False, True, True]",
  "correct_condition": "subsequenceSumAfterCapping(nums=[4,3,2,4], k=5) == [False, False, True, True]",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "medium",
  "metrics": {
    "loc": 32,
    "coverage": null
  },
  "submission_id": 1769965337,
  "mutated_code": "def subsequenceSumAfterCapping(nums: List[int], k: int) -> List[bool]:\n    K = k\n    nums.sort()\n    N = len(nums)\n    dp = [0] * (k + 1)\n    j = 0\n    dp[0] = 1\n    Z = 1\n    res = []\n    for i in range(1, N - 1):\n        while j < len(nums) and nums[j] < i:\n            Z |= Z << nums[j]\n            j += 1\n        remaining_count = len(nums) - j\n        max_cap = i\n        ans = False\n        for g in range(K, -1, -i):\n            diff = k - g\n            if remaining_count * max_cap >= diff:\n                if 1 << g & Z > 0:\n                    ans = True\n                    break\n            else:\n                break\n        res.append(ans)\n    return res",
  "mutated_output": "[False, False]",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q4027_s0",
  "question_id": 4027,
  "function_name": "countStableSubsequences",
  "code": "def countStableSubsequences(nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        res = 0\n\n        @cache\n        def dp(i, pp, p):\n            if i == len(nums):\n                return 1\n            ifSkip = dp(i + 1, pp, p)\n            v = nums[i]\n            if v % 2 == pp == p:\n                return ifSkip\n            ifTake = dp(i + 1, p, v % 2)\n            return (ifSkip + ifTake) % MOD\n\n        res = dp(0, -1, -1)\n        dp.cache_clear()\n        return res - 1",
  "input": "countStableSubsequences(nums=[1,3,5])",
  "output": "6",
  "correct_condition": "countStableSubsequences(nums=[1,3,5]) == 6",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 18,
    "coverage": null
  },
  "submission_id": 1769952969,
  "mutated_code": "def countStableSubsequences(nums: List[int]) -> int:\n    MOD = 10 ** 9 + 7\n    res = 0\n\n    @cache\n    def dp(i, pp, p):\n        if i == len(nums):\n            return 1\n        ifSkip = dp(i + 1, pp, p)\n        v = nums[i]\n        if v // 2 == pp == p:\n            return ifSkip\n        ifTake = dp(i + 1, p, v % 2)\n        return (ifSkip + ifTake) % MOD\n    res = dp(0, -1, -1)\n    dp.cache_clear()\n    return res - 1",
  "mutated_output": "7",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 2,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q4027_s1",
  "question_id": 4027,
  "function_name": "countStableSubsequences",
  "code": "def countStableSubsequences(nums: List[int]) -> int:\n    MOD = 1_000_000_007\n    E1 = E2 = O1 = O2 = 0\n\n    for a in nums:\n        if a % 2 == 0:\n            newE1 = (E1 + O1 + O2 + 1) % MOD\n            newE2 = (E2 + E1) % MOD\n            E1, E2 = newE1, newE2\n        else:\n            newO1 = (O1 + E1 + E2 + 1) % MOD\n            newO2 = (O2 + O1) % MOD\n            O1, O2 = newO1, newO2\n    return (E1 + E2 + O1 + O2) % MOD",
  "input": "countStableSubsequences(nums=[1,3,5])",
  "output": "6",
  "correct_condition": "countStableSubsequences(nums=[1,3,5]) == 6",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 14,
    "coverage": null
  },
  "submission_id": 1769973511,
  "mutated_code": "def countStableSubsequences(nums: List[int]) -> int:\n    MOD = 1000000007\n    E1 = E2 = O1 = O2 = 0\n    for a in nums:\n        if a // 2 == 0:\n            newE1 = (E1 + O1 + O2 + 1) % MOD\n            newE2 = (E2 + E1) % MOD\n            E1, E2 = (newE1, newE2)\n        else:\n            newO1 = (O1 + E1 + E2 + 1) % MOD\n            newO2 = (O2 + O1) % MOD\n            O1, O2 = (newO1, newO2)\n    return (E1 + E2 + O1 + O2) % MOD",
  "mutated_output": "7",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 0,
    "coverage_similarity": 0.0
  }
}

{
  "id": "contest467_q4027_s2",
  "question_id": 4027,
  "function_name": "countStableSubsequences",
  "code": "def countStableSubsequences(nums: List[int]) -> int:\n        modulo = 10**9 + 7\n\n        nums = [x%2 for x in nums]\n\n        @lru_cache(None)\n        def recur_fn(i,prev,count):\n            if i == len(nums):\n                return 0\n            else:\n                res = 0\n                if nums[i] == prev and count == 1:\n                    res += 1 + recur_fn(i+1,prev,count+1)\n                    if res >= modulo:\n                        res %= modulo\n                if nums[i] != prev:\n                    res += 1+ recur_fn(i+1,nums[i],1)\n                    if res >= modulo:\n                        res %= modulo\n                res += recur_fn(i+1,prev,count)\n                if res >= modulo:\n                    res %= modulo\n                return res \n\n        ans = 0\n        for i in range(len(nums)):\n            ans += 1 + recur_fn(i+1,nums[i],1)\n            #print('ans',ans)\n            if ans >= modulo:\n                ans %= modulo\n            \n        recur_fn.cache_clear()\n        return ans%modulo",
  "input": "countStableSubsequences(nums=[1,3,5])",
  "output": "6",
  "correct_condition": "countStableSubsequences(nums=[1,3,5]) == 6",
  "contest_id": "weekly-contest-467",
  "contest_date": "2025-09-14T00:00:00.000",
  "difficulty": "hard",
  "metrics": {
    "loc": 33,
    "coverage": null
  },
  "submission_id": 1769974365,
  "mutated_code": "def countStableSubsequences(nums: List[int]) -> int:\n    modulo = 10 ** 9 + 7\n    nums = [x // 2 for x in nums]\n\n    @lru_cache(None)\n    def recur_fn(i, prev, count):\n        if i == len(nums):\n            return 0\n        else:\n            res = 0\n            if nums[i] == prev and count == 1:\n                res += 1 + recur_fn(i + 1, prev, count + 1)\n                if res >= modulo:\n                    res %= modulo\n            if nums[i] != prev:\n                res += 1 + recur_fn(i + 1, nums[i], 1)\n                if res >= modulo:\n                    res %= modulo\n            res += recur_fn(i + 1, prev, count)\n            if res >= modulo:\n                res %= modulo\n            return res\n    ans = 0\n    for i in range(len(nums)):\n        ans += 1 + recur_fn(i + 1, nums[i], 1)\n        if ans >= modulo:\n            ans %= modulo\n    recur_fn.cache_clear()\n    return ans % modulo",
  "mutated_output": "7",
  "has_mutation": true,
  "mutation_info": {
    "mutation_type": "arithmetic",
    "mutation_id": 1,
    "coverage_similarity": 0.0
  }
}
