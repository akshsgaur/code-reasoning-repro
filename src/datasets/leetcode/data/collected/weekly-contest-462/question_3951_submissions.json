[
  {
    "submission_id": 1729552431,
    "code": "class Solution:\n    def specialPalindrome(self, n: int) -> int:\n        def gsp(mx=16):\n            sp, dg = set(), list(range(1, 10))\n            for r in range(1, len(dg) + 1):\n                for cb in combinations(dg, r):\n                    tl = sum(cb)\n                    if tl > mx:\n                        continue\n                    hf, ct, ok = [], None, True\n                    for d in cb:\n                        c = d\n                        if c % 2:\n                            if ct is None:\n                                ct = str(d)\n                            else:\n                                ok = False\n                                break\n                        hf += [str(d)] * (c // 2)\n                    if not ok:\n                        continue\n                    for pm in set(permutations(hf)):\n                        h = ''.join(pm)\n                        p = h + ct + h[::-1] if ct else h + h[::-1]\n                        sp.add(int(p))\n            return sorted(sp)\n\n        Solution._c = gsp()\n        i = bisect_right(Solution._c, n)\n        return Solution._c[i] if i < len(Solution._c) else -1\n",
    "lang": "python3",
    "question_id": 3951,
    "contest_submission": 25671340
  },
  {
    "submission_id": 1729564937,
    "code": "lim = 16\np = []\nfor r in range(1,10):\n    for digits in combinations(range(1,10),r):\n        if (odd := sum(d%2 for d in digits)) < 2 and sum(digits) <= lim:\n            if odd:\n                for d in digits:\n                    if d%2:\n                        odd = d\n            for perm in permutations(chain.from_iterable([d]*(d//2) for d in digits)):\n                n = 0\n                for d in perm:\n                    n *= 10\n                    n += d\n                if odd:\n                    n *= 10\n                    n += odd\n                for d in reversed(perm):\n                    n *= 10\n                    n += d\n                p.append(n)\np.sort()\n\nclass Solution:\n    def specialPalindrome(self, n: int) -> int:\n        return p[bisect_right(p,n)]",
    "lang": "python3",
    "question_id": 3951,
    "contest_submission": 25680377
  },
  {
    "submission_id": 1729566862,
    "code": "class Solution:\n    def __init__(self):\n        self.ev = [2, 4, 6, 8]\n        self.od = [1, 3, 5, 7, 9]\n        self.sm = {}\n\n        for m in range(1 << 4):\n            t = 0\n            for i in range(4):\n                if (m >> i) & 1:\n                    t += self.ev[i]\n            self.sm.setdefault(t, []).append(m)\n\n    def iter_counts(self, _l: int):\n        if _l & 1:\n            for x in self.od:\n                r = _l - x\n                if r < 0:\n                    continue\n                for m in self.sm.get(r, []):\n                    c = [0] * 10\n                    for i in range(4):\n                        if (m >> i) & 1:\n                            c[self.ev[i]] = self.ev[i]\n                    # print(f\" yield  count for L={L},  x={x}, m={m},   c={c}\")\n                    c[x] = x\n                    yield c\n        else:\n            for m in self.sm.get(_l, []):\n                c = [0] * 10\n                for i in range(4):\n                    if (m >> i) & 1:\n                        c[self.ev[i]] = self.ev[i]\n                yield c\n            # print(f\" yield  count for L={L},  m={m},  c={c}\")\n\n    def build_pal(self, c: List[int], _l: int) -> str:\n        h = []\n        for d in range(1, 10):\n            h.append(str(d) * (c[d] // 2))\n        # print(f\"build_pal: c={c}, _l={_l}, h={h}\")\n\n        lf = ''.join(h)\n\n        ce = ''\n        if _l & 1:\n            for d in range(1, 10):\n                if c[d] & 1:\n                    ce = str(d)\n                    break\n\n        # print(f\"build_pal: c={c}, lf={lf}, ce={ce}\")\n\n        return lf + ce + lf[::-1]\n\n    def ceil_from(self, t: str, _c: List[int]) -> Optional[str]:\n        L = len(t)\n\n        m = L >> 1\n\n        a = list(map(int, t))\n        r = [x // 2 for x in _c]\n\n        ce = ''\n\n        if L & 1:\n            for d in range(1, 10):\n                if _c[d] & 1:\n                    ce = str(d)\n                    break\n        h = []\n\n        def fin():\n            lf = ''.join(h) + ''.join(str(d) * r[d] for d in range(1, 10))\n            return lf + ce + lf[::-1]\n\n        def dfs(i, eq):\n            if i == m:\n                u = fin()\n                return u if u >= t else None\n\n            low = a[i] if eq else 1\n            # print(f\"dfs: i={i}, eq={eq}, low={low}, h={h}, r={r}\")\n            for _x in range(low, 10):\n                if r[_x]:\n                    r[_x] -= 1\n                    h.append(str(_x))\n                    if (not eq) or _x > low:\n                        return fin()\n                    tt = dfs(i + 1, 1)\n                    if tt:\n                        return tt\n                    h.pop()\n                    r[_x] += 1\n            return None\n\n        return dfs(0, 1)\n\n    def specialPalindrome(self, n: int) -> int:\n        s = str(n + 1)\n        u = len(s)\n\n        ret = None\n        for c in self.iter_counts(u):\n            r = self.ceil_from(s, c)\n            if r is not None and (ret is None or r < ret):\n                ret = r\n\n        if ret is not None:\n            return int(ret)\n\n        # print()\n        for L in range(u + 1, 30):\n            fv = None\n            for c in self.iter_counts(L):\n                r = self.build_pal(c, L)\n                # print(f\"checki L={L}, c={c}, r={r}\")\n                if fv is None or r < fv:\n                    fv = r\n\n            if fv is not None:\n                return int(fv)\n\n        return -1\n",
    "lang": "python3",
    "question_id": 3951,
    "contest_submission": 25681800
  }
]