[
  {
    "submission_id": 1520610644,
    "code": "class Solution:\n    def countMentions(self, numberOfUsers: int, events: List[List[str]]) -> List[int]:\n        m = numberOfUsers\n        n = len(events)\n        L = []\n        for event in events:\n            if event[0]=='MESSAGE':\n                t = int(event[1])\n                L.append([t, 2, event[2]])\n            else:\n                t = int(event[1])\n                L.append([t, 0, event[2]])\n                L.append([t+60, 1, event[2]])\n        d = {}\n        for t, x, R in L:\n            if t not in d:\n                d[t] = [[], [], []]\n            d[t][x].append(R)\n        users = set(range(m))\n        answer = [0 for i in range(m)]\n        for t in sorted(d):\n            for user in d[t][1]:\n                users.add(int(user))\n            for user in d[t][0]:\n                user = int(user)\n                if user in users:\n                    users.remove(user)\n            for x in d[t][2]:\n                if x=='ALL':\n                    for i in range(m):\n                        answer[i]+=1\n                elif x=='HERE':\n                    for i in users:\n                        answer[i]+=1\n                else:\n                    x = x.split()\n                    for i in x:\n                        answer[int(i[2:])]+=1\n        return answer",
    "lang": "python3",
    "question_id": 3721,
    "contest_submission": 22186960
  },
  {
    "submission_id": 1520621725,
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def solve(self, ivals):\n        if not ivals:\n            return\n        ivals.sort()\n        mrgd = [ivals[0]]\n        for i in range(1, len(ivals)):\n            if ivals[i][0] <= mrgd[-1][1]:\n                mrgd[-1] = (mrgd[-1][0], max(mrgd[-1][1], ivals[i][1]))\n            else:\n                mrgd.append(ivals[i])\n        ivals[:] = mrgd  \n\n    def solve1(self, ivals, t):\n        if not ivals:\n            return True \n        left, right = 0, len(ivals) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if t < ivals[mid][0]:\n                right = mid - 1\n            elif t >= ivals[mid][1]:\n                left = mid + 1\n            else:\n                return False  \n        return True  \n\n    def countMentions(self, numberOfUsers: int, events: List[List[str]]) -> List[int]:\n        arr = [[] for i in range(numberOfUsers)]\n        for e in events:\n            if e[0] == \"OFFLINE\":\n                t = int(e[1])\n                uidx = int(e[2])\n                arr[uidx].append((t, t + 60))\n\n        for u in range(numberOfUsers):\n            self.solve(arr[u])\n\n        ls = [0 for i in range(numberOfUsers)]  \n\n        for e in events:\n            if e[0] == \"MESSAGE\":\n                t = int(e[1])\n                sts = e[2]\n                tokens = sts.split()\n                \n                for z in tokens:\n                    if z.startswith(\"id\"):\n                        nst = z[2:]\n                        if nst.isdigit():\n                            uidx = int(nst)\n                            if 0 <= uidx < numberOfUsers:\n                                ls[uidx] += 1\n                    elif z == \"ALL\":\n                        for u in range(numberOfUsers):\n                            ls[u] += 1\n                    elif z == \"HERE\":\n                        for u in range(numberOfUsers):\n                            if self.solve1(arr[u], t):\n                                ls[u] += 1\n        return ls\n",
    "lang": "python3",
    "question_id": 3721,
    "contest_submission": 22194245
  },
  {
    "submission_id": 1520595169,
    "code": "from typing import List\n\nclass Solution:\n    def countMentions(self, numberOfUsers: int, events: List[List[str]]) -> List[int]:\n        mentions = [0] * numberOfUsers\n        offline_until = [0] * numberOfUsers\n\n        def sort_events(events: List[List[str]]) -> List[List[str]]:\n          \n            def sort_key(event):\n                ts = int(event[1])\n                event_type_priority = 0 if event[0] == 'OFFLINE' else 1\n                return (ts, event_type_priority)\n\n            return sorted(events, key=sort_key)\n\n        def handle_offline_event(user_id: int, ts: int):\n          \n            offline_until[user_id] = ts + 60\n\n        def handle_message_event(ts: int, payload: str):\n          \n            tokens = payload.split()\n            for token in tokens:\n                if token == 'ALL':\n                    # Mention all users (including offline)\n                    for user in range(numberOfUsers):\n                        mentions[user] += 1\n                elif token == 'HERE':\n                   \n                    for user in range(numberOfUsers):\n                        if offline_until[user] <= ts:\n                            mentions[user] += 1\n                else:  \n                    user = int(token[2:])\n                    mentions[user] += 1\n\n        def process_events(events: List[List[str]]):\n          \n            for event in events:\n                event_type, ts_str, payload = event\n                ts = int(ts_str)\n\n                if event_type == 'OFFLINE':\n                    handle_offline_event(int(payload), ts)\n                elif event_type == 'MESSAGE':\n                    handle_message_event(ts, payload)\n\n        # Sort events and process them\n        sorted_events = sort_events(events)\n        process_events(sorted_events)\n\n        return mentions\n",
    "lang": "python3",
    "question_id": 3721,
    "contest_submission": 22177319
  }
]