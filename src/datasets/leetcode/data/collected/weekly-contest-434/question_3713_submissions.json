[
  {
    "submission_id": 1520629198,
    "code": "# from heapq import heappop, heappush\n\n\ndef toposort(graph):\n    res, found = [], [0] * len(graph)\n    stack = list(range(len(graph)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            res.append(~node)\n        elif not found[node]:\n            found[node] = 1\n            stack.append(~node)\n            stack += graph[node]\n\n    # cycle check\n    for node in res:\n        if any(found[nei] for nei in graph[node]):\n            return None\n        found[node] = 0\n\n    return res[::-1]\n\n\ndef kahn(graph):\n    n = len(graph)\n\n    indeg, idx = [0] * n, [0] * n\n    for i in range(n):\n        for e in graph[i]:\n            indeg[e] += 1\n\n    q, res = [], []\n    for i in range(n):\n        if indeg[i] == 0:\n            q.append(i)  # heappush(q, -i)\n\n    nr = 0\n    while q:\n        res.append(q.pop())  # res.append(-heappop(q))\n        idx[res[-1]], nr = nr, nr + 1\n        for e in graph[res[-1]]:\n            indeg[e] -= 1\n            if indeg[e] == 0:\n                q.append(e)  # heappush(q, -e)\n\n    return res, idx, nr == n\n    \nclass Solution:\n    def supersequences(self, words: List[str]) -> List[List[int]]:\n        \"\"\"\n        certainly every-letter-twice works\n        so, SOME letters twice \n\n        a     a \n        \"\"\"\n        g = [[] for i in range(26)]\n        g2 = [[] for i in range(26)]\n        for xy in words:\n            x = xy[0]\n            y = xy[1]\n            x = ord(x)-ord('a')\n            y = ord(y)-ord('a')\n            g[x].append(y)\n            g2[y].append(x)\n        L = []\n        for i in range(26):\n            if len(g[i]) > 0 or len(g2[i]) > 0:\n                L.append(i)\n        from itertools import combinations\n        m = len(L)\n        for k in range(m+1):\n            works = []\n            for doubled in combinations(L, k):\n                D = set(doubled)\n                g2 = [[] for i in range(26)]\n                for i in L:\n                    if i not in D:\n                        for j in g[i]:\n                            if j not in D:\n                                g2[i].append(j)\n                if toposort(g2) is not None:\n                    works.append(D)\n            if len(works) > 0:\n                answer = []\n                for D in works:\n                    entry = [0 for i in range(26)]\n                    for i in L:\n                        entry[i] = 1 \n                    for i in D:\n                        entry[i]+=1\n                    answer.append(entry)\n                return answer\n        ",
    "lang": "python3",
    "question_id": 3713,
    "contest_submission": 22199278
  },
  {
    "submission_id": 1520639348,
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def supersequences(self, words: List[str]) -> List[List[int]]:\n        lset = set()\n        for w in words:\n            if len(w) >= 1:\n                lset.add(w[0])\n            if len(w) >= 2:\n                lset.add(w[1])\n        letters = sorted(lset)\n        k = len(letters)\n        ind1 = {letter: i for i, letter in enumerate(letters)}\n        adj = [[] for i in range(k)]\n        ls1 = [False] * k\n        for w in words:\n            if len(w) < 2:\n                continue\n            a = ind1[w[0]]\n            b = ind1[w[1]]\n            if a == b:\n                ls1[a] = True\n            else:\n                adj[a].append(b)\n        disc = [-1] * k\n        low = [0] * k\n        sid = [-1] * k\n        stks = [False] * k\n        st = []\n        dfst = 0\n        scnt = 0\n\n        def solve(u):\n            nonlocal dfst, scnt\n            disc[u] = low[u] = dfst\n            dfst += 1\n            st.append(u)\n            stks[u] = True\n            for v in adj[u]:\n                if disc[v] == -1:\n                    solve(v)\n                    low[u] = min(low[u], low[v])\n                elif stks[v]:\n                    low[u] = min(low[u], disc[v])\n            if low[u] == disc[u]:\n                while True:\n                    topv = st.pop()\n                    stks[topv] = False\n                    sid[topv] = scnt\n                    if topv == u:\n                        break\n                scnt += 1\n\n        for i in range(k):\n            if disc[i] == -1:\n                solve(i)\n\n        mem1 = [[] for i in range(scnt)]\n        for i in range(k):\n            mem1[sid[i]].append(i)\n\n        freq1 = [[] for i in range(scnt)]\n\n        def solve2(cmpx, rept):\n            act = set(x for x in cmpx if not rept[x])\n            if not act:\n                return True\n            adjs = defaultdict(list)\n            for x in cmpx:\n                if not rept[x]:\n                    for v in adj[x]:\n                        if v in act:\n                            adjs[x].append(v)\n            vis = {x: 0 for x in act}\n\n            def dfs(u):\n                vis[u] = 1\n                for v in adjs[u]:\n                    if vis[v] == 0:\n                        if dfs(v):\n                            return True\n                    elif vis[v] == 1:\n                        return True\n                vis[u] = 2\n                return False\n\n            for x in act:\n                if vis[x] == 0:\n                    if dfs(x):\n                        return False\n            return True\n\n        for s in range(scnt):\n            cmpx = mem1[s]\n            sz = len(cmpx)\n            if sz == 1:\n                x = cmpx[0]\n                if ls1[x]:\n                    freq1[s].append([2])\n                else:\n                    freq1[s].append([1])\n                continue\n            fnx = [x for x in cmpx if ls1[x]]\n            lcn = {x: i for i, x in enumerate(cmpx)}\n            mskf = 0\n            for x in fnx:\n                mskf |= (1 << lcn[x])\n            bcar = float('inf')\n            gsubs = []\n            for mask in range(1 << sz):\n                if (mask & mskf) != mskf:\n                    continue\n                c = bin(mask).count('1')\n                if c > bcar:\n                    continue\n                rept = [False] * k\n                for i in range(sz):\n                    if (mask & (1 << i)):\n                        ltx = cmpx[i]\n                        rept[ltx] = True\n                if solve2(cmpx, rept):\n                    if c < bcar:\n                        bcar = c\n                        gsubs = [rept.copy()]\n                    elif c == bcar:\n                        gsubs.append(rept.copy())\n            for zx in gsubs:\n                freqp = [1] * sz\n                for i in range(sz):\n                    if zx[cmpx[i]]:\n                        freqp[i] = 2\n                freq1[s].append(freqp)\n\n        pres = []\n        sfreqs = [0] * k\n\n        def dfs2(s, curr):\n            if s == scnt:\n                pres.append(curr.copy())\n                return\n            for freqv in freq1[s]:\n                ncurr = curr.copy()\n                for i, ltx in enumerate(mem1[s]):\n                    ncurr[ltx] = freqv[i]\n                dfs2(s + 1, ncurr)\n\n        dfs2(0, sfreqs)\n\n        msums = float('inf')\n        for fv in pres:\n            s = sum(fv)\n            if s < msums:\n                msums = s\n        minfreq = [fv for fv in pres if sum(fv) == msums]\n\n        fst = set()\n        for fv in minfreq:\n            fre26 = [0] * 26\n            for i, freq in enumerate(fv):\n                letter = letters[i]\n                fre26[ord(letter) - ord('a')] = freq\n            fst.add(tuple(fre26))\n\n        return [list(t) for t in fst]\n",
    "lang": "python3",
    "question_id": 3713,
    "contest_submission": 22206070
  },
  {
    "submission_id": 1520642624,
    "code": "from collections import deque\n\nclass Solution:\n    def supersequences(self, words):\n        if not words:\n            return []\n        \n        # Step 1: Collect unique letters and map to indices\n        unique_chars = set()\n        for word in words:\n            unique_chars.add(word[0])\n            unique_chars.add(word[1])\n        sorted_chars = sorted(unique_chars)\n        u = len(sorted_chars)\n        char_to_idx = {c: i for i, c in enumerate(sorted_chars)}\n        \n        # Step 2: Build adjacency matrix and self_loop array\n        adjacency = [[False] * u for _ in range(u)]\n        self_loop = [False] * u\n        for word in words:\n            c1, c2 = word[0], word[1]\n            x = char_to_idx[c1]\n            y = char_to_idx[c2]\n            if x == y:\n                self_loop[x] = True\n            else:\n                adjacency[x][y] = True\n        \n        # Build graph for Tarjan's algorithm\n        graph = [[] for _ in range(u)]\n        for i in range(u):\n            for j in range(u):\n                if adjacency[i][j]:\n                    graph[i].append(j)\n        \n        # Step 3: Find SCCs using Tarjan's algorithm\n        scc_id, scc_count = self.tarjans_algorithm(u, graph)\n        \n        # Step 4: Build SCC vertices and condensed graph\n        scc_vertices = [[] for _ in range(scc_count)]\n        for node in range(u):\n            scc_vertices[scc_id[node]].append(node)\n        \n        condensed_graph, in_degree = self.build_condensed_graph(scc_id, scc_count, graph)\n        \n        # Step 5: Topological sort of condensed graph\n        topo_order = self.topological_sort(condensed_graph, in_degree, scc_count)\n        \n        # Step 6: Compute frequency options for each SCC\n        freq_options_per_scc = []\n        for scc_idx in topo_order:\n            scc_nodes = scc_vertices[scc_idx]\n            options = self.compute_freq_options_for_scc(scc_nodes, self_loop, adjacency, u)\n            freq_options_per_scc.append(options)\n        \n        # Step 7: Combine options via Cartesian product\n        all_global = self.combine_freq_options(freq_options_per_scc, u)\n        \n        # Step 8: Convert to 26-letter frequencies and deduplicate\n        result = self.convert_and_deduplicate(all_global, sorted_chars)\n        \n        return result\n    \n    def tarjans_algorithm(self, u, graph):\n        index = [-1] * u\n        low_link = [0] * u\n        on_stack = [False] * u\n        stack = []\n        scc_id = [-1] * u\n        current_index = 0\n        scc_count = 0\n        \n        def strongconnect(v):\n            nonlocal current_index, scc_count\n            index[v] = current_index\n            low_link[v] = current_index\n            current_index += 1\n            stack.append(v)\n            on_stack[v] = True\n            for w in graph[v]:\n                if index[w] == -1:\n                    strongconnect(w)\n                    low_link[v] = min(low_link[v], low_link[w])\n                elif on_stack[w]:\n                    low_link[v] = min(low_link[v], index[w])\n            if low_link[v] == index[v]:\n                while True:\n                    node = stack.pop()\n                    on_stack[node] = False\n                    scc_id[node] = scc_count\n                    if node == v:\n                        break\n                scc_count += 1\n        \n        for v in range(u):\n            if index[v] == -1:\n                strongconnect(v)\n        return scc_id, scc_count\n    \n    def build_condensed_graph(self, scc_id, scc_count, graph):\n        condensed = [set() for _ in range(scc_count)]\n        for v in range(len(graph)):\n            current_scc = scc_id[v]\n            for w in graph[v]:\n                target_scc = scc_id[w]\n                if current_scc != target_scc:\n                    condensed[current_scc].add(target_scc)\n        condensed_graph = [list(s) for s in condensed]\n        in_degree = [0] * scc_count\n        for c1 in range(scc_count):\n            for c2 in condensed_graph[c1]:\n                in_degree[c2] += 1\n        return condensed_graph, in_degree\n    \n    def topological_sort(self, condensed_graph, in_degree, scc_count):\n        q = deque()\n        for c in range(scc_count):\n            if in_degree[c] == 0:\n                q.append(c)\n        topo_order = []\n        while q:\n            c = q.popleft()\n            topo_order.append(c)\n            for neighbor in condensed_graph[c]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    q.append(neighbor)\n        return topo_order\n    \n    def compute_freq_options_for_scc(self, scc_nodes, self_loop, adjacency, u):\n        k = len(scc_nodes)\n        if k == 1:\n            only = scc_nodes[0]\n            freq = [0] * u\n            freq[only] = 2 if self_loop[only] else 1\n            return [freq]\n        local_to_global = {i: node for i, node in enumerate(scc_nodes)}\n        forced_mask = 0\n        sub_graph = [[] for _ in range(k)]\n        for i in range(k):\n            global_i = scc_nodes[i]\n            if self_loop[global_i]:\n                forced_mask |= (1 << i)\n            for j in range(k):\n                global_j = scc_nodes[j]\n                if adjacency[global_i][global_j]:\n                    sub_graph[i].append(j)\n        min_sets = self.find_minimal_fvs(k, sub_graph, forced_mask)\n        freq_options = []\n        for mask in min_sets:\n            freq = [0] * u\n            for i in range(k):\n                node = scc_nodes[i]\n                if (mask >> i) & 1:\n                    freq[node] = 2\n                else:\n                    freq[node] = 1\n            freq_options.append(freq)\n        return freq_options\n    \n    def find_minimal_fvs(self, k, sub_graph, forced_mask):\n        optional_mask = ((1 << k) - 1) & ~forced_mask\n        forced_count = bin(forced_mask).count('1')\n        min_size = float('inf')\n        solutions = []\n        for sub in range(0, optional_mask + 1):\n            if (sub & optional_mask) != sub:\n                continue\n            s = forced_mask | sub\n            current_size = forced_count + bin(sub).count('1')\n            if current_size > min_size:\n                continue\n            if self.is_acyclic_after_removal(k, sub_graph, s):\n                if current_size < min_size:\n                    min_size = current_size\n                    solutions = [s]\n                elif current_size == min_size:\n                    solutions.append(s)\n        return solutions\n    \n    def is_acyclic_after_removal(self, k, sub_graph, remove_mask):\n        in_degree = [0] * k\n        remaining = 0\n        for v in range(k):\n            if (remove_mask >> v) & 1:\n                continue\n            remaining += 1\n            for w in sub_graph[v]:\n                if not ((remove_mask >> w) & 1):\n                    in_degree[w] += 1\n        q = deque()\n        for v in range(k):\n            if not ((remove_mask >> v) & 1) and in_degree[v] == 0:\n                q.append(v)\n        visited = 0\n        while q:\n            v = q.popleft()\n            visited += 1\n            for w in sub_graph[v]:\n                if not ((remove_mask >> w) & 1):\n                    in_degree[w] -= 1\n                    if in_degree[w] == 0:\n                        q.append(w)\n        return visited == remaining\n    \n    def combine_freq_options(self, freq_options_per_scc, u):\n        all_global = [[0] * u]\n        for options in freq_options_per_scc:\n            new_all = []\n            for base in all_global:\n                for freq in options:\n                    combined = [base[i] + freq[i] for i in range(u)]\n                    new_all.append(combined)\n            all_global = new_all\n        return all_global\n    \n    def convert_and_deduplicate(self, all_global, sorted_chars):\n        seen = set()\n        result = []\n        for freq_u in all_global:\n            freq_26 = [0] * 26\n            for i, c in enumerate(sorted_chars):\n                idx = ord(c) - ord('a')\n                freq_26[idx] = freq_u[i]\n            key = tuple(freq_26)\n            if key not in seen:\n                seen.add(key)\n                result.append(freq_26)\n        return result",
    "lang": "python3",
    "question_id": 3713,
    "contest_submission": 22208307
  }
]