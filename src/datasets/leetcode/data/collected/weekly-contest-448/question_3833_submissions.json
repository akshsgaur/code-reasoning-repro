[
  {
    "submission_id": 1624871140,
    "code": "class Solution:\n    def minTravelTime(self, l: int, n: int, k: int, position: List[int], time: List[int]) -> int:\n        P = position\n        T0 = time[:n-1]\n        prefix = [0] * n\n        prefix[0] = T0[0]\n        for i in range(1, n-1):\n            prefix[i] = prefix[i-1] + T0[i]\n        prefix[n-1] = prefix[n-2]\n        INF = 10**18\n        max_t = prefix[n-1]\n        dp = [[[INF] * (max_t + 1) for _ in range(k + 1)] for _ in range(n)]\n        dp[0][0][prefix[0]] = 0\n        for i in range(n):\n            for used in range(k + 1):\n                for t_val in range(max_t + 1):\n                    cost = dp[i][used][t_val]\n                    if cost == INF:\n                        continue\n                    for j in range(i+1, n):\n                        merges = j - i - 1\n                        new_used = used + merges\n                        if new_used > k:\n                            break\n                        dist = P[j] - P[i]\n                        new_cost = cost + t_val * dist\n                        new_t = prefix[j] - prefix[i]\n                        if new_cost < dp[j][new_used][new_t]:\n                            dp[j][new_used][new_t] = new_cost\n        return min(dp[n-1][k])\n\n\n\n\n\n\n\n",
    "lang": "python3",
    "question_id": 3833,
    "contest_submission": 23926689
  },
  {
    "submission_id": 1624876072,
    "code": "class Solution:\n    def minTravelTime(self, l: int, n: int, k: int, position: List[int], time: List[int]) -> int:\n        p, t = position, time\n\n        pre = [0] * (n + 1)\n        for i in range(n):\n            pre[i + 1] = pre[i] + t[i]\n\n        dp = {(0, 0, 0, t[0]): 0}\n        for i in range(1, n - 1):\n            _dp = {}\n            for (_r, _p, q, w), c in dp.items():\n\n                if _r < k:\n\n                    ks = (_r + 1, _p, q + 1, w)\n                    # print(f\"i={i}, _r={_r}, _p={_p}, q={q}, w={w}, c={c}\")\n                    if c >= _dp.get(ks, float('inf')):\n                        continue\n                    _dp[ks] = c\n\n                cost = (p[i] - p[_p]) * w\n                # print(f\"i={i}, _r={_r}, _p={_p}, q={q}, w={w}, c={c}, cost={cost}\")\n                ks = (_r, i, 0, t[i] + pre[i] - pre[i - q])\n                # print(f\"i={i}, _r={_r}, _p={_p}, q={q}, w={w}, c={c}, cost={cost}\")\n                if (c + cost) >= _dp.get(ks, float('inf')):\n                    continue\n                _dp[ks] = c + cost\n\n            dp = _dp\n\n        ans = float('inf')\n        for (_r, _p, q, w), c in dp.items():\n            if _r != k:\n                continue\n            val = c + (p[n - 1] - p[_p]) * w\n            # print(f\"i={n - 1}, _r={_r}, _p={_p}, q={q}, w={w}, c={c}, val={val}\")\n            if val < ans:\n                ans = val\n\n        # print(f\"ans={ans}\")\n        return ans\n",
    "lang": "python3",
    "question_id": 3833,
    "contest_submission": 23929672
  },
  {
    "submission_id": 1624877855,
    "code": "class Solution:\n    def minTravelTime(self, l: int, n: int, k: int, position: List[int], time: List[int]) -> int:\n        S = [0] * (n + 1)\n        for i in range(1, n):\n            S[i] = S[i - 1] + time[i - 1]\n        \n        dp = [[{} for _ in range(k + 1)] for _ in range(n)]\n        dp[0][0] = {0: 0}\n        \n        for i in range(n):\n            for r in range(k + 1):\n                for extra, cost in list(dp[i][r].items()):\n                    if i == n - 1:\n                        continue\n                    for j in range(i + 1, n):\n                        removed = j - i - 1\n                        newR = r + removed\n                        if newR > k:\n                            break\n                        newExtra = S[j] - S[i + 1] if removed > 0 else 0\n                        dist = position[j] - position[i]\n                        seg_cost = dist * (time[i] + extra)\n                        newCost = cost + seg_cost\n                        oldCost = dp[j][newR].get(newExtra)\n                        if oldCost is None or newCost < oldCost:\n                            dp[j][newR][newExtra] = newCost\n            \n            for r in range(k + 1):\n                items = sorted(dp[i][r].items(), key=lambda x: (x[0], x[1]))\n                bestCost = float('inf')\n                pruned = {}\n                for extra, cost in items:\n                    if cost < bestCost:\n                        pruned[extra] = cost\n                        bestCost = cost\n                dp[i][r] = pruned\n        \n        return min(dp[n - 1][k].values())\n",
    "lang": "python3",
    "question_id": 3833,
    "contest_submission": 23930723
  }
]