[
  {
    "submission_id": 1624873692,
    "code": "class Solution:\n    def magicalSum(self, M: int, K: int, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        fact = [1] * (M + 1)\n        for i in range(1, M + 1):\n            fact[i] = fact[i - 1] * i % mod\n        inv_fact = [1] * (M + 1)\n        inv_fact[M] = pow(fact[M], mod - 2, mod)\n        for i in range(M, 0, -1):\n            inv_fact[i - 1] = inv_fact[i] * i % mod\n        num_pow = [[pow(nums[i], c, mod) for c in range(M + 1)] for i in range(n)]\n        dp = [[[0] * (K + 1) for _ in range(M + 1)] for __ in range(M + 1)]\n        dp[0][0][0] = 1\n        for i in range(n):\n            new_dp = [[[0] * (K + 1) for _ in range(M + 1)] for __ in range(M + 1)]\n            np_i = num_pow[i]\n            for used in range(M + 1):\n                for carry in range(M + 1):\n                    for pop in range(K + 1):\n                        w = dp[used][carry][pop]\n                        if not w:\n                            continue\n                        max_c = M - used\n                        for c in range(max_c + 1):\n                            total = c + carry\n                            bit = total & 1\n                            new_pop = pop + bit\n                            if new_pop > K:\n                                continue\n                            new_carry = total >> 1\n                            new_used = used + c\n                            new_dp[new_used][new_carry][new_pop] = (\n                                new_dp[new_used][new_carry][new_pop]\n                                + w * np_i[c] * inv_fact[c]\n                            ) % mod\n            dp = new_dp\n        res = 0\n        for carry in range(M + 1):\n            bc = carry.bit_count()\n            for pop in range(K + 1):\n                if pop + bc == K:\n                    res = (res + dp[M][carry][pop]) % mod\n        return res * fact[M] % mod",
    "lang": "python3",
    "question_id": 3851,
    "contest_submission": 23928255
  },
  {
    "submission_id": 1624870301,
    "code": "MOD = 10**9 + 7\n\n\nclass Solution:\n    def magicalSum(self, M: int, K: int, nums: List[int]) -> int:\n        N = len(nums)\n\n        F = [1] * (M + 1)\n        for i in range(1, M + 1):\n            F[i] = F[i - 1] * i % MOD\n\n        iF = [1] * (M + 1)\n        iF[M] = pow(F[M], MOD - 2, MOD)\n        for i in range(M, 0, -1):\n            iF[i - 1] = iF[i] * i % MOD\n        # print(f\"F={F}, iF={iF}\")\n\n        P = []\n        for x in nums:\n            _p = [1] * (M + 1)\n            for i in range(1, M + 1):\n                _p[i] = _p[i - 1] * x % MOD\n            P.append(_p)\n        # print(f\"P={P}\")\n\n        dp = {(M, 0, 0): 1}\n        for j in range(N):\n            _p = P[j]\n            _dp = {}\n            for (_r, _c, _k), v in dp.items():\n                for c in range(_r + 1):\n                    v2 = v * _p[c] % MOD * iF[c] % MOD\n                    bit = (c + _c) & 1\n                    ncr = (c + _c) >> 1\n                    # print(f\"j={j}, _r={_r}, _c={_c}, c={c}, v={v}, v2={v2}, bit={bit}, ncr={ncr}\")\n                    nk = _k + bit\n                    if nk > K:\n                        continue\n                    _dp[(_r - c, ncr, nk)] = (_dp.get((_r - c, ncr, nk), 0) + v2) % MOD\n                    # print(f\"j={j}, _r={_r}, _c={_c}, c={c}, v={v}, v2={v2}, bit={bit}, ncr={ncr}, nk={nk}\")\n            dp = _dp\n\n        ans = 0\n        for (_r, _c, _k), v in dp.items():\n            if _r == 0 and _k + bin(_c).count(\"1\") == K:\n                ans = (ans + v) % MOD\n\n        # print(f\"dp={dp}\")\n        # print(f\"ans={ans}\")\n        return ans * F[M] % MOD\n",
    "lang": "python3",
    "question_id": 3851,
    "contest_submission": 23926174
  },
  {
    "submission_id": 1624869195,
    "code": "class Solution:\n    def magicalSum(self, M: int, K: int, nums: List[int]) -> int:\n        MOD = (10**9)+7\n        fact = [1] * (M+1)\n        for i in range(1, M+1):\n            fact[i] = fact[i-1] * i % MOD\n        inv_fact = [1] * (M+1)\n        inv_fact[M] = pow(fact[M], MOD-2, MOD)\n        for i in range(M, 0, -1):\n            inv_fact[i-1] = inv_fact[i] * i % MOD\n\n        dp = [[[0] * (K+1) for _ in range(M+1)] for _ in range(M+1)]\n        dp[0][0][0] = 1\n\n        for i, v in enumerate(nums):\n            ndp = [[[0] * (K+1) for _ in range(M+1)] for _ in range(M+1)]\n            pw = [1] * (M+1)\n            for c in range(1, M+1):\n                pw[c] = pw[c-1] * v % MOD\n\n            for p in range(M+1):\n                for carry in range(M+1):\n                    for b in range(K+1):\n                        cur = dp[p][carry][b]\n                        if not cur:\n                            continue\n                        max_c = M - p\n                        for c in range(max_c+1):\n                            new_p = p + c\n                            tot = carry + c\n                            bit = tot & 1\n                            new_b = b + bit\n                            if new_b > K:\n                                continue\n                            carry_out = tot >> 1\n                            val = cur * inv_fact[c] % MOD * pw[c] % MOD\n                            ndp[new_p][carry_out][new_b] = (ndp[new_p][carry_out][new_b] + val) % MOD\n\n            dp = ndp\n\n        ans = 0\n        for carry in range(M+1):\n            bc = carry.bit_count()\n            for b in range(K+1):\n                if b + bc == K:\n                    ans = (ans + dp[M][carry][b]) % MOD\n\n        ans = ans * fact[M] % MOD\n        return ans\n",
    "lang": "python3",
    "question_id": 3851,
    "contest_submission": 23925467
  }
]