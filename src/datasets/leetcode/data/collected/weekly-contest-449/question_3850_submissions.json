[
  {
    "submission_id": 1630601076,
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nfrom typing import List\nfrom collections import Counter\n\nclass Solution:\n    def canPartitionGrid(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        maxv = max(max(row) for row in grid)\n\n        rsum = []\n        psum = []\n        tsum = 0\n        for i in range(m):\n            s = sum(grid[i])\n            rsum.append(s)\n            tsum += s\n            psum.append(tsum)\n\n        topc = [0] * (maxv + 1)\n        botc = [0] * (maxv + 1)\n        for i in range(m):\n            for j in range(n):\n                botc[grid[i][j]] += 1\n\n        for i in range(m - 1):\n            for j in range(n):\n                val = grid[i][j]\n                botc[val] -= 1\n                topc[val] += 1\n\n            tops = psum[i]\n            bots = tsum - tops\n            if tops == bots:\n                return True\n\n            mins = abs(tops - bots)\n            comp = tops > bots\n            r = i + 1 if comp else m - (i + 1)\n            c = n\n            hcnt = topc if comp else botc\n\n            if mins <= maxv and hcnt[mins] > 0:\n                if r >= 2 and c >= 2:\n                    return True\n\n                ends = []\n                if r == 1 and c >= 2:\n                    row = 0 if comp else i + 1\n                    ends.append((row, 0))\n                    ends.append((row, n - 1))\n                elif c == 1 and r >= 2:\n                    col = 0\n                    rst = 0 if comp else i + 1\n                    rend = i if comp else m - 1\n                    ends.append((rst, col))\n                    ends.append((rend, col))\n\n                for x, y in ends:\n                    if grid[x][y] == mins:\n                        return True\n\n        csum = []\n        pcsum = []\n        ctot = 0\n        for j in range(n):\n            s = sum(grid[i][j] for i in range(m))\n            csum.append(s)\n            ctot += s\n            pcsum.append(ctot)\n\n        lcnt = [0] * (maxv + 1)\n        rcnt = [0] * (maxv + 1)\n        for i in range(m):\n            for j in range(n):\n                rcnt[grid[i][j]] += 1\n\n        for j in range(n - 1):\n            for i in range(m):\n                val = grid[i][j]\n                rcnt[val] -= 1\n                lcnt[val] += 1\n\n            lsum = pcsum[j]\n            rsum = tsum - lsum\n            if lsum == rsum:\n                return True\n\n            mins = abs(lsum - rsum)\n            hls = lsum > rsum\n            r = m\n            c = j + 1 if hls else n - (j + 1)\n            hcnt = lcnt if hls else rcnt\n\n            if mins <= maxv and hcnt[mins] > 0:\n                if r >= 2 and c >= 2:\n                    return True\n\n                ends = []\n                if r == 1 and c >= 2:\n                    row = 0\n                    cs = 0 if hls else j + 1\n                    ce = j if hls else n - 1\n                    ends.append((0, cs))\n                    ends.append((0, ce))\n                elif c == 1 and r >= 2:\n                    col = j if hls else j + 1\n                    ends.append((0, col))\n                    ends.append((m - 1, col))\n\n                for x, y in ends:\n                    if grid[x][y] == mins:\n                        return True\n\n        return False\n",
    "lang": "python3",
    "question_id": 3850,
    "contest_submission": 24028905
  },
  {
    "submission_id": 1630621200,
    "code": "class Solution:\n    def canPartitionGrid(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        r = [sum(rw) for rw in grid]\n        c = [sum(col) for col in zip(*grid)]\n\n        _sum = sum(r)\n\n        top = Counter()\n        bottom = Counter(x for rw in grid for x in rw)\n\n        st = 0\n        for k in range(1, m):\n            st += r[k - 1]\n            sb = _sum - st\n            for v in grid[k - 1]:\n                bottom[v] -= 1\n                if bottom[v] == 0:\n                    del bottom[v]\n                top[v] += 1\n\n            if st == sb:\n                return True\n\n            d = st - sb\n            D = abs(d)\n\n            count = top if d > 0 else bottom\n            if d > 0:\n                r0, c0, h, w = 0, 0, k, n\n            else:\n                r0, c0, h, w = k, 0, m - k, n\n\n            if (D in count\n                    and (\n                            (h > 1 and w > 1)\n                            or (h == 1 and D in (grid[r0][c0], grid[r0][c0 + w - 1]))\n                            or (w == 1 and D in (grid[r0][c0], grid[r0 + h - 1][c0]))\n                    )):\n                return True\n\n        L = Counter()\n        R = Counter(x for _ in grid for x in _)\n\n        win = 0\n        for l in range(1, n):\n            win += c[l - 1]\n\n            sr = _sum - win\n            for i in range(m):\n                v = grid[i][l - 1]\n                R[v] -= 1\n                if R[v] == 0:\n                    del R[v]\n                L[v] += 1\n\n            if win == sr:\n                return True\n\n            d = win - sr\n            D = abs(d)\n            # print(d, D)\n\n            count = L if d > 0 else R\n            # print(count)\n\n            if d > 0:\n                r0, c0, h, w = 0, 0, m, l\n            else:\n                r0, c0, h, w = 0, l, m, n - l\n\n            # print(r0, c0, h, w)\n\n            if D in count and (\n                    (h > 1 and w > 1) or\n                    (h == 1 and D in (grid[r0][c0], grid[r0][c0 + w - 1])) or\n                    (w == 1 and D in (grid[r0][c0], grid[r0 + h - 1][c0]))\n            ):\n                return True\n        return False\n",
    "lang": "python3",
    "question_id": 3850,
    "contest_submission": 24043043
  },
  {
    "submission_id": 1630614238,
    "code": "class Solution:\n    def canPartitionGrid(self, grid: List[List[int]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        total = sum(sum(row) for row in grid)\n        prefix = [0]*m\n        prefix[0] = sum(grid[0])\n        for i in range(1, m):\n            prefix[i] = prefix[i-1] + sum(grid[i])\n        col_sums = [0]*n\n        for j in range(n):\n            s = 0\n            for i in range(m):\n                s += grid[i][j]\n            col_sums[j] = s\n        vprefix = [0]*n\n        vprefix[0] = col_sums[0]\n        for j in range(1, n):\n            vprefix[j] = vprefix[j-1] + col_sums[j]\n        \n        value_map = {}\n        for i in range(m):\n            for j in range(n):\n                v = grid[i][j]\n                if v not in value_map:\n                    value_map[v] = {}\n                if i not in value_map[v]:\n                    value_map[v][i] = []\n                value_map[v][i].append(j)\n        for v in value_map:\n            for r in value_map[v]:\n                value_map[v][r].sort()\n        \n        def query_value_in_region(v, rlow, rhigh, clow, chigh):\n            if v not in value_map:\n                return False\n            for r in range(rlow, rhigh + 1):\n                if r in value_map[v]:\n                    lst = value_map[v][r]\n                    idx = bisect.bisect_left(lst, clow)\n                    if idx < len(lst) and lst[idx] <= chigh:\n                        return True\n            return False\n\n        def check_partition(rlow, rhigh, clow, chigh, diff):\n            rows = rhigh - rlow + 1\n            cols = chigh - clow + 1\n            if rows * cols == 1:\n                return False\n            if rows > 1 and cols > 1:\n                return query_value_in_region(diff, rlow, rhigh, clow, chigh)\n            else:\n                if rows == 1:\n                    if diff == grid[rlow][clow] or diff == grid[rlow][chigh]:\n                        return True\n                if cols == 1:\n                    if diff == grid[rlow][clow] or diff == grid[rhigh][clow]:\n                        return True\n            return False\n\n        for i in range(m - 1):\n            sum_top = prefix[i]\n            sum_bottom = total - sum_top\n            if sum_top == sum_bottom:\n                return True\n            if sum_top > sum_bottom:\n                diff = sum_top - sum_bottom\n                if check_partition(0, i, 0, n - 1, diff):\n                    return True\n            else:\n                diff = sum_bottom - sum_top\n                if check_partition(i + 1, m - 1, 0, n - 1, diff):\n                    return True\n\n        for j in range(n - 1):\n            sum_left = vprefix[j]\n            sum_right = total - sum_left\n            if sum_left == sum_right:\n                return True\n            if sum_left > sum_right:\n                diff = sum_left - sum_right\n                if check_partition(0, m - 1, 0, j, diff):\n                    return True\n            else:\n                diff = sum_right - sum_left\n                if check_partition(0, m - 1, j + 1, n - 1, diff):\n                    return True\n\n        return False",
    "lang": "python3",
    "question_id": 3850,
    "contest_submission": 24038306
  }
]