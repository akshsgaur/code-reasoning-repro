[
  {
    "submission_id": 1630609738,
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def maxScore(self, n: int, edges: List[List[int]]) -> int:\n        cp = edges.copy()\n        adj = [[] for i in range(n)]\n        for u, v in cp:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        vis = [False] * n\n        ls = []\n\n        class Comp:\n            def __init__(self, ps, type_, size):\n                self.ps = ps\n                self.type = type_\n                self.size = size\n\n        for i in range(n):\n            if not vis[i] and len(adj[i]) == 0:\n                vis[i] = True\n                ls.append(Comp([i], 0, 1))\n\n        for i in range(n):\n            if not vis[i] and len(adj[i]) == 1:\n                ps = []\n                curr, prev = i, -1\n                while True:\n                    ps.append(curr)\n                    vis[curr] = True\n                    nxt = -1\n                    for nb in adj[curr]:\n                        if nb != prev:\n                            nxt = nb\n                            break\n                    if nxt == -1:\n                        break\n                    prev, curr = curr, nxt\n                ls.append(Comp(ps, 1, len(ps)))\n\n        for i in range(n):\n            if not vis[i]:\n                cnode = []\n                stk = [i]\n                vis[i] = True\n                cnode.append(i)\n                while stk:\n                    u = stk.pop()\n                    for nb in adj[u]:\n                        if not vis[nb]:\n                            vis[nb] = True\n                            cnode.append(nb)\n                            stk.append(nb)\n                k = len(cnode)\n                ps = []\n                curr, prev = cnode[0], -1\n                for _ in range(k):\n                    ps.append(curr)\n                    nxt = -1\n                    for nb in adj[curr]:\n                        if nb != prev:\n                            nxt = nb\n                            break\n                    prev, curr = curr, nxt\n                ls.append(Comp(ps, 2, k))\n\n        ls.sort(key=lambda c: (-c.type, -c.size))\n\n        val = [0] * n\n        nxl = n\n        ans = 0\n\n        for C in ls:\n            k = C.size\n            L = [0] * k\n            for j in range(k - 1, -1, -1):\n                L[j] = nxl\n                nxl -= 1\n            l, r, idx = 0, k - 1, 0\n            while l <= r:\n                val[C.ps[l]] = L[idx]\n                idx += 1\n                if l == r:\n                    break\n                val[C.ps[r]] = L[idx]\n                idx += 1\n                l += 1\n                r -= 1\n            for j in range(k - 1):\n                ans += val[C.ps[j]] * val[C.ps[j + 1]]\n            if C.type == 2:\n                ans += val[C.ps[0]] * val[C.ps[-1]]\n\n        return ans\n\n",
    "lang": "python3",
    "question_id": 3845,
    "contest_submission": 24035207
  },
  {
    "submission_id": 1630614540,
    "code": "class Solution:\n    def maxScore(self, n: int, edges: List[List[int]]) -> int:\n        G = [[] for _ in range(n)]\n        D = [0] * n\n        for u, v in edges:\n            G[u].append(v)\n            G[v].append(u)\n            D[u] += 1\n            D[v] += 1\n\n        seen = [0] * n\n        cp = []\n        for i in range(n):\n            if seen[i]:\n                continue\n            _t = [i]\n            seen[i] = 1\n            nodes = []\n            _sum = 0\n            while _t:\n                u = _t.pop()\n                nodes.append(u)\n                _sum += D[u]\n                # print(u, D[u])\n                for v in G[u]:\n                    if seen[v]:\n                        continue\n                    seen[v] = 1\n                    _t.append(v)\n\n            E = _sum // 2\n            B = None\n            if E == len(nodes):\n                for u in nodes:\n                    for v in G[u]:\n                        if u < v and v in nodes:\n                            B = (u, v)\n                            break\n                    if B:\n                        break\n            cp.append((2 * E / len(nodes), len(nodes), E, nodes, B))\n        # print(cp)\n        # print(\"is\", n - sum(c for _, c, _, _, _ in cp))\n        cp.sort(key=lambda x: (-x[0], -x[1]))\n        ret = [0] * n\n\n        # print(\"cp\", cp)\n        high = n\n        for _, c, E, nodes, B in cp:\n            low = high - c + 1\n            high -= c\n            arr = list(range(low, low + c))\n            L = {u: len(G[u])\n                    - (1 if B\n                            and ((u == B[0] and B[1] in G[u])\n                                 or (u == B[1] and B[0] in G[u])) else 0) for u in nodes}\n\n            t = 0\n            q = deque(u for u in nodes if L[u] <= 1)\n            # print(\"arr\", arr)\n            while q:\n                u = q.popleft()\n                if ret[u]:\n                    continue\n                ret[u] = arr[t]\n                t += 1\n\n                # print(\"u\", u, \"arr\", arr, \"t\", t, \"L\", L)\n                for v in G[u]:\n                    if B:\n                        if (u == B[0] and v == B[1]) or (u == B[1] and v == B[0]):\n                            continue\n                    L[v] -= 1\n                    if L[v] == 1:\n                        q.append(v)\n\n        ans = 0\n        for u, v in edges:\n            ans += ret[u] * ret[v]\n            # print(\"u\", u, \"v\", v, \"ret[u]\", ret[u], \"ret[v]\", ret[v], \"ans\", ans)\n        return ans\n",
    "lang": "python3",
    "question_id": 3845,
    "contest_submission": 24038515
  },
  {
    "submission_id": 1630597722,
    "code": "class Solution:\n    def maxScore(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = [False] * n\n        components = []\n        for i in range(n):\n            if not visited[i]:\n                comp = []\n                dq = deque([i])\n                visited[i] = True\n                while dq:\n                    cur = dq.popleft()\n                    comp.append(cur)\n                    for nb in graph[cur]:\n                        if not visited[nb]:\n                            visited[nb] = True\n                            dq.append(nb)\n                components.append(comp)\n        comp_infos = []\n        def optimal_path_order(k: int) -> List[int]:\n            arr = list(range(1, k + 1))\n            res = [None] * k\n            mid = k // 2\n            res[mid] = arr.pop()\n            left_ptr = mid - 1\n            right_ptr = mid + 1\n            flag = True\n            while arr:\n                val = arr.pop()\n                if flag:\n                    if left_ptr >= 0:\n                        res[left_ptr] = val\n                        left_ptr -= 1\n                    else:\n                        res[right_ptr] = val\n                        right_ptr += 1\n                else:\n                    if right_ptr < k:\n                        res[right_ptr] = val\n                        right_ptr += 1\n                    else:\n                        res[left_ptr] = val\n                        left_ptr -= 1\n                flag = not flag\n            return res\n\n        def optimal_cycle_order(k: int) -> List[int]:\n            arr = list(range(1, k + 1))\n            left = arr[::2]\n            right = arr[1::2][::-1]\n            return left + right\n\n        for comp in components:\n            if len(comp) == 1:\n                continue\n            comp_set = set(comp)\n            comp_deg = {}\n            for u in comp:\n                d = sum(1 for nb in graph[u] if nb in comp_set)\n                comp_deg[u] = d\n            total_edges = sum(comp_deg.values()) // 2\n            k = len(comp)\n            isCycle = (k >= 3 and all(deg == 2 for deg in comp_deg.values()))\n            if isCycle:\n                order = optimal_cycle_order(k)\n                m_edges = k\n            else:\n                order = optimal_path_order(k)\n                m_edges = k - 1\n            base_score = 0\n            base_adj_sum = 0\n            if isCycle:\n                for i in range(k):\n                    j = (i + 1) % k\n                    base_score += order[i] * order[j]\n                    base_adj_sum += order[i] + order[j]\n            else:\n                for i in range(k - 1):\n                    base_score += order[i] * order[i + 1]\n                    base_adj_sum += order[i] + order[i + 1]\n            comp_infos.append((k, base_score, base_adj_sum, m_edges))\n        S = sum(info[0] for info in comp_infos)\n        if S == 0:\n            return 0\n        base_shift = n - S\n        def cmp(a, b):\n            k1, bs1, adj1, m1 = a\n            k2, bs2, adj2, m2 = b\n            diff = (adj2 * k1 - adj1 * k2) + (m2 * (k1**2) - m1 * (k2**2)) + 2 * base_shift * (m2 * k1 - m1 * k2)\n            if diff > 0:\n                return -1\n            elif diff < 0:\n                return 1\n            else:\n                return 0\n        comp_infos.sort(key=cmp_to_key(cmp))\n        total_score = 0\n        cum = 0\n        for (k, base_score, base_adj_sum, m_edges) in comp_infos:\n            d = base_shift + cum\n            total_score += base_score + d * base_adj_sum + m_edges * d * d\n            cum += k\n        return total_score",
    "lang": "python3",
    "question_id": 3845,
    "contest_submission": 24026402
  }
]