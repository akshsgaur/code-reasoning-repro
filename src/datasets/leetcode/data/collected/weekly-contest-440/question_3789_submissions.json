[
  {
    "submission_id": 1567558598,
    "code": "class Solution:\n    def maxSubarrays(self, n: int, r: List[List[int]]) -> int:\n        for i in range(len(r)):\n            a, b = r[i]\n            if a > b:\n                r[i] = [b, a]\n        M = [[] for _ in range(n+1)]\n        for a, b in r:\n            M[a].append(b)\n        for i in range(1, n+1):\n            M[i].sort()\n        D = [None]*(n+2)\n        D[n+1] = (n+1, 0, n+1)\n        for i in range(n, 0, -1):\n            d = {}\n            for v in M[i]:\n                d[v] = d.get(v, 0) + 1\n            x0, c0, y0 = D[i+1]\n            if c0 > 0:\n                d[x0] = d.get(x0, 0) + c0\n            if c0 == 1:\n                if y0 != x0:\n                    d[y0] = d.get(y0, 0) + 1\n            U = sorted(d.keys()) if d else [n+1]\n            x = U[0]\n            c = d[x] if d else 0\n            y = U[1] if len(U) > 1 else n+1\n            D[i] = (x, c, y)\n        A = 0\n        for i in range(1, n+1):\n            A += D[i][0] - i\n        d2 = {}\n        for i in range(1, n+1):\n            x, c, y = D[i]\n            if x != n+1 and c == 1:\n                if x not in d2:\n                    d2[x] = ([], [])\n                d2[x][0].append(i)\n                d2[x][1].append(y - x)\n        import bisect\n        for k in d2:\n            L, S = d2[k]\n            for i in range(1, len(S)):\n                S[i] += S[i-1]\n        m = 0\n        for a, b in r:\n            if b in d2:\n                i = bisect.bisect_right(d2[b][0], a)\n            else:\n                i = 0\n            s = d2[b][1][i-1] if i else 0\n            if s > m:\n                m = s\n        return A + m\n",
    "lang": "python3",
    "question_id": 3789,
    "contest_submission": 22982751
  },
  {
    "submission_id": 1567583893,
    "code": "class Solution:\n    def maxSubarrays(self, n: int, conflictingPairs: List[List[int]]) -> int:\n        pairs = []\n        i = 0\n        \n        while i < len(conflictingPairs):\n            a = conflictingPairs[i][0]\n            b = conflictingPairs[i][1]\n            if a > b:\n                tmp = a\n                a = b\n                b = tmp\n            pairs.append((b, a, i))\n            i += 1\n            \n        pairs.sort(key=lambda x: (x[0], x[1]))\n        curMax = 0\n        curSec = 0\n        curCount = 0\n        curId = -1\n        pointer = 0\n        f0 = 0\n        delta = {}\n        r = 1\n        \n        while r <= n:\n            while pointer < len(pairs) and pairs[pointer][0] == r:\n                bVal = pairs[pointer][0]\n                aVal = pairs[pointer][1]\n                pairId = pairs[pointer][2]\n                if aVal > curMax:\n                    curSec = curMax\n                    curMax = aVal\n                    curCount = 1\n                    curId = pairId\n                elif aVal == curMax:\n                    curCount = curCount + 1\n                    curId = -1\n                else:\n                    if aVal > curSec:\n                        curSec = aVal\n                pointer = pointer + 1\n            f0 = f0 + (r - curMax)\n            if curMax > 0 and curCount == 1 and curId != -1:\n                if curId in delta:\n                    delta[curId] = delta[curId] + (curMax - curSec)\n                else:\n                    delta[curId] = (curMax - curSec)\n            r = r + 1\n        maxDelta = 0\n        \n        for key in delta:\n            if delta[key] > maxDelta:\n                maxDelta = delta[key]\n                \n        return f0 + maxDelta",
    "lang": "python3",
    "question_id": 3789,
    "contest_submission": 23000605
  },
  {
    "submission_id": 1567579889,
    "code": "class Solution:\n    def maxSubarrays(self, n: int, cp: List[List[int]]) -> int:\n        NIL = 0\n        I = n + 1\n        p = ((a, b) if a < b else (b, a) for a, b in cp)\n        B = [[] for _ in range(n+1)]\n        for L, R in p:\n            B[L].append(R)\n        d = [None]*(n+2)\n        d[n+1] = (I, 0, I, NIL)\n        for i in range(n, 0, -1):\n            if B[i]:\n                lst = sorted(B[i])\n                f = lst[0]\n                cnt = lst.count(f)\n                s = min((x for x in lst if x > f), default=I)\n                x = (f, cnt, s, i)\n            else:\n                x = (I, 0, I, NIL)\n            y = d[i+1]\n            m = min(x[0], y[0])\n            cnt = 0\n            aid = NIL\n            if x[0] == m:\n                cnt += x[1]\n                if x[1] == 1:\n                    aid = x[3]\n            if y[0] == m:\n                cnt += y[1]\n                if y[1] == 1:\n                    aid = y[3] if aid == NIL else NIL\n            cur = []\n            if x[0] > m: cur.append(x[0])\n            if y[0] > m: cur.append(y[0])\n            if x[2] < I: cur.append(x[2])\n            if y[2] < I: cur.append(y[2])\n            sec = min(cur) if cur else I\n            d[i] = (m, cnt, sec, aid)\n        ans = 0\n        for i in range(1, n+1):\n            ans += (n - i + 1) if d[i][0] == I else (d[i][0] - i)\n        mp = defaultdict(int)\n        for i in range(1, n+1):\n            m, c, s, aid = d[i]\n            if m != I and c == 1 and aid != NIL:\n                sc = s if s != I else (n + 1)\n                mp[aid] += sc - m\n        mx = 0\n        if mp:\n            mx = max(mx, max(mp.values()))\n        return ans + mx",
    "lang": "python3",
    "question_id": 3789,
    "contest_submission": 22997843
  }
]