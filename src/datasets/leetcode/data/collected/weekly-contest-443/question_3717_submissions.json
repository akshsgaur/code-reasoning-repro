[
  {
    "submission_id": 1590636659,
    "code": "class SlidingMedian:\n    def __init__(self):\n        self.small = []  # max-heap, store negatives\n        self.large = []  # min-heap\n        self.delayed_small = {}\n        self.delayed_large = {}\n        self.small_size = 0\n        self.large_size = 0\n        self.sum_small = 0\n        self.sum_large = 0\n\n    def push(self, num: int) -> None:\n        if not self.small or num <= -self.small[0]:\n            heapq.heappush(self.small, -num)\n            self.sum_small += num\n            self.small_size += 1\n        else:\n            heapq.heappush(self.large, num)\n            self.sum_large += num\n            self.large_size += 1\n        self.balance()\n\n    def balance(self) -> None:\n        if self.small_size > self.large_size + 1:\n            val = -heapq.heappop(self.small)\n            self.sum_small -= val\n            self.small_size -= 1\n            heapq.heappush(self.large, val)\n            self.sum_large += val\n            self.large_size += 1\n            self.prune(self.small, self.delayed_small, True)\n        elif self.small_size < self.large_size:\n            val = heapq.heappop(self.large)\n            self.sum_large -= val\n            self.large_size -= 1\n            heapq.heappush(self.small, -val)\n            self.sum_small += val\n            self.small_size += 1\n            self.prune(self.large, self.delayed_large, False)\n\n    def prune(self, heap, delayed, is_small: bool) -> None:\n        while heap:\n            num = -heap[0] if is_small else heap[0]\n            if delayed.get(num, 0):\n                heapq.heappop(heap)\n                delayed[num] -= 1\n                if delayed[num] == 0:\n                    del delayed[num]\n            else:\n                break\n\n    def remove(self, num: int) -> None:\n        med = self.get_median()\n        if num <= med:\n            self.delayed_small[num] = self.delayed_small.get(num, 0) + 1\n            self.sum_small -= num\n            self.small_size -= 1\n            if self.small and -self.small[0] == num:\n                self.prune(self.small, self.delayed_small, True)\n        else:\n            self.delayed_large[num] = self.delayed_large.get(num, 0) + 1\n            self.sum_large -= num\n            self.large_size -= 1\n            if self.large and self.large[0] == num:\n                self.prune(self.large, self.delayed_large, False)\n        self.balance()\n\n    def get_median(self) -> int:\n        return -self.small[0]\n\n    def get_cost(self) -> int:\n        med = self.get_median()\n        return med * self.small_size - self.sum_small + self.sum_large - med * self.large_size\n\nclass Solution:\n    def minOperations(self, nums: List[int], x: int, k: int) -> int:\n        n = len(nums)\n        m = n - x + 1\n        if m < k:\n            return -1\n        seg_cost = [0] * m\n        sm = SlidingMedian()\n        for i in range(x):\n            sm.push(nums[i])\n        seg_cost[0] = sm.get_cost()\n        for i in range(1, m):\n            sm.remove(nums[i-1])\n            sm.push(nums[i+x-1])\n            seg_cost[i] = sm.get_cost()\n        INF = 10**18\n        dp = [[INF]*(m+1) for _ in range(k+1)]\n        for i in range(m+1):\n            dp[0][i] = 0\n        for r in range(1, k+1):\n            for i in range(m-1, -1, -1):\n                if i + x <= m:\n                    candidate = seg_cost[i] + dp[r-1][i+x]\n                else:\n                    candidate = seg_cost[i] if r == 1 else INF\n                dp[r][i] = candidate if candidate < dp[r][i+1] else dp[r][i+1]\n        return dp[k][0] if dp[k][0] < INF else -1",
    "lang": "python3",
    "question_id": 3717,
    "contest_submission": 23416724
  },
  {
    "submission_id": 1590654673,
    "code": "import heapq\nimport math\n\nclass SlidingMedian:\n    def __init__(self):\n        self.L = []\n        self.H = []\n        self.d = {}\n        self.nL = 0\n        self.nH = 0\n        self.sL = 0\n        self.sH = 0\n\n    def clean(self, heap):\n        while heap:\n            num = -heap[0] if heap is self.L else heap[0]\n            if self.d.get(num, 0):\n                heapq.heappop(heap)\n                self.d[num] -= 1\n                if self.d[num] == 0:\n                    del self.d[num]\n            else:\n                break\n\n    def balance(self):\n        if self.nL > self.nH + 1:\n            self.clean(self.L)\n            num = -heapq.heappop(self.L)\n            self.nL -= 1\n            self.sL -= num\n            heapq.heappush(self.H, num)\n            self.nH += 1\n            self.sH += num\n        elif self.nL < self.nH:\n            self.clean(self.H)\n            num = heapq.heappop(self.H)\n            self.nH -= 1\n            self.sH -= num\n            heapq.heappush(self.L, -num)\n            self.nL += 1\n            self.sL += num\n\n    def add(self, num):\n        if self.nL == 0 or num <= -self.L[0]:\n            heapq.heappush(self.L, -num)\n            self.nL += 1\n            self.sL += num\n        else:\n            heapq.heappush(self.H, num)\n            self.nH += 1\n            self.sH += num\n        self.balance()\n\n    def rem(self, num):\n        self.d[num] = self.d.get(num, 0) + 1\n        if self.L and num <= -self.L[0]:\n            self.nL -= 1\n            self.sL -= num\n            if num == -self.L[0]:\n                self.clean(self.L)\n        else:\n            self.nH -= 1\n            self.sH -= num\n            if self.H and num == self.H[0]:\n                self.clean(self.H)\n        self.balance()\n\n    def cost(self):\n        self.clean(self.L)\n        m = -self.L[0]\n        return m * self.nL - self.sL + self.sH - m * self.nH\n\nclass Solution:\n    def minOperations(self, nums: List[int], x: int, k: int) -> int:\n        n = len(nums)\n        w = n - x + 1\n        costs = [0] * w\n        sm = SlidingMedian()\n        for i in range(x):\n            sm.add(nums[i])\n        costs[0] = sm.cost()\n        for i in range(w - 1):\n            sm.rem(nums[i])\n            sm.add(nums[i + x])\n            costs[i + 1] = sm.cost()\n        INF = math.inf\n        dp = [[INF] * (k + 1) for _ in range(w + 1)]\n        for i in range(w + 1):\n            dp[i][0] = 0\n        for i in range(w - 1, -1, -1):\n            for j in range(1, k + 1):\n                this = dp[i + 1][j]\n                if i + x <= w:\n                    this = min(this, costs[i] + dp[i + x][j - 1])\n                else:\n                    this = min(this, costs[i] if j == 1 else float('inf'))\n                dp[i][j] = this\n        return dp[0][k]\n",
    "lang": "python3",
    "question_id": 3717,
    "contest_submission": 23428367
  },
  {
    "submission_id": 1590655367,
    "code": "class SlidingMedian:\n    def __init__(self):\n        # Two heaps: left is a max-heap (store negatives), right is a min-heap.\n        self.left = []    # max heap\n        self.right = []   # min heap\n        self.left_sum = 0\n        self.right_sum = 0\n        self.left_count = 0\n        self.right_count = 0\n        # Dictionaries for lazy removals.\n        self.del_left = {}\n        self.del_right = {}\n\n    def add(self, num: int):\n        # Add new number to one of the heaps.\n        if self.left_count == 0 or num <= -self.left[0]:\n            heapq.heappush(self.left, -num)\n            self.left_sum += num\n            self.left_count += 1\n        else:\n            heapq.heappush(self.right, num)\n            self.right_sum += num\n            self.right_count += 1\n        self._rebalance()\n\n    def remove(self, num: int):\n        # Remove a number (mark it for lazy deletion).\n        if self.left_count > 0 and num <= -self.left[0]:\n            self.left_sum -= num\n            self.left_count -= 1\n            self.del_left[-num] = self.del_left.get(-num, 0) + 1\n        else:\n            self.right_sum -= num\n            self.right_count -= 1\n            self.del_right[num] = self.del_right.get(num, 0) + 1\n        self._prune(self.left, self.del_left)\n        self._prune(self.right, self.del_right)\n        self._rebalance()\n\n    def _prune(self, heap, del_dict):\n        # Remove elements that have been marked for deletion.\n        while heap and del_dict.get(heap[0], 0):\n            val = heap[0]\n            del_dict[val] -= 1\n            if del_dict[val] == 0:\n                del del_dict[val]\n            heapq.heappop(heap)\n\n    def _rebalance(self):\n        # Ensure left has either equal number or one more element than right.\n        if self.left_count > self.right_count + 1:\n            self._prune(self.left, self.del_left)\n            num = -heapq.heappop(self.left)\n            self.left_sum -= num\n            self.left_count -= 1\n            heapq.heappush(self.right, num)\n            self.right_sum += num\n            self.right_count += 1\n        elif self.left_count < self.right_count:\n            self._prune(self.right, self.del_right)\n            num = heapq.heappop(self.right)\n            self.right_sum -= num\n            self.right_count -= 1\n            heapq.heappush(self.left, -num)\n            self.left_sum += num\n            self.left_count += 1\n\n    def get_median(self) -> int:\n        self._prune(self.left, self.del_left)\n        return -self.left[0] if self.left else 0\n\n    def get_cost(self) -> int:\n        # For median m, cost = m*(# left) - (sum of left) + (sum of right) - m*(# right)\n        m = self.get_median()\n        return m * self.left_count - self.left_sum + self.right_sum - m * self.right_count\n\nclass Solution:\n    def compute_costs(self, nums: List[int], x: int) -> List[int]:\n        n = len(nums)\n        if n < x:\n            return []\n        sm = SlidingMedian()\n        # Initialize with the first window.\n        for i in range(x):\n            sm.add(nums[i])\n        costs = [sm.get_cost()]\n        # Slide the window across nums.\n        for i in range(x, n):\n            sm.remove(nums[i - x])\n            sm.add(nums[i])\n            costs.append(sm.get_cost())\n        return costs\n    def minOperations(self, nums: List[int], x: int, k: int) -> int:\n        n = len(nums)\n        # If there are not enough elements to form k subarrays.\n        if n < k * x:\n            return -1\n\n        # Compute cost for every window of length x.\n        # cost[i] is the minimal operations to make nums[i:i+x] constant.\n        costs = self.compute_costs(nums, x)\n        N = len(costs)  # This equals n - x + 1\n\n        # dp[i][r] = minimum cost to choose r intervals from windows starting at index i.\n        dp = [[math.inf] * (k + 1) for _ in range(N + 1)]\n        for i in range(N + 1):\n            dp[i][0] = 0  # Cost 0 to choose 0 intervals.\n\n        # Precompute the next index if we take the window starting at i.\n        # Since each window covers x elements, next[i] = i + x (or N if i+x > N).\n        next_index = [min(i + x, N) for i in range(N)]\n        \n        # Fill the DP table in reverse.\n        for i in range(N - 1, -1, -1):\n            for r in range(1, k + 1):\n                # Option 1: Skip current window.\n                opt1 = dp[i + 1][r]\n                # Option 2: Take current window and add its cost.\n                opt2 = costs[i] + dp[next_index[i]][r - 1]\n                dp[i][r] = min(opt1, opt2)\n                \n        return dp[0][k] if dp[0][k] != math.inf else -1",
    "lang": "python3",
    "question_id": 3717,
    "contest_submission": 23428809
  }
]