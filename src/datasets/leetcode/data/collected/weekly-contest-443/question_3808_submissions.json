[
  {
    "submission_id": 1590625901,
    "code": "class Solution:\n    def longestPalindrome(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        palS = [[False] * n for _ in range(n)]\n        for i in range(n):\n            palS[i][i] = True\n        for i in range(n - 1):\n            palS[i][i + 1] = (s[i] == s[i + 1])\n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                palS[i][j] = (s[i] == s[j] and palS[i + 1][j - 1])\n        left_pal = [0] * n\n        for i in range(n):\n            mx = 0\n            for j in range(i, n):\n                if palS[i][j]:\n                    cur = j - i + 1\n                    if cur > mx:\n                        mx = cur\n            left_pal[i] = mx\n        longest_s = max(left_pal) if n else 0\n\n        palT = [[False] * m for _ in range(m)]\n        for i in range(m):\n            palT[i][i] = True\n        for i in range(m - 1):\n            palT[i][i + 1] = (t[i] == t[i + 1])\n        for length in range(3, m + 1):\n            for i in range(m - length + 1):\n                j = i + length - 1\n                palT[i][j] = (t[i] == t[j] and palT[i + 1][j - 1])\n        right_pal = [0] * m\n        for j in range(m):\n            mx = 0\n            for i in range(j + 1):\n                if palT[i][j]:\n                    cur = j - i + 1\n                    if cur > mx:\n                        mx = cur\n            right_pal[j] = mx\n        longest_t = max(right_pal) if m else 0\n\n        best = max(longest_s, longest_t)\n        R = t[::-1]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == R[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    L = dp[i][j]\n                    extra1 = left_pal[i] if i < n else 0\n                    cand1 = 2 * L + extra1\n                    if cand1 > best:\n                        best = cand1\n                    p = m - j\n                    extra2 = right_pal[p - 1] if p > 0 else 0\n                    cand2 = 2 * L + extra2\n                    if cand2 > best:\n                        best = cand2\n                else:\n                    dp[i][j] = 0\n        return best",
    "lang": "python3",
    "question_id": 3808,
    "contest_submission": 23409613
  },
  {
    "submission_id": 1590624215,
    "code": "class Solution:\n    def longestPalindrome(self, ss1: str, ss2: str) -> int:\n        def solve(s1, s2):\n            trie = {}\n            for i in range(len(s2)):\n                cur = trie\n                for j in range(i, len(s2)):\n                    c = s2[j]\n                    if c not in cur:\n                        cur[c] = {}\n                    cur = cur[c]\n            ans = 1\n            for midl in range(len(s1)):\n                for shift in [0, 1]:\n                    midr = midl + shift\n                    l = midl\n                    r = midr\n                    triestarted = False\n                    while l >= 0:\n                        if not triestarted:\n                            if r < len(s1) and s1[r] == s1[l]:\n                                ans = max(ans, r - l + 1)\n                                l -= 1\n                                r += 1\n                            else:\n                                triestarted = True\n                                cur = trie\n                        else:\n                            if s1[l] not in cur:\n                                break\n                            else:\n                                cur = cur[s1[l]]\n                                ans = max(ans, r - l + 1)\n                                l -= 1\n                                r += 1\n            return ans\n        return max(solve(ss1, ss2), solve(ss2[::-1], ss1[::-1]))\n                                \n",
    "lang": "python3",
    "question_id": 3808,
    "contest_submission": 23408501
  },
  {
    "submission_id": 1590627076,
    "code": "class Solution:\n    def longestPalindrome(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n    \n        # --- Precompute palindromic substrings for s ---\n        # isPalS[i][j] = True if s[i:j+1] is a palindrome.\n        isPalS = [[False] * n for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i < 2 or isPalS[i+1][j-1]):\n                    isPalS[i][j] = True\n        # best_start[i] = length of longest palindrome starting exactly at index i in s.\n        best_start = [0] * n\n        for i in range(n):\n            max_len = 0\n            for j in range(i, n):\n                if isPalS[i][j]:\n                    length = j - i + 1\n                    if length > max_len:\n                        max_len = length\n            best_start[i] = max_len\n        \n        # --- Precompute palindromic substrings for t ---\n        # isPalT[i][j] = True if t[i:j+1] is a palindrome.\n        isPalT = [[False] * m for _ in range(m)]\n        for i in range(m-1, -1, -1):\n            for j in range(i, m):\n                if t[i] == t[j] and (j - i < 2 or isPalT[i+1][j-1]):\n                    isPalT[i][j] = True\n        # best_end[j] = length of longest palindrome ending exactly at index j in t.\n        best_end = [0] * m\n        for j in range(m):\n            max_len = 0\n            for i in range(0, j+1):\n                if isPalT[i][j]:\n                    length = j - i + 1\n                    if length > max_len:\n                        max_len = length\n            best_end[j] = max_len\n        \n        # --- Pure palindromes: those lying entirely in s or entirely in t ---\n        pure = 0\n        if n > 0:\n            pure = max(best_start)  # longest palindrome in s\n        if m > 0:\n            pure = max(pure, max(best_end))  # longest palindrome in t\n        \n        # --- DP for common substrings between s and reverse(t) ---\n        t_rev = t[::-1]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        best_cross = 0\n        \n        # dp[i][j]: longest common suffix of s[:i] and t_rev[:j].\n        # When dp[i][j] = L > 0, it means s[i-L:i] = t_rev[j-L:j],\n        # which corresponds to a substring X in s (ending at index i-1)\n        # and reverse(X) in t. In t, the occurrence of reverse(X) starts at pos = m - j.\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == t_rev[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    L = dp[i][j]\n                    # Case B: extend u in s (u = X + Y, where Y is a palindrome).\n                    # Here, X = s[i - L : i] and we can append Y = (longest palindrome starting at index i).\n                    ext_s = best_start[i] if i < n else 0\n                    candidate_B = 2 * L + ext_s\n                    # Case A: extend v in t (v = p + reverse(X), where p is a palindrome).\n                    # In t, the occurrence of reverse(X) starts at index pos = m - j.\n                    pos = m - j  \n                    ext_t = best_end[pos - 1] if pos > 0 else 0\n                    candidate_A = 2 * L + ext_t\n                    best_cross = max(best_cross, candidate_A, candidate_B)\n        \n        return max(pure, best_cross)",
    "lang": "python3",
    "question_id": 3808,
    "contest_submission": 23410413
  }
]