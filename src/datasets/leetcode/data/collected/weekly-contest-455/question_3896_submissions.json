[
  {
    "submission_id": 1672149867,
    "code": "class Solution:\n    def minTime(self, n, k, m, t, f):\n        if n > 1 and k == 1:\n            return -1.0\n\n        import sys, heapq, math\n        from itertools import combinations\n\n        full = (1 << n) - 1\n        pq = [(0.0, 0, 0, 0)]\n        vis = {}\n\n        while pq:\n            x, a, b, c = heapq.heappop(pq)\n            if vis.get((a, b, c), sys.maxsize) <= x:\n                continue\n            vis[(a, b, c)] = x\n            if a == full and c:\n                return round(x, 5)\n            if c == 0:\n                rem = [i for i in range(n) if not (a >> i & 1)]\n                for j in range(1, min(k, len(rem)) + 1):\n                    for grp in combinations(rem, j):\n                        d = max(t[i] for i in grp) * f[b]\n                        nb = (b + math.floor(d)) % m\n                        na = a\n                        for i in grp:\n                            na |= 1 << i\n                        heapq.heappush(pq, (x + d, na, nb, 1))\n            else:\n                if a != full:\n                    for i in range(n):\n                        if a >> i & 1:\n                            d = t[i] * f[b]\n                            nb = (b + math.floor(d)) % m\n                            na = a & ~(1 << i)\n                            heapq.heappush(pq, (x + d, na, nb, 0))\n\n        return -1.0\n",
    "lang": "python3",
    "question_id": 3896,
    "contest_submission": 24753524
  },
  {
    "submission_id": 1672143232,
    "code": "class Solution:\n    def minTime(\n        self, n: int, k: int, m: int, time: List[int], mul: List[float]\n    ) -> float:\n        full = (1 << n) - 1\n        dp = {}\n        start = (0, 0, 0)\n        dp[start] = 0.0\n        pq = [(0.0, start)]\n        while pq:\n            c, (msk, bt, st) = heapq.heappop(pq)\n            if dp.get((msk, bt, st), float(\"inf\")) < c - 1e-12:\n                continue\n            if msk == full and bt == 1:\n                return round(c, 5)\n            if bt == 0:\n                rem = [i for i in range(n) if (msk >> i) & 1 == 0]\n                for sz in range(1, min(k, len(rem)) + 1):\n                    for group in itertools.combinations(rem, sz):\n                        tmax = 0\n                        bitmask = 0\n                        for i in group:\n                            if time[i] > tmax:\n                                tmax = time[i]\n                            bitmask |= 1 << i\n                        T = tmax * mul[st]\n                        nstage = (st + int(math.floor(T))) % m\n                        nmask = msk | bitmask\n                        nboat = 1\n                        nc = c + T\n                        state = (nmask, nboat, nstage)\n                        if dp.get(state, float(\"inf\")) > nc + 1e-12:\n                            dp[state] = nc\n                            heapq.heappush(pq, (nc, state))\n            else:\n                if msk != full:\n                    for i in range(n):\n                        if (msk >> i) & 1:\n                            T = time[i] * mul[st]\n                            nstage = (st + int(math.floor(T))) % m\n                            nmask = msk & ~(1 << i)\n                            nboat = 0\n                            nc = c + T\n                            state = (nmask, nboat, nstage)\n                            if dp.get(state, float(\"inf\")) > nc + 1e-12:\n                                dp[state] = nc\n                                heapq.heappush(pq, (nc, state))\n        return -1\n",
    "lang": "python3",
    "question_id": 3896,
    "contest_submission": 24749246
  },
  {
    "submission_id": 1672158055,
    "code": "from typing import List, Tuple\nimport heapq\nimport math\nfrom itertools import combinations\n\nclass Solution:\n    def minTime(self, n: int, k: int, m: int, time: List[int], mul: List[float]) -> float:\n        # check impossibility\n        if n > 1 and k == 1:\n            return -1.0\n        FULL = (1 << n) - 1\n        start = (0,0,0)\n        best = {start: 0.0}\n        pq: List[Tuple[float, Tuple[int, int, int]]] = [(0.0, start)]\n\n        # pre compute groups\n        groups_by_size: List[List[Tuple[int, int]]] = [[] for _ in range(k+1)]\n        for sz in range(1, k + 1):\n            for combo in combinations(range(n), sz):\n                bitmask = 0\n                slowest = 0\n                for p in combo:\n                    bitmask |= 1 << p\n                    slowest = max(slowest, time[p])\n                groups_by_size[sz].append((bitmask, slowest))\n\n        while pq:\n            tot_t, (mask, stage, side) = heapq.heappop(pq)\n            if tot_t > best[(mask, stage, side)] + 1e-12:\n                continue\n            if mask == FULL and side == 1:\n                return round(tot_t, 5)\n\n            if side == 0: # boat at base\n                waiting = FULL ^ mask\n                count_waiting = bin(waiting).count(\"1\")\n                for sz in range(1, min(k, count_waiting) + 1):\n                    for gmask, slowest in groups_by_size[sz]:\n                        if gmask & waiting != gmask: # must be a subset of waiting\n                            continue\n                        t = slowest * mul[stage]\n                        nxt_stage = (stage + math.floor(t)) % m\n                        nxt_state = (mask | gmask, nxt_stage, 1)\n                        nxt_t = tot_t + t\n                        if nxt_t < best.get(nxt_state, float(\"inf\")) - 1e-12:\n                            best[nxt_state] = nxt_t\n                            heapq.heappush(pq, (nxt_t, nxt_state))\n                        \n            else: # boat at destination\n                for p in range(n):\n                    if (mask >> p) & 1 == 0:\n                        continue\n                    t = time[p] * mul[stage]\n                    nxt_stage = (stage + math.floor(t)) % m\n                    nxt_state = (mask ^ (1 << p), nxt_stage, 0)\n                    nxt_t = tot_t + t\n                    if nxt_t < best.get(nxt_state, float(\"inf\")) - 1e-12:\n                        best[nxt_state] = nxt_t\n                    heapq.heappush(pq, (nxt_t, nxt_state))\n        return -1.0\n                \n            ",
    "lang": "python3",
    "question_id": 3896,
    "contest_submission": 24758707
  }
]