[
  {
    "submission_id": 1618879937,
    "code": "class Solution:\n    def pathExistenceQueries(self, n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[int]:\n        arr = [(nums[i], i) for i in range(n)]\n        arr.sort(key=lambda x: x[0])\n        sv = [a for a, _ in arr]\n        si = [i for _, i in arr]\n        pos = [0] * n\n        for j in range(n):\n            pos[si[j]] = j\n        comp = [0] * n\n        for i in range(1, n):\n            comp[i] = comp[i - 1] + (1 if sv[i] - sv[i - 1] > maxDiff else 0)\n        r = [0] * n\n        j = 0\n        for i in range(n):\n            while j < n and sv[j] - sv[i] <= maxDiff:\n                j += 1\n            r[i] = j - 1\n        L = n.bit_length()\n        f = [r[:]]\n        for p in range(1, L):\n            fp = [0] * n\n            for i in range(n):\n                fp[i] = f[p - 1][f[p - 1][i]]\n            f.append(fp)\n        def jump(a, b):\n            if sv[b] - sv[a] <= maxDiff:\n                return 1\n            steps, cur = 0, a\n            for p in range(L - 1, -1, -1):\n                if f[p][cur] < b:\n                    cur = f[p][cur]\n                    steps += 1 << p\n            return steps + 1 if f[0][cur] >= b else -1\n        res = []\n        for u, v in queries:\n            if u == v:\n                res.append(0)\n                continue\n            a, b = pos[u], pos[v]\n            if a > b:\n                a, b = b, a\n            if comp[a] != comp[b]:\n                res.append(-1)\n            else:\n                res.append(jump(a, b))\n        return res",
    "lang": "python3",
    "question_id": 3852,
    "contest_submission": 23862528
  },
  {
    "submission_id": 1618878058,
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n    \nfrom bisect import bisect_left, bisect_right\n\nclass Solution:\n    def pathExistenceQueries(self, n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[int]:\n        ls = nums.copy()\n\n        nodes = sorted((val, idx) for idx, val in enumerate(nums))\n        vs = [v for v, _ in nodes]\n        pos = [0] * n\n        for rank, (_, idx) in enumerate(nodes):\n            pos[idx] = rank\n\n        ll = [0] * n\n        for i in range(1, n):\n            ll[i] = ll[i-1] + (vs[i] - vs[i-1] > maxDiff)\n\n        ps = [0] * n\n        j = 0\n        for i in range(n):\n            while j + 1 < n and vs[j+1] - vs[i] <= maxDiff:\n                j += 1\n            ps[i] = j\n\n        ps2 = [0] * n\n        k = 0\n        for i in range(n):\n            while k < i and vs[i] - vs[k] > maxDiff:\n                k += 1\n            ps2[i] = k\n\n        logg = (n-1).bit_length()\n        up1 = [ps[:]]\n        up2 = [ps2[:]]\n        for r in range(1, logg):\n            prev1 = up1[r-1]\n            prev2 = up2[r-1]\n            cur1 = [0] * n\n            cur2 = [0] * n\n            for i in range(n):\n                cur1[i] = prev1[prev1[i]]\n                cur2[i] = prev2[prev2[i]]\n            up1.append(cur1)\n            up2.append(cur2)\n\n        res = []\n        for u, v in queries:\n            pu, pv = pos[u], pos[v]\n            if ll[pu] != ll[pv]:\n                res.append(-1)\n                continue\n            if pu == pv:\n                res.append(0)\n                continue\n            if pu < pv:\n                hv = 0\n                cur = pu\n                for r in reversed(range(logg)):\n                    nxt = up1[r][cur]\n                    if nxt < pv:\n                        cur = nxt\n                        hv |= (1 << r)\n                res.append(hv + 1)\n            else:\n                hv = 0\n                cur = pu\n                for r in reversed(range(logg)):\n                    nxt = up2[r][cur]\n                    if nxt > pv:\n                        cur = nxt\n                        hv |= (1 << r)\n                res.append(hv + 1)\n        return res\n",
    "lang": "python3",
    "question_id": 3852,
    "contest_submission": 23861323
  },
  {
    "submission_id": 1618886059,
    "code": "class Solution:\n    def pathExistenceQueries(self, n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[int]:\n        pairs = sorted((val, idx) for idx, val in enumerate(nums))\n        values = [val for val, _ in pairs]\n        pos = [0] * n\n        for i, (_, idx) in enumerate(pairs):\n            pos[idx] = i\n        \n        comp = [0] * n\n        cid = 0\n        for i in range(1, n):\n            if values[i] - values[i-1] > maxDiff:\n                cid += 1\n            comp[i] = cid\n        \n        R = [0] * n\n        j = 0\n        for i in range(n):\n            while j + 1 < n and values[j+1] <= values[i] + maxDiff:\n                j += 1\n            R[i] = j\n        \n        LOG = math.ceil(math.log2(n)) + 1\n        nxt = [R]\n        for k in range(1, LOG):\n            prev = nxt[k-1]\n            curr = [0] * n\n            for i in range(n):\n                curr[i] = prev[prev[i]]\n            nxt.append(curr)\n        \n        def dist(pu, pv):\n            if pu == pv:\n                return 0\n            steps = 0\n            cur = pu\n            for k in range(LOG-1, -1, -1):\n                if nxt[k][cur] < pv:\n                    cur = nxt[k][cur]\n                    steps += 1 << k\n            \n            return steps + 1\n        \n        ans = []\n        for u, v in queries:\n            pu, pv = pos[u], pos[v]\n            if comp[pu] != comp[pv]:\n                ans.append(-1)\n            else:\n                if pu > pv:\n                    pu, pv = pv, pu\n                ans.append(dist(pu, pv))\n        return ans",
    "lang": "python3",
    "question_id": 3852,
    "contest_submission": 23866426
  }
]