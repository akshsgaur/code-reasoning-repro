[
  {
    "submission_id": 1636870214,
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nimport math\nclass Solution:\n    def minimumWeight(self, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n        n = len(edges) + 1\n        adj = [[] for _ in range(n)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n\n        LOG = math.ceil(math.log2(n))\n        depth = [0] * n\n        dist = [0] * n\n        up = [[0] * n for _ in range(LOG + 1)]\n\n        def dfs(u, p):\n            up[0][u] = p\n            for v, w in adj[u]:\n                if v == p:\n                    continue\n                depth[v] = depth[u] + 1\n                dist[v] = dist[u] + w\n                dfs(v, u)\n\n        dfs(0, 0)\n\n        for i in range(1, LOG + 1):\n            for v in range(n):\n                up[i][v] = up[i - 1][up[i - 1][v]]\n\n        def lca(u, v):\n            if depth[u] < depth[v]:\n                u, v = v, u\n            diff = depth[u] - depth[v]\n            for i in range(LOG + 1):\n                if diff & (1 << i):\n                    u = up[i][u]\n            if u == v:\n                return u\n            for i in range(LOG, -1, -1):\n                if up[i][u] != up[i][v]:\n                    u = up[i][u]\n                    v = up[i][v]\n            return up[0][u]\n\n        def gdist(x, y):\n            z = lca(x, y)\n            return dist[x] + dist[y] - 2 * dist[z]\n\n\n        ans = []\n        for a, b, c in queries:\n            d1 = gdist(a, b)\n            d2 = gdist(b, c)\n            d3 = gdist(a, c)\n            tot = (d1 + d2 + d3) // 2\n            ans.append(int(tot))\n\n        return ans\n",
    "lang": "python3",
    "question_id": 3853,
    "contest_submission": 24094601
  },
  {
    "submission_id": 1636875750,
    "code": "import sys\nclass Solution:\n    def minimumWeight(self, edges, queries):\n        n = len(edges) + 1\n        adj = [[] for _ in range(n)]\n        for u, v, w in edges: adj[u].append((v, w)); adj[v].append((u, w))\n        \n        sys.setrecursionlimit(n + 5000); K = n.bit_length()\n        depth, dist, up = [-1] * n, [-1] * n, [[0] * K for _ in range(n)]\n        \n        def dfs(u, p, dep, dsum):\n            depth[u], dist[u], up[u][0] = dep, dsum, p\n            for v, w in adj[u]:\n                if v != p: dfs(v, u, dep + 1, dsum + w)    \n        dfs(0, 0, 0, 0)\n        for k in range(1, K):\n            for i in range(n): up[i][k] = up[up[i][k-1]][k-1]\n        def get_lca(u, v):\n            if depth[u] < depth[v]: u, v = v, u\n            for k in range(K-1, -1, -1):\n                if depth[u] - (1 << k) >= depth[v]: u = up[u][k]\n            if u == v: return u\n            for k in range(K-1, -1, -1):\n                if up[u][k] != up[v][k]: u, v = up[u][k], up[v][k]\n            return up[u][0]\n        \n        def get_dist(u, v): return dist[u] + dist[v] - 2 * dist[get_lca(u, v)]\n        \n        return [(get_dist(x, y) + get_dist(x, z) + get_dist(y, z)) // 2 for x, y, z in queries]",
    "lang": "python3",
    "question_id": 3853,
    "contest_submission": 24098509
  },
  {
    "submission_id": 1636875390,
    "code": "class Solution:\n    def minimumWeight(self, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n        n = max(max(u, v) for u, v, _ in edges) + 1\n        adj = [[] for _ in range(n)]\n    \n        for u, v, w in edges:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n            \n        LOG = (n-1).bit_length() + 1\n        parent = [[-1]*n for _ in range(LOG)]\n        depth = [0]*n\n        dist_root = [0]*n\n        \n        stack = [(0, -1)]\n        \n        while stack:\n            u, p = stack.pop()\n            parent[0][u] = p\n            for v, w in adj[u]:\n                if v == p:\n                    continue\n                depth[v] = depth[u] + 1\n                dist_root[v] = dist_root[u] + w\n                stack.append((v, u))\n                \n        for k in range(1, LOG):\n            for v in range(n):\n                pp = parent[k-1][v]\n                parent[k][v] = -1 if pp < 0 else parent[k-1][pp]      \n        \n        def lca(u, v):\n            if depth[u] < depth[v]:\n                u, v = v, u\n            diff = depth[u] - depth[v]\n            \n            for k in range(LOG):\n                if diff >> k & 1:\n                    u = parent[k][u]\n            if u == v:\n                return u\n\n            for k in reversed(range(LOG)):\n                if parent[k][u] != parent[k][v]:\n                    u = parent[k][u]\n                    v = parent[k][v]\n            return parent[0][u]\n        \n        def dist(u, v):\n            w = lca(u, v)\n            return dist_root[u] + dist_root[v] - 2*dist_root[w]\n\n        ret = []\n        \n        for s1, s2, d in queries:\n            d12 = dist(s1, s2)\n            d1d = dist(s1, d)\n            d2d = dist(s2, d)\n            ret.append((d12 + d1d + d2d) // 2)\n        return ret\n\n",
    "lang": "python3",
    "question_id": 3853,
    "contest_submission": 24098263
  }
]