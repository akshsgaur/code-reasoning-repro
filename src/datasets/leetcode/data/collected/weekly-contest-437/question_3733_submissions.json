[
  {
    "submission_id": 1544524131,
    "code": "class Solution:\n    def lenOfVDiagonal(self, g: List[List[int]]) -> int:\n        n = len(g)\n        m = len(g[0])\n        ds = [(1, 1), (1, -1), (-1, -1), (-1, 1)]\n        t = [1, 2, 3, 0]\n        nx = [1, 2, 1]\n        ex = [1, 2, 0]\n        dp = [[[[0] * m for _ in range(n)] for _ in range(3)] for _ in range(4)]\n        for i, (a, b) in enumerate(ds):\n            rr = range(n - 1, -1, -1) if a == 1 else range(0, n)\n            cc = range(m - 1, -1, -1) if b == 1 else range(0, m)\n            for r in rr:\n                for c in cc:\n                    for s in range(3):\n                        if g[r][c] != ex[s]:\n                            dp[i][s][r][c] = 0\n                        else:\n                            nr = r + a\n                            nc = c + b\n                            if 0 <= nr < n and 0 <= nc < m:\n                                dp[i][s][r][c] = 1 + dp[i][nx[s]][nr][nc]\n                            else:\n                                dp[i][s][r][c] = 1\n        ed = [[[[0] * m for _ in range(n)] for _ in range(3)] for _ in range(4)]\n        for i, (a, b) in enumerate(ds):\n            rr = range(0, n) if a == 1 else range(n - 1, -1, -1)\n            cc = range(0, m) if b == 1 else range(m - 1, -1, -1)\n            for r in rr:\n                for c in cc:\n                    for s in range(3):\n                        if g[r][c] != ex[s]:\n                            ed[i][s][r][c] = 0\n                        else:\n                            pr = r - a\n                            pc = c - b\n                            if s == 0:\n                                ed[i][s][r][c] = 1\n                            elif 0 <= pr < n and 0 <= pc < m:\n                                if s == 1:\n                                    v = 0\n                                    if ed[i][0][pr][pc]:\n                                        v = ed[i][0][pr][pc]\n                                    if ed[i][2][pr][pc] > v:\n                                        v = ed[i][2][pr][pc]\n                                    ed[i][s][r][c] = v + 1 if v else 0\n                                else:\n                                    ed[i][s][r][c] = ed[i][1][pr][pc] + 1 if ed[i][1][pr][pc] else 0\n                            else:\n                                ed[i][s][r][c] = 0\n        cn = 0\n        for i in range(4):\n            for r in range(n):\n                for c in range(m):\n                    if dp[i][0][r][c] > cn: cn = dp[i][0][r][c]\n        for i in range(4):\n            a, b = ds[t[i]]\n            for r in range(n):\n                for c in range(m):\n                    for s in (1, 2):\n                        L = ed[i][s][r][c]\n                        if L >= 2:\n                            nr = r + a\n                            nc = c + b\n                            if 0 <= nr < n and 0 <= nc < m:\n                                ar = L + dp[t[i]][nx[s]][nr][nc]\n                                if ar > cn: cn = ar\n        return cn\n",
    "lang": "python3",
    "question_id": 3733,
    "contest_submission": 22607519
  },
  {
    "submission_id": 1544518419,
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\n\nclass Solution:\n    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        dirs = [(1, 1), (-1, -1), (1, -1), (-1, 1)]\n        mps = {0: 2, 2: 1, 1: 3, 3: 0}\n        dp = [[[[0,0] for i in range(m)] for j in range(n)] for k in range(4)]\n        \n        for d in range(4):\n            dr, dc = dirs[d]\n            if d == 0:\n                r1 = range(n-1, -1, -1)\n                r2 = range(m-1, -1, -1)\n            elif d == 1:\n                r1 = range(n)\n                r2 = range(m)\n            elif d == 2:\n                r1 = range(n-1, -1, -1)\n                r2 = range(m)\n            elif d == 3:\n                r1 = range(n)\n                r2 = range(m-1, -1, -1)\n            \n            for i in r1:\n                for j in r2:\n                    for p in (0, 1):\n                        now = 2 if p == 1 else 0\n                        if grid[i][j] == now:\n                            ni, nj = i + dr, j + dc\n                            add = 0\n                            if 0 <= ni < n and 0 <= nj < m:\n                                add = dp[d][ni][nj][1-p]\n                            dp[d][i][j][p] = 1 + add\n                        else:\n                            dp[d][i][j][p] = 0\n        \n        ans = 0\n        \n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] != 1:\n                    continue\n                for d in range(4):\n                    path = [(i, j)]\n                    clen = 1 \n                    r, c = i, j\n                    stp = 0  \n                    while True:\n                        nr = r + dirs[d][0]\n                        nc = c + dirs[d][1]\n                        nxt = stp + 1\n                        now = 2 if nxt % 2 == 1 else 0\n                        if not (0 <= nr < n and 0 <= nc < m):\n                            break\n                        if grid[nr][nc] != now:\n                            break\n                        path.append((nr, nc))\n                        clen += 1\n                        r, c = nr, nc\n                        stp += 1\n                    \n                    ans = max(ans, clen)\n                    ndir = mps[d] \n                    dr2, dc2 = dirs[ndir]\n\n                    for t in range(1, len(path)):\n                        tr, tc = path[t]\n\n                        takes = (t + 1) % 2\n                        nr = tr + dr2\n                        nc = tc + dc2\n                        two = 0\n                        if 0 <= nr < n and 0 <= nc < m:\n                            two = dp[ndir][nr][nc][takes]\n                        tot = t + 1 + two \n                        ans = max(ans, tot)\n        \n        return ans\n",
    "lang": "python3",
    "question_id": 3733,
    "contest_submission": 22602970
  },
  {
    "submission_id": 1544546030,
    "code": "class Solution:\n    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        dirs = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\n        dp = [[[[0] * m for i in range(n)] for j in range(3)] for k in range(4)]\n        \n        for d in range(4):\n            dr, dc = dirs[d]\n            si, ei, sti = (n - 1, -1, -1) if dr == 1 else (0, n, 1)\n            sj, ej, stj = (m - 1, -1, -1) if dc == 1 else (0, m, 1)\n            \n            for i in range(si, ei, sti):\n                for j in range(sj, ej, stj):\n                    for s in range(3):\n                        exp = 1 if s == 0 else (2 if s == 1 else 0)\n                        if grid[i][j] == exp:\n                            ni, nj = i + dr, j + dc\n                            ns = 1 if s == 0 else (2 if s == 1 else 1)\n                            plus = dp[d][ns][ni][nj] if 0 <= ni < n and 0 <= nj < m else 0\n                            dp[d][s][i][j] = 1 + plus\n                        else:\n                            dp[d][s][i][j] = 0\n        \n        ans = 0\n        for d in range(4):\n            for i in range(n):\n                for j in range(m):\n                    ans = max(ans, dp[d][0][i][j])\n        \n        for d in range(4):\n            dr, dc = dirs[d]\n            dr2, dc2 = dc, -dr\n            d2 = dirs.index((dr2, dc2))\n            \n            for i in range(n):\n                for j in range(m):\n                    maxs = dp[d][0][i][j]\n                    if maxs <= 0:\n                        continue\n                    \n                    for L in range(1, maxs + 1):\n                        ts, tx = i + (L - 1) * dr, j + (L - 1) * dc\n                        nst = 1 if L % 2 == 1 else 2\n                        nr, nc = ts + dr2, tx + dc2\n                        ext = dp[d2][nst][nr][nc] if 0 <= nr < n and 0 <= nc < m else 0\n                        ans = max(ans, L + ext)\n        \n        return ans\n",
    "lang": "python3",
    "question_id": 3733,
    "contest_submission": 22624753
  }
]