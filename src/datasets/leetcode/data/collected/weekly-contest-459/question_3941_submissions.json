[
  {
    "submission_id": 1704192458,
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def popcountDepth(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        def d(x):\n            r = 0\n            while x != 1:\n                x = bin(x).count(\"1\")\n                r += 1\n            return r\n\n        n = len(nums)\n        v = [d(x) for x in nums]\n        m = 1\n        while m < n:\n            m <<= 1\n\n        t = [[0] * 6 for i in range(2 * m)]\n\n        for i in range(n):\n            t[m + i][v[i]] += 1\n\n        for i in range(m - 1, 0, -1):\n            for k in range(6):\n                t[i][k] = t[2 * i][k] + t[2 * i + 1][k]\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                l, r, k = q[1] + m, q[2] + m, q[3]\n                s = 0\n                while l <= r:\n                    if l & 1:\n                        s += t[l][k]\n                        l += 1\n                    if not (r & 1):\n                        s += t[r][k]\n                        r -= 1\n                    l >>= 1\n                    r >>= 1\n                ans.append(s)\n            else:\n                i, y = q[1], q[2]\n                l0 = d(y)\n                l1 = v[i]\n                if l0 != l1:\n                    p = m + i\n                    t[p][l1] -= 1\n                    t[p][l0] += 1\n                    p >>= 1\n                    while p:\n                        t[p][l1] -= 1\n                        t[p][l0] += 1\n                        p >>= 1\n                    v[i] = l0\n        return ans\n\n\n\n",
    "lang": "python3",
    "question_id": 3941,
    "contest_submission": 25242504
  },
  {
    "submission_id": 1704191790,
    "code": "from typing import List\n\nclass f:\n    def __init__(s, n): s.t = [0] * (n + 1)\n    def a(s, i, d):\n        i += 1\n        while i < len(s.t):\n            s.t[i] += d\n            i += i & -i\n    def q(s, i):\n        i += 1; r = 0\n        while i: r += s.t[i]; i -= i & -i\n        return r\n    def qr(s, l, r):\n        return s.q(r) - (s.q(l - 1) if l else 0)\n\nclass Solution:\n    def popcountDepth(s, a: List[int], q: List[List[int]]) -> List[int]:\n        s.m = {1:0}\n        def d(x):\n            if x in s.m: return s.m[x]\n            s.m[x] = 1 + d(x.bit_count())\n            return s.m[x]\n        n, m = len(a), 6\n        b = [f(n) for _ in range(m)]\n        l = [d(x) for x in a]\n        for i, v in enumerate(l):\n            if v < m: b[v].a(i, 1)\n        r = []\n        for u in q:\n            if u[0] == 1:\n                _, x, y, k = u\n                r.append(0 if k >= m else b[k].qr(x, y))\n            else:\n                _, i, v = u\n                o, p = l[i], d(v)\n                if o != p:\n                    if o < m: b[o].a(i, -1)\n                    if p < m: b[p].a(i, 1)\n                    l[i] = p\n        return r\n",
    "lang": "python3",
    "question_id": 3941,
    "contest_submission": 25241975
  },
  {
    "submission_id": 1704219704,
    "code": "class Solution:\n    def popcountDepth(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        limit = 6\n\n        \n        class FenwickTree:\n            def __init__(self, size):\n                self.tree = [0] * (size + 1)\n\n            def add(self, index, delta):\n                index += 1\n                while index < len(self.tree):\n                    self.tree[index] += delta\n                    index += index & -index\n\n            def prefix_sum(self, index):\n                index += 1\n                s = 0\n                while index > 0:\n                    s += self.tree[index]\n                    index -= index & -index\n                return s\n\n            def query(self, start, end):\n                if start > end:\n                    return 0\n                res = self.prefix_sum(end)\n                if start > 0:\n                    res -= self.prefix_sum(start - 1)\n                return res\n\n        fenwick_trees = [FenwickTree(n) for _ in range(limit)]\n            \n        cache = {1: 0}\n        def popcount(x):\n            count = 0\n            while x > 0:\n                x &= (x - 1)\n                count += 1\n            return count\n\n        def get_depth(x):\n            if x in cache:\n                return cache[x]\n            depth = 1 + get_depth(popcount(x))\n            cache[x] = depth\n            return depth\n\n        curr = [0] * n\n        for i, num in enumerate(nums):\n            depth = get_depth(num)\n            curr[i] = depth\n            if depth < limit:\n                fenwick_trees[depth].add(i, 1)\n\n        res = []\n        for q in queries:\n            t = q[0]\n            if t == 1:\n                _, l, r, k = q\n                if 0 <= k < limit:\n                    count = fenwick_trees[k].query(l, r)\n                    res.append(count)\n                else:\n                    res.append(0)\n\n            elif t == 2:\n                _, i, v = q\n                prev = curr[i]\n                if prev < limit:\n                    fenwick_trees[prev].add(i, -1)\n\n                nums[i] = v\n                ndepth = get_depth(v)\n                curr[i] = ndepth\n\n                if ndepth <limit:\n                    fenwick_trees[ndepth].add(i, 1)\n\n\n        return res\n                \n            ",
    "lang": "python3",
    "question_id": 3941,
    "contest_submission": 25263178
  }
]