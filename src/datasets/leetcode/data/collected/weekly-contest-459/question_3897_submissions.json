[
  {
    "submission_id": 1704200782,
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nfrom math import gcd\nfrom collections import defaultdict\n\nclass Solution:\n    def countTrapezoids(self, p: List[List[int]]) -> int:\n        n = len(p)\n        l, m = {}, defaultdict(list)\n        for i in range(n):\n            x1, y1 = p[i]\n            for j in range(i + 1, n):\n                x2, y2 = p[j]\n                dx0, dy0 = x2 - x1, y2 - y1\n                if dx0 == 0:\n                    s, a, b = (1, 0), 1, 0\n                elif dy0 == 0:\n                    s, a, b = (0, 1), 0, 1\n                else:\n                    g = gcd(dx0, dy0)\n                    dx, dy = dx0 // g, dy0 // g\n                    if dx < 0:\n                        dx, dy = -dx, -dy\n                    s, a, b = (dy, dx), dy, dx\n                c = a * x1 - b * y1\n                key = (s, c)\n                l[key] = l.get(key, 0) | (1 << i) | (1 << j)\n                m[(x1 + x2, y1 + y2)].append((i, j, dx0, dy0))\n\n        sm = defaultdict(list)\n        for (s, _), bits in l.items():\n            cnt = bits.bit_count()\n            if cnt > 1:\n                sm[s].append(cnt)\n\n        ans = 0\n        for vals in sm.values():\n            t = sum(k * (k - 1) // 2 for k in vals)\n            u = sum((k * (k - 1) // 2) ** 2 for k in vals)\n            ans += (t * t - u) // 2\n\n        res = 0\n        for lst in m.values():\n            ln = len(lst)\n            for a in range(ln):\n                i1, j1, dx1, dy1 = lst[a]\n                for b in range(a + 1, ln):\n                    i2, j2, dx2, dy2 = lst[b]\n                    if {i1, j1} & {i2, j2}:\n                        continue\n                    if dx1 * dy2 == dy1 * dx2:\n                        continue\n                    res += 1\n\n        return ans - res\n        ",
    "lang": "python3",
    "question_id": 3897,
    "contest_submission": 25248926
  },
  {
    "submission_id": 1704212080,
    "code": "from collections import defaultdict\n\ndef g(a, b): return abs(a) if b == 0 else g(b, a % b)\n\nclass Solution:\n    def countTrapezoids(z, p):\n        n = len(p); sc = defaultdict(int); lc = defaultdict(lambda:defaultdict(int)); mc = defaultdict(int); msc = defaultdict(lambda:defaultdict(int))\n        for i in range(n):\n            a = p[i]\n            for j in range(i+1, n):\n                b = p[j]; dx = b[0]-a[0]; dy = b[1]-a[1]\n                if dx == 0: dy=1; dx=0\n                elif dy == 0: dy=0; dx=1\n                else:\n                    if dx < 0: dx,dy = -dx,-dy\n                    k = g(abs(dy), abs(dx))\n                    dy//=k; dx//=k\n                s1 = (dy,dx)\n                if dx == 0: lk = (dy,dx,a[0],1)\n                else:\n                    bn=a[1]*dx-a[0]*dy; bd=dx; k2=g(abs(bn),bd); bn//=k2; bd//=k2\n                    if bd<0: bd=-bd; bn=-bn\n                    lk=(dy,dx,bn,bd)\n                m=(a[0]+b[0],a[1]+b[1])\n                sc[s1]+=1; lc[s1][lk]+=1; mc[m]+=1; msc[m][s1]+=1\n        ks = sum(sc.values()); ks2 = sum(v*v for v in sc.values())\n        t1 = (ks2-ks)//2\n        ls = sum(q for d in lc.values() for q in d.values())\n        ls2 = sum(q*q for d in lc.values() for q in d.values())\n        t2 = (ls2-ls)//2\n        tp = t1-t2\n        pr = 0\n        for m in mc:\n            M = mc[m]; sq=0\n            for c in msc[m].values(): sq += c*c\n            pr += (M*M - sq)//2\n        return tp - pr\n",
    "lang": "python3",
    "question_id": 3897,
    "contest_submission": 25257504
  },
  {
    "submission_id": 1704207616,
    "code": "class DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n    \n    def find(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n        \n    def union(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            self.parent[root_i] = root_j\n\nclass Solution:\n    def countTrapezoids(self, points: List[List[int]]) -> int:\n\n        def get_slope(p1, p2):\n            dx = p2[0] - p1[0]\n            dy = p2[1] - p1[1]\n            if dx == 0: return (1, 0)\n            if dy == 0: return (0, 1)\n            GCD = gcd(dy, dx)\n            dy //= GCD\n            dx //= GCD\n\n            if dx < 0:\n                dx = -dx\n                dy *= -1\n\n            return (dy, dx)\n            \n        n = len(points)\n        slopes = defaultdict(list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                s = get_slope(points[i], points[j])\n                slopes[s].append((i, j))\n\n        total = 0\n        for s in slopes:\n            pairs = slopes[s]\n            if len(pairs) < 2: continue\n            dsu = DSU(n)\n            x = set()\n            for i, j in pairs:\n                dsu.union(i, j)\n                x.add(i)\n                x.add(j)\n\n            comps = defaultdict(int)\n            for i in x:\n                root =dsu.find(i)\n                comps[root] += 1\n\n            if len(comps) < 2:\n                continue\n\n            segs = []\n            for root in comps:\n                size = comps[root]\n                if size >= 2:\n                    segs.append(size * (size - 1) // 2)\n\n            k = sum(segs)\n            summ = sum(x * x for x in segs)\n\n            total += (k ** 2 - summ) // 2\n\n        mm = defaultdict(list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                ms = (points[i][0] + points[j][0], points[i][1] + points[j][1])\n                mm[ms].append((i, j))\n\n        count = 0\n        for ms in mm:\n            pairs = mm[ms]\n            k = len(pairs)\n            if k < 2:\n                continue\n            groups = defaultdict(int)\n            for i, j in pairs:\n                s = get_slope(points[i], points[j])\n                groups[s] += 1\n\n            x = k * (k - 1) // 2\n            d = 0\n            for s in groups:\n                cnt = groups[s]\n                d += cnt * (cnt - 1) // 2\n            count += x - d\n\n        return total - count\n\n\n\n        ",
    "lang": "python3",
    "question_id": 3897,
    "contest_submission": 25254112
  }
]