[
  {
    "submission_id": 1612019119,
    "code": "class Solution:\n    def resultArray(self, nums: List[int], k: int, queries: List[List[int]]) -> List[int]:\n        def range_query(left, right):\n            left_prod, right_prod = 1, 1\n            left_counts = [0] * k\n            right_counts = [0] * k\n            l, r = left + seg_size, right + seg_size\n\n            while l < r:\n                if l & 1:\n                    merged = [0] * k\n                    for i in range(k):\n                        merged[i] += left_counts[i]\n                    for i in range(k):\n                        if tree_counts[l][i]:\n                            merged[(left_prod * i) % k] += tree_counts[l][i]\n                    left_prod = (left_prod * tree_product[l]) % k\n                    left_counts = merged\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    merged = [0] * k\n                    for i in range(k):\n                        merged[i] += tree_counts[r][i]\n                    for i in range(k):\n                        if right_counts[i]:\n                            merged[(tree_product[r] * i) % k] += right_counts[i]\n                    right_prod = (tree_product[r] * right_prod) % k\n                    right_counts = merged\n                l //= 2\n                r //= 2\n\n            total_product = (left_prod * right_prod) % k\n            result = [0] * k\n            for i in range(k):\n                result[i] += left_counts[i]\n            for i in range(k):\n                if right_counts[i]:\n                    result[(left_prod * i) % k] += right_counts[i]\n            return total_product, result\n        \n        original_state = (nums.copy(), k, [q[:] for q in queries])\n\n        n = len(nums)\n        seg_size = 1\n        while seg_size < n: \n            seg_size <<= 1\n\n        tree_product = [1] * (2 * seg_size)\n        tree_counts = [[0] * k for _ in range(2 * seg_size)]\n\n        for i in range(n):\n            mod_val = nums[i] % k\n            tree_product[seg_size + i] = mod_val\n            tree_counts[seg_size + i][mod_val] = 1\n\n        for i in range(seg_size - 1, 0, -1):\n            left_prod, right_prod = tree_product[2 * i], tree_product[2 * i + 1]\n            tree_product[i] = (left_prod * right_prod) % k\n            merged = [0] * k\n            for j in range(k):\n                merged[j] += tree_counts[2 * i][j]\n            for j in range(k):\n                if tree_counts[2 * i + 1][j]:\n                    new_mod = (left_prod * j) % k\n                    merged[new_mod] += tree_counts[2 * i + 1][j]\n            tree_counts[i] = merged\n            \n        \n\n        def update(index, value):\n            pos = seg_size + index\n            mod_val = value % k\n            tree_product[pos] = mod_val\n            tree_counts[pos] = [0] * k\n            tree_counts[pos][mod_val] = 1\n\n            pos //= 2\n            while pos:\n                left_prod, right_prod = tree_product[2 * pos], tree_product[2 * pos + 1]\n                tree_product[pos] = (left_prod * right_prod) % k\n                merged = [0] * k\n                for j in range(k):\n                    merged[j] += tree_counts[2 * pos][j]\n                for j in range(k):\n                    if tree_counts[2 * pos + 1][j]:\n                        new_mod = (left_prod * j) % k\n                        merged[new_mod] += tree_counts[2 * pos + 1][j]\n                tree_counts[pos] = merged\n                pos //= 2\n                \n        \n\n        answers = []\n        for idx, val, l, target_mod in queries:\n            update(idx, val)\n            _, mod_counts = range_query(l, n)\n            answers.append(mod_counts[target_mod])\n        return answers\n\n\n        ",
    "lang": "python3",
    "question_id": 3840,
    "contest_submission": 23737479
  },
  {
    "submission_id": 1612008963,
    "code": "class SegTree:\n    def __init__(self, arr, k):\n        self.n = len(arr)\n        self.k = k\n        self.size = 1\n        while self.size < self.n:\n            self.size <<= 1\n        self.tree = [None] * (2 * self.size)\n        for i in range(self.size):\n            if i < self.n:\n                tot = arr[i] % k\n                freq = [0] * k\n                freq[tot] = 1\n                self.tree[self.size + i] = (tot, freq)\n            else:\n                self.tree[self.size + i] = (1, [0] * k)\n        for i in range(self.size - 1, 0, -1):\n            self.tree[i] = self._merge(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def _merge(self, left, right):\n        tot = (left[0] * right[0]) % self.k\n        freq = [0] * self.k\n        for i in range(self.k):\n            freq[i] += left[1][i]\n        for j in range(self.k):\n            freq[(left[0] * j) % self.k] += right[1][j]\n        return (tot, freq)\n\n    def update(self, pos, val):\n        p = pos + self.size\n        tot = val % self.k\n        freq = [0] * self.k\n        freq[tot] = 1\n        self.tree[p] = (tot, freq)\n        p //= 2\n        while p:\n            self.tree[p] = self._merge(self.tree[2 * p], self.tree[2 * p + 1])\n            p //= 2\n\n    def query(self, l, r):\n        resl = (1, [0] * self.k)\n        resr = (1, [0] * self.k)\n        l += self.size\n        r += self.size\n        while l < r:\n            if l & 1:\n                resl = self._merge(resl, self.tree[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                resr = self._merge(self.tree[r], resr)\n            l //= 2\n            r //= 2\n        res = self._merge(resl, resr)\n        return res[1]\n\n\nclass Solution:\n    def resultArray(self, nums: List[int], k: int, queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        seg = SegTree(nums, k)\n        res = []\n        for i, v, l, x in queries:\n            seg.update(i, v)\n            res.append(seg.query(l, n)[x])\n        return res",
    "lang": "python3",
    "question_id": 3840,
    "contest_submission": 23729526
  },
  {
    "submission_id": 1612023624,
    "code": "class Solution:\n    def resultArray(self, nums: List[int], k: int, queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        tree = [None] * (4 * n)\n        \n        def merge(leftNode, rightNode):\n            leftProd, leftHist = leftNode\n            rightProd, rightHist = rightNode\n            totalProd = (leftProd * rightProd) % k\n            newHist = [0] * k\n            for v in range(k):\n                newHist[v] += leftHist[v]\n            for u in range(k):\n                v = (leftProd * u) % k\n                newHist[v] += rightHist[u]\n            return (totalProd, newHist)\n        \n        def build(node, l, r):\n            if l == r:\n                prod = nums[l] % k\n                hist = [0] * k\n                hist[prod] = 1\n                tree[node] = (prod, hist)\n            else:\n                m = (l + r) // 2\n                build(node*2, l, m)\n                build(node*2+1, m+1, r)\n                tree[node] = merge(tree[node*2], tree[node*2+1])\n        \n        def update(node, l, r, idx, val):\n            if l == r:\n                prod = val % k\n                hist = [0] * k\n                hist[prod] = 1\n                tree[node] = (prod, hist)\n            else:\n                m = (l + r) // 2\n                if idx <= m:\n                    update(node*2, l, m, idx, val)\n                else:\n                    update(node*2+1, m+1, r, idx, val)\n                tree[node] = merge(tree[node*2], tree[node*2+1])\n        \n        def query(node, l, r, ql, qr):\n            if ql > r or qr < l:\n                return (1, [0] * k)\n            if ql <= l and r <= qr:\n                return tree[node]\n            m = (l + r) // 2\n            leftRes = query(node*2, l, m, ql, qr)\n            rightRes = query(node*2+1, m+1, r, ql, qr)\n            return merge(leftRes, rightRes)\n        \n        build(1, 0, n-1)\n        result = []\n        for idx, val, start, x in queries:\n            update(1, 0, n-1, idx, val)\n            _, hist = query(1, 0, n-1, start, n-1)\n            result.append(hist[x])\n        return result",
    "lang": "python3",
    "question_id": 3840,
    "contest_submission": 23740906
  }
]