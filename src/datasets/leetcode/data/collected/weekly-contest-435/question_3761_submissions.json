[
  {
    "submission_id": 1528104807,
    "code": "from bisect import bisect_left\nclass Solution:\n    def maxDifference(self, s: str, k: int) -> int:\n        INF = 10**9\n        n = len(s)\n        ans = -10**9\n        for x in range(5):\n            for y in range(5):\n                if x == y:\n                    continue\n                N = n + 1\n                D = [0] * N\n                PX = [0] * N\n                PY = [0] * N\n                CNT = [0] * N\n                sx = str(x)\n                sy = str(y)\n                for i in range(n):\n                    D[i+1] = D[i] + (1 if s[i] == sx else 0) - (1 if s[i] == sy else 0)\n                    PX[i+1] = (PX[i] + (1 if s[i] == sx else 0)) & 1\n                    PY[i+1] = (PY[i] + (1 if s[i] == sy else 0)) & 1\n                    CNT[i+1] = CNT[i] + (1 if s[i] == sy else 0)\n                mp = {(0,0): [], (0,1): [], (1,0): [], (1,1): []}\n                cum = {(0,0): [], (0,1): [], (1,0): [], (1,1): []}\n                key0 = (PX[0], PY[0])\n                mp[key0].append((CNT[0], D[0]))\n                cum[key0].append(D[0])\n                best = -10**9\n                p = 1\n                for r in range(k, N):\n                    while p <= r - k:\n                        key = (PX[p], PY[p])\n                        mp[key].append((CNT[p], D[p]))\n                        if cum[key]:\n                            cum[key].append(min(cum[key][-1], D[p]))\n                        else:\n                            cum[key].append(D[p])\n                        p += 1\n                    keyq = (1 - PX[r], PY[r])\n                    arr = mp[keyq]\n                    if not arr:\n                        continue\n                    pos = bisect_left(arr, (CNT[r], -10**9))\n                    if pos:\n                        cand = D[r] - cum[keyq][pos-1]\n                        if cand > best:\n                            best = cand\n                if best > ans:\n                    ans = best\n        return ans\n\n",
    "lang": "python3",
    "question_id": 3761,
    "contest_submission": 22358207
  },
  {
    "submission_id": 1528121935,
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    class Fenw:\n        def __init__(self, n):\n            self.n = n\n            self.INF = 10**9\n            self.fenw = [self.INF] * (n + 1)\n\n        def update(self, idx, val):\n            while idx <= self.n:\n                self.fenw[idx] = min(self.fenw[idx], val)\n                idx += idx & -idx\n\n        def query(self, idx):\n            ret = self.INF\n            while idx > 0:\n                ret = min(ret, self.fenw[idx])\n                idx -= idx & -idx\n            return ret\n\n    def maxDifference(self, s: str, k: int) -> int:\n        n = len(s)\n        INF = 10**9\n        pref = [[0]*5 for i in range(n+1)]\n        for i in range(n):\n            for d in range(5):\n                pref[i+1][d] = pref[i][d]\n            dig = int(s[i]) \n            pref[i+1][dig] += 1\n        \n        ans = -INF\n        \n        for a in range(5):\n            for b in range(5):\n                if a == b:\n                    continue\n\n                fenw = [[self.Fenw(n + 1) for i in range(2)] for j in range(2)]\n                \n                for j in range(k, n + 1):\n                    ind = j - k\n                    par1 = pref[ind][a] & 1\n                    par2 = pref[ind][b] & 1\n                    key = pref[ind][b] + 1\n                    val = pref[ind][a] - pref[ind][b]\n                    \n                    fenw[par1][par2].update(key, val)\n                    \n                    cur1 = pref[j][a]\n                    cur2 = pref[j][b]\n                    \n                    if cur2 == 0:\n                        continue\n                    rpar1 = (cur1 & 1) ^ 1\n                    rpar2 = (cur2 & 1)\n                    cand = fenw[rpar1][rpar2].query(cur2)\n                    if cand == INF:\n                        continue\n                    ans = max(ans, (cur1 - cur2) - cand)\n        \n        return ans\n",
    "lang": "python3",
    "question_id": 3761,
    "contest_submission": 22369934
  },
  {
    "submission_id": 1528137393,
    "code": "def build_prefix_arrays(s: str, a: int, b: int, n: int) -> tuple:\n    F = [0] * (n + 1)\n    Ca = [0] * (n + 1)\n    Cb = [0] * (n + 1)\n    for i in range(n):\n        dig = int(s[i])\n        delta = 1 if dig == a else (-1 if dig == b else 0)\n        F[i + 1] = F[i] + delta\n        Ca[i + 1] = Ca[i] + (1 if dig == a else 0)\n        Cb[i + 1] = Cb[i] + (1 if dig == b else 0)\n    return F, Ca, Cb\n\ndef build_best_arr(F: list, Ca: list, Cb: list, n: int, INF: float) -> list:\n    best_arr = [[[INF] * (n + 1) for _ in range(2)] for _ in range(2)]\n    pb0 = Cb[0] & 1\n    pa0 = Ca[0] & 1\n    best_arr[pa0][pb0][0] = F[0]\n    for i in range(1, n + 1):\n        pb = Cb[i] & 1\n        pa = Ca[i] & 1\n        for u in range(2):\n            for t in range(2):\n                best_arr[t][u][i] = best_arr[t][u][i - 1]\n        best_arr[pa][pb][i] = min(best_arr[pa][pb][i], F[i])\n    return best_arr\n\ndef find_largest_index(prefix: list, target: int, j: int) -> int:\n    index = -1\n    lo, hi = 0, j\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if prefix[mid] <= target:\n            index = mid\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return index\n\nclass Solution:\n    def maxDifference(self, s: str, k: int) -> int:\n        INF = float('inf')\n        n = len(s)\n        ans = -INF\n        fnd = False\n        for a in range(5):\n            for b in range(5):\n                if a == b:\n                    continue\n                F, Ca, Cb = build_prefix_arrays(s, a, b, n)\n                best_arr = build_best_arr(F, Ca, Cb, n, INF)\n                for j in range(k, n + 1):\n                    if Ca[j] == 0 or Cb[j] == 0:\n                        continue\n                    X3 = find_largest_index(Cb, Cb[j] - 1, j)\n                    X2 = find_largest_index(Ca, Ca[j] - 1, j)\n                    X1 = j - k\n                    X = min(X1, X2, X3)\n                    if X < 0:\n                        continue\n                    reqB = (Cb[j] & 1)\n                    reqA = (1 - (Ca[j] & 1)) & 1\n                    candidate = best_arr[reqA][reqB][X]\n                    if candidate == INF:\n                        continue\n                    diff = F[j] - candidate\n                    fnd = True\n                    ans = max(ans, diff)\n        if not fnd:\n            return -1\n        return ans",
    "lang": "python3",
    "question_id": 3761,
    "contest_submission": 22379866
  }
]