[
  {
    "submission_id": 1712757211,
    "code": "from collections import defaultdict, deque\n\nclass Solution:\n    def minJumps(self, nums: list[int]) -> int:\n        def factors(x):\n            res = []\n            while x > 1:\n                p = smallestPrimeFact[x]\n                res.append(p)\n                while x % p == 0:\n                    x //= p\n            return list(dict.fromkeys(res))\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        maxi = max(nums)\n        \n        smallestPrimeFact = list(range(maxi + 1))\n        \n        for i in range(2, int(maxi**0.5) + 1):\n            \n            if smallestPrimeFact[i] == i:\n                step = i\n                s = i **2\n                \n                for j in range(s, maxi + 1, step):\n                    \n                    if smallestPrimeFact[j] == j:\n                        smallestPrimeFact[j] = i\n        \n        mapPrime = defaultdict(list)\n        \n        for i, v in enumerate(nums):\n            \n            if v >= 2:\n                for p in factors(v):\n                    mapPrime[p].append(i)\n        \n        visited = [False] * n\n        used = set()\n        queue = deque([0])\n        visited[0] = True\n        cnt = 0\n        \n        while queue:\n            \n            for _ in range(len(queue)):\n                i = queue.popleft()\n                \n                if i == n - 1:\n                    return cnt\n                v = nums[i]\n                \n                if v >= 2 and smallestPrimeFact[v] == v and v not in used:\n                    for j in mapPrime.get(v, []):\n                        if not visited[j]:\n                            visited[j] = True\n                            queue.append(j)\n                    used.add(v)\n                \n                if i + 1 < n and not visited[i + 1]:\n                    visited[i + 1] = True\n                    queue.append(i + 1)\n                \n                if i - 1 >= 0 and not visited[i - 1]:\n                    visited[i - 1] = True\n                    queue.append(i - 1)\n            \n            cnt += 1\n        return -1",
    "lang": "python3",
    "question_id": 3933,
    "contest_submission": 25340418
  },
  {
    "submission_id": 1712780859,
    "code": "class Solution:\n    def minJumps(self, nums):\n\n        n = len(nums)\n        mx = max(nums)\n        sieve = [0] * (mx + 1)\n        factors_map = defaultdict(list)\n        q = deque()\n        visited = [0] * n\n        used_prime = set()\n        add_to_q = lambda idx, dist: q.append((idx, dist))\n\n        i, j = 2, 0\n        while i <= mx:\n            if sieve[i] == 0:\n                j = i\n                while j <= mx:\n                    if sieve[j] == 0:\n                        sieve[j] = i\n                    j += i\n            i += 1\n\n        # Map each prime factor to indices\n        for idx, val in enumerate(nums):\n            val_cp = val\n            unique_primes = set()\n            while val_cp > 1:\n                unique_primes.add(sieve[val_cp])\n                val_cp //= sieve[val_cp]\n            for p in unique_primes:\n                factors_map[p].append(idx)\n\n        # BFS time\n        q.append((0, 0))\n        visited[0] = 1\n        while q:\n            curr_idx, dist = q.popleft()\n            if curr_idx == n - 1:\n                return dist\n            for nxt in (curr_idx - 1, curr_idx + 1):\n                if 0 <= nxt < n and not visited[nxt]:\n                    visited[nxt] = 1\n                    add_to_q(nxt, dist + 1)\n            curr_val = nums[curr_idx]\n            if curr_val > 1 and sieve[curr_val] == curr_val and curr_val not in used_prime:\n                for linked_idx in factors_map[curr_val]:\n                    if not visited[linked_idx]:\n                        visited[linked_idx] = 1\n                        add_to_q(linked_idx, dist + 1)\n                used_prime.add(curr_val)\n        return -1\n",
    "lang": "python3",
    "question_id": 3933,
    "contest_submission": 25357702
  },
  {
    "submission_id": 1712748830,
    "code": "class Solution:\n    def minJumps(self, a: List[int]) -> int:\n        n=len(a)\n        if n<2: return 0\n        M=max(a)\n        spf=list(range(M+1))\n        for i in range(2,int(M**0.5)+1):\n            if spf[i]==i:\n                for j in range(i*i,M+1,i):\n                    if spf[j]==j: spf[j]=i\n        mp={}\n        for i,v in enumerate(a):\n            x=v; st=set()\n            while x>1:\n                p=spf[x]; st.add(p)\n                while x%p==0: x//=p\n            for p in st: mp.setdefault(p,[]).append(i)\n        \n        ds=[-1]*n; ds[0]=0\n        dq=deque([0])\n        while dq:\n            i=dq.popleft(); d=ds[i]\n            if i==n-1: return d\n            for j in (i-1,i+1):\n                if 0<=j<n and ds[j]<0:\n                    ds[j]=d+1; dq.append(j)\n            v=a[i]\n            if v>1 and spf[v]==v and v in mp:\n                for j in mp[v]:\n                    if ds[j]<0:\n                        ds[j]=d+1; dq.append(j)\n                del mp[v]\n                \n        return -1",
    "lang": "python3",
    "question_id": 3933,
    "contest_submission": 25334114
  }
]