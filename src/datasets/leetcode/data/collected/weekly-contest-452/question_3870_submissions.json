[
  {
    "submission_id": 1650244035,
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nclass Solution:\n    def minMoves(self, classroom: List[str], energy: int) -> int:\n        grid = classroom\n        m, n = len(grid), len(grid[0])\n        dr = (-1, 1, 0, 0)\n        dc = (0, 0, -1, 1)\n\n        ls = []\n        idx = [[-1]*n for _ in range(m)]\n        sr = sc = -1\n\n        for i in range(m):\n            for j in range(n):\n                c = grid[i][j]\n                if c == 'S':\n                    sr, sc = i, j\n                elif c == 'L':\n                    lid = len(ls)\n                    ls.append((i, j))\n                    idx[i][j] = lid\n\n        sz = len(ls)\n        if sz == 0:\n            return 0\n        msk = (1 << sz) - 1\n        msksz = 1 << sz\n\n        vis = [[[-1] * msksz for _ in range(n)] for __ in range(m)]\n        dq = deque()\n        vis[sr][sc][0] = energy\n        dq.append((sr, sc, 0, energy, 0))\n\n        while dq:\n            r, c, mask, rems, steps = dq.popleft()\n            for d in range(4):\n                nr, nc = r + dr[d], c + dc[d]\n                ne = rems - 1\n                if not (0 <= nr < m and 0 <= nc < n):\n                    continue\n                if grid[nr][nc] == 'X' or ne < 0:\n                    continue\n                if grid[nr][nc] == 'R':\n                    ne = energy\n                nmsk = mask\n                if grid[nr][nc] == 'L':\n                    lid = idx[nr][nc]\n                    nmsk = mask | (1 << lid)\n                if nmsk == msk:\n                    return steps + 1\n                if vis[nr][nc][nmsk] >= ne:\n                    continue\n                vis[nr][nc][nmsk] = ne\n                dq.append((nr, nc, nmsk, ne, steps + 1))\n\n        return -1\n",
    "lang": "python3",
    "question_id": 3870,
    "contest_submission": 24333546
  },
  {
    "submission_id": 1650270272,
    "code": "from collections import deque\n\nclass Solution:\n    def minMoves(self, classroom: List[str], energy: int) -> int:\n        m = len(classroom)\n        n = len(classroom[0])\n        startI = startJ = 0\n        litterMap = {}\n        idx = 0\n        for i in range(m):\n            for j in range(n):\n                c = classroom[i][j]\n                if c == 'S':\n                    startI, startJ = i, j\n                elif c == 'L':\n                    litterMap[(i, j)] = idx\n                    idx += 1\n        allMask = (1 << idx) - 1\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[[-1] * (1 << idx) for _ in range(n)] for __ in range(m)]\n        dq = deque()\n        visited[startI][startJ][0] = energy\n        dq.append((startI, startJ, 0, energy, 0))\n        while dq:\n            i, j, mask, e, moves = dq.popleft()\n            if mask == allMask:\n                return moves\n            for di, dj in dirs:\n                ni, nj = i + di, j + dj\n                if ni < 0 or ni >= m or nj < 0 or nj >= n:\n                    continue\n                cell = classroom[ni][nj]\n                if cell == 'X':\n                    continue\n                ne = e - 1\n                if ne < 0:\n                    continue\n                if cell == 'R':\n                    ne = energy\n                nm = mask\n                if cell == 'L':\n                    nm = mask | (1 << litterMap[(ni, nj)])\n                if visited[ni][nj][nm] >= ne:\n                    continue\n                visited[ni][nj][nm] = ne\n                dq.append((ni, nj, nm, ne, moves + 1))\n        return -1",
    "lang": "python3",
    "question_id": 3870,
    "contest_submission": 24352370
  },
  {
    "submission_id": 1650235495,
    "code": "class Solution:\n    def minMoves(self, classroom: List[str], energy: int) -> int:\n        graph = classroom\n        _m = {}\n\n        m = len(classroom)\n        n = len(classroom[0])\n\n        DIRS = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        k = 0\n        for i in range(m):\n            for j in range(n):\n                if graph[i][j] == \"S\":\n                    _x, _y = i, j\n                elif graph[i][j] == \"L\":\n                    _m[i, j] = k\n                    k += 1\n\n        target = (1 << k) - 1\n        if target == 0:\n            return 0\n\n        dp = [[[-1] * (1 << k) for _ in range(n)] for _ in range(m)]\n        q = [(0, _x, _y, energy, 0)]\n\n        while q:\n            d, x, y, e, mask = heapq.heappop(q)\n            if mask == target:\n                return d\n\n            if dp[x][y][mask] >= e:\n                continue\n            dp[x][y][mask] = e\n\n            for dx, dy in DIRS:\n                nx = x + dx\n                ny = y + dy\n                if 0 <= nx < m and 0 <= ny < n:\n                    if graph[nx][ny] != \"X\":\n                        v = e - 1\n                        if v < 0:\n                            continue\n\n                        _mask = mask\n\n                        if graph[nx][ny] == \"R\":\n                            v = energy\n                        elif graph[nx][ny] == \"L\":\n                            _mask |= 1 << _m[nx, ny]\n                        # print(f\"seen  ({nx}, {ny}) with energy {v} and mask {_mask:0{len(_m)}b}\")\n                        if dp[nx][ny][_mask] < v:\n                            heapq.heappush(q, (d + 1, nx, ny, v, _mask))\n        return -1\n",
    "lang": "python3",
    "question_id": 3870,
    "contest_submission": 24327035
  }
]