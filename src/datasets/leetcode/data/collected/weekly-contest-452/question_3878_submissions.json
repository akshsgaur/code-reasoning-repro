[
  {
    "submission_id": 1650238669,
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nimport bisect\n\nclass Solution:\n    def maximumCount(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        N = n - 1\n        maxv = 0\n        for v in nums:\n            if v > maxv:\n                maxv = v\n        for _, v in queries:\n            if v > maxv:\n                maxv = v\n        isprime = [True] * (maxv + 1)\n        if maxv >= 0:\n            isprime[0] = False\n        if maxv >= 1:\n            isprime[1] = False\n        p = 2\n        while p * p <= maxv:\n            if isprime[p]:\n                for j in range(p * p, maxv + 1, p):\n                    isprime[j] = False\n            p += 1\n        pos = {}\n        for i, v in enumerate(nums):\n            if v <= maxv and isprime[v]:\n                pos.setdefault(v, []).append(i)\n        diff = [0] * (N + 2)\n        for p, lst in pos.items():\n            L = lst[0]\n            R = lst[-1]\n            start = L + 1\n            if start <= N:\n                diff[start] += 1\n                diff[N + 1] -= 1\n            end = R if R <= N else N\n            if end >= 1:\n                diff[1] += 1\n                diff[end + 1] -= 1\n        f = [0] * (N + 1)\n        if N >= 1:\n            f[1] = diff[1]\n            for k in range(2, N + 1):\n                f[k] = f[k - 1] + diff[k]\n        st = [0] * (4 * (N + 1))\n        lz = [0] * (4 * (N + 1))\n        def build(node, l, r):\n            if l == r:\n                st[node] = f[l]\n                return\n            mid = (l + r) >> 1\n            build(node << 1, l, mid)\n            build(node << 1 | 1, mid + 1, r)\n            st[node] = st[node << 1] if st[node << 1] > st[node << 1 | 1] else st[node << 1 | 1]\n        def apply(node, val):\n            st[node] += val\n            lz[node] += val\n        def push(node):\n            v = lz[node]\n            if v:\n                apply(node << 1, v)\n                apply(node << 1 | 1, v)\n                lz[node] = 0\n        def update(node, l, r, ql, qr, val):\n            if ql > r or qr < l:\n                return\n            if ql <= l and r <= qr:\n                apply(node, val)\n                return\n            push(node)\n            mid = (l + r) >> 1\n            update(node << 1, l, mid, ql, qr, val)\n            update(node << 1 | 1, mid + 1, r, ql, qr, val)\n            st[node] = st[node << 1] if st[node << 1] > st[node << 1 | 1] else st[node << 1 | 1]\n        if N >= 1:\n            build(1, 1, N)\n        ans = []\n        for idx, nval in queries:\n            valo = nums[idx]\n            if valo <= maxv and isprime[valo]:\n                lst = pos[valo]\n                lx = lst[0]\n                rx = lst[-1]\n                i = bisect.bisect_left(lst, idx)\n                lst.pop(i)\n                if not lst:\n                    lp = lx + 1\n                    if lp <= N:\n                        update(1, 1, N, lp, N, -1)\n                    end = rx if rx <= N else N\n                    if end >= 1:\n                        update(1, 1, N, 1, end, -1)\n                    del pos[valo]\n                else:\n                    lp = lst[0]\n                    rp = lst[-1]\n                    if idx == lx:\n                        left = lx + 1\n                        right = lp\n                        if left <= right and left <= N:\n                            update(1, 1, N, left, right if right <= N else N, -1)\n                    if idx == rx:\n                        left = rp + 1\n                        right = rx\n                        if left <= right and left <= N:\n                            update(1, 1, N, left, right if right <= N else N, -1)\n            nums[idx] = nval\n            if nval <= maxv and isprime[nval]:\n                lst = pos.get(nval)\n                if lst is None:\n                    pos[nval] = [idx]\n                    start = idx + 1\n                    if start <= N:\n                        update(1, 1, N, start, N, 1)\n                    end = idx if idx <= N else N\n                    if end >= 1:\n                        update(1, 1, N, 1, end, 1)\n                else:\n                    lx = lst[0]\n                    rx = lst[-1]\n                    bisect.insort(lst, idx)\n                    lp = lst[0]\n                    rp = lst[-1]\n                    if idx < lx:\n                        left = idx + 1\n                        right = lx\n                        if left <= right and left <= N:\n                            update(1, 1, N, left, right if right <= N else N, 1)\n                    if idx > rx:\n                        left = rx + 1\n                        right = idx\n                        if left <= right and left <= N:\n                            update(1, 1, N, left, right if right <= N else N, 1)\n            best = st[1] if N >= 1 else 0\n            ans.append(best)\n        return ans\n",
    "lang": "python3",
    "question_id": 3878,
    "contest_submission": 24329505
  },
  {
    "submission_id": 1650263361,
    "code": "import bisect\n\nclass SegmentTree:\n    def __init__(self, n):\n        size = 1\n        while size < n:\n            size <<= 1\n        self.n = size\n        self.tree = [0] * (2 * size)\n        self.lazy = [0] * (2 * size)\n\n    def _apply(self, x, val, length):\n        self.tree[x] += val\n        self.lazy[x] += val\n\n    def _push(self, x):\n        if self.lazy[x] != 0:\n            self._apply(x * 2, self.lazy[x], 0)\n            self._apply(x * 2 + 1, self.lazy[x], 0)\n            self.lazy[x] = 0\n\n    def _update(self, x, lx, rx, l, r, val):\n        if l > rx or r < lx:\n            return\n        if l <= lx and rx <= r:\n            self._apply(x, val, rx - lx + 1)\n            return\n        self._push(x)\n        m = (lx + rx) // 2\n        self._update(x * 2, lx, m, l, r, val)\n        self._update(x * 2 + 1, m + 1, rx, l, r, val)\n        self.tree[x] = max(self.tree[x * 2], self.tree[x * 2 + 1])\n\n    def rangeAdd(self, l, r, val):\n        if l > r:\n            return\n        self._update(1, 1, self.n, l, r, val)\n\n    def queryMax(self):\n        return self.tree[1]\n\nclass Solution:\n    def maximumCount(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        maxVal = 100000\n        isPrime = [True] * (maxVal + 1)\n        isPrime[0] = False\n        isPrime[1] = False\n        for i in range(2, int(maxVal ** 0.5) + 1):\n            if isPrime[i]:\n                for j in range(i * i, maxVal + 1, i):\n                    isPrime[j] = False\n\n        occ = {}\n        for i, v in enumerate(nums):\n            if isPrime[v]:\n                if v not in occ:\n                    occ[v] = []\n                occ[v].append(i)\n\n        for v in occ:\n            occ[v].sort()\n\n        seg = SegmentTree(n)\n        totP = 0\n        for v, lst in occ.items():\n            totP += 1\n            i1 = lst[0]\n            im = lst[-1]\n            l = i1 + 1\n            r = im\n            if l <= r:\n                seg.rangeAdd(l + 1 - 1, r + 1 - 1, 1)\n\n        res = []\n        for idx, val in queries:\n            old = nums[idx]\n            if old != val:\n                if isPrime[old]:\n                    lst = occ[old]\n                    i = bisect.bisect_left(lst, idx)\n                    oldI1 = lst[0]\n                    oldIm = lst[-1]\n                    l = oldI1 + 1\n                    r = oldIm\n                    if l <= r:\n                        seg.rangeAdd(l, r, -1)\n                    lst.pop(i)\n                    if lst:\n                        newI1 = lst[0]\n                        newIm = lst[-1]\n                        l2 = newI1 + 1\n                        r2 = newIm\n                        if l2 <= r2:\n                            seg.rangeAdd(l2, r2, 1)\n                    else:\n                        totP -= 1\n                        del occ[old]\n                if isPrime[val]:\n                    if val in occ:\n                        lst2 = occ[val]\n                        oldI1 = lst2[0]\n                        oldIm = lst2[-1]\n                        l = oldI1 + 1\n                        r = oldIm\n                        if l <= r:\n                            seg.rangeAdd(l, r, -1)\n                        bisect.insort(lst2, idx)\n                        newI1 = lst2[0]\n                        newIm = lst2[-1]\n                        l2 = newI1 + 1\n                        r2 = newIm\n                        if l2 <= r2:\n                            seg.rangeAdd(l2, r2, 1)\n                    else:\n                        occ[val] = [idx]\n                        totP += 1\n                        l = idx + 1\n                        r = idx\n                        # no range add for single occurrence\n                nums[idx] = val\n\n            res.append(totP + seg.queryMax())\n        return res",
    "lang": "python3",
    "question_id": 3878,
    "contest_submission": 24347573
  },
  {
    "submission_id": 1650274450,
    "code": "LIM = 100000\n_L = int(LIM**0.5) + 1\n\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.ft = [0] * (n + 1)\n\n    def add(self, i, v):\n        while i <= self.n:\n            self.ft[i] += v\n            i += i & -i\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.ft[i]\n            i -= i & -i\n        return s\n\n\nclass DS:\n    def __init__(self):\n        self.s = set()\n        self.hmin = []\n        self.hmax = []\n\n\nclass Solution:\n    def maximumCount(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n\n        PS = [False, False] + [True] * LIM\n        for i in range(2, _L):\n            if PS[i]:\n                for j in range(i * i, LIM + 1, i):\n                    PS[j] = False\n\n        def gf(o):\n            h, s = o.hmin, o.s\n            while h and h[0] not in s:\n                heapq.heappop(h)\n            return h[0]\n\n        def gl(o):\n            h, s = o.hmax, o.s\n            while h and -h[0] not in s:\n                heapq.heappop(h)\n            return -h[0]\n\n        _map = {}\n        for i, v in enumerate(nums):\n            if v <= LIM and PS[v]:\n                if v not in _map:\n                    _map[v] = DS()\n                o = _map[v]\n                o.s.add(i)\n                heapq.heappush(o.hmin, i)\n                heapq.heappush(o.hmax, -i)\n\n        size = 1\n        while size < n + 1:\n            size <<= 1\n        mx = [0] * (2 * size)\n        lz = [0] * (2 * size)\n\n        def pull(p):\n            lc = p * 2\n            rc = lc + 1\n            mx[p] = mx[lc] if mx[lc] > mx[rc] else mx[rc]\n\n        def apply(p, v):\n            mx[p] += v\n            lz[p] += v\n\n        def push(p):\n            if lz[p]:\n                v = lz[p]\n                apply(p * 2, v)\n                apply(p * 2 + 1, v)\n                lz[p] = 0\n\n        def update(p, l, r, ql, qr, v):\n            if ql > r or qr < l:\n                return\n            if ql <= l and r <= qr:\n                apply(p, v)\n                return\n            push(p)\n            m = (l + r) >> 1\n            update(p * 2, l, m, ql, qr, v)\n            update(p * 2 + 1, m + 1, r, ql, qr, v)\n            pull(p)\n\n        for o in _map.values():\n            if len(o.s) >= 2:\n                f = gf(o)\n                l = f + 1\n                r = gl(o)\n                if l <= r:\n                    update(1, 1, n, l, r, 1)\n\n        P = len(_map)\n        ans = []\n\n        def rem(o):\n            f0 = gf(o)\n            l0 = f0 + 1\n            r0 = gl(o)\n            if l0 <= r0:\n                update(1, 1, n, l0, r0, -1)\n\n        def add(o):\n            f = gf(o)\n            l = f + 1\n            r = gl(o)\n            if l <= r:\n                update(1, 1, n, l, r, 1)\n\n        for i, v in queries:\n            prev_val = nums[i]\n            if prev_val == v:\n                ans.append(P + max(mx[1], 0))\n                continue\n\n            if prev_val <= LIM and PS[prev_val] and prev_val in _map:\n                o = _map[prev_val]\n                c = len(o.s)\n                if c >= 2:\n                    rem(o)\n                o.s.remove(i)\n                if c == 1:\n                    del _map[prev_val]\n                    P -= 1\n                elif c - 1 >= 2:\n                    add(o)\n\n            if v <= LIM and PS[v]:\n                if v not in _map:\n                    _map[v] = DS()\n                    o = _map[v]\n                    c = 0\n                    P += 1\n                else:\n                    o = _map[v]\n                    c = len(o.s)\n                if c >= 2:\n                    rem(o)\n                o.s.add(i)\n                heapq.heappush(o.hmin, i)\n                heapq.heappush(o.hmax, -i)\n                if c + 1 >= 2:\n                    add(o)\n\n            nums[i] = v\n            ans.append(P + max(mx[1], 0))\n            # print(f\"  {i}, {v}: ans = {ans[-1]}, P = {P}, mx[1] = {mx[1]}\")\n\n        return ans\n",
    "lang": "python3",
    "question_id": 3878,
    "contest_submission": 24355271
  }
]