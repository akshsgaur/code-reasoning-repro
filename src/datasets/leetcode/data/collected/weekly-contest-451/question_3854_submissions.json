[
  {
    "submission_id": 1643590961,
    "code": "import collections\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, n: int, p: List[int], f: List[int], h: List[List[int]], b: int) -> int:\n        z = (n, p, f, h, b)\n        a = collections.defaultdict(list)\n        [a[u].append(v) for u, v in h]\n        m, o, s = {}, {}, [1]\n        while s:\n            u = s[-1]\n            if u in m: s.pop(); continue\n            if u not in o:\n                o[u] = 1\n                s += a[u]\n                continue\n            s.pop()\n            cb = cn = [0] + [-1e9]*b\n            for v in a[u]:\n                vb, vn = m[v]\n                nb = [-1e9]*(b+1)\n                for x in range(b+1):\n                    if cb[x] > -1e9:\n                        for y in range(b - x + 1):\n                            if vb[y] > -1e9:\n                                nb[x + y] = max(nb[x + y], cb[x] + vb[y])\n                cb = nb\n                nn = [-1e9]*(b+1)\n                for x in range(b+1):\n                    if cn[x] > -1e9:\n                        for y in range(b - x + 1):\n                            if vn[y] > -1e9: nn[x + y] = max(nn[x + y], cn[x] + vn[y])\n                cn = nn\n            f0 = cn[:]; f1 = cn[:]\n            c, pr = p[u - 1], f[u - 1]\n            if c <= b:\n                for x in range(b - c + 1):\n                    if cb[x] > -1e9: f1[x + c] = max(f1[x + c], cb[x] + pr - c)\n            c //= 2\n            if c <= b:\n                for x in range(b - c + 1):\n                    if cb[x] > -1e9: f0[x + c] = max(f0[x + c], cb[x] + pr - c)\n            m[u] = (f0, f1)\n        return max(max(m[1][1]), 0)\n",
    "lang": "python3",
    "question_id": 3854,
    "contest_submission": 24254195
  },
  {
    "submission_id": 1643598764,
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nimport sys\nsys.setrecursionlimit(10**7)\n\nclass Solution:\n    def maxProfit(self, n: int, present: List[int], future: List[int], hierarchy: List[List[int]], budget: int) -> int:\n\n        childs = [[] for _ in range(n)]\n        for u, v in hierarchy:\n            childs[u-1].append(v-1)\n\n        negg = -10**15\n        dp = [\n            [[negg] * (budget+1) for _ in range(2)]\n            for _ in range(n)\n        ]\n\n        def dfs(u: int) -> None:\n            for v in childs[u]:\n                dfs(v)\n\n            for eligible in (0, 1):\n                nb = [negg] * (budget+1)\n                nb[0] = 0\n                for v in childs[u]:\n                    nxt = [negg] * (budget+1)\n                    for cost1 in range(budget+1):\n                        if nb[cost1] < 0:\n                            continue\n                        for cost2 in range(budget+1 - cost1):\n                            prof2 = dp[v][0][cost2]\n                            if prof2 < 0:\n                                continue\n                            val = nb[cost1] + prof2\n                            if val > nxt[cost1 + cost2]:\n                                nxt[cost1 + cost2] = val\n                    nb = nxt\n\n                pr1 = (present[u] // 2) if eligible else present[u]\n                pr2 = future[u] - pr1\n                yb = [negg] * (budget+1)\n                if pr1 <= budget:\n                    yb[pr1] = pr2\n\n                for v in childs[u]:\n                    nxt = [negg] * (budget+1)\n                    for cost1 in range(budget+1):\n                        if yb[cost1] <= negg//2:\n                            continue\n                        for cost2 in range(budget+1 - cost1):\n                            prof2 = dp[v][1][cost2]\n                            if prof2 < 0:\n                                continue\n                            val = yb[cost1] + prof2\n                            if val > nxt[cost1 + cost2]:\n                                nxt[cost1 + cost2] = val\n                    yb = nxt\n\n                for c in range(budget+1):\n                    dp[u][eligible][c] = max(nb[c], yb[c])\n\n        dfs(0)\n        ans = max(dp[0][0])\n        return ans\n\n\n",
    "lang": "python3",
    "question_id": 3854,
    "contest_submission": 24260158
  },
  {
    "submission_id": 1643586884,
    "code": "class Solution:\n    def maxProfit(self, n: int, p: List[int], f: List[int], hierarchy: List[List[int]], budget: int) -> int:\n        ch = [[] for _ in range(n + 1)]\n        for u, v in hierarchy:\n            ch[u].append(v)\n        MIN = -10**9\n        def merge(dp_list):\n            f = [0] + [MIN] * budget\n            for dp in dp_list:\n                nf = [MIN] * (budget + 1)\n                for spent in range(budget + 1):\n                    if f[spent] < 0:\n                        continue\n                    for b in range(budget - spent + 1):\n                        if dp[b] < 0:\n                            continue\n                        c = f[spent] + dp[b]\n                        if c > nf[spent + b]:\n                            nf[spent + b] = c\n                f = nf\n            return f\n        def dfs(u):\n            dp0 = []\n            dp1 = []\n            for v in ch[u]:\n                d0, d1 = dfs(v)\n                dp0.append(d0)\n                dp1.append(d1)\n            comb0 = merge(dp0) if dp0 else [0] + [MIN] * budget\n            comb1 = merge(dp1) if dp1 else [0] + [MIN] * budget\n            dp0u = [MIN] * (budget + 1)\n            dp1u = [MIN] * (budget + 1)\n            for b in range(budget + 1):\n                dp1u[b] = comb0[b]\n            cost = p[u - 1] >> 1\n            prof = f[u - 1] - cost\n            for b in range(cost, budget + 1):\n                if comb1[b - cost] < 0:\n                    continue\n                c = prof + comb1[b - cost]\n                if c > dp1u[b]:\n                    dp1u[b] = c\n            for b in range(budget + 1):\n                dp0u[b] = comb0[b]\n            costf = p[u - 1]\n            proff = f[u - 1] - costf\n            for b in range(costf, budget + 1):\n                if comb1[b - costf] < 0:\n                    continue\n                c = proff + comb1[b - costf]\n                if c > dp0u[b]:\n                    dp0u[b] = c\n            return dp0u, dp1u\n        dp0_root, _ = dfs(1)\n        return max(dp0_root)",
    "lang": "python3",
    "question_id": 3854,
    "contest_submission": 24251019
  }
]