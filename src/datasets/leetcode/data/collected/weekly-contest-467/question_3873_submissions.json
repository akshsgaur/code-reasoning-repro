[
  {
    "submission_id": 1769967201,
    "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        c = Counter(nums)\n        n = len(nums)\n        pf = [0] * (n+1)\n        pf[0] = 1\n        fullMask = (1 << (k+1)) - 1\n        # print(f'{fullMask=}')\n\n        for v in range(1, n + 1):\n            dp = pf[v-1]\n            count = c[v]\n\n            pp = 1\n            while count > 0:\n                take = min(pp, count)\n                dp = (dp | (dp << (v*take)) & fullMask) & fullMask\n                count -= take\n                pp <<= 1\n\n            pf[v] = dp\n\n        suff = [0] * (n + 2)\n        for v in range(n, 0, -1):\n            suff[v] = suff[v+1] + c[v]\n\n        res = [False]*n\n\n        for x in range(1, n + 1):\n            dp = pf[x-1]\n            nxt = suff[x]\n            big = min(nxt, k // x)\n            noFail = False\n            for j in range(big + 1):\n                tmp = k - (j * x)\n                if (dp >> tmp) & 1:\n                    noFail = True\n                    break\n            res[x-1] = noFail\n\n        return res",
    "lang": "python3",
    "question_id": 3873,
    "contest_submission": 26435911
  },
  {
    "submission_id": 1769967950,
    "code": "class Solution:\n  def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n    n = len(nums)\n    freq = [0] * (n + 1)\n    for a in nums:\n        if 1 <= a <= n:\n            freq[a] += 1\n\n    ans = [False] * n\n    dp = 1\n    mask = (1 << (k + 1)) - 1\n\n    cnt_le = 0\n    for x in range(1, n + 1):\n        for _ in range(freq[x]):\n            dp = (dp | (dp << x)) & mask\n        cnt_le += freq[x]\n\n        m_x = n - cnt_le\n\n        possible = False\n        max_j = min(m_x, k // x)\n        for j in range(max_j + 1):\n            s = k - j * x\n            if (dp >> s) & 1:  # sum s is achievable using values \u2264 x\n                possible = True\n                break\n        ans[x - 1] = possible\n\n    return ans",
    "lang": "python3",
    "question_id": 3873,
    "contest_submission": 26436495
  },
  {
    "submission_id": 1769965337,
    "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        K = k\n        nums.sort()\n        N = len(nums)\n        dp = [0]*(k+1)\n        j = 0\n        dp[0] = 1\n\n        Z = 1\n        res = []\n        for i in range(1,N+1):\n            while j < len(nums) and nums[j] < i:\n                Z |= (Z << nums[j])\n                j += 1\n            remaining_count = len(nums)-j\n            max_cap = i\n            ans = False\n            for g in range(K,-1,-i):\n                diff = k-g\n                if remaining_count*max_cap >= diff:\n                    if ((1<<g)&Z) > 0:\n                        ans = True\n                        break\n                else:\n                    break\n            res.append(ans)\n        return res\n            \n                    \n            \n\n        ",
    "lang": "python3",
    "question_id": 3873,
    "contest_submission": 26434475
  },
  {
    "submission_id": 1769969358,
    "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        n = len(nums)\n        nums.sort()\n        dp = [1] + [0] * k\n\n        ans = []\n        ans.append(n>=k)\n\n        j = 0\n        for i in range(2, n+1):\n            while j < n and nums[j] < i:\n                for v in range(k, -1, -1):\n                    if v >= nums[j] and dp[v - nums[j]]:\n                        dp[v] = 1\n                j += 1\n            # print(nums, i, j, dp)\n            f = False\n            for x in range(n - j + 1):\n                if k < x * i:\n                    break\n                if dp[k - x * i]:\n                    f = True\n                    break\n            ans.append(f)\n        return ans\n",
    "lang": "python3",
    "question_id": 3873,
    "contest_submission": 26437577
  },
  {
    "submission_id": 1769967678,
    "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        n = len(nums)\n        z = nums\n        z.sort()\n        ans = [False]*n\n        dp=[False]*(k+1)\n        dp[0]= True\n        ni=0\n        for x in range(1,n+1):\n            while ni<n and z[ni]<x:\n                num=z[ni]\n                for j in range(k,num-1,-1):\n                    dp[j]=dp[j]or dp[j-num]\n                ni+=1\n            ccax=n-ni\n            for s in range(k+1):\n                if dp[s]:\n                    rs=k-s\n                    if rs>=0 and rs%x==0:\n                        nxn=rs//x\n                        if nxn<=ccax:\n                            ans[x-1]=True\n                            break\n        return ans                ",
    "lang": "python3",
    "question_id": 3873,
    "contest_submission": 26436278
  },
  {
    "submission_id": 1769969004,
    "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        n = len(nums)\n        freq = [0] * (n + 1)\n        for v in nums:\n            freq[v] += 1\n        suff = [0] * (n + 2)\n        for x in range(n, 0, -1):\n            suff[x] = suff[x + 1] + freq[x]\n        dp = [False] * (k + 1)\n        dp[0] = True\n        res = [False] * n\n        for x in range(1, n + 1):\n            is_possible = dp[k]\n            if not is_possible:\n                m = suff[x]\n                t_max = min(m, k // x)\n                s = k - x\n                for _ in range(t_max):\n                    if dp[s]:\n                        is_possible = True\n                        break\n                    s -= x\n            res[x - 1] = is_possible\n            cx = freq[x]\n            while cx:\n                for s in range(k, x - 1, -1):\n                    if dp[s - x]:\n                        dp[s] = True\n                cx -= 1\n        return res",
    "lang": "python3",
    "question_id": 3873,
    "contest_submission": 26437289
  },
  {
    "submission_id": 1769968293,
    "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        def add_bp(bitset, w, c):\n            if c <= 0 or w > k:\n                return bitset\n\n            take = 1\n            while c > 0:\n                t = min(take, c)\n                shift = w * t\n                if shift <= k:\n                    bitset |= (bitset << shift) & MASK\n                c -= t\n                take <<= 1\n            return bitset\n        \n        n = len(nums)\n\n        cnt = [0] * (n + 2)\n        for v in nums:\n            if 1 <= v <= n:\n                cnt[v] += 1\n            elif v > n:\n                cnt[n + 1] += 1\n\n        f = cnt[:]\n        g = [0] * (n + 2)\n        suf = 0\n        for x in range(n + 1, 0, -1):\n            suf += cnt[x]\n            if x <= n:\n                g[x] = suf\n\n        MASK = (1 << (k + 1)) - 1\n\n        ans = [False] * n\n        base = 1\n\n        for x in range(1, n + 1):\n            tmp = add_bp(base, x, g[x])\n            ans[x - 1] = bool((tmp >> k) & 1)\n\n            base = add_bp(base, x, f[x])\n        return ans\n\n        \n            ",
    "lang": "python3",
    "question_id": 3873,
    "contest_submission": 26436750
  },
  {
    "submission_id": 1769974536,
    "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        n = len(nums)\n        freq = [0] * (n + 1)\n        get = 0\n        for a in nums:\n            if 1 <= a <= n:\n                freq[a] += 1\n            elif a > n:\n                get += 1\n        g = [0] * (n + 2)\n        r = get\n        for v in range(n, 0, -1):\n            r += freq[v]\n            g[v] = r\n        b, mask, ans = 1, (1<<(k+1)) - 1, [False] * n\n        for x in range(1, n + 1):\n            tmax = min(g[x], k // x)\n            M = 0\n            for t in range(tmax + 1):\n                M |= 1<<(k - t * x)\n            ans[x - 1] = (b & M) != 0\n            c, p = freq[x], 1\n            while c:\n                take = min(p, c)\n                b |= (b << (take * x)) & mask\n                c -= take\n                p <<= 1\n        return ans\n            ",
    "lang": "python3",
    "question_id": 3873,
    "contest_submission": 26441498
  },
  {
    "submission_id": 1769976928,
    "code": "from typing import List\nfrom collections import Counter\nclass Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        n = len(nums)\n        if k == 0:                         \n            return [False] * n\n\n        max_val = max(nums)\n        freq = Counter(nums)                \n\n\n        suffix_cnt = [0] * (max(max_val, n) + 2)\n        for v in nums:\n            suffix_cnt[v] += 1\n        for x in range(len(suffix_cnt) - 2, 0, -1):\n            suffix_cnt[x] += suffix_cnt[x + 1]\n\n        reachable = 1                       \n        mask = (1 << (k + 1)) - 1           \n\n        ans = [False] * n\n        current_val = 1                     \n\n        for x in range(1, n + 1):\n \n            while current_val < x and current_val <= max_val:\n                cnt = freq.get(current_val, 0)\n                if cnt:\n                    shift = current_val\n                    for _ in range(cnt):           \n                        reachable |= (reachable << shift) & mask\n                current_val += 1\n\n            if x == 1:                                 \n                ans[x - 1] = suffix_cnt[1] >= k\n                continue\n\n            mx = suffix_cnt[x]                          \n            lim = min(mx, k // x)\n\n\n            ok = False\n            for b in range(lim + 1):\n                remaining = k - b * x\n                if (reachable >> remaining) & 1:  \n                    ok = True\n                    break\n            ans[x - 1] = ok\n\n        return ans\n        ",
    "lang": "python3",
    "question_id": 3873,
    "contest_submission": 26443266
  },
  {
    "submission_id": 1769976869,
    "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        z=nums[:]\n\n        n=len(nums)\n\n        freq=[0]*(n+1)\n\n        for a in nums:\n            freq[a]+=1\n\n        tail_gr=[0]*(n+2)\n\n        for v in range(n,0,-1):\n            tail_gr[v]=tail_gr[v+1]+freq[v]\n\n        dp=1\n        mask=(1<<(k+1))-1\n\n        ans=[False]*n\n\n        def add_bound(dp_bits,w,cnt):\n            p=1\n            while cnt>0:\n                take=min(p,cnt)\n                dp_bits=dp_bits|((dp_bits<<(take*w))&mask)\n                cnt-=take\n                p<<=1\n            return dp_bits\n\n        for x in range(1,n+1):\n            cx=tail_gr[x]\n            mmax=min(cx,k//x) if x!=0 else 0\n\n            possible=False\n\n            if k>0 and ((dp>>k)&1):\n                possible=True\n            else:\n                m=1\n                while not possible and m<=mmax:\n                    s=k-m*x\n                    if s>=0 and ((dp>>s)&1):\n                        possible=True\n                        break\n                    m+=1\n\n            ans[x-1]=possible\n            if freq[x]:\n                dp=add_bound(dp,x,freq[x])\n        return ans\n        ",
    "lang": "python3",
    "question_id": 3873,
    "contest_submission": 26443223
  },
  {
    "submission_id": 1769974502,
    "code": "from typing import List\n\n\nclass Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        N = len(nums)\n        fre = [0] * (N + 2)\n        for v in nums:\n            if 1 <= v <= N:\n                fre[v] += 1\n            elif v > N:\n                fre[N] += 1\n\n        suffix = [0] * (N + 3)\n        window = 0\n        for i in range(N, 0, -1):\n            window += fre[i]\n            suffix[i] = window\n\n        limit_x = min(N, k)\n        dp = [False] * (k + 1)\n        dp[0] = True\n\n        answer = [False] * N\n\n        for x in range(1, limit_x + 1):\n            count_x = fre[x]\n            mult = 1\n            while count_x > 0:\n                take = mult if mult <= count_x else count_x\n                weight = take * x\n                for s in range(k, weight - 1, -1):\n                    if dp[s - weight]:\n                        dp[s] = True\n                count_x -= take\n                mult <<= 1\n\n            cnt_gtx = suffix[x + 1] if x + 1 <= N else 0\n            max_t = min(cnt_gtx, k // x)\n\n            ok = False\n            for t in range(0, max_t + 1):\n                if dp[k - t * x]:\n                    ok = True\n                    break\n            answer[x - 1] = ok\n\n        if N > k:\n            rest = dp[k]\n            for x in range(k + 1, N + 1):\n                answer[x - 1] = rest\n\n        return answer\n",
    "lang": "python3",
    "question_id": 3873,
    "contest_submission": 26441471
  },
  {
    "submission_id": 1769977544,
    "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        n = len(nums)\n        ans = [False] * n\n        nums.sort()\n        p = 0\n        dp = 1\n        for x in range(1, n+1):\n            while p < n and nums[p] <= x:\n                dp |= dp << nums[p]\n                p += 1\n            greater = n - p\n            for j in range(greater+1):\n                if k - j * x < 0:\n                    break\n                if dp & 1 << (k - j * x) != 0:\n                    ans[x-1] = True\n        return ans",
    "lang": "python3",
    "question_id": 3873,
    "contest_submission": 26443698
  },
  {
    "submission_id": 1769970904,
    "code": "from collections import Counter\n\nclass Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        ctr = Counter(nums)\n        n = len(nums)\n        answer = []\n        large = n\n        mask = (1 << (k + 1)) - 1\n        now = 1\n\n        for i in range(1, n + 1):\n            c = ctr[i]\n            for _ in range(c):\n                now = (now | (now << i)) & mask\n\n            large -= c\n\n            is_found = False\n            for j in range(large + 1):\n                need = k - j * i\n                if need < 0:\n                    break\n\n                if (1 << need) & now:\n                    is_found = True\n                    break\n\n            answer.append(is_found)\n\n        return answer",
    "lang": "python3",
    "question_id": 3873,
    "contest_submission": 26438743
  },
  {
    "submission_id": 1769970433,
    "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        n=len(nums)\n        freq=[0]*(n+1)\n        for v in nums:freq[v]+=1\n        mask=(1<<(k+1))-1\n        pre_dp=[0]*(n+1)\n        dp=1\n        pre_dp[0]=dp\n        for v in range(1,n+1):\n            for _ in range(freq[v]):\n                dp|=(dp<<v)\n                dp&=mask\n            pre_dp[v]=dp\n        suff=[0]*(n+2)\n        for v in range(n,0,-1):suff[v]=suff[v+1]+freq[v]\n        ans=[False]*n\n        for x in range(1,n+1):\n            base=pre_dp[x-1]\n            c=suff[x]\n            add=1\n            while c>0:\n                take=min(add,c)\n                shift=take*x\n                if shift>k:break\n                base|=(base<<shift)\n                base&=mask\n                c-=take\n                add<<=1\n            ans[x-1]=bool((base>>k)&1)\n        return ans",
    "lang": "python3",
    "question_id": 3873,
    "contest_submission": 26438389
  },
  {
    "submission_id": 1769975684,
    "code": "class Solution:\n    def subsequenceSumAfterCapping(self, A: List[int], k: int) -> List[bool]:\n        n = len(A)\n        A.sort()\n        p = 0\n        res = []\n        reach = {0}\n        for x in range(1, n + 1):\n            while p < n and A[p] < x:\n                for t in list(reach):\n                    if t + A[p] <= k:\n                        reach.add(t + A[p])\n                p += 1\n            if k in reach:\n                res.extend([True] * (n - len(res)))\n                break\n            rst = n - p\n            res.append(any((k - i * x) in reach for i in range(rst+1)))\n        return res",
    "lang": "python3",
    "question_id": 3873,
    "contest_submission": 26442353
  }
]