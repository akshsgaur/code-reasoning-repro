[
  {
    "submission_id": 1598007661,
    "code": "from collections import deque\nfrom sortedcontainers import SortedList\nimport bisect\n\nclass Packet:\n    def __init__(self, a, b, c, d):\n        self.a = a  # source\n        self.b = b  # destination\n        self.c = c  # timestamp\n        self.d = d  # unique id\n\nclass PacketKey:\n    def __init__(self, a, b, c):\n        self.a = a\n        self.b = b\n        self.c = c\n    \n    def __hash__(self):\n        return hash((self.a, self.b, self.c))\n    \n    def __eq__(self, other):\n        return self.a == other.a and self.b == other.b and self.c == other.c\n\nclass Router:\n    def __init__(self, a):\n        self.a = a  # memory limit\n        self.b = deque()  # Packet queue (FIFO)\n        self.c = set()  # For duplicate tracking\n        self.d = {}  # Mapping: destination -> sorted list of (timestamp, unique id)\n        self.e = 0  # Unique ID counter\n    \n    def _remove_oldest(self):\n        if not self.b:\n            return\n        f = self.b.popleft()\n        g = PacketKey(f.a, f.b, f.c)\n        self.c.discard(g)\n        if f.b in self.d:\n            self.d[f.b].remove((f.c, f.d))\n            if not self.d[f.b]:\n                del self.d[f.b]  # Cleanup empty lists\n\n    def addPacket(self, a, b, c):\n        g = PacketKey(a, b, c)\n        if g in self.c:\n            return False\n        if len(self.b) >= self.a:\n            self._remove_oldest()\n        f = Packet(a, b, c, self.e)\n        self.e += 1\n        self.b.append(f)\n        self.c.add(g)\n        if b not in self.d:\n            self.d[b] = SortedList()\n        self.d[b].add((c, f.d))\n        return True\n\n    def forwardPacket(self):\n        if not self.b:\n            return []\n        f = self.b.popleft()\n        g = PacketKey(f.a, f.b, f.c)\n        self.c.discard(g)\n        if f.b in self.d:\n            self.d[f.b].remove((f.c, f.d))\n            if not self.d[f.b]:\n                del self.d[f.b]  # Cleanup empty lists\n        return [f.a, f.b, f.c]\n    \n    def getCount(self, a, b, c):\n        if a not in self.d:\n            return 0\n        d_list = self.d[a]\n        x = bisect.bisect_left(d_list, (b, 0))\n        y = bisect.bisect_right(d_list, (c, float('inf')))\n        return y - x\n",
    "lang": "python3",
    "question_id": 3827,
    "contest_submission": 23474581
  },
  {
    "submission_id": 1598007569,
    "code": "class Router:\n\n    def __init__(self, memoryLimit: int):\n        self.queue = deque()\n        self.visited = set()\n        self.d_packages = {}\n        self.limit = memoryLimit\n        \n\n    def addPacket(self, source: int, destination: int, timestamp: int) -> bool:\n        if (source, destination, timestamp) in self.visited:\n            return False\n        if len(self.queue) >= self.limit:\n            self.forwardPacket()\n            \n        self.visited.add((source, destination, timestamp))\n        self.queue.append((source, destination, timestamp))\n        if destination not in self.d_packages:\n            self.d_packages[destination] = SortedList()\n        self.d_packages[destination].add(timestamp)\n        # print(self.queue)\n        return True\n                           \n        \n    def forwardPacket(self) -> List[int]:\n        if not self.queue:\n            return []\n        (s, d, t) = self.queue.popleft()\n        self.visited.remove((s, d, t))\n        self.d_packages[d].discard(t)\n        return [s, d, t]\n        \n\n    def getCount(self, destination: int, startTime: int, endTime: int) -> int:\n        if destination not in self.d_packages:\n            return 0\n        # print(self.d_packages)\n        A = self.d_packages[destination]\n        wb = A.bisect_right(endTime)\n        cb = A.bisect_left(startTime)\n        return wb - cb\n        \n        \n        \n\n\n# Your Router object will be instantiated and called as such:\n# obj = Router(memoryLimit)\n# param_1 = obj.addPacket(source,destination,timestamp)\n# param_2 = obj.forwardPacket()\n# param_3 = obj.getCount(destination,startTime,endTime)",
    "lang": "python3",
    "question_id": 3827,
    "contest_submission": 23474515
  },
  {
    "submission_id": 1598057266,
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nimport random\nfrom collections import deque\n\nclass Node:\n    __slots__ = ['key', 'priority', 'count', 'size', 'left', 'right']\n    def __init__(self, key):\n        self.key = key\n        self.priority = random.random()\n        self.count = 1 \n        self.size = 1   \n        self.left = None\n        self.right = None\n\ndef updates(node):\n    if node:\n        node.size = node.count + (node.left.size if node.left else 0) + (node.right.size if node.right else 0)\n\ndef split(root, key):\n    if not root:\n        return (None, None)\n    if key < root.key:\n        left, root.left = split(root.left, key)\n        updates(root)\n        return (left, root)\n    else:\n        root.right, right = split(root.right, key)\n        updates(root)\n        return (root, right)\n\ndef merge(left, right):\n    if not left or not right:\n        return left or right\n    if left.priority < right.priority:\n        left.right = merge(left.right, right)\n        updates(left)\n        return left\n    else:\n        right.left = merge(left, right.left)\n        updates(right)\n        return right\n\ndef insert_node(root, key):\n    if not root:\n        return Node(key)\n    if key == root.key:\n        root.count += 1\n    elif key < root.key:\n        root.left = insert_node(root.left, key)\n        if root.left.priority < root.priority:\n            nrt = root.left\n            root.left = nrt.right\n            nrt.right = root\n            updates(root)\n            updates(nrt)\n            return nrt\n    else:\n        root.right = insert_node(root.right, key)\n        if root.right.priority < root.priority:\n            nrt = root.right\n            root.right = nrt.left\n            nrt.left = root\n            updates(root)\n            updates(nrt)\n            return nrt\n    updates(root)\n    return root\n\ndef del_node(root, key):\n    if not root:\n        return None\n    if key == root.key:\n        if root.count > 1:\n            root.count -= 1\n        else:\n            return merge(root.left, root.right)\n    elif key < root.key:\n        root.left = del_node(root.left, key)\n    else:\n        root.right = del_node(root.right, key)\n    updates(root)\n    return root\n\ndef cless(root, key):\n    if not root:\n        return 0\n    if key < root.key:\n        return cless(root.left, key)\n    else:\n        lsz = root.left.size if root.left else 0\n        return lsz + root.count + cless(root.right, key)\n\ndef cntrng(root, low, high):\n    if not root:\n        return 0\n    return cless(root, high) - cless(root, low - 1)\n\n\nclass Router:\n    def __init__(self, memoryLimit: int):\n        self.memoryLimit = memoryLimit\n        self.queue = deque()\n        self.pst = set()\n        self.dd = {}\n    \n    def _remove_oldest(self):\n        if self.queue:\n            source, destination, timestamp = self.queue.popleft()\n            self.pst.remove((source, destination, timestamp))\n            if destination in self.dd:\n                self.dd[destination] = del_node(self.dd[destination], timestamp)\n                if self.dd[destination] is None:\n                    del self.dd[destination]\n    \n    def addPacket(self, source: int, destination: int, timestamp: int) -> bool:\n        packet = (source, destination, timestamp)\n        if packet in self.pst:\n            return False\n        \n        if len(self.queue) == self.memoryLimit:\n            self._remove_oldest()\n        \n        self.queue.append(packet)\n        self.pst.add(packet)\n        if destination not in self.dd:\n            self.dd[destination] = None\n        self.dd[destination] = insert_node(self.dd[destination], timestamp)\n        return True\n    \n    def forwardPacket(self) -> List[int]:\n        if not self.queue:\n            return []\n        source, destination, timestamp = self.queue.popleft()\n        self.pst.remove((source, destination, timestamp))\n        if destination in self.dd:\n            self.dd[destination] = del_node(self.dd[destination], timestamp)\n            if self.dd[destination] is None:\n                del self.dd[destination]\n        return [source, destination, timestamp]\n    \n    def getCount(self, destination: int, startTime: int, endTime: int) -> int:\n        if destination not in self.dd:\n            return 0\n        return cntrng(self.dd[destination], startTime, endTime)\n\n\n",
    "lang": "python3",
    "question_id": 3827,
    "contest_submission": 23509583
  }
]