[
  {
    "submission_id": 1598020045,
    "code": "import heapq\n\nclass Node:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n        self.prev = None\n        self.next = None\n        self.removed = False\n\nclass Pair:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n    \n    def __lt__(self, other):\n        if self.a == other.a:\n            return self.b.b < other.b.b\n        return self.a < other.a\n\n\nclass Solution:\n    def minimumPairRemoval(self, nums: List[int]) -> int:\n        a = nums\n        b = list(map(int, a))\n        c = len(b)\n        if c == 0:\n            return 0\n        d = Node(b[0], 0)\n        e = d\n        f = 1\n        while f < c:\n            g = Node(b[f], f)\n            g.prev = e\n            e.next = g\n            e = g\n            f += 1\n        h = 0\n        i = d\n        while i and i.next:\n            if i.a > i.next.a:\n                h += 1\n            i = i.next\n        j = []\n        i = d\n        while i and i.next:\n            heapq.heappush(j, Pair(i.a + i.next.a, i))\n            i = i.next\n        k = 0\n        while h > 0 and j:\n            l = heapq.heappop(j)\n            m = l.b\n            if m.removed or not m.next or m.next.removed:\n                continue\n            if m.a + m.next.a != l.a:\n                continue\n            n = m.next\n            if m.prev and m.prev.a > m.a:\n                h -= 1\n            if n.next and n.a > n.next.a:\n                h -= 1\n            if m.a > n.a:\n                h -= 1\n            o = Node(m.a + n.a, m.b)\n            o.prev = m.prev\n            o.next = n.next\n            if o.prev:\n                o.prev.next = o\n                if o.prev.a > o.a:\n                    h += 1\n            if o.next:\n                o.next.prev = o\n                if o.a > o.next.a:\n                    h += 1\n            m.removed = True\n            n.removed = True\n            k += 1\n            if o.prev:\n                heapq.heappush(j, Pair(o.prev.a + o.a, o.prev))\n            if o.next:\n                heapq.heappush(j, Pair(o.a + o.next.a, o))\n        return k\n",
    "lang": "python3",
    "question_id": 3772,
    "contest_submission": 23483307
  },
  {
    "submission_id": 1598011702,
    "code": "class Solution:\n    def minimumPairRemoval(self, nums: List[int]) -> int:\n        pairs = SortedList()\n        ans = 0\n        n = len(nums)\n        sorted_count = 0\n        element_count = n\n        pre = [i - 1 for i in range(n)]\n        after = [i + 1 for i in range(n)]\n        for i in range(1, n):\n            if nums[i] >= nums[i - 1]:\n                sorted_count += 1\n            pairs.add((nums[i] + nums[i - 1], i - 1, i))\n        while sorted_count != element_count - 1:\n            e = pairs[0]\n            element_count -= 1\n            ans += 1\n            # print(e)\n            left_index, right_index = e[1], e[2]\n            pre_index = pre[left_index]\n            after_index = after[right_index]\n            if pre_index != -1:\n                pre_pair = (nums[pre_index] + nums[left_index], pre_index, left_index)\n                pairs.discard(pre_pair)\n            if after_index != n:\n                after_pair = (nums[after_index] + nums[right_index], right_index, after_index)\n                pairs.discard(after_pair)\n            pairs.discard(e)\n            if pre_index != -1 and nums[pre_index] <= nums[left_index]:\n                sorted_count -= 1\n            if after_index != n and nums[after_index] >= nums[right_index]:\n                sorted_count -= 1\n            if nums[left_index] <= nums[right_index]:\n                sorted_count -= 1\n            nums[left_index] = e[0]\n            after[left_index] = after_index\n            if after_index != n:\n                pre[after_index] = left_index\n            if pre_index != -1 and nums[pre_index] <= nums[left_index]:\n                sorted_count += 1\n            if after_index != n and nums[after_index] >= nums[left_index]:\n                sorted_count += 1\n            if pre_index != -1:\n                pre_pair = (nums[pre_index] + nums[left_index], pre_index, left_index)\n                pairs.add(pre_pair)\n            if after_index != n:\n                after_pair = (nums[after_index] + nums[left_index], left_index, after_index)\n                pairs.add(after_pair)\n        return ans",
    "lang": "python3",
    "question_id": 3772,
    "contest_submission": 23477433
  },
  {
    "submission_id": 1598048935,
    "code": "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    \n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n        \n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n        \n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n        \n    def set(self,p,x):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def get(self,p):\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n        \n    def prod(self,l,r):\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n        \n    def all_prod(self):return self.d[1]\n    \n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n        \n    def apply(self,l,r,f):\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n            \n    def max_right(self,l,g):\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(l%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n        \n    def min_left(self,r,g):\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 7 or n == 61:\n        return True\n    if n % 2 == 0:\n        return False\n    d = n - 1\n    while d % 2 == 0:\n        d //= 2\n    bases = [2, 7, 61]\n    for a in bases:\n        t = d\n        y = pow_mod(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0:\n            return False\n    return True\n\ndef primitive_root(m):\n    if m == 2:\n        return 1\n    if m in (167772161, 469762049, 754974721, 998244353):\n        return 3\n    divs = [2]\n    x = (m - 1) // 2\n    while x % 2 == 0:\n        x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs.append(i)\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1:\n        divs.append(x)\n\n    g = 2\n    while True:\n        ok = True\n        for d in divs:\n            if pow_mod(g, (m - 1) // d, m) == 1:\n                ok = False\n                break\n        if ok:\n            return g\n        g += 1\n        \ndef zs(s):\n    n = len(s)\n    ret = [0] * n\n    l = 1\n    ll = 0\n    r = 0\n    while l < len(s):\n        if l < r:\n            ret[l] = min(ret[l-ll],r-l)\n        \n        i = ret[l]\n        while l+i < len(s) and s[i] == s[l+i]:\n            ret[l] +=1\n            \n            i +=1\n        if ret[l] >0:\n            if l+i-1 > r:\n                ll = l\n                r = max(r,l+i-1)        \n        l+=1\n    return ret\n\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def minimumPairRemoval(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n <= 1:\n            return 0\n        if all(nums[i] <= nums[i+1] for i in range(n-1)):\n            return 0\n        \n        maxn = 2 * n  \n        val    = [0] * maxn  \n        left   = [-1] * maxn\n        right  = [-1] * maxn \n        pos    = [0] * maxn  \n        ls = [False] * maxn  \n        for i, num in enumerate(nums):\n            val[i] = num\n            pos[i] = i\n            ls[i] = True\n            left[i] = i - 1 if i > 0 else -1\n            right[i] = i + 1 if i < n - 1 else -1\n        \n        st = set()\n        i = 0\n        while i != -1:\n            r = right[i]\n            if r != -1 and ls[i] and ls[r] and val[i] > val[r]:\n                st.add(i)\n            i = right[i]\n\n        heap = []\n        for i in range(n - 1):\n            j = right[i]\n            heappush(heap, (val[i] + val[j], pos[i], i))\n        \n        ans = 0\n        nid = n \n        \n        def updates(idx):\n            if idx == -1 or not ls[idx]:\n                return\n            r = right[idx]\n            if r != -1 and ls[r] and val[idx] > val[r]:\n                st.add(idx)\n            else:\n                st.discard(idx)\n        \n        while st:\n            while heap:\n                sump, p, i = heappop(heap)\n                if not ls[i]:\n                    continue\n                j = right[i]\n                if j == -1 or not ls[j]:\n                    continue\n                if sump != val[i] + val[j]:\n                    continue\n                break\n            else:\n                i = next(iter(st))\n                j = right[i]\n            \n            ns = val[i] + val[j]\n            npos = pos[i] \n            indn = nid\n            nid += 1\n            val[indn] = ns\n            pos[indn] = npos\n            ls[indn] = True\n            \n            l = left[i]    \n            r = right[j]   \n            left[indn] = l\n            right[indn] = r\n            if l != -1:\n                right[l] = indn\n            if r != -1:\n                left[r] = indn\n            \n            ls[i] = False\n            ls[j] = False\n            st.discard(i)\n            st.discard(j)\n            \n            updates(l)\n            updates(indn)\n            updates(r)\n            \n            if l != -1 and ls[l]:\n                heappush(heap, (val[l] + val[indn], pos[l], l))\n            if r != -1 and ls[r]:\n                heappush(heap, (val[indn] + val[r], npos, indn))\n            \n            ans += 1\n        \n        return ans\n\n",
    "lang": "python3",
    "question_id": 3772,
    "contest_submission": 23503694
  }
]