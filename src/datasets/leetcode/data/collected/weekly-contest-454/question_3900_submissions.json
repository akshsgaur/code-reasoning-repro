[
  {
    "submission_id": 1664378551,
    "code": "from collections import deque\n\nclass Solution:\n    def findMedian(self, n: int, e: list[list[int]], q: list[list[int]]) -> list[int]:\n        L = n.bit_length(); a = [[] for _ in range(n)]\n        for u, v, w in e: a[u].append((v, w)); a[v].append((u, w))\n        p = [[-1]*L for _ in range(n)]; d = [[0]*L for _ in range(n)]; h = [-1]*n; s = [0]*n\n        z = deque([(0, -1, 0, 0)]); h[0] = 0\n        while z:\n            u, par, dep, dist = z.popleft(); p[u][0] = par; s[u] = dist\n            for v, w in a[u]:\n                if v != par: h[v] = dep+1; d[v][0] = w; z.append((v, u, dep+1, dist+w))\n        for j in range(1, L):\n            for i in range(n):\n                x = p[i][j-1]\n                if x != -1: p[i][j] = p[x][j-1]; d[i][j] = d[i][j-1]+d[x][j-1] if p[i][j] != -1 else d[i][j]\n        def lca(u, v):\n            if h[u] < h[v]: u, v = v, u\n            for j in range(L-1, -1, -1): \n                if h[u]-(1<<j) >= h[v]: u = p[u][j]\n            if u == v: return u\n            for j in range(L-1, -1, -1): \n                if p[u][j] != -1 and p[u][j] != p[v][j]: u, v = p[u][j], p[v][j]\n            return p[u][0]\n        r = []\n        for u, v in q:\n            if u == v: r.append(u); continue\n            x = lca(u, v); tot = s[u]+s[v]-2*s[x]; half = tot/2; su = s[u]-s[x]\n            if half <= su:\n                cur, rem = u, half\n                for j in range(L-1, -1, -1):\n                    par = p[cur][j]\n                    if par != -1 and h[par] >= h[x] and d[cur][j] < rem: rem -= d[cur][j]; cur = par\n                r.append(p[cur][0])\n            else:\n                cur, rem = v, s[v]-s[x]-(half-su)\n                for j in range(L-1, -1, -1):\n                    par = p[cur][j]\n                    if par != -1 and h[par] >= h[x] and d[cur][j] <= rem: rem -= d[cur][j]; cur = par\n                r.append(cur)\n        return r\n",
    "lang": "python3",
    "question_id": 3900,
    "contest_submission": 24549579
  },
  {
    "submission_id": 1664400150,
    "code": "class Solution:\n    def findMedian(self, n: int, e: List[List[int]], qs: List[List[int]]) -> List[int]:\n        def lca(x,y):\n            if depth[x]<depth[y]: x,y=y,x\n            diff=depth[x]-depth[y]\n            for i in range(P):\n                if diff>>i&1: x=parent[i][x]\n            if x==y: return x\n            for i in range(P-1,-1,-1):\n                if parent[i][x]!=parent[i][y]:\n                    x=parent[i][x]; y=parent[i][y]\n            return parent[0][x]\n\n        def dfs(u,p):\n            for v,w in g[u]:\n                if v!=p:\n                    parent[0][v]=u; upsum[0][v]=w\n                    depth[v]=depth[u]+1; dsum[v]=dsum[u]+w\n                    dfs(v,u)\n\n        P=(n-1).bit_length()\n        g=[[] for _ in range(n)]\n        for u,v,w in e:\n            g[u].append((v,w)); g[v].append((u,w))\n        parent=[[-1]*n for _ in range(P)]\n        upsum=[[0]*n for _ in range(P)]\n        depth=[0]*n; dsum=[0]*n\n\n        dfs(0,-1)\n        for i in range(1,P):\n            for v in range(n):\n                p0=parent[i-1][v]\n                if p0!=-1:\n                    parent[i][v]=parent[i-1][p0]\n                    upsum[i][v]=upsum[i-1][v]+upsum[i-1][p0]\n\n        res=[]\n        for u,v in qs:\n            if u==v:\n                res.append(u)\n                continue\n            w=lca(u,v)\n            d1=dsum[u]-dsum[w]; d2=dsum[v]-dsum[w]; total=d1+d2\n            if 2*d1>=total:\n                c=u; acc=0\n                for i in range(P-1,-1,-1):\n                    nz=parent[i][c]\n                    if nz!=-1 and acc+2*upsum[i][c]<total:\n                        acc+=2*upsum[i][c]; c=nz\n                c=parent[0][c]\n            else:\n                c=v; acc=0\n                for i in range(P-1,-1,-1):\n                    nz=parent[i][c]\n                    if nz!=-1 and acc+2*upsum[i][c]<=total:\n                        acc+=2*upsum[i][c]; c=nz\n            res.append(c)\n        return res",
    "lang": "python3",
    "question_id": 3900,
    "contest_submission": 24567609
  },
  {
    "submission_id": 1664394809,
    "code": "class Solution:\n    def findMedian(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n        adjMap = defaultdict(list)\n        for u, v, w in edges:\n            adjMap[u].append((v, w))\n            adjMap[v].append((u, w))\n\n        parents = [None] * n\n        depths = [0] * n\n        distRoot = [0] * n\n        children = defaultdict(list)\n\n        def dfs(node, parent):\n            for nxt, w in adjMap[node]:\n                if nxt == parent:\n                    continue\n                parents[nxt] = node\n                depths[nxt] = depths[node] + 1\n                distRoot[nxt] = distRoot[node] + w\n                children[node].append(nxt)\n                dfs(nxt, node)\n        parents[0] = -1\n        dfs(0, -1)\n\n        maxPow = n.bit_length()\n\n        @cache\n        def ancestor(node, power):\n            if node == -1:\n                return -1\n            if power == 0:\n                return parents[node]\n            half = ancestor(node, power - 1)\n            return ancestor(half, power - 1)\n\n        @cache\n        def kthAncestor(node, k):\n            if k == 0 or node == -1:\n                return node\n            bit = k.bit_length() - 1\n            return kthAncestor(ancestor(node, bit), k - (1 << bit))\n\n        def lca(a, b):\n            if depths[a] < depths[b]:\n                a, b = b, a\n            diff = depths[a] - depths[b]\n            a = kthAncestor(a, diff)\n            if a == b:\n                return a\n            for p in range(maxPow, -1, -1):\n                jumpA = ancestor(a, p)\n                jumpB = ancestor(b, p)\n                if jumpA != jumpB:\n                    a = jumpA\n                    b = jumpB\n            return parents[a]\n\n        def pathWeight(a, b):\n            z = lca(a, b)\n            return distRoot[a] + distRoot[b] - 2 * distRoot[z]\n\n        def aToBX(a, b, x):\n            z = lca(a, b)\n            up = depths[a] - depths[z]\n            if x <= up:\n                return kthAncestor(a, x)\n            down = depths[b] - depths[z]\n            return kthAncestor(b, down - (x - up))\n\n        res = []\n        for a, b in queries:\n            tot = pathWeight(a, b)\n            z = lca(a, b)\n            pathLength = depths[a] + depths[b] - (2 * depths[z]) + 1\n            l, r = 0, pathLength - 1\n            resNode = b\n            while l <= r:\n                m = (l+r)//2\n                nodeMid = aToBX(a, b, m)\n                if pathWeight(a, nodeMid) * 2 >= tot:\n                    resNode = nodeMid\n                    r = m - 1\n                else:\n                    l = m + 1\n            res.append(resNode)\n        return res",
    "lang": "python3",
    "question_id": 3900,
    "contest_submission": 24563227
  }
]