{"id": "contest467_q3873_s0", "scenario": "code_generation", "question_id": 3873, "question_title": "Subsequence Sum After Capping Elements", "question_content": "[Problem description for Subsequence Sum After Capping Elements - Question ID: 3873]", "function_name": "subsequenceSumAfterCapping", "function_signature": "def subsequenceSumAfterCapping(self, nums: List[int], k: int)", "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        c = Counter(nums)\n        n = len(nums)\n        pf = [0] * (n+1)\n        pf[0] = 1\n        fullMask = (1 << (k+1)) - 1\n        # print(f'{fullMask=}')\n\n        for v in range(1, n + 1):\n            dp = pf[v-1]\n            count = c[v]\n\n            pp = 1\n            while count > 0:\n                take = min(pp, count)\n                dp = (dp | (dp << (v*take)) & fullMask) & fullMask\n                count -= take\n                pp <<= 1\n\n            pf[v] = dp\n\n        suff = [0] * (n + 2)\n        for v in range(n, 0, -1):\n            suff[v] = suff[v+1] + c[v]\n\n        res = [False]*n\n\n        for x in range(1, n + 1):\n            dp = pf[x-1]\n            nxt = suff[x]\n            big = min(nxt, k // x)\n            noFail = False\n            for j in range(big + 1):\n                tmp = k - (j * x)\n                if (dp >> tmp) & 1:\n                    noFail = True\n                    break\n            res[x-1] = noFail\n\n        return res", "submission_id": 1769967201, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 34}, "platform": "leetcode"}
{"id": "contest467_q3873_s1", "scenario": "code_generation", "question_id": 3873, "question_title": "Subsequence Sum After Capping Elements", "question_content": "[Problem description for Subsequence Sum After Capping Elements - Question ID: 3873]", "function_name": "subsequenceSumAfterCapping", "function_signature": "def subsequenceSumAfterCapping(self, nums: List[int], k: int)", "code": "class Solution:\n  def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n    n = len(nums)\n    freq = [0] * (n + 1)\n    for a in nums:\n        if 1 <= a <= n:\n            freq[a] += 1\n\n    ans = [False] * n\n    dp = 1\n    mask = (1 << (k + 1)) - 1\n\n    cnt_le = 0\n    for x in range(1, n + 1):\n        for _ in range(freq[x]):\n            dp = (dp | (dp << x)) & mask\n        cnt_le += freq[x]\n\n        m_x = n - cnt_le\n\n        possible = False\n        max_j = min(m_x, k // x)\n        for j in range(max_j + 1):\n            s = k - j * x\n            if (dp >> s) & 1:  # sum s is achievable using values \u2264 x\n                possible = True\n                break\n        ans[x - 1] = possible\n\n    return ans", "submission_id": 1769967950, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 25}, "platform": "leetcode"}
{"id": "contest467_q3873_s2", "scenario": "code_generation", "question_id": 3873, "question_title": "Subsequence Sum After Capping Elements", "question_content": "[Problem description for Subsequence Sum After Capping Elements - Question ID: 3873]", "function_name": "subsequenceSumAfterCapping", "function_signature": "def subsequenceSumAfterCapping(self, nums: List[int], k: int)", "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        K = k\n        nums.sort()\n        N = len(nums)\n        dp = [0]*(k+1)\n        j = 0\n        dp[0] = 1\n\n        Z = 1\n        res = []\n        for i in range(1,N+1):\n            while j < len(nums) and nums[j] < i:\n                Z |= (Z << nums[j])\n                j += 1\n            remaining_count = len(nums)-j\n            max_cap = i\n            ans = False\n            for g in range(K,-1,-i):\n                diff = k-g\n                if remaining_count*max_cap >= diff:\n                    if ((1<<g)&Z) > 0:\n                        ans = True\n                        break\n                else:\n                    break\n            res.append(ans)\n        return res\n            \n                    \n            \n\n        ", "submission_id": 1769965337, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 27}, "platform": "leetcode"}
{"id": "contest467_q3873_s3", "scenario": "code_generation", "question_id": 3873, "question_title": "Subsequence Sum After Capping Elements", "question_content": "[Problem description for Subsequence Sum After Capping Elements - Question ID: 3873]", "function_name": "subsequenceSumAfterCapping", "function_signature": "def subsequenceSumAfterCapping(self, nums: List[int], k: int)", "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        n = len(nums)\n        nums.sort()\n        dp = [1] + [0] * k\n\n        ans = []\n        ans.append(n>=k)\n\n        j = 0\n        for i in range(2, n+1):\n            while j < n and nums[j] < i:\n                for v in range(k, -1, -1):\n                    if v >= nums[j] and dp[v - nums[j]]:\n                        dp[v] = 1\n                j += 1\n            # print(nums, i, j, dp)\n            f = False\n            for x in range(n - j + 1):\n                if k < x * i:\n                    break\n                if dp[k - x * i]:\n                    f = True\n                    break\n            ans.append(f)\n        return ans\n", "submission_id": 1769969358, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 24}, "platform": "leetcode"}
{"id": "contest467_q3873_s4", "scenario": "code_generation", "question_id": 3873, "question_title": "Subsequence Sum After Capping Elements", "question_content": "[Problem description for Subsequence Sum After Capping Elements - Question ID: 3873]", "function_name": "subsequenceSumAfterCapping", "function_signature": "def subsequenceSumAfterCapping(self, nums: List[int], k: int)", "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        n = len(nums)\n        z = nums\n        z.sort()\n        ans = [False]*n\n        dp=[False]*(k+1)\n        dp[0]= True\n        ni=0\n        for x in range(1,n+1):\n            while ni<n and z[ni]<x:\n                num=z[ni]\n                for j in range(k,num-1,-1):\n                    dp[j]=dp[j]or dp[j-num]\n                ni+=1\n            ccax=n-ni\n            for s in range(k+1):\n                if dp[s]:\n                    rs=k-s\n                    if rs>=0 and rs%x==0:\n                        nxn=rs//x\n                        if nxn<=ccax:\n                            ans[x-1]=True\n                            break\n        return ans                ", "submission_id": 1769967678, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 25}, "platform": "leetcode"}
{"id": "contest467_q3873_s5", "scenario": "code_generation", "question_id": 3873, "question_title": "Subsequence Sum After Capping Elements", "question_content": "[Problem description for Subsequence Sum After Capping Elements - Question ID: 3873]", "function_name": "subsequenceSumAfterCapping", "function_signature": "def subsequenceSumAfterCapping(self, nums: List[int], k: int)", "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        n = len(nums)\n        freq = [0] * (n + 1)\n        for v in nums:\n            freq[v] += 1\n        suff = [0] * (n + 2)\n        for x in range(n, 0, -1):\n            suff[x] = suff[x + 1] + freq[x]\n        dp = [False] * (k + 1)\n        dp[0] = True\n        res = [False] * n\n        for x in range(1, n + 1):\n            is_possible = dp[k]\n            if not is_possible:\n                m = suff[x]\n                t_max = min(m, k // x)\n                s = k - x\n                for _ in range(t_max):\n                    if dp[s]:\n                        is_possible = True\n                        break\n                    s -= x\n            res[x - 1] = is_possible\n            cx = freq[x]\n            while cx:\n                for s in range(k, x - 1, -1):\n                    if dp[s - x]:\n                        dp[s] = True\n                cx -= 1\n        return res", "submission_id": 1769969004, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 31}, "platform": "leetcode"}
{"id": "contest467_q3873_s6", "scenario": "code_generation", "question_id": 3873, "question_title": "Subsequence Sum After Capping Elements", "question_content": "[Problem description for Subsequence Sum After Capping Elements - Question ID: 3873]", "function_name": "subsequenceSumAfterCapping", "function_signature": "def subsequenceSumAfterCapping(self, nums: List[int], k: int)", "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        def add_bp(bitset, w, c):\n            if c <= 0 or w > k:\n                return bitset\n\n            take = 1\n            while c > 0:\n                t = min(take, c)\n                shift = w * t\n                if shift <= k:\n                    bitset |= (bitset << shift) & MASK\n                c -= t\n                take <<= 1\n            return bitset\n        \n        n = len(nums)\n\n        cnt = [0] * (n + 2)\n        for v in nums:\n            if 1 <= v <= n:\n                cnt[v] += 1\n            elif v > n:\n                cnt[n + 1] += 1\n\n        f = cnt[:]\n        g = [0] * (n + 2)\n        suf = 0\n        for x in range(n + 1, 0, -1):\n            suf += cnt[x]\n            if x <= n:\n                g[x] = suf\n\n        MASK = (1 << (k + 1)) - 1\n\n        ans = [False] * n\n        base = 1\n\n        for x in range(1, n + 1):\n            tmp = add_bp(base, x, g[x])\n            ans[x - 1] = bool((tmp >> k) & 1)\n\n            base = add_bp(base, x, f[x])\n        return ans\n\n        \n            ", "submission_id": 1769968293, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 36}, "platform": "leetcode"}
{"id": "contest467_q3873_s7", "scenario": "code_generation", "question_id": 3873, "question_title": "Subsequence Sum After Capping Elements", "question_content": "[Problem description for Subsequence Sum After Capping Elements - Question ID: 3873]", "function_name": "subsequenceSumAfterCapping", "function_signature": "def subsequenceSumAfterCapping(self, nums: List[int], k: int)", "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        n = len(nums)\n        freq = [0] * (n + 1)\n        get = 0\n        for a in nums:\n            if 1 <= a <= n:\n                freq[a] += 1\n            elif a > n:\n                get += 1\n        g = [0] * (n + 2)\n        r = get\n        for v in range(n, 0, -1):\n            r += freq[v]\n            g[v] = r\n        b, mask, ans = 1, (1<<(k+1)) - 1, [False] * n\n        for x in range(1, n + 1):\n            tmax = min(g[x], k // x)\n            M = 0\n            for t in range(tmax + 1):\n                M |= 1<<(k - t * x)\n            ans[x - 1] = (b & M) != 0\n            c, p = freq[x], 1\n            while c:\n                take = min(p, c)\n                b |= (b << (take * x)) & mask\n                c -= take\n                p <<= 1\n        return ans\n            ", "submission_id": 1769974536, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 29}, "platform": "leetcode"}
{"id": "contest467_q3873_s8", "scenario": "code_generation", "question_id": 3873, "question_title": "Subsequence Sum After Capping Elements", "question_content": "[Problem description for Subsequence Sum After Capping Elements - Question ID: 3873]", "function_name": "subsequenceSumAfterCapping", "function_signature": "def subsequenceSumAfterCapping(self, nums: List[int], k: int)", "code": "from typing import List\nfrom collections import Counter\nclass Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        n = len(nums)\n        if k == 0:                         \n            return [False] * n\n\n        max_val = max(nums)\n        freq = Counter(nums)                \n\n\n        suffix_cnt = [0] * (max(max_val, n) + 2)\n        for v in nums:\n            suffix_cnt[v] += 1\n        for x in range(len(suffix_cnt) - 2, 0, -1):\n            suffix_cnt[x] += suffix_cnt[x + 1]\n\n        reachable = 1                       \n        mask = (1 << (k + 1)) - 1           \n\n        ans = [False] * n\n        current_val = 1                     \n\n        for x in range(1, n + 1):\n \n            while current_val < x and current_val <= max_val:\n                cnt = freq.get(current_val, 0)\n                if cnt:\n                    shift = current_val\n                    for _ in range(cnt):           \n                        reachable |= (reachable << shift) & mask\n                current_val += 1\n\n            if x == 1:                                 \n                ans[x - 1] = suffix_cnt[1] >= k\n                continue\n\n            mx = suffix_cnt[x]                          \n            lim = min(mx, k // x)\n\n\n            ok = False\n            for b in range(lim + 1):\n                remaining = k - b * x\n                if (reachable >> remaining) & 1:  \n                    ok = True\n                    break\n            ans[x - 1] = ok\n\n        return ans\n        ", "submission_id": 1769976928, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 39}, "platform": "leetcode"}
{"id": "contest467_q3873_s9", "scenario": "code_generation", "question_id": 3873, "question_title": "Subsequence Sum After Capping Elements", "question_content": "[Problem description for Subsequence Sum After Capping Elements - Question ID: 3873]", "function_name": "subsequenceSumAfterCapping", "function_signature": "def subsequenceSumAfterCapping(self, nums: List[int], k: int)", "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        z=nums[:]\n\n        n=len(nums)\n\n        freq=[0]*(n+1)\n\n        for a in nums:\n            freq[a]+=1\n\n        tail_gr=[0]*(n+2)\n\n        for v in range(n,0,-1):\n            tail_gr[v]=tail_gr[v+1]+freq[v]\n\n        dp=1\n        mask=(1<<(k+1))-1\n\n        ans=[False]*n\n\n        def add_bound(dp_bits,w,cnt):\n            p=1\n            while cnt>0:\n                take=min(p,cnt)\n                dp_bits=dp_bits|((dp_bits<<(take*w))&mask)\n                cnt-=take\n                p<<=1\n            return dp_bits\n\n        for x in range(1,n+1):\n            cx=tail_gr[x]\n            mmax=min(cx,k//x) if x!=0 else 0\n\n            possible=False\n\n            if k>0 and ((dp>>k)&1):\n                possible=True\n            else:\n                m=1\n                while not possible and m<=mmax:\n                    s=k-m*x\n                    if s>=0 and ((dp>>s)&1):\n                        possible=True\n                        break\n                    m+=1\n\n            ans[x-1]=possible\n            if freq[x]:\n                dp=add_bound(dp,x,freq[x])\n        return ans\n        ", "submission_id": 1769976869, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 39}, "platform": "leetcode"}
{"id": "contest467_q3873_s10", "scenario": "code_generation", "question_id": 3873, "question_title": "Subsequence Sum After Capping Elements", "question_content": "[Problem description for Subsequence Sum After Capping Elements - Question ID: 3873]", "function_name": "subsequenceSumAfterCapping", "function_signature": "def subsequenceSumAfterCapping(self, nums: List[int], k: int)", "code": "from typing import List\n\n\nclass Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        N = len(nums)\n        fre = [0] * (N + 2)\n        for v in nums:\n            if 1 <= v <= N:\n                fre[v] += 1\n            elif v > N:\n                fre[N] += 1\n\n        suffix = [0] * (N + 3)\n        window = 0\n        for i in range(N, 0, -1):\n            window += fre[i]\n            suffix[i] = window\n\n        limit_x = min(N, k)\n        dp = [False] * (k + 1)\n        dp[0] = True\n\n        answer = [False] * N\n\n        for x in range(1, limit_x + 1):\n            count_x = fre[x]\n            mult = 1\n            while count_x > 0:\n                take = mult if mult <= count_x else count_x\n                weight = take * x\n                for s in range(k, weight - 1, -1):\n                    if dp[s - weight]:\n                        dp[s] = True\n                count_x -= take\n                mult <<= 1\n\n            cnt_gtx = suffix[x + 1] if x + 1 <= N else 0\n            max_t = min(cnt_gtx, k // x)\n\n            ok = False\n            for t in range(0, max_t + 1):\n                if dp[k - t * x]:\n                    ok = True\n                    break\n            answer[x - 1] = ok\n\n        if N > k:\n            rest = dp[k]\n            for x in range(k + 1, N + 1):\n                answer[x - 1] = rest\n\n        return answer\n", "submission_id": 1769974502, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 43}, "platform": "leetcode"}
{"id": "contest467_q3873_s11", "scenario": "code_generation", "question_id": 3873, "question_title": "Subsequence Sum After Capping Elements", "question_content": "[Problem description for Subsequence Sum After Capping Elements - Question ID: 3873]", "function_name": "subsequenceSumAfterCapping", "function_signature": "def subsequenceSumAfterCapping(self, nums: List[int], k: int)", "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        n = len(nums)\n        ans = [False] * n\n        nums.sort()\n        p = 0\n        dp = 1\n        for x in range(1, n+1):\n            while p < n and nums[p] <= x:\n                dp |= dp << nums[p]\n                p += 1\n            greater = n - p\n            for j in range(greater+1):\n                if k - j * x < 0:\n                    break\n                if dp & 1 << (k - j * x) != 0:\n                    ans[x-1] = True\n        return ans", "submission_id": 1769977544, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 18}, "platform": "leetcode"}
{"id": "contest467_q3873_s12", "scenario": "code_generation", "question_id": 3873, "question_title": "Subsequence Sum After Capping Elements", "question_content": "[Problem description for Subsequence Sum After Capping Elements - Question ID: 3873]", "function_name": "subsequenceSumAfterCapping", "function_signature": "def subsequenceSumAfterCapping(self, nums: List[int], k: int)", "code": "from collections import Counter\n\nclass Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        ctr = Counter(nums)\n        n = len(nums)\n        answer = []\n        large = n\n        mask = (1 << (k + 1)) - 1\n        now = 1\n\n        for i in range(1, n + 1):\n            c = ctr[i]\n            for _ in range(c):\n                now = (now | (now << i)) & mask\n\n            large -= c\n\n            is_found = False\n            for j in range(large + 1):\n                need = k - j * i\n                if need < 0:\n                    break\n\n                if (1 << need) & now:\n                    is_found = True\n                    break\n\n            answer.append(is_found)\n\n        return answer", "submission_id": 1769970904, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 24}, "platform": "leetcode"}
{"id": "contest467_q3873_s13", "scenario": "code_generation", "question_id": 3873, "question_title": "Subsequence Sum After Capping Elements", "question_content": "[Problem description for Subsequence Sum After Capping Elements - Question ID: 3873]", "function_name": "subsequenceSumAfterCapping", "function_signature": "def subsequenceSumAfterCapping(self, nums: List[int], k: int)", "code": "class Solution:\n    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:\n        n=len(nums)\n        freq=[0]*(n+1)\n        for v in nums:freq[v]+=1\n        mask=(1<<(k+1))-1\n        pre_dp=[0]*(n+1)\n        dp=1\n        pre_dp[0]=dp\n        for v in range(1,n+1):\n            for _ in range(freq[v]):\n                dp|=(dp<<v)\n                dp&=mask\n            pre_dp[v]=dp\n        suff=[0]*(n+2)\n        for v in range(n,0,-1):suff[v]=suff[v+1]+freq[v]\n        ans=[False]*n\n        for x in range(1,n+1):\n            base=pre_dp[x-1]\n            c=suff[x]\n            add=1\n            while c>0:\n                take=min(add,c)\n                shift=take*x\n                if shift>k:break\n                base|=(base<<shift)\n                base&=mask\n                c-=take\n                add<<=1\n            ans[x-1]=bool((base>>k)&1)\n        return ans", "submission_id": 1769970433, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 31}, "platform": "leetcode"}
{"id": "contest467_q3873_s14", "scenario": "code_generation", "question_id": 3873, "question_title": "Subsequence Sum After Capping Elements", "question_content": "[Problem description for Subsequence Sum After Capping Elements - Question ID: 3873]", "function_name": "subsequenceSumAfterCapping", "function_signature": "def subsequenceSumAfterCapping(self, A: List[int], k: int)", "code": "class Solution:\n    def subsequenceSumAfterCapping(self, A: List[int], k: int) -> List[bool]:\n        n = len(A)\n        A.sort()\n        p = 0\n        res = []\n        reach = {0}\n        for x in range(1, n + 1):\n            while p < n and A[p] < x:\n                for t in list(reach):\n                    if t + A[p] <= k:\n                        reach.add(t + A[p])\n                p += 1\n            if k in reach:\n                res.extend([True] * (n - len(res)))\n                break\n            rst = n - p\n            res.append(any((k - i * x) in reach for i in range(rst+1)))\n        return res", "submission_id": 1769975684, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "medium", "metrics": {"loc": 19}, "platform": "leetcode"}
{"id": "contest467_q3997_s0", "scenario": "code_generation", "question_id": 3997, "question_title": "Maximize Sum of At Most K Distinct Elements", "question_content": "[Problem description for Maximize Sum of At Most K Distinct Elements - Question ID: 3997]", "function_name": "maxKDistinct", "function_signature": "def maxKDistinct(self, nums: List[int], k: int)", "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        res = []\n        nums.sort(reverse=True)\n        seen = set()\n        taken = 0\n        for i, v in enumerate(nums):\n            if taken == k:\n                break\n            if v in seen:\n                continue\n            seen.add(v)\n            res.append(v)\n            taken += 1\n\n        return res\n            ", "submission_id": 1769946197, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 15}, "platform": "leetcode"}
{"id": "contest467_q3997_s1", "scenario": "code_generation", "question_id": 3997, "question_title": "Maximize Sum of At Most K Distinct Elements", "question_content": "[Problem description for Maximize Sum of At Most K Distinct Elements - Question ID: 3997]", "function_name": "maxKDistinct", "function_signature": "def maxKDistinct(self, nums: List[int], k: int)", "code": "class Solution:\n  def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n    nums = list(set(nums))\n    nums.sort(key=lambda i: -i)\n    return nums[0: k]", "submission_id": 1769954176, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 5}, "platform": "leetcode"}
{"id": "contest467_q3997_s2", "scenario": "code_generation", "question_id": 3997, "question_title": "Maximize Sum of At Most K Distinct Elements", "question_content": "[Problem description for Maximize Sum of At Most K Distinct Elements - Question ID: 3997]", "function_name": "maxKDistinct", "function_signature": "def maxKDistinct(self, nums: List[int], k: int)", "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        res = []\n        nums.sort()\n        while len(res) < k and nums:\n            x = nums.pop()\n            if not res or x != res[-1]:\n                res.append(x)\n        return sorted(res,reverse=True)", "submission_id": 1769949793, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 9}, "platform": "leetcode"}
{"id": "contest467_q3997_s3", "scenario": "code_generation", "question_id": 3997, "question_title": "Maximize Sum of At Most K Distinct Elements", "question_content": "[Problem description for Maximize Sum of At Most K Distinct Elements - Question ID: 3997]", "function_name": "maxKDistinct", "function_signature": "def maxKDistinct(self, nums: List[int], k: int)", "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        s = set(nums)\n        s = list(s)\n        s.sort(reverse=True)\n        return s[0:k]\n        ", "submission_id": 1769948065, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 6}, "platform": "leetcode"}
{"id": "contest467_q3997_s4", "scenario": "code_generation", "question_id": 3997, "question_title": "Maximize Sum of At Most K Distinct Elements", "question_content": "[Problem description for Maximize Sum of At Most K Distinct Elements - Question ID: 3997]", "function_name": "maxKDistinct", "function_signature": "def maxKDistinct(self, nums: List[int], k: int)", "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        p = nums\n        return sorted(list(set(p)),reverse=True)[:k]", "submission_id": 1769951727, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 4}, "platform": "leetcode"}
{"id": "contest467_q3997_s5", "scenario": "code_generation", "question_id": 3997, "question_title": "Maximize Sum of At Most K Distinct Elements", "question_content": "[Problem description for Maximize Sum of At Most K Distinct Elements - Question ID: 3997]", "function_name": "maxKDistinct", "function_signature": "def maxKDistinct(self, nums: List[int], k: int)", "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        set_sorted = sorted(set(nums), reverse=True)\n        return set_sorted[:k]", "submission_id": 1769958252, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 4}, "platform": "leetcode"}
{"id": "contest467_q3997_s6", "scenario": "code_generation", "question_id": 3997, "question_title": "Maximize Sum of At Most K Distinct Elements", "question_content": "[Problem description for Maximize Sum of At Most K Distinct Elements - Question ID: 3997]", "function_name": "maxKDistinct", "function_signature": "def maxKDistinct(self, nums: List[int], k: int)", "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        nums.sort(reverse=True)\n        myset = set()\n        res = []\n        \n        for num in nums:\n            if len(myset) == k:\n                break\n            if num not in myset:\n                res.append(num)\n                myset.add(num)\n        return res", "submission_id": 1769949771, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 12}, "platform": "leetcode"}
{"id": "contest467_q3997_s7", "scenario": "code_generation", "question_id": 3997, "question_title": "Maximize Sum of At Most K Distinct Elements", "question_content": "[Problem description for Maximize Sum of At Most K Distinct Elements - Question ID: 3997]", "function_name": "maxKDistinct", "function_signature": "def maxKDistinct(self, nums: List[int], k: int)", "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        x = sorted(nums, reverse = True)\n        ans = []\n        for i in x:\n            if i not in ans:\n                ans.append(i)\n            if len(ans) >= k:\n                return ans\n        return ans", "submission_id": 1769951937, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 10}, "platform": "leetcode"}
{"id": "contest467_q3997_s8", "scenario": "code_generation", "question_id": 3997, "question_title": "Maximize Sum of At Most K Distinct Elements", "question_content": "[Problem description for Maximize Sum of At Most K Distinct Elements - Question ID: 3997]", "function_name": "maxKDistinct", "function_signature": "def maxKDistinct(self, nums: List[int], k: int)", "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        nums.sort(reverse = True)\n        map = {}\n        su = []\n        print(nums)\n        for val in nums:\n            if val not in map:\n                map[val] = map.get(val , 0) + 1\n                su.append(val)\n                if len(su) == k: break\n\n        return su\n                \n        \n        ", "submission_id": 1769961609, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 12}, "platform": "leetcode"}
{"id": "contest467_q3997_s9", "scenario": "code_generation", "question_id": 3997, "question_title": "Maximize Sum of At Most K Distinct Elements", "question_content": "[Problem description for Maximize Sum of At Most K Distinct Elements - Question ID: 3997]", "function_name": "maxKDistinct", "function_signature": "def maxKDistinct(self, nums: List[int], k: int)", "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        arr=nums[:]\n        unique_arr=list(set(arr))\n        unique_arr.sort(reverse=True)\n        return unique_arr[:k]", "submission_id": 1769952397, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 6}, "platform": "leetcode"}
{"id": "contest467_q3997_s10", "scenario": "code_generation", "question_id": 3997, "question_title": "Maximize Sum of At Most K Distinct Elements", "question_content": "[Problem description for Maximize Sum of At Most K Distinct Elements - Question ID: 3997]", "function_name": "maxKDistinct", "function_signature": "def maxKDistinct(self, nums: List[int], k: int)", "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        c = Counter(nums)\n        dist = list(sorted(c.keys(), reverse = True))\n        return dist[:k]\n        ", "submission_id": 1769953152, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 5}, "platform": "leetcode"}
{"id": "contest467_q3997_s11", "scenario": "code_generation", "question_id": 3997, "question_title": "Maximize Sum of At Most K Distinct Elements", "question_content": "[Problem description for Maximize Sum of At Most K Distinct Elements - Question ID: 3997]", "function_name": "maxKDistinct", "function_signature": "def maxKDistinct(self, nums: List[int], k: int)", "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        res = []\n        nums = list(set(nums))\n        nums.sort(reverse = True)\n        for i in range(min(k, len(nums))):\n            res.append(nums[i])\n        return res", "submission_id": 1769949812, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 8}, "platform": "leetcode"}
{"id": "contest467_q3997_s12", "scenario": "code_generation", "question_id": 3997, "question_title": "Maximize Sum of At Most K Distinct Elements", "question_content": "[Problem description for Maximize Sum of At Most K Distinct Elements - Question ID: 3997]", "function_name": "maxKDistinct", "function_signature": "def maxKDistinct(self, nums: List[int], k: int)", "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        return sorted({*nums})[::-1][:k]", "submission_id": 1769971143, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 3}, "platform": "leetcode"}
{"id": "contest467_q3997_s13", "scenario": "code_generation", "question_id": 3997, "question_title": "Maximize Sum of At Most K Distinct Elements", "question_content": "[Problem description for Maximize Sum of At Most K Distinct Elements - Question ID: 3997]", "function_name": "maxKDistinct", "function_signature": "def maxKDistinct(self, nums: List[int], k: int)", "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        return sorted(list(set(nums)))[-k:][::-1]", "submission_id": 1769948868, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 3}, "platform": "leetcode"}
{"id": "contest467_q3997_s14", "scenario": "code_generation", "question_id": 3997, "question_title": "Maximize Sum of At Most K Distinct Elements", "question_content": "[Problem description for Maximize Sum of At Most K Distinct Elements - Question ID: 3997]", "function_name": "maxKDistinct", "function_signature": "def maxKDistinct(self, nums: List[int], k: int)", "code": "class Solution:\n    def maxKDistinct(self, nums: List[int], k: int) -> List[int]:\n        nums = sorted(set(nums), reverse = True)\n        res = []\n        for i in range(min(k, len(nums))):\n            res.append(nums[i])\n        return res", "submission_id": 1769946827, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 7}, "platform": "leetcode"}
{"id": "contest467_q4012_s0", "scenario": "code_generation", "question_id": 4012, "question_title": "Earliest Time to Finish One Task", "question_content": "[Problem description for Earliest Time to Finish One Task - Question ID: 4012]", "function_name": "earliestTime", "function_signature": "def earliestTime(self, tasks: List[List[int]])", "code": "class Solution:\n    def earliestTime(self, tasks: List[List[int]]) -> int:\n        res = inf\n        for s, t in tasks:\n            res = min(res, s + t)\n        return res", "submission_id": 1769944892, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 6}, "platform": "leetcode"}
{"id": "contest467_q4012_s1", "scenario": "code_generation", "question_id": 4012, "question_title": "Earliest Time to Finish One Task", "question_content": "[Problem description for Earliest Time to Finish One Task - Question ID: 4012]", "function_name": "earliestTime", "function_signature": "def earliestTime(self, tasks: List[List[int]])", "code": "class Solution:\n  def earliestTime(self, tasks: List[List[int]]) -> int:\n    return min(t[0] + t[1] for t in tasks)", "submission_id": 1769946189, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 3}, "platform": "leetcode"}
{"id": "contest467_q4012_s2", "scenario": "code_generation", "question_id": 4012, "question_title": "Earliest Time to Finish One Task", "question_content": "[Problem description for Earliest Time to Finish One Task - Question ID: 4012]", "function_name": "earliestTime", "function_signature": "def earliestTime(self, tasks: List[List[int]])", "code": "class Solution:\n    def earliestTime(self, tasks: List[List[int]]) -> int:\n        return min([x+y for x,y in tasks])", "submission_id": 1769945503, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 3}, "platform": "leetcode"}
{"id": "contest467_q4012_s3", "scenario": "code_generation", "question_id": 4012, "question_title": "Earliest Time to Finish One Task", "question_content": "[Problem description for Earliest Time to Finish One Task - Question ID: 4012]", "function_name": "earliestTime", "function_signature": "def earliestTime(self, tasks: List[List[int]])", "code": "class Solution:\n    def earliestTime(self, tasks: List[List[int]]) -> int:\n        ans = 1000000\n        for s, t in tasks:\n            ans = min(ans, s + t)\n        return ans", "submission_id": 1769945127, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 6}, "platform": "leetcode"}
{"id": "contest467_q4012_s4", "scenario": "code_generation", "question_id": 4012, "question_title": "Earliest Time to Finish One Task", "question_content": "[Problem description for Earliest Time to Finish One Task - Question ID: 4012]", "function_name": "earliestTime", "function_signature": "def earliestTime(self, tasks: List[List[int]])", "code": "class Solution:\n    def earliestTime(self, tasks: List[List[int]]) -> int:\n        return min(s+t for s,t in tasks)", "submission_id": 1769947096, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 3}, "platform": "leetcode"}
{"id": "contest467_q4012_s5", "scenario": "code_generation", "question_id": 4012, "question_title": "Earliest Time to Finish One Task", "question_content": "[Problem description for Earliest Time to Finish One Task - Question ID: 4012]", "function_name": "earliestTime", "function_signature": "def earliestTime(self, a: List[List[int]])", "code": "class Solution:\n    def earliestTime(self, a: List[List[int]]) -> int:\n        return min([x[0] + x[1] for x in a])", "submission_id": 1769944915, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 3}, "platform": "leetcode"}
{"id": "contest467_q4012_s6", "scenario": "code_generation", "question_id": 4012, "question_title": "Earliest Time to Finish One Task", "question_content": "[Problem description for Earliest Time to Finish One Task - Question ID: 4012]", "function_name": "earliestTime", "function_signature": "def earliestTime(self, tasks: List[List[int]])", "code": "class Solution:\n    def earliestTime(self, tasks: List[List[int]]) -> int:\n        return min(s + t for s, t in tasks)", "submission_id": 1769950026, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 3}, "platform": "leetcode"}
{"id": "contest467_q4012_s7", "scenario": "code_generation", "question_id": 4012, "question_title": "Earliest Time to Finish One Task", "question_content": "[Problem description for Earliest Time to Finish One Task - Question ID: 4012]", "function_name": "earliestTime", "function_signature": "def earliestTime(self, tasks: List[List[int]])", "code": "class Solution:\n    def earliestTime(self, tasks: List[List[int]]) -> int:\n        min_finish = 400\n        for time_s in tasks:\n            min_finish = min(min_finish, time_s[0] + time_s[1])\n        return min_finish\n        ", "submission_id": 1769945730, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 6}, "platform": "leetcode"}
{"id": "contest467_q4012_s8", "scenario": "code_generation", "question_id": 4012, "question_title": "Earliest Time to Finish One Task", "question_content": "[Problem description for Earliest Time to Finish One Task - Question ID: 4012]", "function_name": "earliestTime", "function_signature": "def earliestTime(self, tasks: List[List[int]])", "code": "class Solution:\n    def earliestTime(self, tasks: List[List[int]]) -> int:\n        ans = inf\n        for i, j in tasks:\n            ans = min(ans, i + j)\n        return ans", "submission_id": 1769945037, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 6}, "platform": "leetcode"}
{"id": "contest467_q4012_s9", "scenario": "code_generation", "question_id": 4012, "question_title": "Earliest Time to Finish One Task", "question_content": "[Problem description for Earliest Time to Finish One Task - Question ID: 4012]", "function_name": "earliestTime", "function_signature": "def earliestTime(self, tasks: List[List[int]])", "code": "class Solution:\n    def earliestTime(self, tasks: List[List[int]]) -> int:\n        min_time = float('inf')\n        for task in tasks:\n            completion_time = task[0] + task[1]  # start_time + duration\n            min_time = min(min_time, completion_time)\n        return int(min_time)\n        ", "submission_id": 1769951917, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 7}, "platform": "leetcode"}
{"id": "contest467_q4012_s10", "scenario": "code_generation", "question_id": 4012, "question_title": "Earliest Time to Finish One Task", "question_content": "[Problem description for Earliest Time to Finish One Task - Question ID: 4012]", "function_name": "earliestTime", "function_signature": "def earliestTime(self, tasks: List[List[int]])", "code": "class Solution:\n    def earliestTime(self, tasks: List[List[int]]) -> int:\n        return min(s+t for s,t in tasks)", "submission_id": 1769946661, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 3}, "platform": "leetcode"}
{"id": "contest467_q4012_s11", "scenario": "code_generation", "question_id": 4012, "question_title": "Earliest Time to Finish One Task", "question_content": "[Problem description for Earliest Time to Finish One Task - Question ID: 4012]", "function_name": "earliestTime", "function_signature": "def earliestTime(self, tasks: List[List[int]])", "code": "class Solution:\n    def earliestTime(self, tasks: List[List[int]]) -> int:\n        return min(s+t for s,t in tasks)", "submission_id": 1769948822, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 3}, "platform": "leetcode"}
{"id": "contest467_q4012_s12", "scenario": "code_generation", "question_id": 4012, "question_title": "Earliest Time to Finish One Task", "question_content": "[Problem description for Earliest Time to Finish One Task - Question ID: 4012]", "function_name": "earliestTime", "function_signature": "def earliestTime(self, tasks: List[List[int]])", "code": "class Solution:\n    def earliestTime(self, tasks: List[List[int]]) -> int:\n        mn = inf\n        for s, t, in tasks:\n            mn = min(mn, s + t)\n        return mn", "submission_id": 1769945120, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 6}, "platform": "leetcode"}
{"id": "contest467_q4012_s13", "scenario": "code_generation", "question_id": 4012, "question_title": "Earliest Time to Finish One Task", "question_content": "[Problem description for Earliest Time to Finish One Task - Question ID: 4012]", "function_name": "earliestTime", "function_signature": "def earliestTime(self, tasks: List[List[int]])", "code": "class Solution:\n    def earliestTime(self, tasks: List[List[int]]) -> int:\n        return min(x+y for x,y in tasks)", "submission_id": 1769971835, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 3}, "platform": "leetcode"}
{"id": "contest467_q4012_s14", "scenario": "code_generation", "question_id": 4012, "question_title": "Earliest Time to Finish One Task", "question_content": "[Problem description for Earliest Time to Finish One Task - Question ID: 4012]", "function_name": "earliestTime", "function_signature": "def earliestTime(self, tasks: List[List[int]])", "code": "class Solution:\n    def earliestTime(self, tasks: List[List[int]]) -> int:\n        return min(s + d for s, d in tasks)", "submission_id": 1769945067, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "easy", "metrics": {"loc": 3}, "platform": "leetcode"}
{"id": "contest467_q4027_s0", "scenario": "code_generation", "question_id": 4027, "question_title": "Number of Stable Subsequences", "question_content": "[Problem description for Number of Stable Subsequences - Question ID: 4027]", "function_name": "countStableSubsequences", "function_signature": "def countStableSubsequences(self, nums: List[int])", "code": "class Solution:\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        res = 0\n\n        @cache\n        def dp(i, pp, p):\n            if i == len(nums):\n                return 1\n            ifSkip = dp(i + 1, pp, p)\n            v = nums[i]\n            if v % 2 == pp == p:\n                return ifSkip\n            ifTake = dp(i + 1, p, v % 2)\n            return (ifSkip + ifTake) % MOD\n\n        res = dp(0, -1, -1)\n        dp.cache_clear()\n        return res - 1", "submission_id": 1769952969, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 17}, "platform": "leetcode"}
{"id": "contest467_q4027_s1", "scenario": "code_generation", "question_id": 4027, "question_title": "Number of Stable Subsequences", "question_content": "[Problem description for Number of Stable Subsequences - Question ID: 4027]", "function_name": "countStableSubsequences", "function_signature": "def countStableSubsequences(self, nums: List[int])", "code": "class Solution:\n  def countStableSubsequences(self, nums: List[int]) -> int:\n    MOD = 1_000_000_007\n    E1 = E2 = O1 = O2 = 0\n\n    for a in nums:\n        if a % 2 == 0:\n            newE1 = (E1 + O1 + O2 + 1) % MOD\n            newE2 = (E2 + E1) % MOD\n            E1, E2 = newE1, newE2\n        else:\n            newO1 = (O1 + E1 + E2 + 1) % MOD\n            newO2 = (O2 + O1) % MOD\n            O1, O2 = newO1, newO2\n    return (E1 + E2 + O1 + O2) % MOD", "submission_id": 1769973511, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 14}, "platform": "leetcode"}
{"id": "contest467_q4027_s2", "scenario": "code_generation", "question_id": 4027, "question_title": "Number of Stable Subsequences", "question_content": "[Problem description for Number of Stable Subsequences - Question ID: 4027]", "function_name": "countStableSubsequences", "function_signature": "def countStableSubsequences(self, nums: List[int])", "code": "class Solution:\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        modulo = 10**9 + 7\n\n        nums = [x%2 for x in nums]\n\n        @lru_cache(None)\n        def recur_fn(i,prev,count):\n            if i == len(nums):\n                return 0\n            else:\n                res = 0\n                if nums[i] == prev and count == 1:\n                    res += 1 + recur_fn(i+1,prev,count+1)\n                    if res >= modulo:\n                        res %= modulo\n                if nums[i] != prev:\n                    res += 1+ recur_fn(i+1,nums[i],1)\n                    if res >= modulo:\n                        res %= modulo\n                res += recur_fn(i+1,prev,count)\n                if res >= modulo:\n                    res %= modulo\n                return res \n\n        ans = 0\n        for i in range(len(nums)):\n            ans += 1 + recur_fn(i+1,nums[i],1)\n            #print('ans',ans)\n            if ans >= modulo:\n                ans %= modulo\n            \n        recur_fn.cache_clear()\n        return ans%modulo", "submission_id": 1769974365, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 30}, "platform": "leetcode"}
{"id": "contest467_q4027_s3", "scenario": "code_generation", "question_id": 4027, "question_title": "Number of Stable Subsequences", "question_content": "[Problem description for Number of Stable Subsequences - Question ID: 4027]", "function_name": "countStableSubsequences", "function_signature": "def countStableSubsequences(self, nums: List[int])", "code": "class Solution:\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        mod = 10 ** 9 + 7\n        dp = [[0, 0], [0, 0]]\n        for x in nums:\n            if x % 2 == 1:\n                dp[0][1] += dp[0][0]\n                dp[0][0] += dp[1][0] + dp[1][1] + 1\n                dp[0][0] %= mod\n                dp[0][1] %= mod\n            else:\n                dp[1][1] += dp[1][0]\n                dp[1][0] += dp[0][0] + dp[0][1] + 1\n                dp[1][0] %= mod\n                dp[1][1] %= mod\n        return (sum(dp[0]) + sum(dp[1])) % mod\n        ", "submission_id": 1769975070, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 16}, "platform": "leetcode"}
{"id": "contest467_q4027_s4", "scenario": "code_generation", "question_id": 4027, "question_title": "Number of Stable Subsequences", "question_content": "[Problem description for Number of Stable Subsequences - Question ID: 4027]", "function_name": "countStableSubsequences", "function_signature": "def countStableSubsequences(self, nums: List[int])", "code": "class Solution:\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        m = nums\n        MOD = 10**9+7\n        e1,e2,o1,o2=0,0,0,0\n        for num in m:\n            if num%2==0:\n                ne1=(e1+o1+o2+1)%MOD\n                ne2=(e1+e2)%MOD\n                e1,e2=ne1,ne2\n            else:\n                no1=(o1+e1+e2+1)%MOD\n                no2=(o1+o2)%MOD\n                o1,o2=no1,no2\n        result = (e1+e2+o1+o2)%MOD\n        return result", "submission_id": 1769977174, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 16}, "platform": "leetcode"}
{"id": "contest467_q4027_s5", "scenario": "code_generation", "question_id": 4027, "question_title": "Number of Stable Subsequences", "question_content": "[Problem description for Number of Stable Subsequences - Question ID: 4027]", "function_name": "countStableSubsequences", "function_signature": "def countStableSubsequences(self, nums: List[int])", "code": "class Solution:\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even1 = even2 = odd1 = odd2 = 0\n        for val in nums:\n            if val % 2 == 0:\n                new_even1 = (even1 + odd1 + odd2 + 1) % MOD\n                new_even2 = (even2 + even1) % MOD\n                even1, even2 = new_even1, new_even2\n            else:\n                new_odd1 = (odd1 + even1 + even2 + 1) % MOD\n                new_odd2 = (odd2 + odd1) % MOD\n                odd1, odd2 = new_odd1, new_odd2\n        return (even1 + even2 + odd1 + odd2) % MOD", "submission_id": 1769978339, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 14}, "platform": "leetcode"}
{"id": "contest467_q4027_s6", "scenario": "code_generation", "question_id": 4027, "question_title": "Number of Stable Subsequences", "question_content": "[Problem description for Number of Stable Subsequences - Question ID: 4027]", "function_name": "countStableSubsequences", "function_signature": "def countStableSubsequences(self, nums: List[int])", "code": "MOD = 10 ** 9 + 7\nclass Solution:\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        # dp[i][p][len] ? i-th num, p:odd / even, len: number\n        \n        even1 = even2 = odd1 = odd2 = 0\n\n        for x in nums:\n            p = (x & 1) # 0 = even, 1 = odd\n\n            if p == 0:\n                add_even1 = (1 + odd1 + odd2)\n                add_even2 = even1\n\n                even1 = (even1 + add_even1) # Not choose x + Choose x\n                even2 = (even2 + add_even2)\n            else:\n                add_odd1 = (1 + even1 + even2)\n                add_odd2 = odd1\n\n                odd1 = (odd1 + add_odd1)\n                odd2 = (odd2 + add_odd2)\n        return (even1 + even2 + odd1 + odd2) % MOD\n            ", "submission_id": 1769981844, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 18}, "platform": "leetcode"}
{"id": "contest467_q4027_s7", "scenario": "code_generation", "question_id": 4027, "question_title": "Number of Stable Subsequences", "question_content": "[Problem description for Number of Stable Subsequences - Question ID: 4027]", "function_name": "countStableSubsequences", "function_signature": "def countStableSubsequences(self, nums: List[int])", "code": "class Solution:\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        mod = 10 ** 9 + 7\n\n        e1 = e2 = o1 = o2 = 0\n        for v in nums:\n            if v % 2 == 1:\n                ne1 = (o1 + e1 + e2 + 1) % mod\n                ne2 = (o1 + o2) % mod\n                o1 = ne1\n                o2 = ne2\n            else:\n                ne1 = (e1 + o1 + o2 + 1) % mod\n                ne2 = (e1 + e2) % mod\n                e1 = ne1\n                e2 = ne2\n        return (e1 + e2 + o1 + o2) % mod", "submission_id": 1769982657, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 16}, "platform": "leetcode"}
{"id": "contest467_q4027_s8", "scenario": "code_generation", "question_id": 4027, "question_title": "Number of Stable Subsequences", "question_content": "[Problem description for Number of Stable Subsequences - Question ID: 4027]", "function_name": "countStableSubsequences", "function_signature": "def countStableSubsequences(self, nums: List[int])", "code": "from typing import List\n\nclass Solution:\n    MOD = 1_000_000_007\n\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        # even1, even2, odd1, odd2 as described\n        e1 = e2 = o1 = o2 = 0\n        M = self.MOD\n\n        for x in nums:\n            if x & 1:                            # x is odd\n                no1 = (o1 + e1 + e2 + 1) % M     # keep o1  + append to evens + new single\n                no2 = (o2 + o1) % M              # keep o2  + extend o1 \u2192 o2\n                ne1 = e1                         # skip x, evens unchanged in their buckets\n                ne2 = e2\n            else:                                # x is even\n                ne1 = (e1 + o1 + o2 + 1) % M\n                ne2 = (e2 + e1) % M\n                no1 = o1\n                no2 = o2\n\n            e1, e2, o1, o2 = ne1, ne2, no1, no2\n\n        return (e1 + e2 + o1 + o2) % M", "submission_id": 1769969410, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 20}, "platform": "leetcode"}
{"id": "contest467_q4027_s9", "scenario": "code_generation", "question_id": 4027, "question_title": "Number of Stable Subsequences", "question_content": "[Problem description for Number of Stable Subsequences - Question ID: 4027]", "function_name": "countStableSubsequences", "function_signature": "def countStableSubsequences(self, nums: List[int])", "code": "class Solution:\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        arr=nums[:]\n        mod=10**9+7\n\n        e1=e2=o1=o2=0\n\n        for a in nums:\n            nee1,nee2,neo1,neo2=e1,e2,o1,o2\n\n            if a%2==0:\n                nee2=(nee2+e1)%mod\n                nee1=(nee1+o1+o2+1)%mod\n            else:\n                neo2=(neo2+o1)%mod\n                neo1=(neo1+e1+e2+1)%mod\n            e1,e2,o1,o2=nee1,nee2,neo1,neo2\n\n        return (e1+e2+o1+o2)%mod", "submission_id": 1769985141, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 15}, "platform": "leetcode"}
{"id": "contest467_q4027_s10", "scenario": "code_generation", "question_id": 4027, "question_title": "Number of Stable Subsequences", "question_content": "[Problem description for Number of Stable Subsequences - Question ID: 4027]", "function_name": "countStableSubsequences", "function_signature": "def countStableSubsequences(self, nums: List[int])", "code": "MOD = 10**9 + 7\n\nclass Solution:\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        even_state = [0, 0]\n        odd_state = [0, 0]\n        \n        for value in nums:\n            if value % 2:\n                odd_1 = (odd_state[0] + sum(even_state) + 1) % MOD\n                odd_2 = sum(odd_state) % MOD\n                odd_state = [odd_1, odd_2]\n            else:\n                even_1 = (even_state[0] + sum(odd_state) + 1) % MOD\n                even_2 = sum(even_state) % MOD\n                even_state = [even_1, even_2]\n\n        return sum([*odd_state, *even_state]) % MOD", "submission_id": 1769986363, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 15}, "platform": "leetcode"}
{"id": "contest467_q4027_s11", "scenario": "code_generation", "question_id": 4027, "question_title": "Number of Stable Subsequences", "question_content": "[Problem description for Number of Stable Subsequences - Question ID: 4027]", "function_name": "countStableSubsequences", "function_signature": "def countStableSubsequences(self, nums: List[int])", "code": "class Solution:\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        odd = [0] * 2\n        even = [0] * 2\n        for num in nums:\n            if num % 2 == 0:\n                even[1] += even[0] % mod\n                even[0] += (odd[0] + odd[1] + 1) % mod\n            else:\n                odd[1] += odd[0] % mod\n                odd[0] += (even[0] + even[1] + 1) % mod\n        return (sum(even) + sum(odd)) % mod", "submission_id": 1769986451, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 13}, "platform": "leetcode"}
{"id": "contest467_q4027_s12", "scenario": "code_generation", "question_id": 4027, "question_title": "Number of Stable Subsequences", "question_content": "[Problem description for Number of Stable Subsequences - Question ID: 4027]", "function_name": "countStableSubsequences", "function_signature": "def countStableSubsequences(self, nums: List[int])", "code": "class Solution:\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        ans = 0\n        cnt = [[0,0],[0,0]]\n        z = o = 0\n        for x in nums:\n            # print(x, cnt, o, z)\n            if x%2 == 0:\n                ans += cnt[0][1] + cnt[1][1] + cnt[1][0]\n                cnt[0][0] += (cnt[1][0] + z) % (10**9+7)\n                cnt[1][0] += (cnt[0][1] + cnt[1][1] + o) % (10**9+7)\n            else:\n                ans += cnt[0][1] + cnt[0][0] + cnt[1][0]\n                cnt[1][1] += (cnt[0][1] + o) % (10**9+7)\n                cnt[0][1] += (cnt[0][0] + cnt[1][0] + z) % (10**9+7)\n            o += x%2 == 1\n            z += x%2 == 0\n        n = len(nums)\n        return (ans + n*(n+1)//2) % (10**9+7)", "submission_id": 1769955863, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 19}, "platform": "leetcode"}
{"id": "contest467_q4027_s13", "scenario": "code_generation", "question_id": 4027, "question_title": "Number of Stable Subsequences", "question_content": "[Problem description for Number of Stable Subsequences - Question ID: 4027]", "function_name": "countStableSubsequences", "function_signature": "def countStableSubsequences(self, nums: List[int])", "code": "class Solution:\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n\n        answer = n\n\n        dp = [0, 0, 0, 0]  # ee, eo, oe, oo\n\n        ctr = [0, 0]\n        ctr[nums[0] % 2] += 1\n\n        for i, x in enumerate(nums[1:], 1):\n            temp = dp.copy()\n            \n            if x % 2 == 0:\n                temp[0] += ctr[0]\n                temp[1] += ctr[1]\n\n                temp[0] += dp[1]\n                temp[1] += dp[2] + dp[3]\n\n            else:\n                temp[2] += ctr[0]\n                temp[3] += ctr[1]\n\n                temp[2] += dp[0] + dp[1]\n                temp[3] += dp[2]\n\n            ctr[x % 2] += 1\n\n            dp = [y % mod for y in temp]\n\n        return (answer + sum(dp)) % mod\n                \n", "submission_id": 1769987364, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 23}, "platform": "leetcode"}
{"id": "contest467_q4027_s14", "scenario": "code_generation", "question_id": 4027, "question_title": "Number of Stable Subsequences", "question_content": "[Problem description for Number of Stable Subsequences - Question ID: 4027]", "function_name": "countStableSubsequences", "function_signature": "def countStableSubsequences(self, nums: List[int])", "code": "MOD = 10**9+7\nclass Solution:\n    def countStableSubsequences(self, nums: List[int]) -> int:\n        @cache\n        def dfs(i, last, run):\n            if i == len(nums):\n                return int(last != -1)\n            res = dfs(i + 1, last, run)\n            if last == -1:\n                res += dfs(i + 1, nums[i] % 2, 1)\n                if res >= MOD:\n                    res -= MOD\n            else:\n                if nums[i] % 2 == last:\n                    if run < 2:\n                        res += dfs(i + 1, last, run + 1)\n                        if res >= MOD:\n                            res -= MOD\n                else:\n                    res += dfs(i + 1, last ^ 1, 1)\n                    if res >= MOD:\n                        res -= MOD\n            return res\n        res = dfs(0, -1, 0)\n        dfs.cache_clear()\n        return res", "submission_id": 1769957971, "contest_id": "weekly-contest-467", "contest_date": "2024-10-13T00:00:00.000", "difficulty": "hard", "metrics": {"loc": 26}, "platform": "leetcode"}
